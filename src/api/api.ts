import * as querystring from 'querystring';
import * as fetch from 'isomorphic-fetch';
import {assign} from './assign';


export interface AccountingBatch {
	"id"?: number;
	"batchIdentifier": string;
	"exportInvoicesFlag"?: boolean;
	"exportExpensesFlag"?: boolean;
	"exportProductsFlag"?: boolean;
	"closedFlag"?: boolean;

	/**
	 * Metadata of the entity
	 */
	"info"?: Metadata;
}

export interface Activity {
	"id"?: number;
	"name": string;
	"type"?: ActivityTypeReference;
	"company"?: CompanyReference;
	"contact"?: ContactReference;
	"phoneNumber"?: string;
	"email"?: string;
	"status"?: ActivityStatusReference;
	"opportunity"?: OpportunityReference;
	"ticket"?: TicketReference;
	"agreement"?: AgreementReference;
	"campaign"?: CampaignReference;
	"notes"?: string;
	"dateStart"?: Date;
	"dateEnd"?: Date;
	"assignedBy"?: MemberReference;
	"assignTo": MemberReference;
	"scheduleStatus"?: ScheduleStatusReference;
	"reminder"?: ReminderReference;
	"where"?: ServiceLocationReference;
	"notifyFlag"?: boolean;
	"mobileGuid"?: Guid;

	/**
	 * Metadata of the entity
	 */
	"info"?: Metadata;
	"customFields"?: Array<CustomFieldValue>;
}

export interface ActivityReference {
	"id"?: number;
	"name"?: string;

	/**
	 * Metadata of the entity
	 */
	"info"?: Metadata;
}

export interface ActivityStatus {
	"id"?: number;
	"name": string;
	"defaultFlag"?: boolean;
	"inactiveFlag"?: boolean;
	"spawnFollowupFlag"?: boolean;
	"closedFlag"?: boolean;

	/**
	 * Metadata of the entity
	 */
	"info"?: Metadata;
}

export interface ActivityStatusReference {
	"id"?: number;
	"name"?: string;

	/**
	 * Metadata of the entity
	 */
	"info"?: Metadata;
}

export interface ActivityStopwatch {

	/**
	 * Metadata of the entity
	 */
	"info"?: Metadata;
	"activityId": number;
	"activityMobileGuid"?: Guid;
	"agreement"?: AgreementReference;
	"billableOption"?: ActivityStopwatch.BillableOptionEnum;
	"businessUnitId"?: number;
	"dateEntered"?: Date;
	"endTime"?: Date;
	"id"?: number;
	"internalNotes"?: string;
	"locationId"?: number;
	"member": MemberReference;
	"mobileGuid"?: Guid;
	"notes"?: string;
	"startTime"?: Date;
	"status": ActivityStopwatch.StatusEnum;
	"totalPauseTime"?: number;
	"workRole"?: WorkRoleReference;
	"workType"?: WorkTypeReference;
}

export namespace ActivityStopwatch {

export type BillableOptionEnum = 'Billable' | 'DoNotBill' | 'NoCharge' | 'NoDefault';

export type StatusEnum = 'Reset' | 'Running' | 'Paused' | 'Stopped';
}
export interface ActivityType {
	"id"?: number;
	"name": string;
	"points"?: number;
	"defaultFlag"?: boolean;
	"inactiveFlag"?: boolean;
	"emailFlag"?: boolean;
	"memoFlag"?: boolean;

	/**
	 * Metadata of the entity
	 */
	"info"?: Metadata;
}

export interface ActivityTypeReference {
	"id"?: number;
	"name"?: string;

	/**
	 * Metadata of the entity
	 */
	"info"?: Metadata;
}

export interface Addition {
	"id"?: number;
	"product": IvItemReference;
	"quantity"?: number;
	"lessIncluded"?: number;
	"unitPrice"?: number;
	"unitCost"?: number;
	"billCustomer": Addition.BillCustomerEnum;
	"effectiveDate"?: Date;
	"cancelledDate"?: Date;
	"taxableFlag"?: boolean;
	"serialNumber"?: string;
	"invoiceDescription"?: string;
	"purchaseItemFlag"?: boolean;
	"specialOrderFlag"?: boolean;
	"agreementId"?: number;
	"description"?: string;
	"billedQuantity"?: number;
	"uom"?: string;
	"extPrice"?: number;
	"extCost"?: number;
	"sequenceNumber"?: number;
	"margin"?: number;
	"prorateCost"?: number;
	"proratePrice"?: number;
	"extendedProrateCost"?: number;
	"extendedProratePrice"?: number;
	"prorateCurrentPeriodFlag"?: boolean;

	/**
	 * Metadata of the entity
	 */
	"info"?: Metadata;
}

export namespace Addition {

export type BillCustomerEnum = 'Billable' | 'DoNotBill' | 'NoCharge';
}
export interface Adjustment {
	"id"?: number;
	"amount"?: number;
	"description"?: string;
	"effectiveDate"?: Date;
	"agreementId"?: number;

	/**
	 * Metadata of the entity
	 */
	"info"?: Metadata;
	"identifier": string;
	"type": AdjustmentTypeReference;
	"reason"?: string;
	"notes"?: string;
	"closedFlag"?: boolean;
	"closedBy"?: string;
	"closedDate"?: Date;
}

export interface AdjustmentDetail {
	"id"?: number;
	"catalogItem": CatalogItemReference;
	"description"?: string;
	"quantityOnHand"?: number;
	"unitCost"?: number;
	"warehouse": WarehouseReference;
	"warehouseBin": WarehouseBinReference;
	"quantityAdjusted": number;
	"serialNumber"?: string;
	"adjustment"?: AdjustmentReference;

	/**
	 * Metadata of the entity
	 */
	"info"?: Metadata;
}

export interface AdjustmentReference {
	"id"?: number;
	"name"?: string;

	/**
	 * Metadata of the entity
	 */
	"info"?: Metadata;
}

export interface AdjustmentType {
	"id"?: number;
	"identifier": string;
	"name"?: string;
	"auditTrailFlag"?: boolean;
	"dateCreated"?: Date;
	"createdBy"?: string;

	/**
	 * Metadata of the entity
	 */
	"info"?: Metadata;
}

export interface AdjustmentTypeReference {
	"id"?: number;
	"identifier"?: string;

	/**
	 * Metadata of the entity
	 */
	"info"?: Metadata;
}

export interface Agreement {
	"id"?: number;
	"name": string;
	"type": AgreementTypeReference;
	"company": CompanyReference;
	"contact": ContactReference;
	"subContractCompany"?: CompanyReference;
	"subContractContact"?: ContactReference;
	"parentAgreementId"?: number;
	"customerPO"?: string;
	"locationId"?: number;
	"businessUnitId"?: number;
	"restrictLocationFlag"?: boolean;
	"restrictDepartmentFlag"?: boolean;
	"startDate"?: Date;
	"endDate"?: Date;
	"noEndingDateFlag"?: boolean;
	"opportunity"?: OpportunityReference;
	"cancelledFlag"?: boolean;
	"dateCancelled"?: Date;
	"reasonCancelled"?: string;
	"slaId"?: number;
	"workOrder"?: string;
	"internalNotes"?: string;
	"applicationUnits"?: Agreement.ApplicationUnitsEnum;
	"applicationLimit"?: number;
	"applicationCycle"?: Agreement.ApplicationCycleEnum;
	"applicationUnlimitedFlag"?: boolean;
	"oneTimeFlag"?: boolean;
	"coverAgreementTime"?: boolean;
	"coverAgreementProduct"?: boolean;
	"coverAgreementExpense"?: boolean;
	"coverSalesTax"?: boolean;
	"carryOverUnused"?: boolean;
	"allowOverruns"?: boolean;
	"expiredDays"?: number;
	"limit"?: number;
	"expireWhenZero"?: boolean;
	"chargeToFirm"?: boolean;
	"employeeCompRate"?: Agreement.EmployeeCompRateEnum;
	"employeeCompNotExceed"?: Agreement.EmployeeCompNotExceedEnum;
	"compHourlyRate"?: number;
	"compLimitAmount"?: number;
	"billCycleId"?: number;
	"billOneTimeFlag"?: boolean;
	"billTermsId"?: number;
	"invoicingCycle"?: Agreement.InvoicingCycleEnum;
	"billToCompany"?: CompanyReference;
	"billToSite"?: SiteReference;
	"billAmount"?: number;
	"taxable"?: boolean;
	"prorateFirstBill"?: number;
	"billStartDate"?: Date;
	"taxCodeId"?: number;
	"restrictDownPayment"?: boolean;
	"prorateFlag"?: boolean;
	"invoiceDescription"?: string;
	"topComment"?: boolean;
	"bottomComment"?: boolean;
	"workRole"?: WorkRoleReference;
	"workType"?: WorkTypeReference;
	"projectTypeId"?: number;
	"invoiceTemplateSetupId"?: number;
	"billTime"?: Agreement.BillTimeEnum;
	"billExpenses"?: Agreement.BillExpensesEnum;
	"billProducts"?: Agreement.BillProductsEnum;
	"billableTimeInvoice"?: boolean;
	"billableExpenseInvoice"?: boolean;
	"billableProductInvoice"?: boolean;

	/**
	 * Metadata of the entity
	 */
	"info"?: Metadata;
	"periodType"?: Agreement.PeriodTypeEnum;
}

export namespace Agreement {

export type ApplicationUnitsEnum = 'Amount' | 'Hours' | 'Incidents';

export type ApplicationCycleEnum = 'Contract2Weeks' | 'Contract4Weeks' | 'ContractYear' | 'CalendarMonth' | 'CalendarQuarter' | 'CalendarWeek' | 'ContractQuarter' | 'CalendarYear';

export type EmployeeCompRateEnum = 'Actual' | 'Hourly';

export type EmployeeCompNotExceedEnum = 'Billing' | 'Percent' | 'Amount';

export type InvoicingCycleEnum = 'CalendarYear' | 'ContractYear';

export type BillTimeEnum = 'Billable' | 'DoNotBill' | 'NoCharge' | 'NoDefault';

export type BillExpensesEnum = 'Billable' | 'DoNotBill' | 'NoCharge' | 'NoDefault';

export type BillProductsEnum = 'Billable' | 'DoNotBill' | 'NoCharge' | 'NoDefault';

export type PeriodTypeEnum = 'Current' | 'Future' | 'Both' | 'Undefined';
}
export interface AgreementReference {
	"id"?: number;
	"name"?: string;

	/**
	 * Metadata of the entity
	 */
	"info"?: Metadata;
}

export interface AgreementSite {
	"id"?: number;
	"company": CompanyReference;
	"site"?: SiteReference;
	"agreementId"?: number;

	/**
	 * Metadata of the entity
	 */
	"info"?: Metadata;
}

export interface AgreementType {
	"id"?: number;
	"name": string;
	"prefixSuffixOption": AgreementType.PrefixSuffixOptionEnum;
	"defaultFlag"?: boolean;
	"inactiveFlag"?: boolean;
	"prePaymentFlag"?: boolean;
	"invoicePreSuffix"?: string;
	"locationId"?: number;
	"businessUnitId"?: number;
	"restrictLocationFlag"?: boolean;
	"restrictDepartmentFlag"?: boolean;
	"slaId"?: number;
	"applicationUnits"?: AgreementType.ApplicationUnitsEnum;
	"applicationLimit"?: number;
	"applicationCycle"?: AgreementType.ApplicationCycleEnum;
	"applicationUnlimitedFlag"?: boolean;
	"oneTimeFlag"?: boolean;
	"coverAgreementTimeFlag"?: boolean;
	"coverAgreementProductFlag"?: boolean;
	"coverAgreementExpenseFlag"?: boolean;
	"coverSalesTaxFlag"?: boolean;
	"carryOverUnusedFlag"?: boolean;
	"allowOverrunsFlag"?: boolean;
	"expiredDays"?: number;
	"limit"?: number;
	"expireWhenZero"?: boolean;
	"chargeToFirmFlag"?: boolean;
	"employeeCompRate": AgreementType.EmployeeCompRateEnum;
	"employeeCompNotExceed": AgreementType.EmployeeCompNotExceedEnum;
	"compHourlyRate"?: number;
	"compLimitAmount"?: number;
	"billCycleId"?: number;
	"billOneTimeFlag"?: boolean;
	"billTermsId"?: number;
	"invoicingCycle": AgreementType.InvoicingCycleEnum;
	"billAmount"?: number;
	"taxableFlag"?: boolean;
	"restrictDownPaymentFlag"?: boolean;
	"invoiceDescription"?: string;
	"topCommentFlag"?: boolean;
	"bottomCommentFlag"?: boolean;
	"workRole"?: WorkRoleReference;
	"workType"?: WorkTypeReference;
	"projectTypeId"?: number;
	"invoiceTemplateSetupId"?: number;
	"billTime": AgreementType.BillTimeEnum;
	"billExpenses": AgreementType.BillExpensesEnum;
	"billProducts": AgreementType.BillProductsEnum;
	"billableTimeInvoiceFlag"?: boolean;
	"billableExpenseInvoiceFlag"?: boolean;
	"billableProductInvoiceFlag"?: boolean;
	"copyWorkRolesFlag"?: boolean;
	"copyWorkTypesFlag"?: boolean;

	/**
	 * Metadata of the entity
	 */
	"info"?: Metadata;
}

export namespace AgreementType {

export type PrefixSuffixOptionEnum = 'Prefix' | 'Suffix';

export type ApplicationUnitsEnum = 'Amount' | 'Hours' | 'Incidents';

export type ApplicationCycleEnum = 'Contract2Weeks' | 'Contract4Weeks' | 'ContractYear' | 'CalendarMonth' | 'CalendarQuarter' | 'CalendarWeek' | 'ContractQuarter' | 'CalendarYear';

export type EmployeeCompRateEnum = 'Actual' | 'Hourly';

export type EmployeeCompNotExceedEnum = 'Billing' | 'Percent' | 'Amount';

export type InvoicingCycleEnum = 'CalendarYear' | 'ContractYear';

export type BillTimeEnum = 'Billable' | 'DoNotBill' | 'NoCharge' | 'NoDefault';

export type BillExpensesEnum = 'Billable' | 'DoNotBill' | 'NoCharge' | 'NoDefault';

export type BillProductsEnum = 'Billable' | 'DoNotBill' | 'NoCharge' | 'NoDefault';
}
export interface AgreementTypeReference {
	"id"?: number;
	"name"?: string;

	/**
	 * Metadata of the entity
	 */
	"info"?: Metadata;
}

export interface AgreementWorkRole {
	"id"?: number;
	"workRole"?: WorkRoleReference;
	"locationId"?: number;
	"rateType": AgreementWorkRole.RateTypeEnum;
	"rate"?: number;
	"limitTo"?: number;
	"effectiveDate"?: Date;
	"endingDate"?: Date;
	"agreementId"?: number;

	/**
	 * Metadata of the entity
	 */
	"info"?: Metadata;
}

export namespace AgreementWorkRole {

export type RateTypeEnum = 'AdjAmount' | 'Custom' | 'Multiplier';
}
export interface AgreementWorkRoleExclusion {
	"id"?: number;
	"workRole": WorkRoleReference;
	"agreementId"?: number;

	/**
	 * Metadata of the entity
	 */
	"info"?: Metadata;
}

export interface AgreementWorkType {
	"id"?: number;
	"workType"?: WorkTypeReference;
	"locationId"?: number;
	"rateType": AgreementWorkType.RateTypeEnum;
	"billTime": AgreementWorkType.BillTimeEnum;
	"rate"?: number;
	"hoursMax"?: number;
	"hoursMin"?: number;
	"roundBillHours"?: number;
	"overageRate"?: number;
	"overageRateType"?: AgreementWorkType.OverageRateTypeEnum;
	"agreementLimit"?: number;
	"site"?: SiteReference;
	"effectiveDate"?: Date;
	"endingDate"?: Date;
	"agreementId"?: number;
	"company"?: CompanyReference;

	/**
	 * Metadata of the entity
	 */
	"info"?: Metadata;
}

export namespace AgreementWorkType {

export type RateTypeEnum = 'AdjAmount' | 'Custom' | 'Multiplier';

export type BillTimeEnum = 'Billable' | 'DoNotBill' | 'NoCharge' | 'NoDefault';

export type OverageRateTypeEnum = 'AdjAmount' | 'Custom' | 'Multiplier';
}
export interface AgreementWorkTypeExclusion {
	"id"?: number;
	"workType": WorkTypeReference;
	"agreementId"?: number;

	/**
	 * Metadata of the entity
	 */
	"info"?: Metadata;
}

export interface AuditTrailEntry {
	"text"?: string;
	"enteredDate"?: string;
	"enteredBy"?: string;
	"auditType"?: string;
	"auditSubType"?: string;
	"auditSource"?: string;
}

export interface BatchRequest {
	"id"?: string;
	"requests"?: Array<EndpointRequest>;

	/**
	 * Metadata of the entity
	 */
	"headers"?: Metadata;
}

export interface BatchResponse {
	"id"?: string;
	"responses"?: Array<EndpointResponse>;
}

export interface BillingDeliveryReference {
	"id"?: number;
	"name"?: string;

	/**
	 * Metadata of the entity
	 */
	"info"?: Metadata;
}

export interface BillingStatusReference {
	"id"?: number;
	"name"?: string;

	/**
	 * Metadata of the entity
	 */
	"info"?: Metadata;
}

export interface BillingTermsReference {
	"id"?: number;
	"name"?: string;

	/**
	 * Metadata of the entity
	 */
	"info"?: Metadata;
}

export interface Board {
	"id"?: number;
	"name": string;
	"locationId": number;
	"businessUnitId": number;
	"inactive"?: boolean;
	"signOffTemplate"?: ServiceSignoffReference;
	"sendToContact"?: boolean;
	"contactTemplateId"?: number;
	"sendToResource"?: boolean;
	"resourceTemplateId"?: number;
	"projectFlag"?: boolean;

	/**
	 * This field only shows if it is Project Board.
	 */
	"showDependenciesFlag"?: boolean;

	/**
	 * This field only shows if it is Project Board.
	 */
	"showEstimatesFlag"?: boolean;

	/**
	 * Metadata of the entity
	 */
	"info"?: Metadata;
}

export interface BoardDefault {
	"id"?: number;
	"board": BoardReference;
	"serviceType"?: ServiceTypeReference;
	"defaultFlag"?: boolean;
	"agreementId"?: number;

	/**
	 * Metadata of the entity
	 */
	"info"?: Metadata;
}

export interface BoardReference {
	"id"?: number;
	"name"?: string;

	/**
	 * Metadata of the entity
	 */
	"info"?: Metadata;
}

export interface CalendarReference {
	"id"?: number;
	"name"?: string;

	/**
	 * Metadata of the entity
	 */
	"info"?: Metadata;
}

export interface CallbackEntry {
	"id"?: number;
	"description"?: string;
	"url": string;
	"objectId": number;
	"type": string;
	"level": string;
	"memberId"?: number;
	"inactiveFlag"?: boolean;

	/**
	 * Metadata of the entity
	 */
	"info"?: Metadata;
}

export interface Campaign {
	"id"?: number;
	"name": string;
	"type": CampaignTypeReference;
	"subType": CampaignSubTypeReference;
	"status"?: CampaignStatusReference;
	"startDate": Date;
	"endDate"?: Date;
	"locationId"?: number;
	"member"?: MemberReference;
	"inactive"?: boolean;
	"inactiveDaysAfterEnd"?: number;
	"notes"?: string;
	"defaultGroup"?: GroupReference;
	"marketingManagerDefaultTrackId"?: number;
	"opportunityDefaultTrackId"?: number;
	"impressions"?: number;
	"budgetRevenue"?: number;
	"budgetCost"?: number;
	"actualCost"?: number;
	"budgetGrossMargin"?: number;
	"budgetROI"?: number;
	"actualRevenue"?: number;
	"actualGrossMargin"?: number;
	"actualROI"?: number;
	"emailsSent"?: number;

	/**
	 * Metadata of the entity
	 */
	"info"?: Metadata;
}

export interface CampaignAudit {
	"id"?: number;
	"emailsSent": number;
	"emailsUnsent"?: number;
	"documentsCreated"?: number;
	"emailSubject"?: string;
	"group"?: GroupReference;
	"campaignId"?: number;
	"createdBy"?: string;
	"dateCreated"?: string;
}

export interface CampaignReference {
	"id"?: number;
	"name"?: string;

	/**
	 * Metadata of the entity
	 */
	"info"?: Metadata;
}

export interface CampaignStatus {
	"id"?: number;
	"name": string;
	"defaultFlag"?: boolean;
	"inactiveFlag"?: boolean;

	/**
	 * Metadata of the entity
	 */
	"info"?: Metadata;
}

export interface CampaignStatusReference {
	"id"?: number;
	"name"?: string;

	/**
	 * Metadata of the entity
	 */
	"info"?: Metadata;
}

export interface CampaignSubType {
	"id"?: number;
	"typeId"?: number;
	"name": string;

	/**
	 * Metadata of the entity
	 */
	"info"?: Metadata;
}

export interface CampaignSubTypeReference {
	"id"?: number;
	"name"?: string;

	/**
	 * Metadata of the entity
	 */
	"info"?: Metadata;
}

export interface CampaignType {
	"id"?: number;
	"name": string;
	"defaultFlag"?: boolean;

	/**
	 * Metadata of the entity
	 */
	"info"?: Metadata;
}

export interface CampaignTypeReference {
	"id"?: number;
	"name"?: string;

	/**
	 * Metadata of the entity
	 */
	"info"?: Metadata;
}

export interface CatalogComponent {
	"id"?: number;
	"sequenceNumber"?: number;
	"quantity": number;
	"catalogItem": CatalogItemReference;
	"hidePriceFlag"?: boolean;
	"hideItemIdentifierFlag"?: boolean;
	"hideDescriptionFlag"?: boolean;
	"hideQuantityFlag"?: boolean;
	"parentCatalogItem"?: CatalogItemReference;
	"price"?: number;
	"cost"?: number;

	/**
	 * Metadata of the entity
	 */
	"info"?: Metadata;
}

export interface CatalogItem {
	"id"?: number;
	"identifier": string;
	"description": string;
	"inactiveFlag"?: boolean;
	"subcategory": ProductSubCategoryReference;
	"type": ProductTypeReference;

	/**
	 * Defaults to Non-Inventory
	 */
	"productClass"?: CatalogItem.ProductClassEnum;
	"serializedFlag"?: boolean;
	"serializedCostFlag"?: boolean;
	"phaseProductFlag"?: boolean;
	"unitOfMeasure"?: UnitOfMeasureReference;
	"minStockLevel"?: number;
	"price"?: number;
	"cost"?: number;
	"priceAttribute"?: CatalogItem.PriceAttributeEnum;
	"taxableFlag"?: boolean;
	"customerDescription": string;
	"manufacturer"?: ManufacturerReference;
	"manufacturerPartNumber"?: string;
	"vendor"?: CompanyReference;
	"vendorSku"?: string;
	"notes"?: string;
	"integrationXRef"?: string;
	"dateEntered"?: string;
	"category"?: ProductCategoryReference;

	/**
	 * Metadata of the entity
	 */
	"info"?: Metadata;
}

export namespace CatalogItem {

export type ProductClassEnum = 'Agreement' | 'Bundle' | 'Inventory' | 'NonInventory' | 'Service';

export type PriceAttributeEnum = 'FixedFee' | 'NotToExceed' | 'TimeAndMaterials' | 'OverrideRate';
}
export interface CatalogItemReference {
	"id"?: number;
	"identifier"?: string;

	/**
	 * Metadata of the entity
	 */
	"info"?: Metadata;
}

export interface Category {
	"id"?: number;
	"name": string;
	"inactiveFlag"?: boolean;
	"priceLevelXref"?: string;
	"integrationXref"?: string;
	"locationIds"?: Array<number>;
	"addAllLocations"?: boolean;
	"removeAllLocations"?: boolean;

	/**
	 * Metadata of the entity
	 */
	"info"?: Metadata;
}

export interface Certification {
	"id"?: number;
	"name": string;
	"company": CompanyReference;

	/**
	 * Metadata of the entity
	 */
	"info"?: Metadata;
}

export interface ChargeCodeReference {
	"id"?: number;
	"name"?: string;

	/**
	 * Metadata of the entity
	 */
	"info"?: Metadata;
}

export interface ClassificationReference {
	"id"?: number;
	"name"?: string;

	/**
	 * Metadata of the entity
	 */
	"info"?: Metadata;
}

export interface Code {
	"id"?: number;
	"name": string;
	"description": string;
	"boardId"?: number;
	"locationId"?: number;
	"businessUnitId"?: number;

	/**
	 * Metadata of the entity
	 */
	"info"?: Metadata;
}

export interface CommunicationTypeReference {
	"id"?: number;
	"name"?: string;

	/**
	 * Metadata of the entity
	 */
	"info"?: Metadata;
}

export interface Company {
	"id"?: number;
	"identifier": string;
	"name": string;
	"status"?: CompanyStatusReference;
	"type"?: CompanyTypeReference;

	/**
	 * At least one address field is required -- addressLine1, addressLine2, city, state, zip and/or country
	 */
	"addressLine1"?: string;

	/**
	 * At least one address field is required -- addressLine1, addressLine2, city, state, zip and/or country
	 */
	"addressLine2"?: string;

	/**
	 * At least one address field is required -- addressLine1, addressLine2, city, state, zip and/or country
	 */
	"city"?: string;

	/**
	 * At least one address field is required -- addressLine1, addressLine2, city, state, zip and/or country
	 */
	"state"?: string;

	/**
	 * At least one address field is required -- addressLine1, addressLine2, city, state, zip and/or country
	 */
	"zip"?: string;

	/**
	 * At least one address field is required -- addressLine1, addressLine2, city, state, zip and/or country
	 */
	"country"?: CountryReference;
	"phoneNumber"?: string;
	"faxNumber"?: string;
	"website"?: string;
	"territoryId"?: number;
	"marketId"?: number;
	"accountNumber"?: string;
	"defaultContact"?: ContactReference;
	"dateAcquired"?: Date;
	"sicCode"?: SicCodeReference;
	"parentCompany"?: CompanyReference;
	"annualRevenue"?: number;
	"numberOfEmployees"?: number;
	"ownershipType"?: OwnershipTypeReference;
	"timeZone"?: TimeZoneReference;
	"leadSource"?: string;
	"leadFlag"?: boolean;
	"unsubscribeFlag"?: boolean;
	"calendarId"?: number;
	"userDefinedField1"?: string;
	"userDefinedField2"?: string;
	"userDefinedField3"?: string;
	"userDefinedField4"?: string;
	"userDefinedField5"?: string;
	"userDefinedField6"?: string;
	"userDefinedField7"?: string;
	"userDefinedField8"?: string;
	"userDefinedField9"?: string;
	"userDefinedField10"?: string;
	"vendorIdentifier"?: string;
	"taxIdentifier"?: string;

	/**
	 * New companies will be created with the default tax code unless otherwise specified.
	 */
	"taxCode"?: TaxCodeReference;
	"billingTerms"?: BillingTermsReference;
	"invoiceTemplate"?: InvoiceTemplateReference;
	"pricingSchedule"?: PricingScheduleReference;

	/**
	 * Based on CompanyEntityType Report
	 */
	"companyEntityType"?: EntityTypeReference;
	"billToCompany"?: CompanyReference;
	"billingSite"?: SiteReference;
	"billingContact"?: ContactReference;
	"invoiceDeliveryMethod"?: BillingDeliveryReference;
	"invoiceToEmailAddress"?: string;
	"invoiceCCEmailAddress"?: string;
	"deletedFlag"?: boolean;
	"dateDeleted"?: Date;
	"deletedBy"?: string;
	"mobileGuid"?: Guid;
	"currency"?: CurrencyReference;
	"territoryManager"?: MemberReference;

	/**
	 * Metadata of the entity
	 */
	"info"?: Metadata;
	"customFields"?: Array<CustomFieldValue>;
}

export interface CompanyCustomNote {
	"id"?: number;
	"customNote": string;
	"status": CompanyStatusReference;
	"company"?: CompanyReference;

	/**
	 * Metadata of the entity
	 */
	"info"?: Metadata;
}

export interface CompanyManagementSummary {
	"id"?: number;
	"managementSolution"?: ManagementSolutionReference;
	"groupIdentifier": string;

	/**
	 * deviceType is required if the managementSolution is Legacy
	 */
	"deviceType"?: CompanyManagementSummary.DeviceTypeEnum;
	"agreement"?: AgreementReference;
	"snmpMachines"?: number;
	"totalWorkstations"?: number;
	"totalServers"?: number;
	"totalWindowsServers"?: number;
	"totalWindowsWorkstations"?: number;
	"totalManagedMachines"?: number;
	"serversOffline"?: number;
	"serversDiskSpaceLow"?: number;
	"failedBackupJobs"?: number;
	"totalNotifications"?: number;
	"successfulBackupJobs"?: number;
	"serverAvailability"?: number;
	"virusesRemoved"?: number;
	"spywareItemsRemoved"?: number;
	"windowsPatchesInstalled"?: number;
	"diskCleanups"?: number;
	"diskDefragmentations"?: number;
	"fullyPatchedMachines"?: number;
	"missingOneTwoPatchesMachines"?: number;
	"missingThreeFivePatchesMachines"?: number;
	"missingMoreFivePatchesMachines"?: number;
	"missingUnscannedPatchesMachines"?: number;
	"alertsGenerated"?: string;
	"internetConnectivity"?: number;
	"diskSpaceCleanedMb"?: number;
	"missingSecurityPatches"?: string;
	"cpuUtilization"?: number;
	"memoryUtilization"?: number;
	"company"?: CompanyReference;

	/**
	 * Metadata of the entity
	 */
	"info"?: Metadata;
}

export namespace CompanyManagementSummary {

export type DeviceTypeEnum = 'WorkstationsAndServers' | 'BackupStats' | 'Servers' | 'Workstations';
}
export interface CompanyMerge {
	"toCompanyId": number;
	"name"?: CompanyMerge.NameEnum;
	"identifier"?: CompanyMerge.IdentifierEnum;
	"status"?: CompanyMerge.StatusEnum;
	"type"?: CompanyMerge.TypeEnum;
	"primaryAddress"?: CompanyMerge.PrimaryAddressEnum;
	"primaryContact"?: CompanyMerge.PrimaryContactEnum;
	"phone"?: CompanyMerge.PhoneEnum;
	"fax"?: CompanyMerge.FaxEnum;
	"website"?: CompanyMerge.WebsiteEnum;
	"market"?: CompanyMerge.MarketEnum;
	"territory"?: CompanyMerge.TerritoryEnum;
	"revenue"?: CompanyMerge.RevenueEnum;
	"revenueYear"?: CompanyMerge.RevenueYearEnum;
	"numberOfEmployees"?: CompanyMerge.NumberOfEmployeesEnum;
	"sicCode"?: CompanyMerge.SicCodeEnum;
	"dateAcquired"?: CompanyMerge.DateAcquiredEnum;
	"timeZone"?: CompanyMerge.TimeZoneEnum;
	"sourceList"?: CompanyMerge.SourceListEnum;
	"userDefinedField1"?: CompanyMerge.UserDefinedField1Enum;
	"userDefinedField2"?: CompanyMerge.UserDefinedField2Enum;
	"userDefinedField3"?: CompanyMerge.UserDefinedField3Enum;
	"userDefinedField4"?: CompanyMerge.UserDefinedField4Enum;
	"userDefinedField5"?: CompanyMerge.UserDefinedField5Enum;
	"userDefinedField6"?: CompanyMerge.UserDefinedField6Enum;
	"userDefinedField7"?: CompanyMerge.UserDefinedField7Enum;
	"userDefinedField8"?: CompanyMerge.UserDefinedField8Enum;
	"userDefinedField9"?: CompanyMerge.UserDefinedField9Enum;
	"userDefinedField10"?: CompanyMerge.UserDefinedField10Enum;
	"billingAddress"?: CompanyMerge.BillingAddressEnum;
	"billingContact"?: CompanyMerge.BillingContactEnum;
	"taxCode"?: CompanyMerge.TaxCodeEnum;
	"accountNumber"?: CompanyMerge.AccountNumberEnum;
	"billingTerms"?: CompanyMerge.BillingTermsEnum;
	"notes"?: CompanyMerge.NotesEnum;
	"sites"?: CompanyMerge.SitesEnum;
	"activities"?: CompanyMerge.ActivitiesEnum;
	"opportunities"?: CompanyMerge.OpportunitiesEnum;
	"services"?: CompanyMerge.ServicesEnum;
	"projects"?: CompanyMerge.ProjectsEnum;
	"contacts"?: CompanyMerge.ContactsEnum;
	"documents"?: CompanyMerge.DocumentsEnum;
}

export namespace CompanyMerge {

export type NameEnum = 'From' | 'To';

export type IdentifierEnum = 'From' | 'To';

export type StatusEnum = 'From' | 'To';

export type TypeEnum = 'From' | 'To';

export type PrimaryAddressEnum = 'From' | 'To';

export type PrimaryContactEnum = 'From' | 'To';

export type PhoneEnum = 'From' | 'To';

export type FaxEnum = 'From' | 'To';

export type WebsiteEnum = 'From' | 'To';

export type MarketEnum = 'From' | 'To';

export type TerritoryEnum = 'From' | 'To';

export type RevenueEnum = 'From' | 'To';

export type RevenueYearEnum = 'From' | 'To';

export type NumberOfEmployeesEnum = 'From' | 'To';

export type SicCodeEnum = 'From' | 'To';

export type DateAcquiredEnum = 'From' | 'To';

export type TimeZoneEnum = 'From' | 'To';

export type SourceListEnum = 'From' | 'To';

export type UserDefinedField1Enum = 'From' | 'To';

export type UserDefinedField2Enum = 'From' | 'To';

export type UserDefinedField3Enum = 'From' | 'To';

export type UserDefinedField4Enum = 'From' | 'To';

export type UserDefinedField5Enum = 'From' | 'To';

export type UserDefinedField6Enum = 'From' | 'To';

export type UserDefinedField7Enum = 'From' | 'To';

export type UserDefinedField8Enum = 'From' | 'To';

export type UserDefinedField9Enum = 'From' | 'To';

export type UserDefinedField10Enum = 'From' | 'To';

export type BillingAddressEnum = 'From' | 'To';

export type BillingContactEnum = 'From' | 'To';

export type TaxCodeEnum = 'From' | 'To';

export type AccountNumberEnum = 'From' | 'To';

export type BillingTermsEnum = 'From' | 'To';

export type NotesEnum = 'Discard' | 'Merge';

export type SitesEnum = 'Discard' | 'Merge';

export type ActivitiesEnum = 'Discard' | 'Merge';

export type OpportunitiesEnum = 'Discard' | 'Merge';

export type ServicesEnum = 'Discard' | 'Merge';

export type ProjectsEnum = 'Discard' | 'Merge';

export type ContactsEnum = 'Discard' | 'Merge';

export type DocumentsEnum = 'Discard' | 'Merge';
}
export interface CompanyNote {
	"id"?: number;
	"text": string;
	"type"?: NoteTypeReference;
	"flagged"?: boolean;
	"enteredBy"?: string;
	"company"?: CompanyReference;

	/**
	 * Metadata of the entity
	 */
	"info"?: Metadata;
}

/**
 * If chargeToId is not specified, we asume you enter time against the company specified
 */
export interface CompanyReference {
	"id"?: number;
	"identifier"?: string;
	"name"?: string;

	/**
	 * Metadata of the entity
	 */
	"info"?: Metadata;
}

export interface CompanySite {
	"id"?: number;
	"name": string;
	"addressLine1"?: string;
	"addressLine2"?: string;
	"city"?: string;
	"state"?: string;
	"zip"?: string;
	"country"?: CountryReference;
	"phoneNumber"?: string;
	"faxNumber"?: string;
	"taxCodeId"?: number;
	"expenseReimbursement"?: number;
	"primaryAddressFlag"?: boolean;
	"defaultShippingFlag"?: boolean;
	"defaultBillingFlag"?: boolean;
	"defaultMailingFlag"?: boolean;
	"calendar"?: CalendarReference;
	"timeZone"?: TimeZoneReference;
	"company"?: CompanyReference;

	/**
	 * Metadata of the entity
	 */
	"info"?: Metadata;
}

export interface CompanyStatus {
	"id"?: number;
	"name": string;
	"defaultFlag"?: boolean;
	"inactiveFlag"?: boolean;
	"notifyFlag"?: boolean;
	"disallowSavingFlag"?: boolean;
	"notificationMessage"?: string;
	"customNoteFlag"?: boolean;
	"cancelOpenTracksFlag"?: boolean;
	"track"?: TrackReference;

	/**
	 * Metadata of the entity
	 */
	"info"?: Metadata;
}

export interface CompanyStatusReference {
	"id"?: number;
	"name"?: string;

	/**
	 * Metadata of the entity
	 */
	"info"?: Metadata;
}

export interface CompanyTeam {
	"id"?: number;
	"company"?: CompanyReference;
	"teamRole": TeamRoleReference;
	"locationId"?: number;
	"businessUnitId"?: number;
	"contact"?: ContactReference;
	"member"?: MemberReference;
	"accountManagerFlag"?: boolean;
	"techFlag"?: boolean;
	"salesFlag"?: boolean;

	/**
	 * Metadata of the entity
	 */
	"info"?: Metadata;
}

export interface CompanyType {
	"id"?: number;
	"name": string;
	"defaultFlag"?: boolean;
	"vendorFlag"?: boolean;

	/**
	 * Metadata of the entity
	 */
	"info"?: Metadata;
}

export interface CompanyTypeReference {
	"id"?: number;
	"name"?: string;

	/**
	 * Metadata of the entity
	 */
	"info"?: Metadata;
}

export interface Configuration {
	"id"?: number;
	"name": string;
	"type": ConfigurationTypeReference;
	"status"?: ConfigurationStatusReference;
	"company": CompanyReference;
	"contact"?: ContactReference;
	"site"?: SiteReference;
	"locationId"?: number;
	"businessUnitId"?: number;
	"deviceIdentifier"?: string;
	"serialNumber"?: string;
	"modelNumber"?: string;
	"tagNumber"?: string;
	"purchaseDate"?: Date;
	"installationDate"?: Date;
	"installedBy"?: MemberReference;
	"warrantyExpirationDate"?: Date;
	"vendorNotes"?: string;
	"notes"?: string;
	"macAddress"?: string;
	"lastLoginName"?: string;
	"billFlag"?: boolean;
	"backupSuccesses"?: number;
	"backupIncomplete"?: number;
	"backupFailed"?: number;
	"backupRestores"?: number;
	"lastBackupDate"?: Date;
	"backupServerName"?: string;
	"backupBillableSpaceGb"?: number;
	"backupProtectedDeviceList"?: string;
	"backupYear"?: number;
	"backupMonth"?: number;
	"ipAddress"?: string;
	"defaultGateway"?: string;
	"osType"?: string;
	"osInfo"?: string;
	"cpuSpeed"?: string;
	"ram"?: string;
	"localHardDrives"?: string;
	"parentConfigurationId"?: number;
	"vendor"?: CompanyReference;
	"manufacturer"?: ManufacturerReference;
	"questions"?: Array<ConfigurationQuestion>;
	"activeFlag"?: boolean;
	"managementLink"?: string;
	"remoteLink"?: string;
	"sla"?: SLAReference;
	"mobileGuid"?: Guid;

	/**
	 * Metadata of the entity
	 */
	"info"?: Metadata;
	"displayVendorFlag"?: boolean;
	"customFields"?: Array<CustomFieldValue>;
}

export interface ConfigurationQuestion {
	"answerId"?: number;
	"questionId"?: number;
	"question"?: string;
	"answer"?: string;
	"sequenceNumber"?: number;
	"numberOfDecimals"?: number;
	"fieldType"?: ConfigurationQuestion.FieldTypeEnum;
	"requiredFlag"?: boolean;
}

export namespace ConfigurationQuestion {

export type FieldTypeEnum = 'Text' | 'Button' | 'Currency' | 'Date' | 'Hyperlink' | 'IPAddress' | 'Checkbox' | 'Number' | 'Percent' | 'TextArea' | 'Password';
}
export interface ConfigurationReference {
	"id"?: number;
	"deviceIdentifier"?: string;

	/**
	 * Metadata of the entity
	 */
	"info"?: Metadata;
}

export interface ConfigurationStatus {
	"id"?: number;
	"description": string;
	"closedFlag"?: boolean;
	"defaultFlag"?: boolean;

	/**
	 * Metadata of the entity
	 */
	"info"?: Metadata;
}

export interface ConfigurationStatusReference {
	"id"?: number;
	"name"?: string;

	/**
	 * Metadata of the entity
	 */
	"info"?: Metadata;
}

export interface ConfigurationType {
	"id"?: number;
	"name": string;
	"inactiveFlag"?: boolean;
	"systemFlag"?: boolean;

	/**
	 * Metadata of the entity
	 */
	"info"?: Metadata;
}

export interface ConfigurationTypeQuestion {
	"id"?: number;
	"configurationTypeId"?: number;
	"fieldType": ConfigurationTypeQuestion.FieldTypeEnum;
	"entryType": ConfigurationTypeQuestion.EntryTypeEnum;
	"sequenceNumber"?: number;
	"question": string;
	"numberOfDecimals"?: number;
	"requiredFlag"?: boolean;
	"inactiveFlag"?: boolean;
	"possibleAnswers"?: Array<string>;

	/**
	 * Metadata of the entity
	 */
	"info"?: Metadata;
}

export namespace ConfigurationTypeQuestion {

export type FieldTypeEnum = 'Text' | 'Button' | 'Currency' | 'Date' | 'Hyperlink' | 'IPAddress' | 'Checkbox' | 'Number' | 'Percent' | 'TextArea' | 'Password';

export type EntryTypeEnum = 'EntryField' | 'List' | 'Option';
}
export interface ConfigurationTypeReference {
	"id"?: number;
	"name"?: string;

	/**
	 * Metadata of the entity
	 */
	"info"?: Metadata;
}

export interface ConnectWiseHostedSetup {
	"id"?: number;

	/**
	 * Can be obtained via ConnectWiseHostedApiScreen report
	 */
	"screenId": number;
	"description": string;
	"url": string;
	"type": ConnectWiseHostedSetup.TypeEnum;
	"origin"?: string;
	"podHeight"?: number;
	"toolbarButtonDialogHeight"?: number;
	"toolbarButtonDialogWidth"?: number;

	/**
	 * Only required for ToolbarButtons
	 */
	"toolbarButtonText"?: string;
	"toolbarButtonToolTip"?: string;
	"toolbarButtonIconDocumentId"?: number;
	"disabledFlag"?: boolean;
	"createdBy"?: string;
	"dateCreated"?: string;

	/**
	 * Metadata of the entity
	 */
	"info"?: Metadata;
}

export namespace ConnectWiseHostedSetup {

export type TypeEnum = 'Tab' | 'Pod' | 'ToolbarButton';
}
export interface Contact {
	"id"?: number;
	"firstName": string;
	"lastName"?: string;
	"type"?: ContactTypeReference;
	"company"?: CompanyReference;
	"site"?: SiteReference;
	"addressLine1"?: string;
	"addressLine2"?: string;
	"city"?: string;
	"state"?: string;
	"zip"?: string;
	"country"?: string;
	"relationship"?: RelationshipReference;
	"department"?: ContactDepartmentReference;
	"inactiveFlag"?: boolean;
	"defaultMergeContactId"?: number;
	"securityIdentifier"?: string;
	"managerContactId"?: number;
	"assistantContactId"?: number;
	"title"?: string;
	"school"?: string;
	"nickName"?: string;
	"marriedFlag"?: boolean;
	"childrenFlag"?: boolean;
	"significantOther"?: string;
	"portalPassword"?: string;
	"portalSecurityLevel"?: number;
	"disablePortalLoginFlag"?: boolean;
	"unsubscribeFlag"?: boolean;
	"gender"?: Contact.GenderEnum;
	"birthDay"?: Date;
	"anniversary"?: Date;
	"presence"?: Contact.PresenceEnum;
	"mobileGuid"?: Guid;
	"facebookUrl"?: string;
	"twitterUrl"?: string;
	"linkedInUrl"?: string;
	"defaultBillingFlag"?: boolean;
	"communicationItems"?: Array<ContactCommunicationItem>;

	/**
	 * Metadata of the entity
	 */
	"info"?: Metadata;
	"customFields"?: Array<CustomFieldValue>;
}

export namespace Contact {

export type GenderEnum = 'Male' | 'Female';

export type PresenceEnum = 'Online' | 'DoNotDisturb' | 'Away' | 'Offline' | 'NoAgent';
}
export interface ContactCommunication {
	"id"?: number;
	"contactId"?: number;
	"type": CommunicationTypeReference;
	"value": string;
	"extension"?: string;
	"defaultFlag"?: boolean;
	"mobileGuid"?: Guid;
	"communicationType"?: ContactCommunication.CommunicationTypeEnum;

	/**
	 * Metadata of the entity
	 */
	"info"?: Metadata;
}

export namespace ContactCommunication {

export type CommunicationTypeEnum = 'Phone' | 'Fax' | 'Email';
}
export interface ContactCommunicationItem {
	"id"?: number;
	"type": CommunicationTypeReference;
	"value": string;
	"extension"?: string;
	"defaultFlag"?: boolean;
	"communicationType"?: ContactCommunicationItem.CommunicationTypeEnum;
}

export namespace ContactCommunicationItem {

export type CommunicationTypeEnum = 'Phone' | 'Fax' | 'Email';
}
export interface ContactDepartment {
	"id"?: number;
	"name": string;

	/**
	 * Metadata of the entity
	 */
	"info"?: Metadata;
}

export interface ContactDepartmentReference {
	"id"?: number;
	"name"?: string;

	/**
	 * Metadata of the entity
	 */
	"info"?: Metadata;
}

export interface ContactNote {
	"id"?: number;
	"contactId"?: number;
	"text": string;
	"type"?: NoteTypeReference;
	"flagged"?: boolean;
	"enteredBy"?: string;

	/**
	 * Metadata of the entity
	 */
	"info"?: Metadata;
}

export interface ContactReference {
	"id"?: number;
	"name"?: string;

	/**
	 * Metadata of the entity
	 */
	"info"?: Metadata;
}

export interface ContactRelationship {
	"id"?: number;
	"name": string;

	/**
	 * Metadata of the entity
	 */
	"info"?: Metadata;
}

export interface ContactType {
	"id"?: number;
	"description": string;
	"defaultFlag"?: boolean;

	/**
	 * Metadata of the entity
	 */
	"info"?: Metadata;
}

export interface ContactTypeReference {
	"id"?: number;
	"name"?: string;

	/**
	 * Metadata of the entity
	 */
	"info"?: Metadata;
}

export interface Conversion {
	"id"?: number;
	"quantity": number;
	"uomType": UnitOfMeasureReference;
	"parentUOM"?: UnitOfMeasureReference;

	/**
	 * Metadata of the entity
	 */
	"info"?: Metadata;
}

export interface Count {
	"count"?: number;
}

/**
 * At least one address field is required -- addressLine1, addressLine2, city, state, zip and/or country
 */
export interface CountryReference {
	"id"?: number;
	"name"?: string;

	/**
	 * Metadata of the entity
	 */
	"info"?: Metadata;
}

export interface CreateAccountingBatchRequest {
	"id"?: number;
	"batchIdentifier": string;
	"glInterfaceIdentifier"?: string;

	/**
	 * Batch must export Invoices, Expenses or Products
	 */
	"exportInvoicesFlag"?: boolean;

	/**
	 * Batch must export Invoices, Expenses or Products
	 */
	"exportExpensesFlag"?: boolean;

	/**
	 * Batch must export Invoices, Expenses or Products
	 */
	"exportProductsFlag"?: boolean;
	"processedRecordIds": Array<number>;
	"summarizeExpenses"?: boolean;
}

export interface Currency {
	"id"?: number;
	"currencyIdentifier": string;
	"name"?: string;
	"symbol"?: string;
	"displayIdFlag"?: boolean;
	"displaySymbolFlag"?: boolean;
	"isoCode"?: string;

	/**
	 * Metadata of the entity
	 */
	"info"?: Metadata;
}

export interface CurrencyReference {
	"id"?: number;
	"identifier"?: string;

	/**
	 * Metadata of the entity
	 */
	"info"?: Metadata;
}

export interface CustomFieldValue {
	"id"?: number;
	"caption"?: string;
	"type"?: CustomFieldValue.TypeEnum;
	"entryMethod"?: CustomFieldValue.EntryMethodEnum;
	"numberOfDecimals"?: number;
	"value"?: string;
}

export namespace CustomFieldValue {

export type TypeEnum = 'Text' | 'Button' | 'Currency' | 'Date' | 'Hyperlink' | 'IPAddress' | 'Checkbox' | 'Number' | 'Percent' | 'TextArea' | 'Password';

export type EntryMethodEnum = 'EntryField' | 'List' | 'Option';
}
export interface DocumentInfo {
	"id"?: number;
	"title"?: string;
	"fileName"?: string;
	"serverFileName"?: string;
	"owner"?: string;
	"linkFlag"?: boolean;
	"imageFlag"?: boolean;
	"publicFlag"?: boolean;
	"readOnlyFlag"?: boolean;

	/**
	 * Metadata of the entity
	 */
	"info"?: Metadata;
}

export interface DocumentReference {
	"id"?: number;

	/**
	 * Metadata of the entity
	 */
	"info"?: Metadata;
}

export interface EmailOpened {
	"id"?: number;
	"campaignId"?: number;
	"contactId": number;
	"dateOpened"?: Date;
}

export interface EndpointRequest {
	"id"?: string;
	"contentType"?: string;
	"method"?: string;
	"relativeUrl"?: string;
	"body"?: string;
}

export interface EndpointResponse {
	"id"?: string;
	"code"?: number;
	"message"?: string;
	"sort"?: number;
}

/**
 * Based on CompanyEntityType Report
 */
export interface EntityTypeReference {
	"id"?: number;
	"name"?: string;

	/**
	 * Metadata of the entity
	 */
	"info"?: Metadata;
}

export interface Error {
	"code"?: string;
	"message"?: string;
	"errors"?: Array<ValidationError>;
}

export interface ExcludedMember {
	"id"?: number;
	"memberId": number;
	"boardId"?: number;

	/**
	 * Metadata of the entity
	 */
	"info"?: Metadata;
}

export interface ExpenseEntry {
	"id"?: number;

	/**
	 * Company or chargeToType is required
	 */
	"company"?: CompanyReference;
	"chargeToId"?: number;

	/**
	 * Company or chargeToType is required
	 */
	"chargeToType"?: ExpenseEntry.ChargeToTypeEnum;
	"type": ExpenseTypeReference;
	"member"?: MemberReference;
	"paymentMethod"?: PaymentMethodReference;
	"classification"?: ClassificationReference;
	"amount": number;
	"billableOption": ExpenseEntry.BillableOptionEnum;
	"date": Date;
	"locationId"?: number;
	"businessUnitId"?: number;
	"notes"?: string;
	"agreement"?: AgreementReference;
	"invoiceAmount"?: number;
	"taxes"?: Array<ExpenseTax>;
	"invoice"?: InvoiceReference;

	/**
	 * Metadata of the entity
	 */
	"info"?: Metadata;
}

export namespace ExpenseEntry {

export type ChargeToTypeEnum = 'ServiceTicket' | 'ProjectTicket' | 'ChargeCode' | 'Activity';

export type BillableOptionEnum = 'Billable' | 'DoNotBill' | 'NoCharge' | 'NoDefault';
}
export interface ExpenseTax {
	"id"?: number;
	"amount"?: number;
	"type"?: ExpenseTaxTypeReference;
}

export interface ExpenseTaxTypeReference {
	"id"?: number;
	"name"?: string;

	/**
	 * Metadata of the entity
	 */
	"info"?: Metadata;
}

export interface ExpenseType {
	"id"?: number;
	"name": string;
	"amountCaption": string;
	"reimbursementRate"?: number;
	"billExpenses": ExpenseType.BillExpensesEnum;
	"invoiceMarkupOption": ExpenseType.InvoiceMarkupOptionEnum;
	"invoiceMarkupAmount"?: number;
	"advancedAmountFlag"?: boolean;
	"mileageFlag"?: boolean;
	"quantityFlag"?: boolean;
	"inactiveFlag"?: boolean;
	"maxAmount"?: number;

	/**
	 * Metadata of the entity
	 */
	"info"?: Metadata;
}

export namespace ExpenseType {

export type BillExpensesEnum = 'Billable' | 'DoNotBill' | 'NoCharge';

export type InvoiceMarkupOptionEnum = 'Percent' | 'Amount' | 'Mile';
}
export interface ExpenseTypeReference {
	"id"?: number;
	"name"?: string;

	/**
	 * Metadata of the entity
	 */
	"info"?: Metadata;
}

export interface ExportAccountingBatchRequest {
	"batchIdentifier": string;
	"glInterfaceIdentifier"?: string;
	"thruDate"?: Date;
	"locationId"?: number;
	"summarizeInvoices"?: ExportAccountingBatchRequest.SummarizeInvoicesEnum;

	/**
	 * Batch export must include invoices, expenses, or products (procurement)
	 */
	"exportInvoicesFlag"?: boolean;
	"includedInvoiceIds"?: Array<number>;
	"excludedInvoiceIds"?: Array<number>;

	/**
	 * Batch export must include invoices, expenses, or products (procurement)
	 */
	"exportExpensesFlag"?: boolean;
	"includedExpenseIds"?: Array<number>;
	"excludedExpenseIds"?: Array<number>;

	/**
	 * Batch export must include invoices, expenses, or products (procurement)
	 */
	"exportProductsFlag"?: boolean;
	"includedProductIds"?: Array<string>;
	"excludedProductIds"?: Array<string>;
}

export namespace ExportAccountingBatchRequest {

export type SummarizeInvoicesEnum = 'Default' | 'Condensed' | 'Detailed';
}
export interface FilterValues {
	"conditions"?: string;
	"orderBy"?: string;
	"childconditions"?: string;
	"customfieldconditions"?: string;
}

export interface Forecast {
	"id"?: number;
	"name"?: string;
	"revenue"?: number;
	"cost"?: number;
	"type": Forecast.TypeEnum;
	"status"?: OpportunityStatusReference;
	"includedFlag"?: boolean;
	"recurring"?: ProductRecurring;
	"percent"?: number;
	"margin"?: number;
	"opportunityId"?: number;

	/**
	 * Metadata of the entity
	 */
	"info"?: Metadata;
}

export namespace Forecast {

export type TypeEnum = 'Product' | 'Service' | 'Agreement' | 'Other1' | 'Other2';
}
export interface FormSubmitted {
	"id"?: number;
	"campaignId"?: number;
	"contactId": number;
	"dateSubmitted"?: Date;
	"url": string;
	"queryString"?: string;
	"pageType"?: string;
	"pageSubType"?: string;
	"topic"?: string;
	"version"?: string;
	"status"?: string;
}

export interface GLExport {

	/**
	 * Mapped to GlPreferences Class
	 */
	"exportSettings"?: GLExportSettings;
	"vendors"?: Array<GLExportVendor>;
	"customers"?: Array<GLExportCustomer>;
	"transactions"?: Array<GLExportTransaction>;
	"expenses"?: Array<GLExportExpense>;
	"expenseBills"?: Array<GLExportExpenseBill>;
	"purchaseTransactions"?: Array<GLExportPurchaseTransaction>;
	"adjustmentTransactions"?: Array<GLExportAdjustmentTransaction>;
	"inventoryTransfers"?: Array<GLExportInventoryTransfer>;
}

export interface GLExportAdjustmentTransaction {
	"id"?: string;
	"documentType"?: string;
	"documentDate"?: Date;
	"glTypeID"?: string;
	"accountNumber"?: string;
	"memo"?: string;
	"glClass"?: string;
	"adjustmentDescription"?: string;
	"adjustmentDetail"?: Array<GLExportAdjustmentTransactionDetail>;
}

export interface GLExportAdjustmentTransactionDetail {
	"glClass"?: string;
	"description"?: string;
	"memo"?: string;
	"item"?: IvItemReference;
	"quantity"?: number;
	"total"?: number;
	"cost"?: number;
	"costAccountNumber"?: string;
	"inventoryAccountNumber"?: string;
	"accountNumber"?: string;
	"productAccountNumber"?: string;
}

export interface GLExportCustomer {
	"company"?: CompanyReference;
	"companyType"?: CompanyTypeReference;
	"contact"?: ContactReference;
	"site"?: SiteReference;
	"accountNumber"?: string;
	"billingTerms"?: BillingTermsReference;
	"billingTermsXref"?: string;
	"dueDays"?: number;
	"taxable"?: boolean;
	"taxCode"?: TaxCodeReference;
	"currency"?: CurrencyReference;
	"stateTaxXref"?: string;
	"countyTaxXref"?: string;
	"cityTaxXref"?: string;
	"countryTaxXref"?: string;
	"compositeTaxXref"?: string;
	"stateTaxRate"?: number;
	"countyTaxRate"?: number;
	"cityTaxRate"?: number;
	"countryTaxRate"?: number;
	"compositeTaxRate"?: number;
	"taxGroupRate"?: number;
	"taxAgencyXref"?: string;
	"stateTaxAgencyXref"?: string;
	"countyTaxAgencyXref"?: string;
	"cityTaxAgencyXref"?: string;
	"countryTaxAgencyXref"?: string;
	"compositeTaxAgencyXref"?: string;
}

export interface GLExportExpense {
	"id"?: number;
	"documentDate"?: Date;
	"documentType"?: string;
	"apAccountNumber"?: string;
	"apClass"?: string;
	"accountNumber"?: string;
	"glClass"?: string;
	"glTypeId"?: string;
	"memo"?: string;
	"description"?: string;
	"periodStartDate"?: Date;
	"periodEndDate"?: Date;
	"member"?: MemberReference;
	"vendorNumber"?: string;
	"company"?: CompanyReference;
	"companyAccountNumber"?: string;
	"project"?: ProjectReference;
	"currency"?: CurrencyReference;
	"total"?: number;
	"offset"?: GLExportExpenseOffset;
}

export interface GLExportExpenseBill {
	"id"?: number;
	"documentDate"?: string;
	"documentType"?: string;
	"documentNumber"?: string;
	"memo"?: string;
	"glClass"?: string;
	"apAccountNumber"?: string;
	"member"?: MemberReference;
	"vendorNumber"?: string;
	"currency"?: CurrencyReference;
	"total"?: number;
	"detail"?: Array<GLExportExpenseBillDetail>;
}

export interface GLExportExpenseBillDetail {
	"id"?: number;
	"documentDate"?: string;
	"glTypeId"?: string;
	"memo"?: string;
	"company"?: CompanyReference;
	"accountNumber"?: string;
	"expenseClass"?: ClassificationReference;
	"currency"?: CurrencyReference;
	"total"?: number;
	"billable"?: boolean;
	"reimbursable"?: boolean;
	"companyAdvance"?: boolean;
}

export interface GLExportExpenseOffset {
	"id"?: number;
	"documentDate"?: Date;
	"documentType"?: string;
	"accountNumber"?: string;
	"glTypeId"?: string;
	"glClass"?: string;
	"member"?: MemberReference;
	"memo"?: string;
	"description"?: string;
	"total"?: number;
}

export interface GLExportInventoryTransfer {
	"id"?: string;
	"documentType"?: string;
	"documentDate"?: Date;
	"accountNumber"?: string;
	"glClass"?: string;
	"glTypeId"?: string;
	"description"?: string;
	"salesCode"?: string;
	"memo"?: string;
	"costAcccountNumber"?: string;
	"inventoryAccountNumber"?: string;
	"transferId"?: number;
	"item"?: IvItemReference;
	"glItemId"?: string;
	"salesDescription"?: string;
	"itemDescription"?: string;
	"currency"?: CurrencyReference;
	"itemPrice"?: number;
	"taxable"?: boolean;
	"unitOfMeasure"?: UnitOfMeasureReference;
	"quantity"?: number;
	"cost"?: number;
	"total"?: number;
	"subCategory"?: ProductSubCategoryReference;
	"serializedFlag"?: boolean;
	"serialNumbers"?: string;
	"shipmentMethod"?: ShipmentMethodReference;
	"bin"?: WarehouseBinReference;
	"warehouse"?: WarehouseReference;
	"transferFromBin"?: WarehouseBinReference;
	"transferFromLocationXref"?: string;
	"transferToBin"?: WarehouseBinReference;
	"transferToLocationXref"?: string;
	"locationXref"?: string;
	"priceLevelXref"?: string;
	"uomScheduleXref"?: string;
	"itemTypeXref"?: string;
	"inventoryXref"?: string;
	"cogsXref"?: string;
	"taxNote"?: string;
	"taxCode"?: TaxCodeReference;
	"offset"?: GLExportInventoryTransferOffset;
}

export interface GLExportInventoryTransferOffset {
	"id"?: number;
	"documentType"?: string;
	"documentDate"?: Date;
	"accountNumber"?: string;
	"glClass"?: string;
	"total"?: number;
	"memo"?: string;
	"description"?: string;
	"glTypeId"?: string;
}

export interface GLExportPurchaseTransaction {
	"id"?: string;
	"documentDate"?: Date;
	"documentNumber"?: string;
	"description"?: string;
	"memo"?: string;
	"apAccountNumber"?: string;
	"purchaseDate"?: Date;
	"company"?: CompanyReference;
	"companyType"?: CompanyTypeReference;
	"contact"?: ContactReference;
	"site"?: SiteReference;
	"purchaseClass"?: string;
	"freightAmount"?: number;
	"freightPackingSlip"?: string;
	"packingSlip"?: string;
	"dropshipFlag"?: boolean;
	"currency"?: CurrencyReference;
	"total"?: number;
	"billingTerms"?: BillingTermsReference;
	"billingTermsXref"?: string;
	"dueDays"?: number;
	"vendorNumber"?: string;
	"vendorAccountNumber"?: string;
	"vendorInvoiceDate"?: Date;
	"vendorInvoiceNumber"?: string;
	"taxAgencyXref"?: string;
	"stateTaxXref"?: string;
	"countyTaxXref"?: string;
	"cityTaxXref"?: string;
	"shipToCompany"?: CompanyReference;
	"shipToCompanyAccountNumber"?: string;
	"shipToCompanyType"?: CompanyTypeReference;
	"shipToContact"?: ContactReference;
	"shipToSite"?: SiteReference;
	"shipToTaxGroup"?: string;
	"taxCode"?: TaxCodeReference;
	"taxGroupRate"?: number;
	"useAvalaraTaxFlag"?: boolean;
	"purchaseHeaderTaxGroup"?: string;
	"purchaseHeaderTaxableFlag"?: boolean;
	"purchaseHeaderFreightTaxableFlag"?: boolean;
	"purchaseDetail"?: Array<GLExportPurchaseTransactionDetail>;
	"purchaseDetailTax"?: Array<GLExportPurchaseTransactionDetailTax>;
}

export interface GLExportPurchaseTransactionDetail {
	"id"?: number;
	"documentDate"?: Date;
	"glClass"?: string;
	"glTypeId"?: string;
	"glItemId"?: string;
	"salesCode"?: string;
	"description"?: string;
	"cost"?: number;
	"memo"?: string;
	"taxNote"?: string;
	"vendorNumber"?: string;
	"accountNumber"?: string;
	"costAccountNumber"?: string;
	"inventoryAccountNumber"?: string;
	"vendorAccountNumber"?: string;
	"item"?: IvItemReference;
	"itemDescription"?: string;
	"salesDescription"?: string;
	"taxable"?: boolean;
	"itemPrice"?: number;
	"itemCost"?: number;
	"unitOfMeasure"?: UnitOfMeasureReference;
	"quantity"?: number;
	"total"?: number;
	"currency"?: CurrencyReference;
	"serializedFlag"?: boolean;
	"serialNumbers"?: string;
	"dropShippedFlag"?: boolean;
	"lineNumber"?: number;
	"warehouseBin"?: WarehouseBinReference;
	"warehouseSite"?: SiteReference;
	"subCategory"?: ProductSubCategoryReference;
	"shipmentMethod"?: ShipmentMethodReference;
	"itemTypeXref"?: string;
	"inventoryXref"?: string;
	"cogsXref"?: string;
	"uomScheduleXref"?: string;
	"priceLevelXref"?: string;
	"locationXref"?: string;
	"taxCode"?: TaxCodeReference;
	"purchaseHeaderTaxGroup"?: string;
	"taxCodeXref"?: string;
	"taxRate"?: number;
	"taxAgencyXref"?: string;
}

export interface GLExportPurchaseTransactionDetailTax {
	"id"?: number;
	"documentDate"?: Date;
	"accountNumber"?: string;
	"glClass"?: string;
	"cost"?: number;
	"salesCode"?: string;
	"glTypeId"?: string;
	"glItemId"?: string;
	"memo"?: string;
	"vendorNumber"?: string;
	"vendorAccountNumber"?: string;
	"costAccountNumber"?: string;
	"inventoryAccountNumber"?: string;
	"itemTypeXref"?: string;
	"inventoryXref"?: string;
	"cogsXref"?: string;
	"uomScheduleXref"?: string;
	"priceLevelXref"?: string;
	"locationXref"?: string;
	"item"?: IvItemReference;
	"taxableFlag"?: boolean;
	"salesDescription"?: string;
	"itemDescription"?: string;
	"itemPrice"?: number;
	"itemCost"?: number;
	"unitOfMeasure"?: UnitOfMeasureReference;
	"quantity"?: number;
	"total"?: number;
	"currency"?: CurrencyReference;
	"serializedFlag"?: boolean;
	"serialNumbers"?: string;
	"dropShippedFlag"?: boolean;
	"lineNumber"?: number;
	"warehouseSite"?: SiteReference;
	"warehouseBin"?: WarehouseBinReference;
	"shipmentMethod"?: ShipmentMethodReference;
	"subCategory"?: ProductSubCategoryReference;
	"taxCode"?: TaxCodeReference;
	"taxRate"?: number;
	"taxRatePercent"?: number;
	"taxAgencyXref"?: string;
	"taxNote"?: string;
	"purchaseHeaderTaxGroup"?: string;
}

/**
 * Mapped to GlPreferences Class
 */
export interface GLExportSettings {
}

export interface GLExportTransaction {
	"id"?: number;
	"glClass"?: string;
	"glTypeId"?: string;
	"documentDate"?: Date;
	"documentNumber"?: string;
	"documentType"?: string;
	"memo"?: string;
	"description"?: string;
	"attention"?: string;
	"salesTerritory"?: string;
	"company"?: CompanyReference;
	"companyType"?: CompanyTypeReference;
	"companyAccountNumber"?: string;
	"site"?: SiteReference;
	"billingTerms"?: BillingTermsReference;
	"billingTermsXref"?: string;
	"dueDays"?: number;
	"dueDate"?: Date;
	"emailDeliveryFlag"?: boolean;
	"printDeliveryFlag"?: boolean;
	"agreementPrePaymentFlag"?: boolean;
	"accountNumber"?: string;
	"billingType"?: string;
	"glEntryIds"?: string;
	"purchaseOrder"?: PurchaseOrderReference;
	"project"?: ProjectReference;
	"currency"?: CurrencyReference;
	"total"?: number;
	"salesRepId"?: string;
	"salesRepName"?: string;
	"taxable"?: boolean;
	"taxableTotal"?: number;
	"taxCode"?: TaxCodeReference;
	"taxGroupRate"?: number;
	"piggyBackFlag"?: boolean;
	"taxAccountNumber"?: string;
	"salesTax"?: number;
	"stateTax"?: number;
	"countyTax"?: number;
	"cityTax"?: number;
	"taxableAmount1"?: number;
	"taxableAmount2"?: number;
	"taxableAmount3"?: number;
	"taxableAmount4"?: number;
	"taxableAmount5"?: number;
	"taxAgencyXref"?: string;
	"stateTaxXref"?: string;
	"countyTaxXref"?: string;
	"taxId"?: string;
	"taxDpAppliedFlag"?: boolean;
	"useAvalaraFlag"?: boolean;
	"sendAvalaraTaxFlag"?: boolean;
	"shipToCompany"?: CompanyReference;
	"shipCompanyAccountNumber"?: string;
	"shipCompanyType"?: CompanyTypeReference;
	"shipTaxId"?: string;
	"shipSite"?: SiteReference;
	"shipContact"?: ContactReference;
	"detail"?: Array<GLExportTransactionDetail>;
}

export interface GLExportTransactionDetail {
	"id"?: number;
	"documentDate"?: Date;
	"documentType"?: string;
	"accountNumber"?: string;
	"glClass"?: string;
	"glTypeId"?: string;
	"glItemId"?: string;
	"invoiceSummaryOption"?: number;
	"cost"?: number;
	"salesCode"?: string;
	"memo"?: string;
	"description"?: string;
	"quantity"?: number;
	"total"?: number;
	"currency"?: CurrencyReference;
	"timeEntry"?: TimeEntryReference;
	"costAccountNumber"?: string;
	"inventoryAccountNumber"?: string;
	"productAccountNumber"?: string;
	"taxCode"?: TaxCodeReference;
	"taxCodeXref"?: string;
	"taxAgencyXref"?: string;
	"taxNote"?: string;
	"taxRate"?: number;
	"taxRatePercent"?: number;
	"taxableFlag"?: boolean;
	"taxable2Flag"?: boolean;
	"taxable3Flag"?: boolean;
	"taxable4Flag"?: boolean;
	"taxable5Flag"?: boolean;
	"item"?: IvItemReference;
	"itemTaxableFlag"?: boolean;
	"itemPrice"?: number;
	"itemCost"?: number;
	"itemDescription"?: string;
	"salesDescription"?: string;
	"unitOfMeasure"?: UnitOfMeasureReference;
	"subCategory"?: ProductSubCategoryReference;
	"serializedFlag"?: boolean;
	"serialNumbers"?: string;
	"warehouseSite"?: SiteReference;
	"warehouseBin"?: WarehouseBinReference;
	"shipmentMethod"?: ShipmentMethodReference;
	"dropShippedFlag"?: boolean;
	"itemTypeXref"?: string;
	"inventoryXref"?: string;
	"cogsXref"?: string;
	"uomScheduleXref"?: string;
	"priceLevelXref"?: string;
	"locationXref"?: string;
}

export interface GLExportVendor {

	/**
	 * Vendor Can be either Member or Company Reference
	 */
	"member"?: MemberReference;

	/**
	 * Vendor Can be either Member or Company Reference
	 */
	"vendor"?: CompanyReference;
	"vendorNumber"?: string;
	"company"?: CompanyReference;
	"contact"?: ContactReference;
	"accountNumber"?: string;
	"billingTerms"?: BillingTermsReference;
	"dueDays"?: number;
	"site"?: SiteReference;
	"taxCode"?: TaxCodeReference;
}

export interface GenericIdIdentifierReference {
	"id"?: number;
	"identifier"?: string;
}

export interface Group {
	"id"?: number;
	"name": string;
	"publicDescription"?: string;
	"publicFlag"?: boolean;
	"inactiveFlag"?: boolean;

	/**
	 * Metadata of the entity
	 */
	"info"?: Metadata;
}

export interface GroupReference {
	"id"?: number;
	"name"?: string;

	/**
	 * Metadata of the entity
	 */
	"info"?: Metadata;
}

export interface Guid {
}

export interface InOutBoard {
	"id"?: number;
	"member": MemberReference;
	"inOutType": InOutTypeReference;
	"additionalInfo"?: string;
	"dateBack": Date;

	/**
	 * Metadata of the entity
	 */
	"info"?: Metadata;
}

export interface InOutType {
	"id"?: number;
	"description": string;

	/**
	 * Metadata of the entity
	 */
	"info"?: Metadata;
}

export interface InOutTypeReference {
	"id"?: number;
	"name"?: string;

	/**
	 * Metadata of the entity
	 */
	"info"?: Metadata;
}

export interface Info {
	"version"?: string;
	"isCloud"?: boolean;
	"serverTimeZone"?: string;
}

export interface Invoice {
	"id"?: number;
	"invoiceNumber"?: string;
	"type": Invoice.TypeEnum;
	"status"?: BillingStatusReference;
	"company": CompanyReference;
	"billToCompany"?: CompanyReference;
	"shipToCompany"?: CompanyReference;
	"applyToType"?: Invoice.ApplyToTypeEnum;
	"applyToId"?: number;
	"attention"?: string;
	"billingSite"?: SiteReference;
	"shippingSite"?: SiteReference;
	"billingTerms"?: BillingTermsReference;
	"reference"?: string;
	"customerPO"?: string;

	/**
	 * Can be obtained via InvoiceTemplate report
	 */
	"templateSetupId"?: number;

	/**
	 * Can be obtained via InvoiceEmailTemplate report
	 */
	"emailTemplateId"?: number;
	"addToBatchEmailList"?: boolean;
	"date"?: Date;
	"restrictDownpaymentFlag"?: boolean;
	"locationId"?: number;
	"departmentId"?: number;
	"territoryId"?: number;
	"topComment"?: string;
	"bottomComment"?: string;
	"taxableFlag"?: boolean;
	"taxCode"?: TaxCodeReference;
	"internalNotes"?: string;
	"downpaymentPreviouslyTaxedFlag"?: boolean;
	"serviceTotal"?: number;
	"dueDate"?: Date;
	"expenseTotal"?: number;
	"productTotal"?: number;
	"previousProgressApplied"?: number;
	"serviceAdjustmentAmount"?: number;
	"agreementAmount"?: number;
	"downpaymentApplied"?: number;
	"subtotal"?: number;
	"total"?: number;
	"remainingDownpayment"?: number;
	"salesTax"?: number;
	"adjustmentReason"?: string;
	"adjustedBy"?: string;
	"payments"?: number;
	"credits"?: number;
	"balance"?: number;
	"specialInvoiceFlag"?: boolean;

	/**
	 * Metadata of the entity
	 */
	"info"?: Metadata;
}

export namespace Invoice {

export type TypeEnum = 'Agreement' | 'CreditMemo' | 'DownPayment' | 'Miscellaneous' | 'Progress' | 'Standard';

export type ApplyToTypeEnum = 'All' | 'Agreement' | 'Project' | 'ProjectPhase' | 'SalesOrder' | 'Ticket';
}
export interface InvoiceReference {
	"id"?: number;
	"identifier"?: string;

	/**
	 * Metadata of the entity
	 */
	"info"?: Metadata;
}

export interface InvoiceTemplateReference {
	"id"?: number;
	"name"?: string;

	/**
	 * Metadata of the entity
	 */
	"info"?: Metadata;
}

export interface Item {
	"id"?: number;
	"name": string;
	"inactive"?: boolean;
	"typeAssociations"?: Array<TypeAssociations>;
	"addAllSubTypes"?: boolean;
	"removeAllSubTypes"?: boolean;
	"typeId"?: number;
	"boardId"?: number;

	/**
	 * Metadata of the entity
	 */
	"info"?: Metadata;
}

export interface IvItemReference {
	"id"?: number;
	"identifier"?: string;

	/**
	 * Metadata of the entity
	 */
	"info"?: Metadata;
}

export interface JObject {
}

export interface KnowledgeBaseArticle {
	"id"?: number;
	"title": string;
	"issue": string;
	"resolution": string;
	"locationId"?: number;
	"businessUnitId"?: number;
	"board"?: BoardReference;
	"categoryId"?: number;
	"subCategoryId"?: number;
	"dateCreated"?: string;
	"createdBy"?: string;

	/**
	 * Metadata of the entity
	 */
	"info"?: Metadata;
}

export interface Link {
	"id"?: number;
	"name": string;
	"tableReferenceId": number;
	"url"?: string;

	/**
	 * Metadata of the entity
	 */
	"info"?: Metadata;
}

export interface LinkClicked {
	"id"?: number;
	"campaignId"?: number;
	"contactId": number;
	"dateClicked"?: Date;
	"url": string;
	"queryString"?: string;
}

export interface Location {
	"id"?: number;
	"name": string;
	"where": Location.WhereEnum;
	"defaultFlag"?: boolean;

	/**
	 * Metadata of the entity
	 */
	"info"?: Metadata;
}

export namespace Location {

export type WhereEnum = 'OnSite' | 'Remote' | 'InHouse';
}
export interface ManagementBackup {
	"id"?: number;
	"type": AgreementTypeReference;
	"item": CatalogItemReference;
	"billingLevel": ManagementBackup.BillingLevelEnum;

	/**
	 * Metadata of the entity
	 */
	"info"?: Metadata;
}

export namespace ManagementBackup {

export type BillingLevelEnum = 'Summary' | 'Detail';
}
export interface ManagementEmail {
	"id"?: number;
	"name": string;
	"managementSolution": ManagementEmail.ManagementSolutionEnum;
	"identifier": string;
	"emailUsername"?: string;

	/**
	 * The password field can only be set on initial POST.
	 */
	"emailPassword"?: string;
	"serverPrefix"?: string;

	/**
	 * Metadata of the entity
	 */
	"info"?: Metadata;
}

export namespace ManagementEmail {

export type ManagementSolutionEnum = 'DoubleCheck' | 'Postini';
}
export interface ManagementSolutionReference {
	"id"?: number;
	"name"?: string;

	/**
	 * Metadata of the entity
	 */
	"info"?: Metadata;
}

export interface Manufacturer {
	"id"?: number;
	"name": string;
	"inactiveFlag"?: boolean;

	/**
	 * Metadata of the entity
	 */
	"info"?: Metadata;
}

export interface ManufacturerReference {
	"id"?: number;
	"name"?: string;

	/**
	 * Metadata of the entity
	 */
	"info"?: Metadata;
}

export interface MarketDescription {
	"id"?: number;
	"name": string;

	/**
	 * Metadata of the entity
	 */
	"info"?: Metadata;
}

export interface MarketingCompany {
	"id": number;
	"groupId"?: number;
	"defaultContactFlag"?: boolean;
	"allContactsFlag"?: boolean;
	"unsubscribeFlag"?: boolean;

	/**
	 * Metadata of the entity
	 */
	"info"?: Metadata;
}

export interface MarketingContact {
	"id": number;
	"groupId"?: number;
	"note"?: string;
	"unsubscribeFlag"?: boolean;

	/**
	 * Metadata of the entity
	 */
	"info"?: Metadata;
}

export interface Member {
	"adminFlag"?: boolean;
	"allowExpensesEnteredAgainstCompaniesFlag"?: boolean;
	"allowInCellEntryOnTimeSheet"?: boolean;
	"billableForecast"?: number;
	"calendar"?: CalendarReference;
	"calendarSyncIntegrationFlag"?: boolean;
	"country"?: CountryReference;
	"dailyCapacity"?: number;
	"daysTolerance"?: number;
	"defaultDepartmentId": number;
	"defaultEmail": Member.DefaultEmailEnum;
	"defaultLocationId": number;
	"defaultPhone": Member.DefaultPhoneEnum;
	"disableOnlineFlag"?: boolean;
	"enableLdapAuthenticationFlag"?: boolean;
	"enableMobileFlag"?: boolean;
	"enableMobileGpsFlag"?: boolean;
	"enterTimeAgainstCompanyFlag"?: boolean;
	"expenseApprover": MemberReference;
	"firstName": string;
	"hideMemberInDispatchPortalFlag"?: boolean;
	"hireDate": Date;
	"homeEmail"?: string;
	"homeExtension"?: string;
	"homePhone"?: string;
	"hourlyCost"?: number;
	"hourlyRate"?: number;
	"id"?: number;
	"identifier": string;
	"inactiveDate"?: Date;
	"inactiveFlag"?: boolean;
	"includeInUtilizationReportingFlag"?: boolean;
	"lastLogin"?: string;
	"lastName": string;

	/**
	 * F = Regular Member, A = API Member, C = StreamlineIT Member, X = Subcontractor Member
	 */
	"licenseClass": Member.LicenseClassEnum;
	"mapiName"?: string;
	"middleInitial"?: string;
	"minimumHours"?: number;
	"mobileEmail"?: string;
	"mobileExtension"?: string;
	"mobilePhone"?: string;
	"notes"?: string;
	"officeEmail"?: string;
	"officeExtension"?: string;
	"officePhone"?: string;
	"projectDefaultBoard"?: ProjectBoardReference;
	"projectDefaultDepartmentId"?: number;
	"projectDefaultLocationId"?: number;
	"reportsTo"?: MemberReference;
	"requireExpenseEntryFlag"?: boolean;
	"requireStartAndEndTimeOnTimeEntryFlag"?: boolean;
	"requireTimeSheetEntryFlag"?: boolean;
	"restrictDefaultSalesTerritoryFlag"?: boolean;
	"restrictDefaultWarehouseBinFlag"?: boolean;
	"restrictDefaultWarehouseFlag"?: boolean;
	"restrictDepartmentFlag"?: boolean;
	"restrictLocationFlag"?: boolean;
	"restrictProjectDefaultDepartmentFlag"?: boolean;
	"restrictProjectDefaultLocationFlag"?: boolean;
	"restrictScheduleFlag"?: boolean;
	"restrictServiceDefaultDepartmentFlag"?: boolean;
	"restrictServiceDefaultLocationFlag"?: boolean;
	"salesDefaultLocationId": number;
	"scheduleCapacity"?: number;
	"scheduleDefaultDepartmentId"?: number;
	"scheduleDefaultLocationId"?: number;
	"securityLevel"?: string;
	"securityLocationId"?: number;
	"securityRole"?: SecurityRoleReference;
	"serviceDefaultBoard"?: BoardReference;
	"serviceDefaultDepartmentId"?: number;
	"serviceDefaultLocationId"?: number;
	"serviceLocation"?: ServiceLocationReference;
	"serviceTeams"?: Array<number>;
	"timeApprover": MemberReference;
	"timeReminderEmailFlag"?: boolean;
	"timeSheetStartDate"?: Date;
	"timeZone": TimeZoneReference;
	"title"?: string;
	"type"?: MemberTypeReference;
	"vendorNumber"?: string;
	"warehouse"?: WarehouseReference;
	"warehouseBin"?: WarehouseBinReference;
	"workRole": WorkRoleReference;
	"workType"?: WorkTypeReference;

	/**
	 * Metadata of the entity
	 */
	"info"?: Metadata;
	"systemFlag"?: boolean;
}

export namespace Member {

export type DefaultEmailEnum = 'Office' | 'Mobile' | 'Home';

export type DefaultPhoneEnum = 'Office' | 'Mobile' | 'Home';

export type LicenseClassEnum = 'F' | 'A' | 'C' | 'X';
}
/**
 * Activity schedule requires a member
 */
export interface MemberReference {
	"id"?: number;
	"identifier"?: string;
	"name"?: string;

	/**
	 * Metadata of the entity
	 */
	"info"?: Metadata;
}

export interface MemberTypeReference {
	"id"?: number;
	"name"?: string;

	/**
	 * Metadata of the entity
	 */
	"info"?: Metadata;
}

export interface MenuEntry {
	"id"?: number;
	"menuLocation": MenuLocationReference;
	"caption": string;
	"link": string;
	"newWindowFlag": boolean;
	"locationIds"?: Array<number>;
	"origin"?: string;
	"addAllLocations"?: boolean;
	"removeAllLocations"?: boolean;
	"smallMenuIconId"?: number;
	"largeMenuIconId"?: number;

	/**
	 * Metadata of the entity
	 */
	"info"?: Metadata;
}

export interface MenuLocationReference {
	"id"?: number;
	"name"?: string;

	/**
	 * Metadata of the entity
	 */
	"info"?: Metadata;
}

/**
 * Metadata of the entity
 */
export interface Metadata {
}

export interface NoteType {
	"id"?: number;
	"identifier"?: string;
	"name": string;
	"defaultFlag"?: boolean;
	"importFlag"?: boolean;

	/**
	 * Metadata of the entity
	 */
	"info"?: Metadata;
}

export interface NoteTypeReference {
	"id"?: number;
	"name"?: string;

	/**
	 * Metadata of the entity
	 */
	"info"?: Metadata;
}

export interface Opportunity {
	"id"?: number;
	"name": string;
	"expectedCloseDate"?: Date;
	"type"?: OpportunityTypeReference;
	"stage"?: OpportunityStageReference;
	"status"?: OpportunityStatusReference;
	"priority"?: OpportunityPriorityReference;
	"notes"?: string;
	"probability"?: OpportunityProbabilityReference;
	"source"?: string;
	"rating"?: OpportunityRatingReference;
	"campaign"?: CampaignReference;
	"primarySalesRep": MemberReference;
	"secondarySalesRep"?: MemberReference;
	"locationId"?: number;
	"businessUnitId"?: number;
	"company": CompanyReference;
	"contact": ContactReference;
	"site": SiteReference;
	"customerPO"?: string;
	"pipelineChangeDate"?: Date;
	"dateBecameLead"?: Date;
	"closedDate"?: Date;
	"closedBy"?: MemberReference;
	"totalSalesTax"?: number;
	"shipToCompany"?: CompanyReference;
	"shipToContact"?: ContactReference;
	"shipToSite"?: SiteReference;
	"billToCompany"?: CompanyReference;
	"billToContact"?: ContactReference;
	"billToSite"?: SiteReference;
	"billingTerms"?: BillingTermsReference;
	"taxCode"?: TaxCodeReference;

	/**
	 * Metadata of the entity
	 */
	"info"?: Metadata;
	"customFields"?: Array<CustomFieldValue>;
}

export interface OpportunityContact {
	"id"?: number;
	"contact": ContactReference;
	"company"?: CompanyReference;
	"role"?: OpportunitySalesRoleReference;
	"notes"?: string;
	"referralFlag"?: boolean;
	"opportunityId"?: number;
	"phoneNumber"?: string;
	"emailAddress"?: string;

	/**
	 * Metadata of the entity
	 */
	"info"?: Metadata;
}

export interface OpportunityNote {
	"id"?: number;
	"opportunityId"?: number;
	"type"?: NoteTypeReference;
	"text": string;
	"flagged"?: boolean;
	"enteredBy"?: string;
	"mobileGuid"?: Guid;

	/**
	 * Metadata of the entity
	 */
	"info"?: Metadata;
}

export interface OpportunityPriorityReference {
	"id"?: number;
	"name"?: string;

	/**
	 * Metadata of the entity
	 */
	"info"?: Metadata;
}

export interface OpportunityProbabilityReference {
	"id"?: number;
	"name"?: string;

	/**
	 * Metadata of the entity
	 */
	"info"?: Metadata;
}

export interface OpportunityRating {
	"id"?: number;
	"name": string;
	"sortOrder"?: number;

	/**
	 * Metadata of the entity
	 */
	"info"?: Metadata;
}

export interface OpportunityRatingReference {
	"id"?: number;
	"name"?: string;

	/**
	 * Metadata of the entity
	 */
	"info"?: Metadata;
}

export interface OpportunityReference {
	"id"?: number;
	"name"?: string;

	/**
	 * Metadata of the entity
	 */
	"info"?: Metadata;
}

export interface OpportunitySalesRoleReference {
	"id"?: number;
	"name"?: string;

	/**
	 * Metadata of the entity
	 */
	"info"?: Metadata;
}

export interface OpportunityStage {
	"id"?: number;
	"name": string;
	"probability"?: OpportunityProbabilityReference;
	"color"?: string;
	"sequenceNumber"?: number;

	/**
	 * Metadata of the entity
	 */
	"info"?: Metadata;
}

export interface OpportunityStageReference {
	"id"?: number;
	"name"?: string;

	/**
	 * Metadata of the entity
	 */
	"info"?: Metadata;
}

export interface OpportunityStatus {
	"id"?: number;
	"name": string;
	"wonFlag"?: boolean;
	"lostFlag"?: boolean;
	"closedFlag"?: boolean;
	"inactiveFlag"?: boolean;
	"defaultFlag"?: boolean;

	/**
	 * Metadata of the entity
	 */
	"info"?: Metadata;
	"enteredBy"?: string;
	"dateEntered"?: Date;
}

export interface OpportunityStatusReference {
	"id"?: number;
	"name"?: string;

	/**
	 * Metadata of the entity
	 */
	"info"?: Metadata;
}

export interface OpportunityToAgreementConversion {
	"agreementId"?: number;
	"name"?: string;
	"type"?: AgreementTypeReference;
	"startDate"?: string;
	"endDate"?: string;
	"noEndingDateFlag"?: boolean;
	"billCycleId"?: number;
	"billOneTimeFlag"?: boolean;
	"locationId"?: number;
	"businessUnitId"?: number;
	"includeAllNotesFlag"?: boolean;
	"includeAllDocumentsFlag"?: boolean;
	"includeAllProductsFlag"?: boolean;
	"includeNoteIds"?: Array<number>;
	"includeDocumentIds"?: Array<number>;
	"includeProductIds"?: Array<number>;
}

export interface OpportunityToProjectConversion {
	"projectId"?: number;
	"name"?: string;
	"status"?: ProjectStatusReference;
	"locationId"?: number;
	"businessUnitId"?: number;
	"board"?: ProjectBoardReference;
	"manager"?: MemberReference;
	"estimatedStart"?: string;
	"estimatedEnd"?: string;
	"includeAllNotesFlag"?: boolean;
	"includeAllDocumentsFlag"?: boolean;
	"includeAllProductsFlag"?: boolean;
	"includeNoteIds"?: Array<number>;
	"includeDocumentIds"?: Array<number>;
	"includeProductIds"?: Array<number>;
}

export interface OpportunityToSalesOrderConversion {
	"salesOrderId"?: number;
	"name"?: string;
	"includeAllNotesFlag"?: boolean;
	"includeAllDocumentsFlag"?: boolean;
	"includeAllProductsFlag"?: boolean;
	"includeNoteIds"?: Array<number>;
	"includeDocumentIds"?: Array<number>;
	"includeProductIds"?: Array<number>;
}

export interface OpportunityToServiceTicketConversion {
	"ticketId"?: number;
	"summary"?: string;
	"includeAllNotesFlag"?: boolean;
	"includeAllDocumentsFlag"?: boolean;
	"includeAllProductsFlag"?: boolean;
	"includeNoteIds"?: Array<number>;
	"includeDocumentIds"?: Array<number>;
	"includeProductIds"?: Array<number>;
}

export interface OpportunityType {
	"id"?: number;
	"description": string;
	"inactiveFlag"?: boolean;

	/**
	 * Metadata of the entity
	 */
	"info"?: Metadata;
}

export interface OpportunityTypeReference {
	"id"?: number;
	"name"?: string;

	/**
	 * Metadata of the entity
	 */
	"info"?: Metadata;
}

export interface Order {
	"id"?: number;
	"company": CompanyReference;
	"contact"?: ContactReference;
	"phone"?: string;
	"phoneExt"?: string;
	"email"?: string;
	"site"?: SiteReference;
	"status": OrderStatusReference;
	"opportunity"?: OpportunityReference;
	"orderDate"?: Date;
	"dueDate"?: Date;
	"billingTerms"?: BillingTermsReference;
	"taxCode"?: TaxCodeReference;
	"poNumber"?: string;
	"locationId"?: number;
	"businessUnitId"?: number;
	"salesRep": MemberReference;
	"notes"?: string;
	"billClosedFlag"?: boolean;
	"billShippedFlag"?: boolean;
	"restrictDownpaymentFlag"?: boolean;
	"description"?: string;
	"topCommentFlag"?: boolean;
	"bottomCommentFlag"?: boolean;
	"shipToCompany"?: CompanyReference;
	"shipToContact"?: ContactReference;
	"shipToSite"?: SiteReference;
	"billToCompany"?: CompanyReference;
	"billToContact"?: ContactReference;
	"billToSite"?: SiteReference;
	"productIds"?: Array<number>;
	"documentIds"?: Array<number>;
	"invoiceIds"?: Array<number>;
	"configIds"?: Array<number>;
	"total"?: number;
	"taxTotal"?: number;

	/**
	 * Metadata of the entity
	 */
	"info"?: Metadata;
}

export interface OrderStatus {
	"id"?: number;
	"name": string;
	"defaultFlag"?: boolean;
	"inactiveFlag"?: boolean;
	"sortOrder"?: number;
	"closedFlag"?: boolean;

	/**
	 * Metadata of the entity
	 */
	"info"?: Metadata;
}

export interface OrderStatusReference {
	"id"?: number;
	"name"?: string;

	/**
	 * Metadata of the entity
	 */
	"info"?: Metadata;
}

export interface OwnershipType {
	"id"?: number;
	"name": string;

	/**
	 * Metadata of the entity
	 */
	"info"?: Metadata;
}

export interface OwnershipTypeReference {
	"id"?: number;
	"name"?: string;

	/**
	 * Metadata of the entity
	 */
	"info"?: Metadata;
}

export interface PatchOperation {
	"op"?: string;
	"path"?: string;
	"value"?: string;
}

export interface Payment {
	"id"?: number;
	"type"?: string;
	"invoice"?: InvoiceReference;
	"amount": number;
	"paymentDate"?: Date;
	"appliedBy"?: string;

	/**
	 * Metadata of the entity
	 */
	"info"?: Metadata;
}

export interface PaymentMethodReference {
	"id"?: number;
	"name"?: string;

	/**
	 * Metadata of the entity
	 */
	"info"?: Metadata;
}

export interface PhaseStatusReference {
	"id"?: number;
	"name"?: string;

	/**
	 * Metadata of the entity
	 */
	"info"?: Metadata;
}

export interface PortalSecurity {
	"identifier"?: string;
	"enabled"?: boolean;
}

export interface PricingBreak {
	"id"?: number;
	"detailId"?: number;
	"amount"?: number;
	"quantityStart"?: number;
	"quantityEnd"?: number;
	"priceMethod": PricingBreak.PriceMethodEnum;

	/**
	 * Metadata of the entity
	 */
	"info"?: Metadata;
}

export namespace PricingBreak {

export type PriceMethodEnum = 'FlatRateForRange' | 'PercentMarkupFromCost' | 'PercentMarkdownFromPrice' | 'PricePerUnit';
}
export interface PricingDetail {
	"id"?: number;
	"product"?: CatalogItemReference;
	"category"?: ProductCategoryReference;
	"subCategory"?: ProductSubCategoryReference;
	"startDate": Date;
	"endDate"?: Date;

	/**
	 * Metadata of the entity
	 */
	"info"?: Metadata;
}

export interface PricingSchedule {
	"id"?: number;
	"name": string;
	"inactiveFlag"?: boolean;
	"defaultFlag"?: boolean;
	"companies"?: Array<number>;
	"setAllCompaniesFlag"?: boolean;
	"removeAllCompaniesFlag"?: boolean;

	/**
	 * Metadata of the entity
	 */
	"info"?: Metadata;
}

export interface PricingScheduleReference {
	"id"?: number;
	"name"?: string;

	/**
	 * Metadata of the entity
	 */
	"info"?: Metadata;
}

export interface Priority {
	"id"?: number;
	"name": string;
	"color": string;
	"sortOrder"?: number;
	"defaultFlag"?: boolean;
	"imageLink"?: string;

	/**
	 * Metadata of the entity
	 */
	"info"?: Metadata;
}

export interface PriorityReference {
	"id"?: number;
	"name"?: string;
	"sort"?: number;

	/**
	 * Metadata of the entity
	 */
	"info"?: Metadata;
}

export interface ProductCategoryReference {
	"id"?: number;
	"name"?: string;

	/**
	 * Metadata of the entity
	 */
	"info"?: Metadata;
}

export interface ProductComponent {
	"id"?: number;
	"sequenceNumber"?: number;
	"quantity": number;
	"catalogItem": CatalogItemReference;
	"hidePriceFlag"?: boolean;
	"hideItemIdentifierFlag"?: boolean;
	"hideDescriptionFlag"?: boolean;
	"hideQuantityFlag"?: boolean;
	"vendor"?: CompanyReference;
	"parentProductItem"?: ProductItemReference;
	"productItem"?: ProductItemReference;
	"price"?: number;
	"cost"?: number;

	/**
	 * Metadata of the entity
	 */
	"info"?: Metadata;
}

export interface ProductItem {
	"id"?: number;
	"catalogItem": CatalogItemReference;
	"chargeToId": number;
	"chargeToType": ProductItem.ChargeToTypeEnum;
	"description"?: string;
	"sequenceNumber"?: number;
	"quantity"?: number;
	"price"?: number;
	"cost"?: number;
	"discount"?: number;
	"priceMethod"?: ProductItem.PriceMethodEnum;
	"billableOption": ProductItem.BillableOptionEnum;
	"agreement"?: AgreementReference;
	"locationId"?: number;
	"businessUnitId"?: number;
	"vendor"?: CompanyReference;
	"vendorSku"?: string;
	"taxableFlag"?: boolean;
	"dropshipFlag"?: boolean;
	"specialOrderFlag"?: boolean;
	"phaseProductFlag"?: boolean;
	"cancelledFlag"?: boolean;
	"quantityCancelled"?: number;
	"cancelledReason"?: string;
	"customerDescription"?: string;
	"internalNotes"?: string;
	"productSuppliedFlag"?: boolean;
	"subContractorShipToId"?: number;
	"subContractorAmountLimit"?: number;
	"recurring"?: ProductRecurring;
	"sla"?: SLAReference;
	"entityType"?: EntityTypeReference;
	"forecastDetailId"?: number;
	"cancelledBy"?: number;
	"cancelledDate"?: Date;
	"warehouse"?: string;
	"warehouseBin"?: string;
	"purchaseDate"?: Date;
	"integrationXRef"?: string;
	"listPrice"?: number;
	"serialNumberIds"?: Array<number>;
	"company"?: CompanyReference;
	"forecastStatus"?: OpportunityStatusReference;

	/**
	 * Metadata of the entity
	 */
	"info"?: Metadata;
	"bypassForecastUpdate"?: boolean;
}

export namespace ProductItem {

export type ChargeToTypeEnum = 'Ticket' | 'Project' | 'Invoice' | 'Opportunity' | 'SalesOrder';

export type PriceMethodEnum = 'FlatRateForRange' | 'PercentMarkupFromCost' | 'PercentMarkdownFromPrice' | 'PricePerUnit';

export type BillableOptionEnum = 'Billable' | 'DoNotBill' | 'NoCharge';
}
export interface ProductItemReference {
	"id"?: number;
	"name"?: string;

	/**
	 * Metadata of the entity
	 */
	"info"?: Metadata;
}

export interface ProductPickingShippingDetail {
	"id"?: number;
	"pickedQuantity": number;
	"shippedQuantity": number;
	"warehouse": WarehouseReference;
	"warehouseBin": WarehouseBinReference;
	"shipmentMethod"?: ShipmentMethodReference;
	"serialNumber"?: string;
	"serialNumberIds"?: Array<number>;
	"trackingNumber"?: string;
	"productItem"?: ProductItemReference;
	"lineNumber"?: number;
	"quantity"?: number;

	/**
	 * Metadata of the entity
	 */
	"info"?: Metadata;
}

export interface ProductRecurring {
	"recurringRevenue": number;
	"recurringCost": number;
	"startDate": Date;
	"endDate": Date;
	"billCycleId": number;
	"cycles": number;
	"cycleType": ProductRecurring.CycleTypeEnum;
}

export namespace ProductRecurring {

export type CycleTypeEnum = 'CalendarYear' | 'ContractYear';
}
export interface ProductReference {
	"id"?: number;
	"description"?: string;

	/**
	 * Metadata of the entity
	 */
	"info"?: Metadata;
}

export interface ProductSubCategoryReference {
	"id"?: number;
	"name"?: string;

	/**
	 * Metadata of the entity
	 */
	"info"?: Metadata;
}

export interface ProductType {
	"id"?: number;
	"name": string;
	"inactiveFlag"?: boolean;
	"typeXref"?: ProductType.TypeXrefEnum;

	/**
	 * Metadata of the entity
	 */
	"info"?: Metadata;
}

export namespace ProductType {

export type TypeXrefEnum = 'InventoryPart' | 'NonInventoryPart' | 'OtherCharge' | 'Service';
}
export interface ProductTypeReference {
	"id"?: number;
	"name"?: string;

	/**
	 * Metadata of the entity
	 */
	"info"?: Metadata;
}

export interface Project {
	"id"?: number;

	/**
	 * Metadata of the entity
	 */
	"info"?: Metadata;
	"actualEnd"?: Date;
	"actualHours"?: number;
	"actualStart"?: Date;
	"agreement"?: AgreementReference;
	"billExpenses"?: Project.BillExpensesEnum;
	"billingAmount"?: number;
	"billingAttention"?: string;
	"billingMethod": Project.BillingMethodEnum;
	"billingRateType"?: Project.BillingRateTypeEnum;
	"billingTerms"?: BillingTermsReference;
	"billProducts"?: Project.BillProductsEnum;
	"billProjectAfterClosedFlag"?: boolean;
	"billTime"?: Project.BillTimeEnum;
	"billToCompany"?: CompanyReference;
	"billToContact"?: ContactReference;
	"billToSite"?: SiteReference;
	"billUnapprovedTimeAndExpense"?: boolean;
	"board": ProjectBoardReference;
	"budgetAnalysis"?: Project.BudgetAnalysisEnum;
	"budgetFlag"?: boolean;
	"budgetHours"?: number;
	"businessUnitId"?: number;
	"company": CompanyReference;
	"contact"?: ContactReference;
	"customerPO"?: string;
	"description"?: string;
	"downpayment"?: number;
	"estimatedEnd": Date;
	"estimatedExpenseRevenue"?: number;
	"estimatedHours"?: number;
	"estimatedProductRevenue"?: number;
	"estimatedStart": Date;
	"estimatedTimeRevenue"?: number;
	"expenseApprover"?: MemberReference;
	"includeDependenciesFlag"?: boolean;
	"includeEstimatesFlag"?: boolean;
	"locationId"?: number;
	"manager"?: MemberReference;
	"name": string;
	"opportunity"?: OpportunityReference;
	"projectTemplateId"?: number;
	"restrictDownPaymentFlag"?: boolean;
	"scheduledEnd"?: Date;
	"scheduledHours"?: number;
	"scheduledStart"?: Date;
	"shipToCompany"?: CompanyReference;
	"shipToContact"?: ContactReference;
	"shipToSite"?: SiteReference;
	"site"?: SiteReference;
	"status"?: ProjectStatusReference;
	"timeApprover"?: MemberReference;
	"type"?: ProjectTypeReference;
	"doNotDisplayInPortalFlag"?: boolean;
	"billingStartDate"?: Date;
	"estimatedTimeCost"?: number;
	"estimatedExpenseCost"?: number;
	"estimatedProductCost"?: number;
	"taxCode"?: TaxCodeReference;
}

export namespace Project {

export type BillExpensesEnum = 'Billable' | 'DoNotBill' | 'NoCharge' | 'NoDefault';

export type BillingMethodEnum = 'ActualRates' | 'FixedFee' | 'NotToExceed' | 'OverrideRate';

export type BillingRateTypeEnum = 'WorkRole' | 'StaffMember';

export type BillProductsEnum = 'Billable' | 'DoNotBill' | 'NoCharge' | 'NoDefault';

export type BillTimeEnum = 'Billable' | 'DoNotBill' | 'NoCharge' | 'NoDefault';

export type BudgetAnalysisEnum = 'ActualHours' | 'BillableHours';
}
export interface ProjectBoardReference {
	"id"?: number;
	"name"?: string;

	/**
	 * Metadata of the entity
	 */
	"info"?: Metadata;
}

export interface ProjectContact {
	"id"?: number;
	"projectId"?: number;
	"contact": ContactReference;

	/**
	 * Metadata of the entity
	 */
	"info"?: Metadata;
}

export interface ProjectNote {
	"id"?: number;
	"projectId"?: number;
	"text": string;
	"type"?: NoteTypeReference;
	"flagged"?: boolean;

	/**
	 * Metadata of the entity
	 */
	"info"?: Metadata;
}

export interface ProjectPhase {
	"id"?: number;
	"projectId"?: number;
	"description": string;
	"board"?: ProjectBoardReference;
	"status"?: PhaseStatusReference;
	"agreement"?: AgreementReference;
	"opportunity"?: OpportunityReference;
	"parentPhase"?: ProjectPhaseReference;
	"wbsCode"?: string;
	"billTime"?: ProjectPhase.BillTimeEnum;
	"billExpenses"?: ProjectPhase.BillExpensesEnum;
	"billProducts"?: ProjectPhase.BillProductsEnum;
	"markAsMilestoneFlag"?: boolean;
	"notes"?: string;
	"deadlineDate"?: Date;
	"billSeparatelyFlag"?: boolean;

	/**
	 * billingMethod is required if the phase billSeparatelyFlag is true
	 */
	"billingMethod"?: ProjectPhase.BillingMethodEnum;
	"scheduledHours"?: number;
	"scheduledStart"?: string;
	"scheduledEnd"?: string;
	"actualHours"?: number;
	"actualStart"?: string;
	"actualEnd"?: string;
	"budgetHours"?: number;
	"locationId"?: number;
	"businessUnitId"?: number;
	"hourlyRate"?: number;
	"billingStartDate"?: Date;

	/**
	 * This phase can only be billed after it has been closed
	 */
	"billPhaseClosedFlag"?: boolean;

	/**
	 * This phase can only be billed after the project has been closed
	 */
	"billProjectClosedFlag"?: boolean;
	"downpayment"?: number;
	"poNumber"?: string;
	"poAmount"?: number;
	"estimatedTimeCost"?: number;
	"estimatedExpenseCost"?: number;
	"estimatedProductCost"?: number;
	"estimatedTimeRevenue"?: number;
	"estimatedExpenseRevenue"?: number;
	"estimatedProductRevenue"?: number;

	/**
	 * Metadata of the entity
	 */
	"info"?: Metadata;
}

export namespace ProjectPhase {

export type BillTimeEnum = 'Billable' | 'DoNotBill' | 'NoCharge' | 'NoDefault';

export type BillExpensesEnum = 'Billable' | 'DoNotBill' | 'NoCharge' | 'NoDefault';

export type BillProductsEnum = 'Billable' | 'DoNotBill' | 'NoCharge' | 'NoDefault';

export type BillingMethodEnum = 'ActualRates' | 'FixedFee' | 'NotToExceed' | 'OverrideRate';
}
export interface ProjectPhaseReference {
	"id"?: number;
	"name"?: string;

	/**
	 * Metadata of the entity
	 */
	"info"?: Metadata;
}

export interface ProjectReference {
	"id"?: number;
	"name"?: string;

	/**
	 * Metadata of the entity
	 */
	"info"?: Metadata;
}

export interface ProjectRoleReference {
	"id"?: number;
	"identifier"?: string;

	/**
	 * Metadata of the entity
	 */
	"info"?: Metadata;
}

export interface ProjectStatusReference {
	"id"?: number;
	"name"?: string;

	/**
	 * Metadata of the entity
	 */
	"info"?: Metadata;
}

export interface ProjectTeammember {
	"id"?: number;
	"projectId"?: number;
	"hours"?: number;
	"member": MemberReference;
	"projectRole": ProjectRoleReference;
	"workRole"?: WorkRoleReference;
	"startDate"?: Date;
	"endDate"?: Date;

	/**
	 * Metadata of the entity
	 */
	"info"?: Metadata;
}

export interface ProjectTypeReference {
	"id"?: number;
	"name"?: string;

	/**
	 * Metadata of the entity
	 */
	"info"?: Metadata;
}

export interface PurchaseOrder {
	"id"?: number;

	/**
	 * Metadata of the entity
	 */
	"info"?: Metadata;
	"businessUnitId"?: number;
	"cancelReason"?: string;
	"closedFlag"?: boolean;
	"customerCity"?: string;
	"customerCompany"?: CompanyReference;
	"customerContact"?: ContactReference;
	"customerCountry"?: CountryReference;
	"customerExtension"?: string;
	"customerName"?: string;
	"customerPhone"?: string;
	"customerSite"?: SiteReference;
	"customerSiteName"?: string;
	"customerState"?: string;
	"customerStreetLine1"?: string;
	"customerStreetLine2"?: string;
	"customerZip"?: string;
	"dateClosed"?: Date;
	"dropShipCustomerFlag"?: boolean;
	"enteredBy"?: string;
	"freightCost"?: number;
	"freightPackingSlip"?: string;
	"freightTaxTotal"?: number;
	"internalNotes"?: string;
	"locationId": number;
	"poDate"?: Date;
	"poNumber"?: string;
	"salesTax"?: number;
	"shipmentDate"?: Date;
	"shipmentMethod"?: ShipmentMethodReference;
	"shippingInstructions"?: string;
	"status": PurchaseOrderStatusReference;
	"subTotal"?: number;
	"taxCode"?: TaxCodeReference;
	"taxFreightFlag"?: boolean;
	"taxPoFlag"?: boolean;
	"terms": BillingTermsReference;
	"total"?: number;
	"trackingNumber"?: string;

	/**
	 * Determines whether or not to update all of the shipment info for each associated line item when new shipment info is passed in
	 */
	"updateShipmentInfo"?: boolean;

	/**
	 * Determines whether or not to update vendor order number for each associated line item when new vendor order number is passed in
	 */
	"updateVendorOrderNumber"?: boolean;
	"vendorCompany": CompanyReference;
	"vendorContact"?: ContactReference;
	"vendorInvoiceDate"?: Date;
	"vendorInvoiceNumber"?: string;
	"vendorOrderNumber"?: string;
	"vendorSite"?: SiteReference;
	"warehouse"?: WarehouseReference;
}

export interface PurchaseOrderLineItem {
	"id"?: number;
	"backorderedFlag"?: boolean;
	"canceledBy"?: string;
	"canceledFlag"?: boolean;
	"canceledReason"?: string;
	"closedFlag"?: boolean;
	"dateCanceled"?: Date;
	"dateCanceledUtc"?: Date;
	"description": string;
	"displayInternalNotesFlag"?: boolean;
	"expectedShipDate"?: Date;
	"internalNotes"?: string;
	"lineNumber": number;
	"packingSlip"?: string;
	"product": IvItemReference;
	"purchaseOrderId"?: number;
	"quantity": number;
	"receivedQuantity"?: number;
	"serialNumbers"?: string;
	"shipDate"?: Date;
	"shipmentMethod"?: ShipmentMethodReference;
	"tax"?: number;
	"trackingNumber"?: string;
	"unitCost"?: number;
	"unitOfMeasure": UnitOfMeasureReference;
	"vendorOrderNumber"?: string;
	"warehouse"?: WarehouseReference;
	"warehouseBin"?: WarehouseBinReference;

	/**
	 * Metadata of the entity
	 */
	"info"?: Metadata;
}

export interface PurchaseOrderReference {
	"id"?: number;
	"name"?: string;

	/**
	 * Metadata of the entity
	 */
	"info"?: Metadata;
}

export interface PurchaseOrderStatusReference {
	"id"?: number;
	"name"?: string;

	/**
	 * Metadata of the entity
	 */
	"info"?: Metadata;
}

export interface RMAAction {
	"id"?: number;
	"name": string;
	"defaultFlag"?: boolean;

	/**
	 * Metadata of the entity
	 */
	"info"?: Metadata;
}

export interface RMADisposition {
	"id"?: number;
	"name": string;
	"defaultFlag"?: boolean;

	/**
	 * Metadata of the entity
	 */
	"info"?: Metadata;
}

export interface RelationshipReference {
	"id"?: number;
	"name"?: string;

	/**
	 * Metadata of the entity
	 */
	"info"?: Metadata;
}

export interface ReminderReference {
	"id"?: number;
	"name"?: string;

	/**
	 * Metadata of the entity
	 */
	"info"?: Metadata;
}

export interface Report {
	"name"?: string;
}

export interface ReportDataResponse {
	"columnDefinitions"?: Array<JObject>;
	"rowValues"?: Array<JObject>;
}

export interface RequestPasswordRequest {
	"email": string;
}

export interface Role {
	"id"?: number;
	"name": string;

	/**
	 * Metadata of the entity
	 */
	"info"?: Metadata;
}

export interface SLAReference {
	"id"?: number;
	"name"?: string;

	/**
	 * Metadata of the entity
	 */
	"info"?: Metadata;
}

export interface SalesProbability {
	"id"?: number;
	"probability": number;

	/**
	 * Metadata of the entity
	 */
	"info"?: Metadata;
}

export interface SalesTeamReference {
	"id"?: number;
	"identifier"?: string;

	/**
	 * Metadata of the entity
	 */
	"info"?: Metadata;
}

export interface ScheduleEntry {
	"id"?: number;
	"objectId"?: number;
	"name"?: string;

	/**
	 * Activity schedule requires a member
	 */
	"member"?: MemberReference;
	"where"?: ServiceLocationReference;
	"dateStart"?: Date;
	"dateEnd"?: Date;
	"reminder"?: ReminderReference;
	"status"?: ScheduleStatusReference;
	"type": ScheduleTypeReference;
	"span"?: ScheduleSpanReference;
	"doneFlag"?: boolean;
	"acknowledgedFlag"?: boolean;
	"ownerFlag"?: boolean;
	"allowScheduleConflictsFlag"?: boolean;
	"addMemberToProjectFlag"?: boolean;
	"projectRoleId"?: number;
	"mobileGuid"?: Guid;
	"closeDate"?: Date;
	"hours"?: number;

	/**
	 * Metadata of the entity
	 */
	"info"?: Metadata;
}

export interface ScheduleEntryReference {
	"id"?: number;
	"description"?: string;

	/**
	 * Metadata of the entity
	 */
	"info"?: Metadata;
}

export interface ScheduleReminderTime {
	"id"?: number;

	/**
	 * Time is calculated in minutes
	 */
	"time"?: number;
	"description"?: string;
	"defaultFlag"?: boolean;

	/**
	 * Metadata of the entity
	 */
	"info"?: Metadata;
}

export interface ScheduleSpanReference {
	"id"?: number;
	"identifier"?: string;

	/**
	 * Metadata of the entity
	 */
	"info"?: Metadata;
}

export interface ScheduleStatus {
	"id"?: number;
	"name": string;
	"defaultFlag"?: boolean;
	"showAsTentativeFlag"?: boolean;

	/**
	 * Metadata of the entity
	 */
	"info"?: Metadata;
}

export interface ScheduleStatusReference {
	"id"?: number;
	"name"?: string;

	/**
	 * Metadata of the entity
	 */
	"info"?: Metadata;
}

export interface ScheduleStopwatch {

	/**
	 * Metadata of the entity
	 */
	"info"?: Metadata;
	"agreement"?: AgreementReference;
	"billableOption"?: ScheduleStopwatch.BillableOptionEnum;
	"businessUnitId"?: number;
	"dateEntered"?: Date;
	"endTime"?: Date;
	"id"?: number;
	"internalNotes"?: string;
	"locationId"?: number;
	"member": MemberReference;
	"mobileGuid"?: Guid;
	"notes"?: string;
	"scheduleId": number;
	"scheduleMobileGuid"?: Guid;
	"startTime"?: Date;
	"status": ScheduleStopwatch.StatusEnum;
	"totalPauseTime"?: number;
	"workRole"?: WorkRoleReference;
	"workType"?: WorkTypeReference;
}

export namespace ScheduleStopwatch {

export type BillableOptionEnum = 'Billable' | 'DoNotBill' | 'NoCharge' | 'NoDefault';

export type StatusEnum = 'Reset' | 'Running' | 'Paused' | 'Stopped';
}
export interface ScheduleType {
	"id"?: number;
	"name": string;
	"identifier": string;
	"chargeCode"?: ChargeCodeReference;
	"where"?: ServiceLocationReference;
	"systemFlag"?: boolean;

	/**
	 * Metadata of the entity
	 */
	"info"?: Metadata;
}

export interface ScheduleTypeReference {
	"id"?: number;
	"identifier"?: string;

	/**
	 * Metadata of the entity
	 */
	"info"?: Metadata;
}

export interface SecurityRoleReference {
	"id"?: number;
	"name"?: string;

	/**
	 * Metadata of the entity
	 */
	"info"?: Metadata;
}

export interface ServiceCodeReference {
	"id"?: number;
	"name"?: string;

	/**
	 * Metadata of the entity
	 */
	"info"?: Metadata;
}

export interface ServiceItemReference {
	"id"?: number;
	"name"?: string;

	/**
	 * Metadata of the entity
	 */
	"info"?: Metadata;
}

export interface ServiceLocationReference {
	"id"?: number;
	"name"?: string;

	/**
	 * Metadata of the entity
	 */
	"info"?: Metadata;
}

export interface ServiceNote {
	"id"?: number;
	"ticketId"?: number;
	"text"?: string;
	"detailDescriptionFlag"?: boolean;
	"internalAnalysisFlag"?: boolean;
	"resolutionFlag"?: boolean;
	"member"?: MemberReference;
	"contact"?: ContactReference;
	"customerUpdatedFlag"?: boolean;
	"processNotifications"?: boolean;
	"dateCreated"?: string;
	"createdBy"?: string;
	"internalFlag"?: boolean;
	"externalFlag"?: boolean;

	/**
	 * Metadata of the entity
	 */
	"info"?: Metadata;
}

export interface ServiceSignoffReference {
	"id"?: number;
	"name"?: string;

	/**
	 * Metadata of the entity
	 */
	"info"?: Metadata;
}

export interface ServiceSourceReference {
	"id"?: number;
	"name"?: string;

	/**
	 * Metadata of the entity
	 */
	"info"?: Metadata;
}

export interface ServiceStatusReference {
	"id"?: number;
	"name"?: string;

	/**
	 * Metadata of the entity
	 */
	"info"?: Metadata;
}

export interface ServiceSubTypeReference {
	"id"?: number;
	"name"?: string;

	/**
	 * Metadata of the entity
	 */
	"info"?: Metadata;
}

export interface ServiceTeamReference {
	"id"?: number;
	"name"?: string;

	/**
	 * Metadata of the entity
	 */
	"info"?: Metadata;
}

export interface ServiceTypeReference {
	"id"?: number;
	"name"?: string;

	/**
	 * Metadata of the entity
	 */
	"info"?: Metadata;
}

export interface ShipmentMethod {
	"id"?: number;
	"name": string;
	"defaultFlag"?: boolean;
	"trackingUrl"?: string;
	"shippingType"?: ShipmentMethod.ShippingTypeEnum;

	/**
	 * Metadata of the entity
	 */
	"info"?: Metadata;
}

export namespace ShipmentMethod {

export type ShippingTypeEnum = 'None' | 'FedExTwoDay' | 'FedExPriority' | 'FedExGround' | 'UpsNextDay' | 'UpsSecondDay' | 'UpsGround' | 'CourierService' | 'UspsPriority' | 'UspsExpress';
}
export interface ShipmentMethodReference {
	"id"?: number;
	"name"?: string;

	/**
	 * Metadata of the entity
	 */
	"info"?: Metadata;
}

export interface SicCodeReference {
	"id"?: number;
	"name"?: string;

	/**
	 * Metadata of the entity
	 */
	"info"?: Metadata;
}

export interface SiteReference {
	"id"?: number;
	"name"?: string;

	/**
	 * Metadata of the entity
	 */
	"info"?: Metadata;
}

export interface Skill {
	"id"?: number;
	"name": string;
	"category": SkillCategoryReference;

	/**
	 * Metadata of the entity
	 */
	"info"?: Metadata;
}

export interface SkillCategory {
	"id"?: number;
	"name": string;

	/**
	 * Metadata of the entity
	 */
	"info"?: Metadata;
}

export interface SkillCategoryReference {
	"id"?: number;
	"name"?: string;

	/**
	 * Metadata of the entity
	 */
	"info"?: Metadata;
}

export interface Source {
	"id"?: number;
	"name": string;
	"defaultFlag"?: boolean;

	/**
	 * Metadata of the entity
	 */
	"info"?: Metadata;
	"enteredBy"?: string;
	"dateEntered"?: Date;
}

export interface Status {
	"id"?: number;
	"name": string;
	"boardId"?: number;
	"sortOrder"?: number;
	"displayOnBoard"?: boolean;
	"inactive"?: boolean;
	"closedStatus"?: boolean;
	"timeEntryNotAllowed"?: boolean;
	"defaultFlag"?: boolean;
	"escalationStatus"?: Status.EscalationStatusEnum;

	/**
	 * Metadata of the entity
	 */
	"info"?: Metadata;
}

export namespace Status {

export type EscalationStatusEnum = 'NotResponded' | 'Responded' | 'ResolutionPlan' | 'Resolved' | 'NoEscalation';
}
export interface SubCategory {
	"id"?: number;
	"name": string;
	"inactiveFlag"?: boolean;

	/**
	 * Metadata of the entity
	 */
	"info"?: Metadata;
}

export interface SubType {
	"id"?: number;
	"name": string;
	"inactive"?: boolean;
	"typeAssociationIds"?: Array<number>;
	"addAllTypes"?: boolean;
	"removeAllTypes"?: boolean;
	"boardId"?: number;

	/**
	 * Metadata of the entity
	 */
	"info"?: Metadata;
}

export interface SubtypeAssociation {
	"id"?: number;
	"type": ServiceTypeReference;
	"subType"?: ServiceSubTypeReference;
	"board"?: BoardReference;

	/**
	 * Metadata of the entity
	 */
	"info"?: Metadata;
}

export interface SuccessResponse {
	"success"?: boolean;
	"message"?: string;
}

export interface Survey {
	"id"?: number;
	"name": string;
	"inactiveFlag"?: boolean;
	"headerIncludeLogoFlag"?: boolean;
	"headerText"?: string;
	"headerTextVisibleFlag"?: boolean;
	"footerText"?: string;
	"footerTextVisibleFlag"?: boolean;
	"thankYouText"?: string;
	"notifyWho"?: GenericIdIdentifierReference;
	"notifyWhoVisibleFlag"?: boolean;
	"notifyMember"?: MemberReference;

	/**
	 * Metadata of the entity
	 */
	"info"?: Metadata;
}

export interface SurveyQuestion {
	"id"?: number;
	"sequenceNumber"?: number;
	"type": SurveyQuestion.TypeEnum;
	"question": string;
	"options"?: Array<SurveyQuestionOption>;
	"includeFlag"?: boolean;
	"requiredFlag"?: boolean;
	"noAnswerPoints"?: number;
	"surveyId"?: number;

	/**
	 * Metadata of the entity
	 */
	"info"?: Metadata;
}

export namespace SurveyQuestion {

export type TypeEnum = 'OpenEnded' | 'Selection';
}
export interface SurveyQuestionOption {
	"includeFlag"?: boolean;
	"caption": string;
	"points"?: number;
}

export interface SurveyResult {
	"id"?: number;
	"ticketId": number;
	"emailAddress"?: string;
	"footerResponse"?: string;
	"contactMeFlag"?: boolean;
	"contact"?: ContactReference;
	"results"?: Array<SurveyResultDetail>;
	"totalPoints"?: number;
	"company"?: CompanyReference;
	"surveyId"?: number;

	/**
	 * Metadata of the entity
	 */
	"info"?: Metadata;
}

export interface SurveyResultDetail {
	"questionId": number;

	/**
	 * If question type is Selection, this should be the option array index
	 */
	"answer"?: string;
}

export interface Task {
	"id"?: number;
	"ticketId"?: number;
	"notes"?: string;
	"closedFlag"?: boolean;
	"priority"?: number;
	"schedule"?: ScheduleEntryReference;
	"code"?: ServiceCodeReference;
	"resolution"?: string;
	"childScheduleAction"?: Task.ChildScheduleActionEnum;
	"childTicketId"?: number;

	/**
	 * Metadata of the entity
	 */
	"info"?: Metadata;
}

export namespace Task {

export type ChildScheduleActionEnum = 'Transfer' | 'Delete' | 'Done';
}
export interface TaxCode {
	"id"?: number;
	"identifier": string;
	"description": string;
	"invoiceCaption": string;
	"country"?: CountryReference;
	"effectiveDate": Date;
	"defaultFlag"?: boolean;
	"displayOnInvoiceFlag"?: boolean;
	"canadaCalculateGSTFlag"?: boolean;
	"cancelDate"?: Date;
	"levelOneRate"?: number;
	"levelOneRateType"?: TaxCode.LevelOneRateTypeEnum;
	"levelOneTaxableMax"?: number;
	"levelOneCaption"?: string;
	"levelOneTaxCodeXref"?: string;
	"levelOneAgencyXref"?: string;
	"levelOneServicesFlag"?: boolean;
	"levelOneExpensesFlag"?: boolean;
	"levelOneProductsFlag"?: boolean;
	"levelOneApplySingleUnitFlag"?: boolean;
	"levelOneApplySingleUnitMin"?: number;
	"levelOneApplySingleUnitMax"?: number;
	"levelTwoRate"?: number;
	"levelTwoRateType"?: TaxCode.LevelTwoRateTypeEnum;
	"levelTwoTaxableMax"?: number;
	"levelTwoCaption"?: string;
	"levelTwoTaxCodeXref"?: string;
	"levelTwoAgencyXref"?: string;
	"levelTwoServicesFlag"?: boolean;
	"levelTwoExpensesFlag"?: boolean;
	"levelTwoProductsFlag"?: boolean;
	"levelTwoApplySingleUnitFlag"?: boolean;
	"levelTwoApplySingleUnitMin"?: number;
	"levelTwoApplySingleUnitMax"?: number;
	"levelThreeRate"?: number;
	"levelThreeRateType"?: TaxCode.LevelThreeRateTypeEnum;
	"levelThreeTaxableMax"?: number;
	"levelThreeCaption"?: string;
	"levelThreeTaxCodeXref"?: string;
	"levelThreeAgencyXref"?: string;
	"levelThreeServicesFlag"?: boolean;
	"levelThreeExpensesFlag"?: boolean;
	"levelThreeProductsFlag"?: boolean;
	"levelThreeApplySingleUnitFlag"?: boolean;
	"levelThreeApplySingleUnitMin"?: number;
	"levelThreeApplySingleUnitMax"?: number;
	"levelFourRate"?: number;
	"levelFourRateType"?: TaxCode.LevelFourRateTypeEnum;
	"levelFourTaxableMax"?: number;
	"levelFourCaption"?: string;
	"levelFourTaxCodeXref"?: string;
	"levelFourAgencyXref"?: string;
	"levelFourServicesFlag"?: boolean;
	"levelFourExpensesFlag"?: boolean;
	"levelFourProductsFlag"?: boolean;
	"levelFourApplySingleUnitFlag"?: boolean;
	"levelFourApplySingleUnitMin"?: number;
	"levelFourApplySingleUnitMax"?: number;
	"levelFiveRate"?: number;
	"levelFiveRateType"?: TaxCode.LevelFiveRateTypeEnum;
	"levelFiveTaxableMax"?: number;
	"levelFiveCaption"?: string;
	"levelFiveTaxCodeXref"?: string;
	"levelFiveAgencyXref"?: string;
	"levelFiveServicesFlag"?: boolean;
	"levelFiveExpensesFlag"?: boolean;
	"levelFiveProductsFlag"?: boolean;
	"levelFiveApplySingleUnitFlag"?: boolean;
	"levelFiveApplySingleUnitMin"?: number;
	"levelFiveApplySingleUnitMax"?: number;

	/**
	 * Metadata of the entity
	 */
	"info"?: Metadata;
}

export namespace TaxCode {

export type LevelOneRateTypeEnum = 'Amount' | 'Percent';

export type LevelTwoRateTypeEnum = 'Amount' | 'Percent';

export type LevelThreeRateTypeEnum = 'Amount' | 'Percent';

export type LevelFourRateTypeEnum = 'Amount' | 'Percent';

export type LevelFiveRateTypeEnum = 'Amount' | 'Percent';
}
/**
 * New companies will be created with the default tax code unless otherwise specified.
 */
export interface TaxCodeReference {
	"id"?: number;
	"name"?: string;

	/**
	 * Metadata of the entity
	 */
	"info"?: Metadata;
}

export interface TaxCodeXRef {
	"id"?: number;
	"description": string;
	"defaultFlag"?: boolean;
	"levelOne"?: TaxCodeXRef.LevelOneEnum;
	"levelTwo"?: TaxCodeXRef.LevelTwoEnum;
	"levelThree"?: TaxCodeXRef.LevelThreeEnum;
	"levelFour"?: TaxCodeXRef.LevelFourEnum;
	"levelFive"?: TaxCodeXRef.LevelFiveEnum;
	"taxCode"?: TaxCodeReference;

	/**
	 * Metadata of the entity
	 */
	"info"?: Metadata;
}

export namespace TaxCodeXRef {

export type LevelOneEnum = 'NonTaxable' | 'Taxable';

export type LevelTwoEnum = 'NonTaxable' | 'Taxable';

export type LevelThreeEnum = 'NonTaxable' | 'Taxable';

export type LevelFourEnum = 'NonTaxable' | 'Taxable';

export type LevelFiveEnum = 'NonTaxable' | 'Taxable';
}
export interface Team {
	"id"?: number;
	"type"?: Team.TypeEnum;
	"member"?: MemberReference;
	"salesTeam"?: SalesTeamReference;
	"commissionPercent"?: number;
	"referralFlag"?: boolean;
	"opportunityId"?: number;
	"responsibleFlag"?: boolean;

	/**
	 * Metadata of the entity
	 */
	"info"?: Metadata;
	"name": string;
	"teamLeader": MemberReference;
	"members"?: Array<number>;
	"defaultFlag"?: boolean;
	"notifyOnTicketDelete"?: boolean;
	"boardId"?: number;
	"locationId"?: number;
	"businessUnitId"?: number;
}

export namespace Team {

export type TypeEnum = 'Individual' | 'Team';
}
export interface TeamRole {
	"id"?: number;
	"name": string;

	/**
	 * Metadata of the entity
	 */
	"info"?: Metadata;
}

export interface TeamRoleReference {
	"id"?: number;
	"name"?: string;

	/**
	 * Metadata of the entity
	 */
	"info"?: Metadata;
}

export interface Ticket {
	"id"?: number;
	"summary": string;
	"recordType"?: Ticket.RecordTypeEnum;
	"board"?: BoardReference;
	"status"?: ServiceStatusReference;
	"project"?: ProjectReference;
	"phase"?: ProjectPhaseReference;
	"wbsCode"?: string;
	"company": CompanyReference;
	"site"?: SiteReference;
	"siteName"?: string;
	"addressLine1"?: string;
	"addressLine2"?: string;
	"city"?: string;
	"stateIdentifier"?: string;
	"zip"?: string;
	"country"?: CountryReference;
	"contact"?: ContactReference;
	"contactName"?: string;
	"contactPhoneNumber"?: string;
	"contactPhoneExtension"?: string;
	"contactEmailAddress"?: string;
	"type"?: ServiceTypeReference;
	"subType"?: ServiceSubTypeReference;
	"item"?: ServiceItemReference;
	"team"?: ServiceTeamReference;
	"owner"?: MemberReference;
	"priority"?: PriorityReference;
	"serviceLocation"?: ServiceLocationReference;
	"source"?: ServiceSourceReference;
	"requiredDate"?: Date;
	"budgetHours"?: number;
	"opportunity"?: OpportunityReference;
	"agreement"?: AgreementReference;
	"severity"?: Ticket.SeverityEnum;
	"impact"?: Ticket.ImpactEnum;
	"externalXRef"?: string;
	"poNumber"?: string;
	"knowledgeBaseCategoryId"?: number;
	"knowledgeBaseSubCategoryId"?: number;
	"allowAllClientsPortalView"?: boolean;
	"customerUpdatedFlag"?: boolean;
	"automaticEmailContactFlag"?: boolean;
	"automaticEmailResourceFlag"?: boolean;
	"automaticEmailCcFlag"?: boolean;
	"automaticEmailCc"?: string;

	/**
	 * Only available for POST, will not be returned in the response
	 */
	"initialDescription"?: string;

	/**
	 * Only available for POST, will not be returned in the response
	 */
	"initialInternalAnalysis"?: string;

	/**
	 * Only available for POST, will not be returned in the response
	 */
	"initialResolution"?: string;
	"contactEmailLookup"?: string;

	/**
	 * Can be set to false to skip notification processing when adding or updating a ticket (Defaults to True)
	 */
	"processNotifications"?: boolean;
	"skipCallback"?: boolean;
	"closedDate"?: string;
	"closedBy"?: string;
	"closedFlag"?: boolean;
	"dateEntered"?: string;
	"enteredBy"?: string;
	"actualHours"?: number;
	"approved"?: boolean;
	"subBillingMethod"?: Ticket.SubBillingMethodEnum;
	"subBillingAmount"?: number;
	"subDateAccepted"?: string;
	"dateResolved"?: string;
	"dateResplan"?: string;
	"dateResponded"?: string;
	"resolveMinutes"?: number;
	"resPlanMinutes"?: number;
	"respondMinutes"?: number;
	"isInSla"?: boolean;
	"knowledgeBaseLinkId"?: number;
	"resources"?: string;
	"parentTicketId"?: number;
	"hasChildTicket"?: boolean;
	"knowledgeBaseLinkType"?: Ticket.KnowledgeBaseLinkTypeEnum;
	"billTime"?: Ticket.BillTimeEnum;
	"billExpenses"?: Ticket.BillExpensesEnum;
	"billProducts"?: Ticket.BillProductsEnum;
	"predecessorType"?: Ticket.PredecessorTypeEnum;
	"predecessorId"?: number;
	"predecessorClosedFlag"?: boolean;
	"lagDays"?: number;
	"lagNonworkingDaysFlag"?: boolean;
	"estimatedStartDate"?: Date;
	"duration"?: number;
	"locationId"?: number;
	"businessUnitId"?: number;
	"mobileGuid"?: Guid;
	"sla"?: SLAReference;

	/**
	 * Metadata of the entity
	 */
	"info"?: Metadata;
	"customFields"?: Array<CustomFieldValue>;
}

export namespace Ticket {

export type RecordTypeEnum = 'ServiceTicket' | 'ProjectTicket' | 'ProjectIssue';

export type SeverityEnum = 'Low' | 'Medium' | 'High';

export type ImpactEnum = 'Low' | 'Medium' | 'High';

export type SubBillingMethodEnum = 'ActualRates' | 'FixedFee' | 'NotToExceed' | 'OverrideRate';

export type KnowledgeBaseLinkTypeEnum = 'ServiceTicket' | 'ProjectTicket' | 'ProjectIssue' | 'KnowledgeBaseArticle' | 'Time' | 'Activity';

export type BillTimeEnum = 'Billable' | 'DoNotBill' | 'NoCharge' | 'NoDefault';

export type BillExpensesEnum = 'Billable' | 'DoNotBill' | 'NoCharge' | 'NoDefault';

export type BillProductsEnum = 'Billable' | 'DoNotBill' | 'NoCharge' | 'NoDefault';

export type PredecessorTypeEnum = 'Ticket' | 'Phase';
}
export interface TicketMerge {
	"mergeTicketIds": Array<number>;
	"status": ServiceStatusReference;
}

export interface TicketReference {
	"id"?: number;
	"summary"?: string;

	/**
	 * Metadata of the entity
	 */
	"info"?: Metadata;
}

export interface TicketStopwatch {

	/**
	 * Metadata of the entity
	 */
	"info"?: Metadata;
	"agreement"?: AgreementReference;
	"billableOption"?: TicketStopwatch.BillableOptionEnum;
	"businessUnitId"?: number;
	"dateEntered"?: Date;
	"endTime"?: Date;
	"id"?: number;
	"internalNotes"?: string;
	"locationId"?: number;
	"member": MemberReference;
	"mobileGuid"?: Guid;
	"notes"?: string;
	"serviceStatus"?: ServiceStatusReference;
	"startTime"?: Date;
	"status": TicketStopwatch.StatusEnum;
	"ticket": TicketReference;
	"ticketMobileGuid"?: Guid;
	"totalPauseTime"?: number;
	"workRole"?: WorkRoleReference;
	"workType"?: WorkTypeReference;
	"showNotesInDiscussionFlag"?: boolean;
	"showNotesInInternalFlag"?: boolean;
	"showNotesInResolutionFlag"?: boolean;
	"emailNotesToContactFlag"?: boolean;
	"emailNotesToResourcesFlag"?: boolean;
}

export namespace TicketStopwatch {

export type BillableOptionEnum = 'Billable' | 'DoNotBill' | 'NoCharge' | 'NoDefault';

export type StatusEnum = 'Reset' | 'Running' | 'Paused' | 'Stopped';
}
export interface TimeEntry {
	"id"?: number;

	/**
	 * If chargeToId is not specified, we asume you enter time against the company specified
	 */
	"company"?: CompanyReference;

	/**
	 * If chargeToId is not specified, we asume you enter time against the company specified
	 */
	"chargeToId"?: number;

	/**
	 * If chargeToId is not specified, we asume you enter time against the company specified
	 */
	"chargeToType"?: TimeEntry.ChargeToTypeEnum;
	"member"?: MemberReference;
	"locationId"?: number;
	"businessUnitId"?: number;
	"workType"?: WorkTypeReference;
	"workRole"?: WorkRoleReference;
	"agreement"?: AgreementReference;
	"timeStart": Date;
	"timeEnd"?: Date;
	"hoursDeduct"?: number;
	"actualHours"?: number;
	"billableOption"?: TimeEntry.BillableOptionEnum;
	"notes"?: string;
	"internalNotes"?: string;
	"addToDetailDescriptionFlag"?: boolean;
	"addToInternalAnalysisFlag"?: boolean;
	"addToResolutionFlag"?: boolean;

	/**
	 * This is an action flag. To update this value use the /service/tickets endpoint automaticEmailResourceFlag field
	 */
	"emailResourceFlag"?: boolean;

	/**
	 * This is an action flag. To update this value use the /service/tickets endpoint automaticEmailContactFlag field
	 */
	"emailContactFlag"?: boolean;

	/**
	 * This is an action flag. To update this value use the /service/tickets endpoint automaticEmailCcFlag field
	 */
	"emailCcFlag"?: boolean;

	/**
	 * To update this value use the /service/tickets endpoint automaticEmailCc field
	 */
	"emailCc"?: string;
	"hoursBilled"?: number;
	"enteredBy"?: string;
	"dateEntered"?: Date;
	"invoice"?: InvoiceReference;

	/**
	 * This field may only be Updated, it is defaulted on Create
	 */
	"hourlyRate"?: number;

	/**
	 * Metadata of the entity
	 */
	"info"?: Metadata;
	"customFields"?: Array<CustomFieldValue>;
}

export namespace TimeEntry {

export type ChargeToTypeEnum = 'ServiceTicket' | 'ProjectTicket' | 'ChargeCode' | 'Activity';

export type BillableOptionEnum = 'Billable' | 'DoNotBill' | 'NoCharge' | 'NoDefault';
}
export interface TimeEntryReference {
	"id"?: number;

	/**
	 * Metadata of the entity
	 */
	"info"?: Metadata;
}

export interface TimeZoneReference {
	"id"?: number;
	"name"?: string;

	/**
	 * Metadata of the entity
	 */
	"info"?: Metadata;
}

export interface TodayPageCategory {
	"id"?: number;
	"name": string;
	"sortOrder"?: number;
	"locationId"?: number;

	/**
	 * Metadata of the entity
	 */
	"info"?: Metadata;
}

export interface Token {
	"publicKey"?: string;
	"privateKey"?: string;
	"expiration"?: string;
}

export interface Track {
	"id"?: number;
	"trackId": number;
	"name"?: string;
	"startDate"?: string;
	"endDate"?: string;
	"actionTaken"?: number;
	"actionRemaining"?: number;
	"startedBy"?: string;
	"company"?: CompanyReference;
	"contact"?: ContactReference;

	/**
	 * Metadata of the entity
	 */
	"info"?: Metadata;
}

export interface TrackReference {
	"id"?: number;
	"name"?: string;

	/**
	 * Metadata of the entity
	 */
	"info"?: Metadata;
}

export interface Type {
	"id"?: number;
	"name": string;
	"category"?: Type.CategoryEnum;
	"defaultFlag"?: boolean;
	"inactive"?: boolean;
	"requestForChange"?: boolean;
	"boardId"?: number;
	"locationId"?: number;
	"businessUnitId"?: number;

	/**
	 * Metadata of the entity
	 */
	"info"?: Metadata;
	"inactiveFlag"?: boolean;
}

export namespace Type {

export type CategoryEnum = 'Reactive' | 'Proactive';
}
export interface TypeAssociations {
	"typeId"?: number;
	"subTypeAssociationIds"?: Array<number>;
}

export interface UnitOfMeasure {
	"id"?: number;
	"name": string;
	"inactiveFlag"?: boolean;
	"defaultFlag"?: boolean;
	"uomScheduleXref"?: string;

	/**
	 * Metadata of the entity
	 */
	"info"?: Metadata;
}

export interface UnitOfMeasureReference {
	"id"?: number;
	"name"?: string;

	/**
	 * Metadata of the entity
	 */
	"info"?: Metadata;
}

export interface UnpostedExpense {
	"id"?: number;
	"locationId"?: number;
	"departmentId"?: number;
	"company"?: CompanyReference;
	"accountNumber"?: string;
	"creditAccount"?: string;
	"expenseDetailId"?: number;
	"expenseType"?: ExpenseTypeReference;
	"classification"?: UnpostedExpense.ClassificationEnum;
	"glType"?: UnpostedExpense.GlTypeEnum;
	"member"?: MemberReference;
	"dateExpense"?: Date;
	"chargeCode"?: ChargeCodeReference;
	"chargeDescription"?: string;
	"inPolicy"?: boolean;
	"paymentMethod"?: PaymentMethodReference;
	"currency"?: CurrencyReference;
	"total"?: number;
	"billableAmount"?: number;
	"nonBillableAmount"?: number;
	"agreement"?: AgreementReference;
	"agreementAmountCovered"?: number;
	"ticket"?: TicketReference;
	"project"?: ProjectReference;
	"projectPhase"?: ProjectPhaseReference;
	"taxCode"?: TaxCodeReference;

	/**
	 * Used to determine if Avalara tax is enabled.
	 */
	"avalaraTaxFlag"?: boolean;
	"itemTaxableFlag"?: boolean;
	"salesTaxAmount"?: number;

	/**
	 * Set to true if transaction is taxable at the state level.
	 */
	"stateTaxFlag"?: boolean;
	"stateTaxXref"?: string;
	"stateTaxAmount"?: number;

	/**
	 * Set to true if transaction is taxable at the county level.
	 */
	"countyTaxFlag"?: boolean;
	"countyTaxXref"?: string;
	"countyTaxAmount"?: number;

	/**
	 * Set to true if transaction is taxable at the city level.
	 */
	"cityTaxFlag"?: boolean;
	"cityTaxXref"?: string;
	"cityTaxAmount"?: number;

	/**
	 * Set to true if transaction is taxable at the country level.
	 */
	"countryTaxFlag"?: boolean;
	"countryTaxXref"?: string;
	"countryTaxAmount"?: number;

	/**
	 * Set to true if transaction is taxable at the composite level.
	 */
	"compositeTaxFlag"?: boolean;
	"compositeTaxXref"?: string;
	"compositeTaxAmount"?: number;
	"dateClosed"?: Date;

	/**
	 * Metadata of the entity
	 */
	"info"?: Metadata;
}

export namespace UnpostedExpense {

export type ClassificationEnum = 'NonReimbursable' | 'Reimbursable' | 'Personal';

export type GlTypeEnum = 'AP' | 'AR' | 'EE' | 'EI' | 'EO' | 'IA' | 'IT' | 'P' | 'PF' | 'R' | 'RA' | 'RD' | 'RE' | 'RP' | 'ST' | 'SD' | 'ET' | 'RM' | 'FT' | 'PT';
}
export interface UnpostedInvoice {
	"id"?: number;
	"billingLogId"?: number;
	"locationId"?: number;
	"departmentId"?: number;
	"company"?: CompanyReference;
	"accountNumber"?: string;
	"billToCompany"?: CompanyReference;
	"billToSite"?: SiteReference;
	"shipToCompany"?: CompanyReference;
	"shipToSite"?: SiteReference;
	"invoiceNumber"?: string;
	"invoiceDate"?: Date;
	"invoiceType"?: UnpostedInvoice.InvoiceTypeEnum;
	"description"?: string;
	"billingTerms"?: BillingTermsReference;
	"dueDays"?: string;
	"dueDate"?: Date;
	"currency"?: CurrencyReference;
	"subTotal"?: number;
	"total"?: number;
	"invoiceTaxableFlag"?: boolean;
	"taxCode"?: TaxCodeReference;

	/**
	 * Used to determine if Avalara tax is enabled.
	 */
	"avalaraTaxFlag"?: boolean;
	"itemTaxableFlag"?: boolean;
	"salesTaxAmount"?: number;

	/**
	 * Set to true if transaction is taxable at the state level.
	 */
	"stateTaxFlag"?: boolean;
	"stateTaxXref"?: string;
	"stateTaxAmount"?: number;

	/**
	 * Set to true if transaction is taxable at the county level.
	 */
	"countyTaxFlag"?: boolean;
	"countyTaxXref"?: string;
	"countyTaxAmount"?: number;

	/**
	 * Set to true if transaction is taxable at the city level.
	 */
	"cityTaxFlag"?: boolean;
	"cityTaxXref"?: string;
	"cityTaxAmount"?: number;

	/**
	 * Set to true if transaction is taxable at the country level.
	 */
	"countryTaxFlag"?: boolean;
	"countryTaxXref"?: string;
	"countryTaxAmount"?: number;

	/**
	 * Set to true if transaction is taxable at the composite level.
	 */
	"compositeTaxFlag"?: boolean;
	"compositeTaxXref"?: string;
	"compositeTaxAmount"?: number;
	"createdBy"?: string;
	"dateClosed"?: Date;

	/**
	 * Metadata of the entity
	 */
	"info"?: Metadata;
}

export namespace UnpostedInvoice {

export type InvoiceTypeEnum = 'Agreement' | 'CreditMemo' | 'DownPayment' | 'Miscellaneous' | 'Progress' | 'Standard';
}
export interface UnpostedProcurement {
	"id"?: number;
	"description"?: string;
	"locationId"?: number;
	"departmentId"?: number;
	"procurementType"?: UnpostedProcurement.ProcurementTypeEnum;
	"purchaseOrder"?: PurchaseOrderReference;
	"purchaseDate"?: Date;
	"trackingNumber"?: string;
	"billingTerms"?: BillingTermsReference;
	"currency"?: CurrencyReference;
	"total"?: number;
	"taxCode"?: TaxCodeReference;

	/**
	 * Used to determine if Avalara tax is enabled.
	 */
	"avalaraTaxFlag"?: boolean;
	"itemTaxableFlag"?: boolean;
	"purchaseOrderTaxableFlag"?: boolean;

	/**
	 * Set to true if transaction is taxable at the state level.
	 */
	"stateTaxFlag"?: boolean;
	"stateTaxXref"?: string;
	"stateTaxAmount"?: number;

	/**
	 * Set to true if transaction is taxable at the county level.
	 */
	"countyTaxFlag"?: boolean;
	"countyTaxXref"?: string;
	"countyTaxAmount"?: number;

	/**
	 * Set to true if transaction is taxable at the city level.
	 */
	"cityTaxFlag"?: boolean;
	"cityTaxXref"?: string;
	"cityTaxAmount"?: number;

	/**
	 * Set to true if transaction is taxable at the country level.
	 */
	"countryTaxFlag"?: boolean;
	"countryTaxXref"?: string;
	"countryTaxAmount"?: number;

	/**
	 * Set to true if transaction is taxable at the composite level.
	 */
	"compositeTaxFlag"?: boolean;
	"compositeTaxXref"?: string;
	"compositeTaxAmount"?: number;
	"taxTotal"?: number;
	"customer"?: CompanyReference;
	"vendor"?: CompanyReference;
	"vendorAccountNumber"?: string;
	"vendorInvoiceNumber"?: string;
	"vendorInvoiceDate"?: Date;
	"taxFreightFlag"?: boolean;
	"freightTaxTotal"?: number;
	"freightCost"?: number;
	"dateClosed"?: Date;

	/**
	 * Metadata of the entity
	 */
	"info"?: Metadata;
}

export namespace UnpostedProcurement {

export type ProcurementTypeEnum = 'Purchase' | 'Adjustment' | 'Transfer';
}
export interface UserDefinedField {

	/**
	 * ID of the custom user defined field
	 */
	"id"?: number;

	/**
	 * Id of the Pod where the custom field will be placed
	 */
	"podId": number;

	/**
	 * Field caption
	 */
	"caption": string;

	/**
	 * Must be between 1 and 50.  This defines the order in which the custom fields will appear
	 */
	"sequenceNumber": number;

	/**
	 * Help text to accompany the custom field
	 */
	"helpText"?: string;
	"fieldTypeIdentifier": UserDefinedField.FieldTypeIdentifierEnum;

	/**
	 * Only valid for Number or percent
	 */
	"numberDecimals"?: number;
	"entryTypeIdentifier"?: UserDefinedField.EntryTypeIdentifierEnum;
	"requiredFlag"?: boolean;
	"displayOnScreenFlag"?: boolean;
	"readOnlyFlag"?: boolean;

	/**
	 * Denotes that this custom field is included on a list view
	 */
	"listViewFlag"?: boolean;

	/**
	 * Only available with Button Field Type. Required when entryTypeIdentifier is button
	 */
	"buttonUrl"?: string;
	"options"?: Array<UserDefinedFieldOption>;
	"businessUnitIds"?: Array<number>;
	"locationIds"?: Array<number>;
	"addAllBusinessUnits"?: boolean;
	"removeAllBusinessUnits"?: boolean;
	"addAllLocations"?: boolean;
	"removeAllLocations"?: boolean;

	/**
	 * Date in UTC the custom field was created
	 */
	"dateCreated"?: Date;

	/**
	 * Metadata of the entity
	 */
	"info"?: Metadata;
}

export namespace UserDefinedField {

export type FieldTypeIdentifierEnum = 'Text' | 'Button' | 'Date' | 'Hyperlink' | 'Checkbox' | 'Number' | 'Percent' | 'TextArea';

export type EntryTypeIdentifierEnum = 'EntryField' | 'List' | 'Option';
}
export interface UserDefinedFieldOption {
	"id"?: number;
	"optionValue": string;
	"defaultFlag"?: boolean;
	"inactiveFlag"?: boolean;
	"sortOrder"?: number;
}

export interface ValidatePortalRequest {
	"email": string;
	"password": string;
}

export interface ValidatePortalResponse {
	"success"?: boolean;
	"contactId"?: number;
}

export interface ValidationError {
	"code"?: string;
	"message"?: string;
	"resource"?: string;
	"field"?: string;
}

export interface WarehouseBinReference {
	"id"?: number;
	"name"?: string;

	/**
	 * Metadata of the entity
	 */
	"info"?: Metadata;
}

export interface WarehouseReference {
	"id"?: number;
	"name"?: string;

	/**
	 * Metadata of the entity
	 */
	"info"?: Metadata;
}

export interface WorkRoleReference {
	"id"?: number;
	"name"?: string;

	/**
	 * Metadata of the entity
	 */
	"info"?: Metadata;
}

export interface WorkTypeReference {
	"id"?: number;
	"name"?: string;

	/**
	 * Metadata of the entity
	 */
	"info"?: Metadata;
}


//export namespace  {
	'use strict';

	export class AccountingBatchesApi {
		protected basePath = 'https://api-na.myconnectwise.net/v4_6_release/apis/3.0';
		public defaultHeaders : any = {};

		constructor(basePath?: string) {
			if (basePath) {
				this.basePath = basePath;
			}
		}

		/**
		 *
		 * Get Batches Count
		 * @param conditions
		 */
		public financeAccountingBatchesCountGet (params: {  conditions?: string; }, extraQueryParams?: any, extraFetchParams?: any ) : Promise<Count> {
			const localVarPath = this.basePath + '/finance/accounting/batches/count';

			let queryParameters: any = assign({}, extraQueryParams);
			let headerParams: any = assign({}, this.defaultHeaders);
			if (params.conditions !== undefined) {
				queryParameters['conditions'] = params.conditions;
			}

			let fetchParams = {
				method: 'GET',
				headers: headerParams,

			};

			if (extraFetchParams) {
				fetchParams = assign(fetchParams, extraFetchParams);
			}

			let localVarPathWithQueryParameters = localVarPath + (localVarPath.indexOf('?') !== -1 ? '&' : '?') + querystring.stringify(queryParameters);

			return fetch(localVarPathWithQueryParameters, fetchParams).then((response) => {
				if (response.status >= 200 && response.status < 300) {
					return response.json();
				} else {
					let error = new Error(response.statusText);
					(error as any).response = response;
					throw error;
				}
			});
		}
		/**
		 *
		 * Get Batches
		 * @param conditions
		 * @param orderBy
		 * @param childconditions
		 * @param customfieldconditions
		 * @param page
		 * @param pageSize
		 */
		public financeAccountingBatchesGet (params: {  conditions?: string; orderBy?: string; childconditions?: string; customfieldconditions?: string; page?: number; pageSize?: number; }, extraQueryParams?: any, extraFetchParams?: any ) : Promise<Array<AccountingBatch>> {
			const localVarPath = this.basePath + '/finance/accounting/batches';

			let queryParameters: any = assign({}, extraQueryParams);
			let headerParams: any = assign({}, this.defaultHeaders);
			if (params.conditions !== undefined) {
				queryParameters['conditions'] = params.conditions;
			}

			if (params.orderBy !== undefined) {
				queryParameters['orderBy'] = params.orderBy;
			}

			if (params.childconditions !== undefined) {
				queryParameters['childconditions'] = params.childconditions;
			}

			if (params.customfieldconditions !== undefined) {
				queryParameters['customfieldconditions'] = params.customfieldconditions;
			}

			if (params.page !== undefined) {
				queryParameters['page'] = params.page;
			}

			if (params.pageSize !== undefined) {
				queryParameters['pageSize'] = params.pageSize;
			}

			let fetchParams = {
				method: 'GET',
				headers: headerParams,

			};

			if (extraFetchParams) {
				fetchParams = assign(fetchParams, extraFetchParams);
			}

			let localVarPathWithQueryParameters = localVarPath + (localVarPath.indexOf('?') !== -1 ? '&' : '?') + querystring.stringify(queryParameters);

			return fetch(localVarPathWithQueryParameters, fetchParams).then((response) => {
				if (response.status >= 200 && response.status < 300) {
					return response.json();
				} else {
					let error = new Error(response.statusText);
					(error as any).response = response;
					throw error;
				}
			});
		}
		/**
		 *
		 * Delete Batch By Id
		 * @param id
		 */
		public financeAccountingBatchesIdDelete (params: {  id: number; }, extraQueryParams?: any, extraFetchParams?: any ) : Promise<{}> {
			const localVarPath = this.basePath + '/finance/accounting/batches/{id}'
				.replace('{' + 'id' + '}', String(params.id));

			let queryParameters: any = assign({}, extraQueryParams);
			let headerParams: any = assign({}, this.defaultHeaders);
			// verify required parameter 'id' is set
			if (params.id == null) {
				throw new Error('Missing required parameter id when calling financeAccountingBatchesIdDelete');
			}
			let fetchParams = {
				method: 'DELETE',
				headers: headerParams,

			};

			if (extraFetchParams) {
				fetchParams = assign(fetchParams, extraFetchParams);
			}

			let localVarPathWithQueryParameters = localVarPath + (localVarPath.indexOf('?') !== -1 ? '&' : '?') + querystring.stringify(queryParameters);

			return fetch(localVarPathWithQueryParameters, fetchParams).then((response) => {
				if (response.status >= 200 && response.status < 300) {
					return response.json();
				} else {
					let error = new Error(response.statusText);
					(error as any).response = response;
					throw error;
				}
			});
		}
		/**
		 *
		 * Re-export the payload data from an existing batch (RecreateBatch in SOAP)
		 * @param id
		 * @param batchExportParameters
		 */
		public financeAccountingBatchesIdExportPost (params: {  id: number; batchExportParameters: ExportAccountingBatchRequest; }, extraQueryParams?: any, extraFetchParams?: any ) : Promise<GLExport> {
			const localVarPath = this.basePath + '/finance/accounting/batches/{id}/export'
				.replace('{' + 'id' + '}', String(params.id));

			let queryParameters: any = assign({}, extraQueryParams);
			let headerParams: any = assign({}, this.defaultHeaders);
			headerParams['Content-Type'] = 'application/json';

			// verify required parameter 'id' is set
			if (params.id == null) {
				throw new Error('Missing required parameter id when calling financeAccountingBatchesIdExportPost');
			}
			// verify required parameter 'batchExportParameters' is set
			if (params.batchExportParameters == null) {
				throw new Error('Missing required parameter batchExportParameters when calling financeAccountingBatchesIdExportPost');
			}
			let fetchParams = {
				method: 'POST',
				headers: headerParams,
				body: JSON.stringify(params.batchExportParameters),

			};

			if (extraFetchParams) {
				fetchParams = assign(fetchParams, extraFetchParams);
			}

			let localVarPathWithQueryParameters = localVarPath + (localVarPath.indexOf('?') !== -1 ? '&' : '?') + querystring.stringify(queryParameters);

			return fetch(localVarPathWithQueryParameters, fetchParams).then((response) => {
				if (response.status >= 200 && response.status < 300) {
					return response.json();
				} else {
					let error = new Error(response.statusText);
					(error as any).response = response;
					throw error;
				}
			});
		}
		/**
		 *
		 * Get Batch By Id
		 * @param id
		 */
		public financeAccountingBatchesIdGet (params: {  id: number; }, extraQueryParams?: any, extraFetchParams?: any ) : Promise<AccountingBatch> {
			const localVarPath = this.basePath + '/finance/accounting/batches/{id}'
				.replace('{' + 'id' + '}', String(params.id));

			let queryParameters: any = assign({}, extraQueryParams);
			let headerParams: any = assign({}, this.defaultHeaders);
			// verify required parameter 'id' is set
			if (params.id == null) {
				throw new Error('Missing required parameter id when calling financeAccountingBatchesIdGet');
			}
			let fetchParams = {
				method: 'GET',
				headers: headerParams,

			};

			if (extraFetchParams) {
				fetchParams = assign(fetchParams, extraFetchParams);
			}

			let localVarPathWithQueryParameters = localVarPath + (localVarPath.indexOf('?') !== -1 ? '&' : '?') + querystring.stringify(queryParameters);

			return fetch(localVarPathWithQueryParameters, fetchParams).then((response) => {
				if (response.status >= 200 && response.status < 300) {
					return response.json();
				} else {
					let error = new Error(response.statusText);
					(error as any).response = response;
					throw error;
				}
			});
		}
		/**
		 *
		 * Creates the Accounting Batch and updates GL Records (UpdateBatch in SOAP)
		 * @param accountingBatchParameters
		 */
		public financeAccountingBatchesPost (params: {  accountingBatchParameters: CreateAccountingBatchRequest; }, extraQueryParams?: any, extraFetchParams?: any ) : Promise<GLExport> {
			const localVarPath = this.basePath + '/finance/accounting/batches';

			let queryParameters: any = assign({}, extraQueryParams);
			let headerParams: any = assign({}, this.defaultHeaders);
			headerParams['Content-Type'] = 'application/json';

			// verify required parameter 'accountingBatchParameters' is set
			if (params.accountingBatchParameters == null) {
				throw new Error('Missing required parameter accountingBatchParameters when calling financeAccountingBatchesPost');
			}
			let fetchParams = {
				method: 'POST',
				headers: headerParams,
				body: JSON.stringify(params.accountingBatchParameters),

			};

			if (extraFetchParams) {
				fetchParams = assign(fetchParams, extraFetchParams);
			}

			let localVarPathWithQueryParameters = localVarPath + (localVarPath.indexOf('?') !== -1 ? '&' : '?') + querystring.stringify(queryParameters);

			return fetch(localVarPathWithQueryParameters, fetchParams).then((response) => {
				if (response.status >= 200 && response.status < 300) {
					return response.json();
				} else {
					let error = new Error(response.statusText);
					(error as any).response = response;
					throw error;
				}
			});
		}
		/**
		 *
		 * Exports accouting batch payload based on parameters (CreateBatch in SOAP)
		 * @param batchExportParameters
		 */
		public financeAccountingExportPost (params: {  batchExportParameters: ExportAccountingBatchRequest; }, extraQueryParams?: any, extraFetchParams?: any ) : Promise<GLExport> {
			const localVarPath = this.basePath + '/finance/accounting/export';

			let queryParameters: any = assign({}, extraQueryParams);
			let headerParams: any = assign({}, this.defaultHeaders);
			headerParams['Content-Type'] = 'application/json';

			// verify required parameter 'batchExportParameters' is set
			if (params.batchExportParameters == null) {
				throw new Error('Missing required parameter batchExportParameters when calling financeAccountingExportPost');
			}
			let fetchParams = {
				method: 'POST',
				headers: headerParams,
				body: JSON.stringify(params.batchExportParameters),

			};

			if (extraFetchParams) {
				fetchParams = assign(fetchParams, extraFetchParams);
			}

			let localVarPathWithQueryParameters = localVarPath + (localVarPath.indexOf('?') !== -1 ? '&' : '?') + querystring.stringify(queryParameters);

			return fetch(localVarPathWithQueryParameters, fetchParams).then((response) => {
				if (response.status >= 200 && response.status < 300) {
					return response.json();
				} else {
					let error = new Error(response.statusText);
					(error as any).response = response;
					throw error;
				}
			});
		}
	}
//}
//export namespace  {
	'use strict';

	export class AccountingUnpostedExpensesApi {
		protected basePath = 'https://api-na.myconnectwise.net/v4_6_release/apis/3.0';
		public defaultHeaders : any = {};

		constructor(basePath?: string) {
			if (basePath) {
				this.basePath = basePath;
			}
		}

		/**
		 *
		 * Get Unposted Expenses Count
		 * @param conditions
		 */
		public financeAccountingUnpostedexpensesCountGet (params: {  conditions?: string; }, extraQueryParams?: any, extraFetchParams?: any ) : Promise<Count> {
			const localVarPath = this.basePath + '/finance/accounting/unpostedexpenses/count';

			let queryParameters: any = assign({}, extraQueryParams);
			let headerParams: any = assign({}, this.defaultHeaders);
			if (params.conditions !== undefined) {
				queryParameters['conditions'] = params.conditions;
			}

			let fetchParams = {
				method: 'GET',
				headers: headerParams,

			};

			if (extraFetchParams) {
				fetchParams = assign(fetchParams, extraFetchParams);
			}

			let localVarPathWithQueryParameters = localVarPath + (localVarPath.indexOf('?') !== -1 ? '&' : '?') + querystring.stringify(queryParameters);

			return fetch(localVarPathWithQueryParameters, fetchParams).then((response) => {
				if (response.status >= 200 && response.status < 300) {
					return response.json();
				} else {
					let error = new Error(response.statusText);
					(error as any).response = response;
					throw error;
				}
			});
		}
		/**
		 *
		 * Get Unposted Expenses
		 * @param conditions
		 * @param orderBy
		 * @param childconditions
		 * @param customfieldconditions
		 * @param page
		 * @param pageSize
		 */
		public financeAccountingUnpostedexpensesGet (params: {  conditions?: string; orderBy?: string; childconditions?: string; customfieldconditions?: string; page?: number; pageSize?: number; }, extraQueryParams?: any, extraFetchParams?: any ) : Promise<Array<UnpostedExpense>> {
			const localVarPath = this.basePath + '/finance/accounting/unpostedexpenses';

			let queryParameters: any = assign({}, extraQueryParams);
			let headerParams: any = assign({}, this.defaultHeaders);
			if (params.conditions !== undefined) {
				queryParameters['conditions'] = params.conditions;
			}

			if (params.orderBy !== undefined) {
				queryParameters['orderBy'] = params.orderBy;
			}

			if (params.childconditions !== undefined) {
				queryParameters['childconditions'] = params.childconditions;
			}

			if (params.customfieldconditions !== undefined) {
				queryParameters['customfieldconditions'] = params.customfieldconditions;
			}

			if (params.page !== undefined) {
				queryParameters['page'] = params.page;
			}

			if (params.pageSize !== undefined) {
				queryParameters['pageSize'] = params.pageSize;
			}

			let fetchParams = {
				method: 'GET',
				headers: headerParams,

			};

			if (extraFetchParams) {
				fetchParams = assign(fetchParams, extraFetchParams);
			}

			let localVarPathWithQueryParameters = localVarPath + (localVarPath.indexOf('?') !== -1 ? '&' : '?') + querystring.stringify(queryParameters);

			return fetch(localVarPathWithQueryParameters, fetchParams).then((response) => {
				if (response.status >= 200 && response.status < 300) {
					return response.json();
				} else {
					let error = new Error(response.statusText);
					(error as any).response = response;
					throw error;
				}
			});
		}
		/**
		 *
		 * Get Unposted Expense By Id
		 * @param id
		 */
		public financeAccountingUnpostedexpensesIdGet (params: {  id: number; }, extraQueryParams?: any, extraFetchParams?: any ) : Promise<UnpostedExpense> {
			const localVarPath = this.basePath + '/finance/accounting/unpostedexpenses/{id}'
				.replace('{' + 'id' + '}', String(params.id));

			let queryParameters: any = assign({}, extraQueryParams);
			let headerParams: any = assign({}, this.defaultHeaders);
			// verify required parameter 'id' is set
			if (params.id == null) {
				throw new Error('Missing required parameter id when calling financeAccountingUnpostedexpensesIdGet');
			}
			let fetchParams = {
				method: 'GET',
				headers: headerParams,

			};

			if (extraFetchParams) {
				fetchParams = assign(fetchParams, extraFetchParams);
			}

			let localVarPathWithQueryParameters = localVarPath + (localVarPath.indexOf('?') !== -1 ? '&' : '?') + querystring.stringify(queryParameters);

			return fetch(localVarPathWithQueryParameters, fetchParams).then((response) => {
				if (response.status >= 200 && response.status < 300) {
					return response.json();
				} else {
					let error = new Error(response.statusText);
					(error as any).response = response;
					throw error;
				}
			});
		}
	}
//}
//export namespace  {
	'use strict';

	export class AccountingUnpostedProcurementsApi {
		protected basePath = 'https://api-na.myconnectwise.net/v4_6_release/apis/3.0';
		public defaultHeaders : any = {};

		constructor(basePath?: string) {
			if (basePath) {
				this.basePath = basePath;
			}
		}

		/**
		 *
		 * Get Unposted Procurements Count
		 * @param conditions
		 */
		public financeAccountingUnpostedprocurementCountGet (params: {  conditions?: string; }, extraQueryParams?: any, extraFetchParams?: any ) : Promise<Count> {
			const localVarPath = this.basePath + '/finance/accounting/unpostedprocurement/count';

			let queryParameters: any = assign({}, extraQueryParams);
			let headerParams: any = assign({}, this.defaultHeaders);
			if (params.conditions !== undefined) {
				queryParameters['conditions'] = params.conditions;
			}

			let fetchParams = {
				method: 'GET',
				headers: headerParams,

			};

			if (extraFetchParams) {
				fetchParams = assign(fetchParams, extraFetchParams);
			}

			let localVarPathWithQueryParameters = localVarPath + (localVarPath.indexOf('?') !== -1 ? '&' : '?') + querystring.stringify(queryParameters);

			return fetch(localVarPathWithQueryParameters, fetchParams).then((response) => {
				if (response.status >= 200 && response.status < 300) {
					return response.json();
				} else {
					let error = new Error(response.statusText);
					(error as any).response = response;
					throw error;
				}
			});
		}
		/**
		 *
		 * Get Unposted Procurements
		 * @param conditions
		 * @param orderBy
		 * @param childconditions
		 * @param customfieldconditions
		 * @param page
		 * @param pageSize
		 */
		public financeAccountingUnpostedprocurementGet (params: {  conditions?: string; orderBy?: string; childconditions?: string; customfieldconditions?: string; page?: number; pageSize?: number; }, extraQueryParams?: any, extraFetchParams?: any ) : Promise<Array<UnpostedProcurement>> {
			const localVarPath = this.basePath + '/finance/accounting/unpostedprocurement';

			let queryParameters: any = assign({}, extraQueryParams);
			let headerParams: any = assign({}, this.defaultHeaders);
			if (params.conditions !== undefined) {
				queryParameters['conditions'] = params.conditions;
			}

			if (params.orderBy !== undefined) {
				queryParameters['orderBy'] = params.orderBy;
			}

			if (params.childconditions !== undefined) {
				queryParameters['childconditions'] = params.childconditions;
			}

			if (params.customfieldconditions !== undefined) {
				queryParameters['customfieldconditions'] = params.customfieldconditions;
			}

			if (params.page !== undefined) {
				queryParameters['page'] = params.page;
			}

			if (params.pageSize !== undefined) {
				queryParameters['pageSize'] = params.pageSize;
			}

			let fetchParams = {
				method: 'GET',
				headers: headerParams,

			};

			if (extraFetchParams) {
				fetchParams = assign(fetchParams, extraFetchParams);
			}

			let localVarPathWithQueryParameters = localVarPath + (localVarPath.indexOf('?') !== -1 ? '&' : '?') + querystring.stringify(queryParameters);

			return fetch(localVarPathWithQueryParameters, fetchParams).then((response) => {
				if (response.status >= 200 && response.status < 300) {
					return response.json();
				} else {
					let error = new Error(response.statusText);
					(error as any).response = response;
					throw error;
				}
			});
		}
		/**
		 *
		 * Get Unposted Procurement By Id
		 * @param id
		 */
		public financeAccountingUnpostedprocurementIdGet (params: {  id: number; }, extraQueryParams?: any, extraFetchParams?: any ) : Promise<UnpostedProcurement> {
			const localVarPath = this.basePath + '/finance/accounting/unpostedprocurement/{id}'
				.replace('{' + 'id' + '}', String(params.id));

			let queryParameters: any = assign({}, extraQueryParams);
			let headerParams: any = assign({}, this.defaultHeaders);
			// verify required parameter 'id' is set
			if (params.id == null) {
				throw new Error('Missing required parameter id when calling financeAccountingUnpostedprocurementIdGet');
			}
			let fetchParams = {
				method: 'GET',
				headers: headerParams,

			};

			if (extraFetchParams) {
				fetchParams = assign(fetchParams, extraFetchParams);
			}

			let localVarPathWithQueryParameters = localVarPath + (localVarPath.indexOf('?') !== -1 ? '&' : '?') + querystring.stringify(queryParameters);

			return fetch(localVarPathWithQueryParameters, fetchParams).then((response) => {
				if (response.status >= 200 && response.status < 300) {
					return response.json();
				} else {
					let error = new Error(response.statusText);
					(error as any).response = response;
					throw error;
				}
			});
		}
	}
//}
//export namespace  {
	'use strict';

	export class AccountingUnpostedinvoicesApi {
		protected basePath = 'https://api-na.myconnectwise.net/v4_6_release/apis/3.0';
		public defaultHeaders : any = {};

		constructor(basePath?: string) {
			if (basePath) {
				this.basePath = basePath;
			}
		}

		/**
		 *
		 * Get Unposted Invoices Count
		 * @param conditions
		 */
		public financeAccountingUnpostedinvoicesCountGet (params: {  conditions?: string; }, extraQueryParams?: any, extraFetchParams?: any ) : Promise<Count> {
			const localVarPath = this.basePath + '/finance/accounting/unpostedinvoices/count';

			let queryParameters: any = assign({}, extraQueryParams);
			let headerParams: any = assign({}, this.defaultHeaders);
			if (params.conditions !== undefined) {
				queryParameters['conditions'] = params.conditions;
			}

			let fetchParams = {
				method: 'GET',
				headers: headerParams,

			};

			if (extraFetchParams) {
				fetchParams = assign(fetchParams, extraFetchParams);
			}

			let localVarPathWithQueryParameters = localVarPath + (localVarPath.indexOf('?') !== -1 ? '&' : '?') + querystring.stringify(queryParameters);

			return fetch(localVarPathWithQueryParameters, fetchParams).then((response) => {
				if (response.status >= 200 && response.status < 300) {
					return response.json();
				} else {
					let error = new Error(response.statusText);
					(error as any).response = response;
					throw error;
				}
			});
		}
		/**
		 *
		 * Get Unposted Invoices
		 * @param conditions
		 * @param orderBy
		 * @param childconditions
		 * @param customfieldconditions
		 * @param page
		 * @param pageSize
		 */
		public financeAccountingUnpostedinvoicesGet (params: {  conditions?: string; orderBy?: string; childconditions?: string; customfieldconditions?: string; page?: number; pageSize?: number; }, extraQueryParams?: any, extraFetchParams?: any ) : Promise<Array<UnpostedInvoice>> {
			const localVarPath = this.basePath + '/finance/accounting/unpostedinvoices';

			let queryParameters: any = assign({}, extraQueryParams);
			let headerParams: any = assign({}, this.defaultHeaders);
			if (params.conditions !== undefined) {
				queryParameters['conditions'] = params.conditions;
			}

			if (params.orderBy !== undefined) {
				queryParameters['orderBy'] = params.orderBy;
			}

			if (params.childconditions !== undefined) {
				queryParameters['childconditions'] = params.childconditions;
			}

			if (params.customfieldconditions !== undefined) {
				queryParameters['customfieldconditions'] = params.customfieldconditions;
			}

			if (params.page !== undefined) {
				queryParameters['page'] = params.page;
			}

			if (params.pageSize !== undefined) {
				queryParameters['pageSize'] = params.pageSize;
			}

			let fetchParams = {
				method: 'GET',
				headers: headerParams,

			};

			if (extraFetchParams) {
				fetchParams = assign(fetchParams, extraFetchParams);
			}

			let localVarPathWithQueryParameters = localVarPath + (localVarPath.indexOf('?') !== -1 ? '&' : '?') + querystring.stringify(queryParameters);

			return fetch(localVarPathWithQueryParameters, fetchParams).then((response) => {
				if (response.status >= 200 && response.status < 300) {
					return response.json();
				} else {
					let error = new Error(response.statusText);
					(error as any).response = response;
					throw error;
				}
			});
		}
		/**
		 *
		 * Get Unposted Invoice By Id
		 * @param id
		 */
		public financeAccountingUnpostedinvoicesIdGet (params: {  id: number; }, extraQueryParams?: any, extraFetchParams?: any ) : Promise<UnpostedInvoice> {
			const localVarPath = this.basePath + '/finance/accounting/unpostedinvoices/{id}'
				.replace('{' + 'id' + '}', String(params.id));

			let queryParameters: any = assign({}, extraQueryParams);
			let headerParams: any = assign({}, this.defaultHeaders);
			// verify required parameter 'id' is set
			if (params.id == null) {
				throw new Error('Missing required parameter id when calling financeAccountingUnpostedinvoicesIdGet');
			}
			let fetchParams = {
				method: 'GET',
				headers: headerParams,

			};

			if (extraFetchParams) {
				fetchParams = assign(fetchParams, extraFetchParams);
			}

			let localVarPathWithQueryParameters = localVarPath + (localVarPath.indexOf('?') !== -1 ? '&' : '?') + querystring.stringify(queryParameters);

			return fetch(localVarPathWithQueryParameters, fetchParams).then((response) => {
				if (response.status >= 200 && response.status < 300) {
					return response.json();
				} else {
					let error = new Error(response.statusText);
					(error as any).response = response;
					throw error;
				}
			});
		}
	}
//}
//export namespace  {
	'use strict';

	export class ActivitiesApi {
		protected basePath = 'https://api-na.myconnectwise.net/v4_6_release/apis/3.0';
		public defaultHeaders : any = {};

		constructor(basePath?: string) {
			if (basePath) {
				this.basePath = basePath;
			}
		}

		/**
		 *
		 * Get Activities Count
		 * @param conditions
		 * @param customFieldConditions
		 */
		public salesActivitiesCountGet (params: {  conditions?: string; customFieldConditions?: string; }, extraQueryParams?: any, extraFetchParams?: any ) : Promise<Count> {
			const localVarPath = this.basePath + '/sales/activities/count';

			let queryParameters: any = assign({}, extraQueryParams);
			let headerParams: any = assign({}, this.defaultHeaders);
			if (params.conditions !== undefined) {
				queryParameters['conditions'] = params.conditions;
			}

			if (params.customFieldConditions !== undefined) {
				queryParameters['customFieldConditions'] = params.customFieldConditions;
			}

			let fetchParams = {
				method: 'GET',
				headers: headerParams,

			};

			if (extraFetchParams) {
				fetchParams = assign(fetchParams, extraFetchParams);
			}

			let localVarPathWithQueryParameters = localVarPath + (localVarPath.indexOf('?') !== -1 ? '&' : '?') + querystring.stringify(queryParameters);

			return fetch(localVarPathWithQueryParameters, fetchParams).then((response) => {
				if (response.status >= 200 && response.status < 300) {
					return response.json();
				} else {
					let error = new Error(response.statusText);
					(error as any).response = response;
					throw error;
				}
			});
		}
		/**
		 *
		 * Get Activities
		 * @param conditions
		 * @param orderBy
		 * @param childconditions
		 * @param customfieldconditions
		 * @param page
		 * @param pageSize
		 */
		public salesActivitiesGet (params: {  conditions?: string; orderBy?: string; childconditions?: string; customfieldconditions?: string; page?: number; pageSize?: number; }, extraQueryParams?: any, extraFetchParams?: any ) : Promise<Array<Activity>> {
			const localVarPath = this.basePath + '/sales/activities';

			let queryParameters: any = assign({}, extraQueryParams);
			let headerParams: any = assign({}, this.defaultHeaders);
			if (params.conditions !== undefined) {
				queryParameters['conditions'] = params.conditions;
			}

			if (params.orderBy !== undefined) {
				queryParameters['orderBy'] = params.orderBy;
			}

			if (params.childconditions !== undefined) {
				queryParameters['childconditions'] = params.childconditions;
			}

			if (params.customfieldconditions !== undefined) {
				queryParameters['customfieldconditions'] = params.customfieldconditions;
			}

			if (params.page !== undefined) {
				queryParameters['page'] = params.page;
			}

			if (params.pageSize !== undefined) {
				queryParameters['pageSize'] = params.pageSize;
			}

			let fetchParams = {
				method: 'GET',
				headers: headerParams,

			};

			if (extraFetchParams) {
				fetchParams = assign(fetchParams, extraFetchParams);
			}

			let localVarPathWithQueryParameters = localVarPath + (localVarPath.indexOf('?') !== -1 ? '&' : '?') + querystring.stringify(queryParameters);

			return fetch(localVarPathWithQueryParameters, fetchParams).then((response) => {
				if (response.status >= 200 && response.status < 300) {
					return response.json();
				} else {
					let error = new Error(response.statusText);
					(error as any).response = response;
					throw error;
				}
			});
		}
		/**
		 *
		 * Delete Activity By Id
		 * @param id
		 */
		public salesActivitiesIdDelete (params: {  id: number; }, extraQueryParams?: any, extraFetchParams?: any ) : Promise<{}> {
			const localVarPath = this.basePath + '/sales/activities/{id}'
				.replace('{' + 'id' + '}', String(params.id));

			let queryParameters: any = assign({}, extraQueryParams);
			let headerParams: any = assign({}, this.defaultHeaders);
			// verify required parameter 'id' is set
			if (params.id == null) {
				throw new Error('Missing required parameter id when calling salesActivitiesIdDelete');
			}
			let fetchParams = {
				method: 'DELETE',
				headers: headerParams,

			};

			if (extraFetchParams) {
				fetchParams = assign(fetchParams, extraFetchParams);
			}

			let localVarPathWithQueryParameters = localVarPath + (localVarPath.indexOf('?') !== -1 ? '&' : '?') + querystring.stringify(queryParameters);

			return fetch(localVarPathWithQueryParameters, fetchParams).then((response) => {
				if (response.status >= 200 && response.status < 300) {
					return response.json();
				} else {
					let error = new Error(response.statusText);
					(error as any).response = response;
					throw error;
				}
			});
		}
		/**
		 *
		 * Get Activity By Id
		 * @param id
		 */
		public salesActivitiesIdGet (params: {  id: number; }, extraQueryParams?: any, extraFetchParams?: any ) : Promise<Activity> {
			const localVarPath = this.basePath + '/sales/activities/{id}'
				.replace('{' + 'id' + '}', String(params.id));

			let queryParameters: any = assign({}, extraQueryParams);
			let headerParams: any = assign({}, this.defaultHeaders);
			// verify required parameter 'id' is set
			if (params.id == null) {
				throw new Error('Missing required parameter id when calling salesActivitiesIdGet');
			}
			let fetchParams = {
				method: 'GET',
				headers: headerParams,

			};

			if (extraFetchParams) {
				fetchParams = assign(fetchParams, extraFetchParams);
			}

			let localVarPathWithQueryParameters = localVarPath + (localVarPath.indexOf('?') !== -1 ? '&' : '?') + querystring.stringify(queryParameters);

			return fetch(localVarPathWithQueryParameters, fetchParams).then((response) => {
				if (response.status >= 200 && response.status < 300) {
					return response.json();
				} else {
					let error = new Error(response.statusText);
					(error as any).response = response;
					throw error;
				}
			});
		}
		/**
		 *
		 * Update Activity
		 * @param id
		 * @param operations
		 */
		public salesActivitiesIdPatch (params: {  id: number; operations: Array<PatchOperation>; }, extraQueryParams?: any, extraFetchParams?: any ) : Promise<Activity> {
			const localVarPath = this.basePath + '/sales/activities/{id}'
				.replace('{' + 'id' + '}', String(params.id));

			let queryParameters: any = assign({}, extraQueryParams);
			let headerParams: any = assign({}, this.defaultHeaders);
			headerParams['Content-Type'] = 'application/json';

			// verify required parameter 'id' is set
			if (params.id == null) {
				throw new Error('Missing required parameter id when calling salesActivitiesIdPatch');
			}
			// verify required parameter 'operations' is set
			if (params.operations == null) {
				throw new Error('Missing required parameter operations when calling salesActivitiesIdPatch');
			}
			let fetchParams = {
				method: 'PATCH',
				headers: headerParams,
				body: JSON.stringify(params.operations),

			};

			if (extraFetchParams) {
				fetchParams = assign(fetchParams, extraFetchParams);
			}

			let localVarPathWithQueryParameters = localVarPath + (localVarPath.indexOf('?') !== -1 ? '&' : '?') + querystring.stringify(queryParameters);

			return fetch(localVarPathWithQueryParameters, fetchParams).then((response) => {
				if (response.status >= 200 && response.status < 300) {
					return response.json();
				} else {
					let error = new Error(response.statusText);
					(error as any).response = response;
					throw error;
				}
			});
		}
		/**
		 *
		 * Replace Activity
		 * @param id
		 * @param activity
		 */
		public salesActivitiesIdPut (params: {  id: number; activity: Activity; }, extraQueryParams?: any, extraFetchParams?: any ) : Promise<Activity> {
			const localVarPath = this.basePath + '/sales/activities/{id}'
				.replace('{' + 'id' + '}', String(params.id));

			let queryParameters: any = assign({}, extraQueryParams);
			let headerParams: any = assign({}, this.defaultHeaders);
			headerParams['Content-Type'] = 'application/json';

			// verify required parameter 'id' is set
			if (params.id == null) {
				throw new Error('Missing required parameter id when calling salesActivitiesIdPut');
			}
			// verify required parameter 'activity' is set
			if (params.activity == null) {
				throw new Error('Missing required parameter activity when calling salesActivitiesIdPut');
			}
			let fetchParams = {
				method: 'PUT',
				headers: headerParams,
				body: JSON.stringify(params.activity),

			};

			if (extraFetchParams) {
				fetchParams = assign(fetchParams, extraFetchParams);
			}

			let localVarPathWithQueryParameters = localVarPath + (localVarPath.indexOf('?') !== -1 ? '&' : '?') + querystring.stringify(queryParameters);

			return fetch(localVarPathWithQueryParameters, fetchParams).then((response) => {
				if (response.status >= 200 && response.status < 300) {
					return response.json();
				} else {
					let error = new Error(response.statusText);
					(error as any).response = response;
					throw error;
				}
			});
		}
		/**
		 *
		 * Create Activity
		 * @param activity
		 */
		public salesActivitiesPost (params: {  activity: Activity; }, extraQueryParams?: any, extraFetchParams?: any ) : Promise<Activity> {
			const localVarPath = this.basePath + '/sales/activities';

			let queryParameters: any = assign({}, extraQueryParams);
			let headerParams: any = assign({}, this.defaultHeaders);
			headerParams['Content-Type'] = 'application/json';

			// verify required parameter 'activity' is set
			if (params.activity == null) {
				throw new Error('Missing required parameter activity when calling salesActivitiesPost');
			}
			let fetchParams = {
				method: 'POST',
				headers: headerParams,
				body: JSON.stringify(params.activity),

			};

			if (extraFetchParams) {
				fetchParams = assign(fetchParams, extraFetchParams);
			}

			let localVarPathWithQueryParameters = localVarPath + (localVarPath.indexOf('?') !== -1 ? '&' : '?') + querystring.stringify(queryParameters);

			return fetch(localVarPathWithQueryParameters, fetchParams).then((response) => {
				if (response.status >= 200 && response.status < 300) {
					return response.json();
				} else {
					let error = new Error(response.statusText);
					(error as any).response = response;
					throw error;
				}
			});
		}
	}
//}
//export namespace  {
	'use strict';

	export class ActivityStatusesApi {
		protected basePath = 'https://api-na.myconnectwise.net/v4_6_release/apis/3.0';
		public defaultHeaders : any = {};

		constructor(basePath?: string) {
			if (basePath) {
				this.basePath = basePath;
			}
		}

		/**
		 *
		 * Get Activity Statuses Count
		 * @param conditions
		 */
		public salesActivitiesStatusesCountGet (params: {  conditions?: string; }, extraQueryParams?: any, extraFetchParams?: any ) : Promise<Count> {
			const localVarPath = this.basePath + '/sales/activities/statuses/count';

			let queryParameters: any = assign({}, extraQueryParams);
			let headerParams: any = assign({}, this.defaultHeaders);
			if (params.conditions !== undefined) {
				queryParameters['conditions'] = params.conditions;
			}

			let fetchParams = {
				method: 'GET',
				headers: headerParams,

			};

			if (extraFetchParams) {
				fetchParams = assign(fetchParams, extraFetchParams);
			}

			let localVarPathWithQueryParameters = localVarPath + (localVarPath.indexOf('?') !== -1 ? '&' : '?') + querystring.stringify(queryParameters);

			return fetch(localVarPathWithQueryParameters, fetchParams).then((response) => {
				if (response.status >= 200 && response.status < 300) {
					return response.json();
				} else {
					let error = new Error(response.statusText);
					(error as any).response = response;
					throw error;
				}
			});
		}
		/**
		 *
		 * Get Activity Statuses
		 * @param conditions
		 * @param orderBy
		 * @param childconditions
		 * @param customfieldconditions
		 * @param page
		 * @param pageSize
		 */
		public salesActivitiesStatusesGet (params: {  conditions?: string; orderBy?: string; childconditions?: string; customfieldconditions?: string; page?: number; pageSize?: number; }, extraQueryParams?: any, extraFetchParams?: any ) : Promise<Array<ActivityStatus>> {
			const localVarPath = this.basePath + '/sales/activities/statuses';

			let queryParameters: any = assign({}, extraQueryParams);
			let headerParams: any = assign({}, this.defaultHeaders);
			if (params.conditions !== undefined) {
				queryParameters['conditions'] = params.conditions;
			}

			if (params.orderBy !== undefined) {
				queryParameters['orderBy'] = params.orderBy;
			}

			if (params.childconditions !== undefined) {
				queryParameters['childconditions'] = params.childconditions;
			}

			if (params.customfieldconditions !== undefined) {
				queryParameters['customfieldconditions'] = params.customfieldconditions;
			}

			if (params.page !== undefined) {
				queryParameters['page'] = params.page;
			}

			if (params.pageSize !== undefined) {
				queryParameters['pageSize'] = params.pageSize;
			}

			let fetchParams = {
				method: 'GET',
				headers: headerParams,

			};

			if (extraFetchParams) {
				fetchParams = assign(fetchParams, extraFetchParams);
			}

			let localVarPathWithQueryParameters = localVarPath + (localVarPath.indexOf('?') !== -1 ? '&' : '?') + querystring.stringify(queryParameters);

			return fetch(localVarPathWithQueryParameters, fetchParams).then((response) => {
				if (response.status >= 200 && response.status < 300) {
					return response.json();
				} else {
					let error = new Error(response.statusText);
					(error as any).response = response;
					throw error;
				}
			});
		}
		/**
		 *
		 * Delete Activity Status By Id
		 * @param id
		 */
		public salesActivitiesStatusesIdDelete (params: {  id: number; }, extraQueryParams?: any, extraFetchParams?: any ) : Promise<{}> {
			const localVarPath = this.basePath + '/sales/activities/statuses/{id}'
				.replace('{' + 'id' + '}', String(params.id));

			let queryParameters: any = assign({}, extraQueryParams);
			let headerParams: any = assign({}, this.defaultHeaders);
			// verify required parameter 'id' is set
			if (params.id == null) {
				throw new Error('Missing required parameter id when calling salesActivitiesStatusesIdDelete');
			}
			let fetchParams = {
				method: 'DELETE',
				headers: headerParams,

			};

			if (extraFetchParams) {
				fetchParams = assign(fetchParams, extraFetchParams);
			}

			let localVarPathWithQueryParameters = localVarPath + (localVarPath.indexOf('?') !== -1 ? '&' : '?') + querystring.stringify(queryParameters);

			return fetch(localVarPathWithQueryParameters, fetchParams).then((response) => {
				if (response.status >= 200 && response.status < 300) {
					return response.json();
				} else {
					let error = new Error(response.statusText);
					(error as any).response = response;
					throw error;
				}
			});
		}
		/**
		 *
		 * Get Activity Status By Id
		 * @param id
		 */
		public salesActivitiesStatusesIdGet (params: {  id: number; }, extraQueryParams?: any, extraFetchParams?: any ) : Promise<ActivityStatus> {
			const localVarPath = this.basePath + '/sales/activities/statuses/{id}'
				.replace('{' + 'id' + '}', String(params.id));

			let queryParameters: any = assign({}, extraQueryParams);
			let headerParams: any = assign({}, this.defaultHeaders);
			// verify required parameter 'id' is set
			if (params.id == null) {
				throw new Error('Missing required parameter id when calling salesActivitiesStatusesIdGet');
			}
			let fetchParams = {
				method: 'GET',
				headers: headerParams,

			};

			if (extraFetchParams) {
				fetchParams = assign(fetchParams, extraFetchParams);
			}

			let localVarPathWithQueryParameters = localVarPath + (localVarPath.indexOf('?') !== -1 ? '&' : '?') + querystring.stringify(queryParameters);

			return fetch(localVarPathWithQueryParameters, fetchParams).then((response) => {
				if (response.status >= 200 && response.status < 300) {
					return response.json();
				} else {
					let error = new Error(response.statusText);
					(error as any).response = response;
					throw error;
				}
			});
		}
		/**
		 *
		 * Update Activity Status
		 * @param id
		 * @param operations
		 */
		public salesActivitiesStatusesIdPatch (params: {  id: number; operations: Array<PatchOperation>; }, extraQueryParams?: any, extraFetchParams?: any ) : Promise<ActivityStatus> {
			const localVarPath = this.basePath + '/sales/activities/statuses/{id}'
				.replace('{' + 'id' + '}', String(params.id));

			let queryParameters: any = assign({}, extraQueryParams);
			let headerParams: any = assign({}, this.defaultHeaders);
			headerParams['Content-Type'] = 'application/json';

			// verify required parameter 'id' is set
			if (params.id == null) {
				throw new Error('Missing required parameter id when calling salesActivitiesStatusesIdPatch');
			}
			// verify required parameter 'operations' is set
			if (params.operations == null) {
				throw new Error('Missing required parameter operations when calling salesActivitiesStatusesIdPatch');
			}
			let fetchParams = {
				method: 'PATCH',
				headers: headerParams,
				body: JSON.stringify(params.operations),

			};

			if (extraFetchParams) {
				fetchParams = assign(fetchParams, extraFetchParams);
			}

			let localVarPathWithQueryParameters = localVarPath + (localVarPath.indexOf('?') !== -1 ? '&' : '?') + querystring.stringify(queryParameters);

			return fetch(localVarPathWithQueryParameters, fetchParams).then((response) => {
				if (response.status >= 200 && response.status < 300) {
					return response.json();
				} else {
					let error = new Error(response.statusText);
					(error as any).response = response;
					throw error;
				}
			});
		}
		/**
		 *
		 * Replace Activity Status
		 * @param id
		 * @param activityStatus
		 */
		public salesActivitiesStatusesIdPut (params: {  id: number; activityStatus: ActivityStatus; }, extraQueryParams?: any, extraFetchParams?: any ) : Promise<ActivityStatus> {
			const localVarPath = this.basePath + '/sales/activities/statuses/{id}'
				.replace('{' + 'id' + '}', String(params.id));

			let queryParameters: any = assign({}, extraQueryParams);
			let headerParams: any = assign({}, this.defaultHeaders);
			headerParams['Content-Type'] = 'application/json';

			// verify required parameter 'id' is set
			if (params.id == null) {
				throw new Error('Missing required parameter id when calling salesActivitiesStatusesIdPut');
			}
			// verify required parameter 'activityStatus' is set
			if (params.activityStatus == null) {
				throw new Error('Missing required parameter activityStatus when calling salesActivitiesStatusesIdPut');
			}
			let fetchParams = {
				method: 'PUT',
				headers: headerParams,
				body: JSON.stringify(params.activityStatus),

			};

			if (extraFetchParams) {
				fetchParams = assign(fetchParams, extraFetchParams);
			}

			let localVarPathWithQueryParameters = localVarPath + (localVarPath.indexOf('?') !== -1 ? '&' : '?') + querystring.stringify(queryParameters);

			return fetch(localVarPathWithQueryParameters, fetchParams).then((response) => {
				if (response.status >= 200 && response.status < 300) {
					return response.json();
				} else {
					let error = new Error(response.statusText);
					(error as any).response = response;
					throw error;
				}
			});
		}
		/**
		 *
		 * Create Activity Status
		 * @param activityStatus
		 */
		public salesActivitiesStatusesPost (params: {  activityStatus: ActivityStatus; }, extraQueryParams?: any, extraFetchParams?: any ) : Promise<ActivityStatus> {
			const localVarPath = this.basePath + '/sales/activities/statuses';

			let queryParameters: any = assign({}, extraQueryParams);
			let headerParams: any = assign({}, this.defaultHeaders);
			headerParams['Content-Type'] = 'application/json';

			// verify required parameter 'activityStatus' is set
			if (params.activityStatus == null) {
				throw new Error('Missing required parameter activityStatus when calling salesActivitiesStatusesPost');
			}
			let fetchParams = {
				method: 'POST',
				headers: headerParams,
				body: JSON.stringify(params.activityStatus),

			};

			if (extraFetchParams) {
				fetchParams = assign(fetchParams, extraFetchParams);
			}

			let localVarPathWithQueryParameters = localVarPath + (localVarPath.indexOf('?') !== -1 ? '&' : '?') + querystring.stringify(queryParameters);

			return fetch(localVarPathWithQueryParameters, fetchParams).then((response) => {
				if (response.status >= 200 && response.status < 300) {
					return response.json();
				} else {
					let error = new Error(response.statusText);
					(error as any).response = response;
					throw error;
				}
			});
		}
	}
//}
//export namespace  {
	'use strict';

	export class ActivityStopwatchesApi {
		protected basePath = 'https://api-na.myconnectwise.net/v4_6_release/apis/3.0';
		public defaultHeaders : any = {};

		constructor(basePath?: string) {
			if (basePath) {
				this.basePath = basePath;
			}
		}

		/**
		 *
		 * Get Activity Stopwatches Count
		 * @param conditions
		 */
		public timeActivitystopwatchesCountGet (params: {  conditions?: string; }, extraQueryParams?: any, extraFetchParams?: any ) : Promise<Count> {
			const localVarPath = this.basePath + '/time/activitystopwatches/count';

			let queryParameters: any = assign({}, extraQueryParams);
			let headerParams: any = assign({}, this.defaultHeaders);
			if (params.conditions !== undefined) {
				queryParameters['conditions'] = params.conditions;
			}

			let fetchParams = {
				method: 'GET',
				headers: headerParams,

			};

			if (extraFetchParams) {
				fetchParams = assign(fetchParams, extraFetchParams);
			}

			let localVarPathWithQueryParameters = localVarPath + (localVarPath.indexOf('?') !== -1 ? '&' : '?') + querystring.stringify(queryParameters);

			return fetch(localVarPathWithQueryParameters, fetchParams).then((response) => {
				if (response.status >= 200 && response.status < 300) {
					return response.json();
				} else {
					let error = new Error(response.statusText);
					(error as any).response = response;
					throw error;
				}
			});
		}
		/**
		 *
		 * Get Activity Stopwatches
		 * @param conditions
		 * @param orderBy
		 * @param childconditions
		 * @param customfieldconditions
		 * @param page
		 * @param pageSize
		 */
		public timeActivitystopwatchesGet (params: {  conditions?: string; orderBy?: string; childconditions?: string; customfieldconditions?: string; page?: number; pageSize?: number; }, extraQueryParams?: any, extraFetchParams?: any ) : Promise<Array<ActivityStopwatch>> {
			const localVarPath = this.basePath + '/time/activitystopwatches';

			let queryParameters: any = assign({}, extraQueryParams);
			let headerParams: any = assign({}, this.defaultHeaders);
			if (params.conditions !== undefined) {
				queryParameters['conditions'] = params.conditions;
			}

			if (params.orderBy !== undefined) {
				queryParameters['orderBy'] = params.orderBy;
			}

			if (params.childconditions !== undefined) {
				queryParameters['childconditions'] = params.childconditions;
			}

			if (params.customfieldconditions !== undefined) {
				queryParameters['customfieldconditions'] = params.customfieldconditions;
			}

			if (params.page !== undefined) {
				queryParameters['page'] = params.page;
			}

			if (params.pageSize !== undefined) {
				queryParameters['pageSize'] = params.pageSize;
			}

			let fetchParams = {
				method: 'GET',
				headers: headerParams,

			};

			if (extraFetchParams) {
				fetchParams = assign(fetchParams, extraFetchParams);
			}

			let localVarPathWithQueryParameters = localVarPath + (localVarPath.indexOf('?') !== -1 ? '&' : '?') + querystring.stringify(queryParameters);

			return fetch(localVarPathWithQueryParameters, fetchParams).then((response) => {
				if (response.status >= 200 && response.status < 300) {
					return response.json();
				} else {
					let error = new Error(response.statusText);
					(error as any).response = response;
					throw error;
				}
			});
		}
		/**
		 *
		 * Delete Activity Stopwatch By Id
		 * @param id
		 */
		public timeActivitystopwatchesIdDelete (params: {  id: number; }, extraQueryParams?: any, extraFetchParams?: any ) : Promise<{}> {
			const localVarPath = this.basePath + '/time/activitystopwatches/{id}'
				.replace('{' + 'id' + '}', String(params.id));

			let queryParameters: any = assign({}, extraQueryParams);
			let headerParams: any = assign({}, this.defaultHeaders);
			// verify required parameter 'id' is set
			if (params.id == null) {
				throw new Error('Missing required parameter id when calling timeActivitystopwatchesIdDelete');
			}
			let fetchParams = {
				method: 'DELETE',
				headers: headerParams,

			};

			if (extraFetchParams) {
				fetchParams = assign(fetchParams, extraFetchParams);
			}

			let localVarPathWithQueryParameters = localVarPath + (localVarPath.indexOf('?') !== -1 ? '&' : '?') + querystring.stringify(queryParameters);

			return fetch(localVarPathWithQueryParameters, fetchParams).then((response) => {
				if (response.status >= 200 && response.status < 300) {
					return response.json();
				} else {
					let error = new Error(response.statusText);
					(error as any).response = response;
					throw error;
				}
			});
		}
		/**
		 *
		 * Get Activity Stopwatch By Id
		 * @param id
		 */
		public timeActivitystopwatchesIdGet (params: {  id: number; }, extraQueryParams?: any, extraFetchParams?: any ) : Promise<ActivityStopwatch> {
			const localVarPath = this.basePath + '/time/activitystopwatches/{id}'
				.replace('{' + 'id' + '}', String(params.id));

			let queryParameters: any = assign({}, extraQueryParams);
			let headerParams: any = assign({}, this.defaultHeaders);
			// verify required parameter 'id' is set
			if (params.id == null) {
				throw new Error('Missing required parameter id when calling timeActivitystopwatchesIdGet');
			}
			let fetchParams = {
				method: 'GET',
				headers: headerParams,

			};

			if (extraFetchParams) {
				fetchParams = assign(fetchParams, extraFetchParams);
			}

			let localVarPathWithQueryParameters = localVarPath + (localVarPath.indexOf('?') !== -1 ? '&' : '?') + querystring.stringify(queryParameters);

			return fetch(localVarPathWithQueryParameters, fetchParams).then((response) => {
				if (response.status >= 200 && response.status < 300) {
					return response.json();
				} else {
					let error = new Error(response.statusText);
					(error as any).response = response;
					throw error;
				}
			});
		}
		/**
		 *
		 * Update Activity Stopwatch
		 * @param id
		 * @param operations
		 */
		public timeActivitystopwatchesIdPatch (params: {  id: number; operations: Array<PatchOperation>; }, extraQueryParams?: any, extraFetchParams?: any ) : Promise<ActivityStopwatch> {
			const localVarPath = this.basePath + '/time/activitystopwatches/{id}'
				.replace('{' + 'id' + '}', String(params.id));

			let queryParameters: any = assign({}, extraQueryParams);
			let headerParams: any = assign({}, this.defaultHeaders);
			headerParams['Content-Type'] = 'application/json';

			// verify required parameter 'id' is set
			if (params.id == null) {
				throw new Error('Missing required parameter id when calling timeActivitystopwatchesIdPatch');
			}
			// verify required parameter 'operations' is set
			if (params.operations == null) {
				throw new Error('Missing required parameter operations when calling timeActivitystopwatchesIdPatch');
			}
			let fetchParams = {
				method: 'PATCH',
				headers: headerParams,
				body: JSON.stringify(params.operations),

			};

			if (extraFetchParams) {
				fetchParams = assign(fetchParams, extraFetchParams);
			}

			let localVarPathWithQueryParameters = localVarPath + (localVarPath.indexOf('?') !== -1 ? '&' : '?') + querystring.stringify(queryParameters);

			return fetch(localVarPathWithQueryParameters, fetchParams).then((response) => {
				if (response.status >= 200 && response.status < 300) {
					return response.json();
				} else {
					let error = new Error(response.statusText);
					(error as any).response = response;
					throw error;
				}
			});
		}
		/**
		 *
		 * Replace Activity Stopwatch
		 * @param id
		 * @param activityStopwatch
		 */
		public timeActivitystopwatchesIdPut (params: {  id: number; activityStopwatch: ActivityStopwatch; }, extraQueryParams?: any, extraFetchParams?: any ) : Promise<ActivityStopwatch> {
			const localVarPath = this.basePath + '/time/activitystopwatches/{id}'
				.replace('{' + 'id' + '}', String(params.id));

			let queryParameters: any = assign({}, extraQueryParams);
			let headerParams: any = assign({}, this.defaultHeaders);
			headerParams['Content-Type'] = 'application/json';

			// verify required parameter 'id' is set
			if (params.id == null) {
				throw new Error('Missing required parameter id when calling timeActivitystopwatchesIdPut');
			}
			// verify required parameter 'activityStopwatch' is set
			if (params.activityStopwatch == null) {
				throw new Error('Missing required parameter activityStopwatch when calling timeActivitystopwatchesIdPut');
			}
			let fetchParams = {
				method: 'PUT',
				headers: headerParams,
				body: JSON.stringify(params.activityStopwatch),

			};

			if (extraFetchParams) {
				fetchParams = assign(fetchParams, extraFetchParams);
			}

			let localVarPathWithQueryParameters = localVarPath + (localVarPath.indexOf('?') !== -1 ? '&' : '?') + querystring.stringify(queryParameters);

			return fetch(localVarPathWithQueryParameters, fetchParams).then((response) => {
				if (response.status >= 200 && response.status < 300) {
					return response.json();
				} else {
					let error = new Error(response.statusText);
					(error as any).response = response;
					throw error;
				}
			});
		}
		/**
		 *
		 * Create Activity Stopwatch
		 * @param activityStopwatch
		 */
		public timeActivitystopwatchesPost (params: {  activityStopwatch: ActivityStopwatch; }, extraQueryParams?: any, extraFetchParams?: any ) : Promise<ActivityStopwatch> {
			const localVarPath = this.basePath + '/time/activitystopwatches';

			let queryParameters: any = assign({}, extraQueryParams);
			let headerParams: any = assign({}, this.defaultHeaders);
			headerParams['Content-Type'] = 'application/json';

			// verify required parameter 'activityStopwatch' is set
			if (params.activityStopwatch == null) {
				throw new Error('Missing required parameter activityStopwatch when calling timeActivitystopwatchesPost');
			}
			let fetchParams = {
				method: 'POST',
				headers: headerParams,
				body: JSON.stringify(params.activityStopwatch),

			};

			if (extraFetchParams) {
				fetchParams = assign(fetchParams, extraFetchParams);
			}

			let localVarPathWithQueryParameters = localVarPath + (localVarPath.indexOf('?') !== -1 ? '&' : '?') + querystring.stringify(queryParameters);

			return fetch(localVarPathWithQueryParameters, fetchParams).then((response) => {
				if (response.status >= 200 && response.status < 300) {
					return response.json();
				} else {
					let error = new Error(response.statusText);
					(error as any).response = response;
					throw error;
				}
			});
		}
	}
//}
//export namespace  {
	'use strict';

	export class ActivityTypesApi {
		protected basePath = 'https://api-na.myconnectwise.net/v4_6_release/apis/3.0';
		public defaultHeaders : any = {};

		constructor(basePath?: string) {
			if (basePath) {
				this.basePath = basePath;
			}
		}

		/**
		 *
		 * Get Activity Types Count
		 * @param conditions
		 */
		public salesActivitiesTypesCountGet (params: {  conditions?: string; }, extraQueryParams?: any, extraFetchParams?: any ) : Promise<Count> {
			const localVarPath = this.basePath + '/sales/activities/types/count';

			let queryParameters: any = assign({}, extraQueryParams);
			let headerParams: any = assign({}, this.defaultHeaders);
			if (params.conditions !== undefined) {
				queryParameters['conditions'] = params.conditions;
			}

			let fetchParams = {
				method: 'GET',
				headers: headerParams,

			};

			if (extraFetchParams) {
				fetchParams = assign(fetchParams, extraFetchParams);
			}

			let localVarPathWithQueryParameters = localVarPath + (localVarPath.indexOf('?') !== -1 ? '&' : '?') + querystring.stringify(queryParameters);

			return fetch(localVarPathWithQueryParameters, fetchParams).then((response) => {
				if (response.status >= 200 && response.status < 300) {
					return response.json();
				} else {
					let error = new Error(response.statusText);
					(error as any).response = response;
					throw error;
				}
			});
		}
		/**
		 *
		 * Get Activity Types
		 * @param conditions
		 * @param orderBy
		 * @param childconditions
		 * @param customfieldconditions
		 * @param page
		 * @param pageSize
		 */
		public salesActivitiesTypesGet (params: {  conditions?: string; orderBy?: string; childconditions?: string; customfieldconditions?: string; page?: number; pageSize?: number; }, extraQueryParams?: any, extraFetchParams?: any ) : Promise<Array<ActivityType>> {
			const localVarPath = this.basePath + '/sales/activities/types';

			let queryParameters: any = assign({}, extraQueryParams);
			let headerParams: any = assign({}, this.defaultHeaders);
			if (params.conditions !== undefined) {
				queryParameters['conditions'] = params.conditions;
			}

			if (params.orderBy !== undefined) {
				queryParameters['orderBy'] = params.orderBy;
			}

			if (params.childconditions !== undefined) {
				queryParameters['childconditions'] = params.childconditions;
			}

			if (params.customfieldconditions !== undefined) {
				queryParameters['customfieldconditions'] = params.customfieldconditions;
			}

			if (params.page !== undefined) {
				queryParameters['page'] = params.page;
			}

			if (params.pageSize !== undefined) {
				queryParameters['pageSize'] = params.pageSize;
			}

			let fetchParams = {
				method: 'GET',
				headers: headerParams,

			};

			if (extraFetchParams) {
				fetchParams = assign(fetchParams, extraFetchParams);
			}

			let localVarPathWithQueryParameters = localVarPath + (localVarPath.indexOf('?') !== -1 ? '&' : '?') + querystring.stringify(queryParameters);

			return fetch(localVarPathWithQueryParameters, fetchParams).then((response) => {
				if (response.status >= 200 && response.status < 300) {
					return response.json();
				} else {
					let error = new Error(response.statusText);
					(error as any).response = response;
					throw error;
				}
			});
		}
		/**
		 *
		 * Delete Activity Type By Id
		 * @param id
		 */
		public salesActivitiesTypesIdDelete (params: {  id: number; }, extraQueryParams?: any, extraFetchParams?: any ) : Promise<{}> {
			const localVarPath = this.basePath + '/sales/activities/types/{id}'
				.replace('{' + 'id' + '}', String(params.id));

			let queryParameters: any = assign({}, extraQueryParams);
			let headerParams: any = assign({}, this.defaultHeaders);
			// verify required parameter 'id' is set
			if (params.id == null) {
				throw new Error('Missing required parameter id when calling salesActivitiesTypesIdDelete');
			}
			let fetchParams = {
				method: 'DELETE',
				headers: headerParams,

			};

			if (extraFetchParams) {
				fetchParams = assign(fetchParams, extraFetchParams);
			}

			let localVarPathWithQueryParameters = localVarPath + (localVarPath.indexOf('?') !== -1 ? '&' : '?') + querystring.stringify(queryParameters);

			return fetch(localVarPathWithQueryParameters, fetchParams).then((response) => {
				if (response.status >= 200 && response.status < 300) {
					return response.json();
				} else {
					let error = new Error(response.statusText);
					(error as any).response = response;
					throw error;
				}
			});
		}
		/**
		 *
		 * Get Activity Type By Id
		 * @param id
		 */
		public salesActivitiesTypesIdGet (params: {  id: number; }, extraQueryParams?: any, extraFetchParams?: any ) : Promise<ActivityType> {
			const localVarPath = this.basePath + '/sales/activities/types/{id}'
				.replace('{' + 'id' + '}', String(params.id));

			let queryParameters: any = assign({}, extraQueryParams);
			let headerParams: any = assign({}, this.defaultHeaders);
			// verify required parameter 'id' is set
			if (params.id == null) {
				throw new Error('Missing required parameter id when calling salesActivitiesTypesIdGet');
			}
			let fetchParams = {
				method: 'GET',
				headers: headerParams,

			};

			if (extraFetchParams) {
				fetchParams = assign(fetchParams, extraFetchParams);
			}

			let localVarPathWithQueryParameters = localVarPath + (localVarPath.indexOf('?') !== -1 ? '&' : '?') + querystring.stringify(queryParameters);

			return fetch(localVarPathWithQueryParameters, fetchParams).then((response) => {
				if (response.status >= 200 && response.status < 300) {
					return response.json();
				} else {
					let error = new Error(response.statusText);
					(error as any).response = response;
					throw error;
				}
			});
		}
		/**
		 *
		 * Update Activity Type
		 * @param id
		 * @param operations
		 */
		public salesActivitiesTypesIdPatch (params: {  id: number; operations: Array<PatchOperation>; }, extraQueryParams?: any, extraFetchParams?: any ) : Promise<ActivityType> {
			const localVarPath = this.basePath + '/sales/activities/types/{id}'
				.replace('{' + 'id' + '}', String(params.id));

			let queryParameters: any = assign({}, extraQueryParams);
			let headerParams: any = assign({}, this.defaultHeaders);
			headerParams['Content-Type'] = 'application/json';

			// verify required parameter 'id' is set
			if (params.id == null) {
				throw new Error('Missing required parameter id when calling salesActivitiesTypesIdPatch');
			}
			// verify required parameter 'operations' is set
			if (params.operations == null) {
				throw new Error('Missing required parameter operations when calling salesActivitiesTypesIdPatch');
			}
			let fetchParams = {
				method: 'PATCH',
				headers: headerParams,
				body: JSON.stringify(params.operations),

			};

			if (extraFetchParams) {
				fetchParams = assign(fetchParams, extraFetchParams);
			}

			let localVarPathWithQueryParameters = localVarPath + (localVarPath.indexOf('?') !== -1 ? '&' : '?') + querystring.stringify(queryParameters);

			return fetch(localVarPathWithQueryParameters, fetchParams).then((response) => {
				if (response.status >= 200 && response.status < 300) {
					return response.json();
				} else {
					let error = new Error(response.statusText);
					(error as any).response = response;
					throw error;
				}
			});
		}
		/**
		 *
		 * Replace Activity Type
		 * @param id
		 * @param activityType
		 */
		public salesActivitiesTypesIdPut (params: {  id: number; activityType: ActivityType; }, extraQueryParams?: any, extraFetchParams?: any ) : Promise<ActivityType> {
			const localVarPath = this.basePath + '/sales/activities/types/{id}'
				.replace('{' + 'id' + '}', String(params.id));

			let queryParameters: any = assign({}, extraQueryParams);
			let headerParams: any = assign({}, this.defaultHeaders);
			headerParams['Content-Type'] = 'application/json';

			// verify required parameter 'id' is set
			if (params.id == null) {
				throw new Error('Missing required parameter id when calling salesActivitiesTypesIdPut');
			}
			// verify required parameter 'activityType' is set
			if (params.activityType == null) {
				throw new Error('Missing required parameter activityType when calling salesActivitiesTypesIdPut');
			}
			let fetchParams = {
				method: 'PUT',
				headers: headerParams,
				body: JSON.stringify(params.activityType),

			};

			if (extraFetchParams) {
				fetchParams = assign(fetchParams, extraFetchParams);
			}

			let localVarPathWithQueryParameters = localVarPath + (localVarPath.indexOf('?') !== -1 ? '&' : '?') + querystring.stringify(queryParameters);

			return fetch(localVarPathWithQueryParameters, fetchParams).then((response) => {
				if (response.status >= 200 && response.status < 300) {
					return response.json();
				} else {
					let error = new Error(response.statusText);
					(error as any).response = response;
					throw error;
				}
			});
		}
		/**
		 *
		 * Create Activity Type
		 * @param activityType
		 */
		public salesActivitiesTypesPost (params: {  activityType: ActivityType; }, extraQueryParams?: any, extraFetchParams?: any ) : Promise<ActivityType> {
			const localVarPath = this.basePath + '/sales/activities/types';

			let queryParameters: any = assign({}, extraQueryParams);
			let headerParams: any = assign({}, this.defaultHeaders);
			headerParams['Content-Type'] = 'application/json';

			// verify required parameter 'activityType' is set
			if (params.activityType == null) {
				throw new Error('Missing required parameter activityType when calling salesActivitiesTypesPost');
			}
			let fetchParams = {
				method: 'POST',
				headers: headerParams,
				body: JSON.stringify(params.activityType),

			};

			if (extraFetchParams) {
				fetchParams = assign(fetchParams, extraFetchParams);
			}

			let localVarPathWithQueryParameters = localVarPath + (localVarPath.indexOf('?') !== -1 ? '&' : '?') + querystring.stringify(queryParameters);

			return fetch(localVarPathWithQueryParameters, fetchParams).then((response) => {
				if (response.status >= 200 && response.status < 300) {
					return response.json();
				} else {
					let error = new Error(response.statusText);
					(error as any).response = response;
					throw error;
				}
			});
		}
	}
//}
//export namespace  {
	'use strict';

	export class AdjustmentDetailsApi {
		protected basePath = 'https://api-na.myconnectwise.net/v4_6_release/apis/3.0';
		public defaultHeaders : any = {};

		constructor(basePath?: string) {
			if (basePath) {
				this.basePath = basePath;
			}
		}

		/**
		 *
		 * Get Adjustment Detail Count
		 * @param id
		 * @param conditions
		 */
		public procurementAdjustmentsIdDetailsCountGet (params: {  id: number; conditions?: string; }, extraQueryParams?: any, extraFetchParams?: any ) : Promise<Count> {
			const localVarPath = this.basePath + '/procurement/adjustments/{id}/details/count'
				.replace('{' + 'id' + '}', String(params.id));

			let queryParameters: any = assign({}, extraQueryParams);
			let headerParams: any = assign({}, this.defaultHeaders);
			// verify required parameter 'id' is set
			if (params.id == null) {
				throw new Error('Missing required parameter id when calling procurementAdjustmentsIdDetailsCountGet');
			}
			if (params.conditions !== undefined) {
				queryParameters['conditions'] = params.conditions;
			}

			let fetchParams = {
				method: 'GET',
				headers: headerParams,

			};

			if (extraFetchParams) {
				fetchParams = assign(fetchParams, extraFetchParams);
			}

			let localVarPathWithQueryParameters = localVarPath + (localVarPath.indexOf('?') !== -1 ? '&' : '?') + querystring.stringify(queryParameters);

			return fetch(localVarPathWithQueryParameters, fetchParams).then((response) => {
				if (response.status >= 200 && response.status < 300) {
					return response.json();
				} else {
					let error = new Error(response.statusText);
					(error as any).response = response;
					throw error;
				}
			});
		}
		/**
		 *
		 * Delete Adjustment Detail By Id
		 * @param id
		 * @param detailId
		 */
		public procurementAdjustmentsIdDetailsDetailIdDelete (params: {  id: number; detailId: number; }, extraQueryParams?: any, extraFetchParams?: any ) : Promise<{}> {
			const localVarPath = this.basePath + '/procurement/adjustments/{id}/details/{detailId}'
				.replace('{' + 'id' + '}', String(params.id))
				.replace('{' + 'detailId' + '}', String(params.detailId));

			let queryParameters: any = assign({}, extraQueryParams);
			let headerParams: any = assign({}, this.defaultHeaders);
			// verify required parameter 'id' is set
			if (params.id == null) {
				throw new Error('Missing required parameter id when calling procurementAdjustmentsIdDetailsDetailIdDelete');
			}
			// verify required parameter 'detailId' is set
			if (params.detailId == null) {
				throw new Error('Missing required parameter detailId when calling procurementAdjustmentsIdDetailsDetailIdDelete');
			}
			let fetchParams = {
				method: 'DELETE',
				headers: headerParams,

			};

			if (extraFetchParams) {
				fetchParams = assign(fetchParams, extraFetchParams);
			}

			let localVarPathWithQueryParameters = localVarPath + (localVarPath.indexOf('?') !== -1 ? '&' : '?') + querystring.stringify(queryParameters);

			return fetch(localVarPathWithQueryParameters, fetchParams).then((response) => {
				if (response.status >= 200 && response.status < 300) {
					return response.json();
				} else {
					let error = new Error(response.statusText);
					(error as any).response = response;
					throw error;
				}
			});
		}
		/**
		 *
		 * Get Adjustment Detail By Id
		 * @param id
		 * @param detailId
		 */
		public procurementAdjustmentsIdDetailsDetailIdGet (params: {  id: number; detailId: number; }, extraQueryParams?: any, extraFetchParams?: any ) : Promise<AdjustmentDetail> {
			const localVarPath = this.basePath + '/procurement/adjustments/{id}/details/{detailId}'
				.replace('{' + 'id' + '}', String(params.id))
				.replace('{' + 'detailId' + '}', String(params.detailId));

			let queryParameters: any = assign({}, extraQueryParams);
			let headerParams: any = assign({}, this.defaultHeaders);
			// verify required parameter 'id' is set
			if (params.id == null) {
				throw new Error('Missing required parameter id when calling procurementAdjustmentsIdDetailsDetailIdGet');
			}
			// verify required parameter 'detailId' is set
			if (params.detailId == null) {
				throw new Error('Missing required parameter detailId when calling procurementAdjustmentsIdDetailsDetailIdGet');
			}
			let fetchParams = {
				method: 'GET',
				headers: headerParams,

			};

			if (extraFetchParams) {
				fetchParams = assign(fetchParams, extraFetchParams);
			}

			let localVarPathWithQueryParameters = localVarPath + (localVarPath.indexOf('?') !== -1 ? '&' : '?') + querystring.stringify(queryParameters);

			return fetch(localVarPathWithQueryParameters, fetchParams).then((response) => {
				if (response.status >= 200 && response.status < 300) {
					return response.json();
				} else {
					let error = new Error(response.statusText);
					(error as any).response = response;
					throw error;
				}
			});
		}
		/**
		 *
		 * Get Adjustment Detail
		 * @param id
		 * @param conditions
		 * @param orderBy
		 * @param childconditions
		 * @param customfieldconditions
		 * @param page
		 * @param pageSize
		 */
		public procurementAdjustmentsIdDetailsGet (params: {  id: number; conditions?: string; orderBy?: string; childconditions?: string; customfieldconditions?: string; page?: number; pageSize?: number; }, extraQueryParams?: any, extraFetchParams?: any ) : Promise<Array<AdjustmentDetail>> {
			const localVarPath = this.basePath + '/procurement/adjustments/{id}/details'
				.replace('{' + 'id' + '}', String(params.id));

			let queryParameters: any = assign({}, extraQueryParams);
			let headerParams: any = assign({}, this.defaultHeaders);
			// verify required parameter 'id' is set
			if (params.id == null) {
				throw new Error('Missing required parameter id when calling procurementAdjustmentsIdDetailsGet');
			}
			if (params.conditions !== undefined) {
				queryParameters['conditions'] = params.conditions;
			}

			if (params.orderBy !== undefined) {
				queryParameters['orderBy'] = params.orderBy;
			}

			if (params.childconditions !== undefined) {
				queryParameters['childconditions'] = params.childconditions;
			}

			if (params.customfieldconditions !== undefined) {
				queryParameters['customfieldconditions'] = params.customfieldconditions;
			}

			if (params.page !== undefined) {
				queryParameters['page'] = params.page;
			}

			if (params.pageSize !== undefined) {
				queryParameters['pageSize'] = params.pageSize;
			}

			let fetchParams = {
				method: 'GET',
				headers: headerParams,

			};

			if (extraFetchParams) {
				fetchParams = assign(fetchParams, extraFetchParams);
			}

			let localVarPathWithQueryParameters = localVarPath + (localVarPath.indexOf('?') !== -1 ? '&' : '?') + querystring.stringify(queryParameters);

			return fetch(localVarPathWithQueryParameters, fetchParams).then((response) => {
				if (response.status >= 200 && response.status < 300) {
					return response.json();
				} else {
					let error = new Error(response.statusText);
					(error as any).response = response;
					throw error;
				}
			});
		}
		/**
		 *
		 * Create Adjustment Detail
		 * @param id
		 * @param adjustmentDetail
		 */
		public procurementAdjustmentsIdDetailsPost (params: {  id: number; adjustmentDetail: AdjustmentDetail; }, extraQueryParams?: any, extraFetchParams?: any ) : Promise<AdjustmentDetail> {
			const localVarPath = this.basePath + '/procurement/adjustments/{id}/details'
				.replace('{' + 'id' + '}', String(params.id));

			let queryParameters: any = assign({}, extraQueryParams);
			let headerParams: any = assign({}, this.defaultHeaders);
			headerParams['Content-Type'] = 'application/json';

			// verify required parameter 'id' is set
			if (params.id == null) {
				throw new Error('Missing required parameter id when calling procurementAdjustmentsIdDetailsPost');
			}
			// verify required parameter 'adjustmentDetail' is set
			if (params.adjustmentDetail == null) {
				throw new Error('Missing required parameter adjustmentDetail when calling procurementAdjustmentsIdDetailsPost');
			}
			let fetchParams = {
				method: 'POST',
				headers: headerParams,
				body: JSON.stringify(params.adjustmentDetail),

			};

			if (extraFetchParams) {
				fetchParams = assign(fetchParams, extraFetchParams);
			}

			let localVarPathWithQueryParameters = localVarPath + (localVarPath.indexOf('?') !== -1 ? '&' : '?') + querystring.stringify(queryParameters);

			return fetch(localVarPathWithQueryParameters, fetchParams).then((response) => {
				if (response.status >= 200 && response.status < 300) {
					return response.json();
				} else {
					let error = new Error(response.statusText);
					(error as any).response = response;
					throw error;
				}
			});
		}
	}
//}
//export namespace  {
	'use strict';

	export class AdjustmentTypesApi {
		protected basePath = 'https://api-na.myconnectwise.net/v4_6_release/apis/3.0';
		public defaultHeaders : any = {};

		constructor(basePath?: string) {
			if (basePath) {
				this.basePath = basePath;
			}
		}

		/**
		 *
		 * Get Adjustment Types Count
		 * @param conditions
		 */
		public procurementAdjustmentsTypesCountGet (params: {  conditions?: string; }, extraQueryParams?: any, extraFetchParams?: any ) : Promise<Count> {
			const localVarPath = this.basePath + '/procurement/adjustments/types/count';

			let queryParameters: any = assign({}, extraQueryParams);
			let headerParams: any = assign({}, this.defaultHeaders);
			if (params.conditions !== undefined) {
				queryParameters['conditions'] = params.conditions;
			}

			let fetchParams = {
				method: 'GET',
				headers: headerParams,

			};

			if (extraFetchParams) {
				fetchParams = assign(fetchParams, extraFetchParams);
			}

			let localVarPathWithQueryParameters = localVarPath + (localVarPath.indexOf('?') !== -1 ? '&' : '?') + querystring.stringify(queryParameters);

			return fetch(localVarPathWithQueryParameters, fetchParams).then((response) => {
				if (response.status >= 200 && response.status < 300) {
					return response.json();
				} else {
					let error = new Error(response.statusText);
					(error as any).response = response;
					throw error;
				}
			});
		}
		/**
		 *
		 * Get Adjustment Types
		 * @param conditions
		 * @param orderBy
		 * @param childconditions
		 * @param customfieldconditions
		 * @param page
		 * @param pageSize
		 */
		public procurementAdjustmentsTypesGet (params: {  conditions?: string; orderBy?: string; childconditions?: string; customfieldconditions?: string; page?: number; pageSize?: number; }, extraQueryParams?: any, extraFetchParams?: any ) : Promise<Array<AdjustmentType>> {
			const localVarPath = this.basePath + '/procurement/adjustments/types';

			let queryParameters: any = assign({}, extraQueryParams);
			let headerParams: any = assign({}, this.defaultHeaders);
			if (params.conditions !== undefined) {
				queryParameters['conditions'] = params.conditions;
			}

			if (params.orderBy !== undefined) {
				queryParameters['orderBy'] = params.orderBy;
			}

			if (params.childconditions !== undefined) {
				queryParameters['childconditions'] = params.childconditions;
			}

			if (params.customfieldconditions !== undefined) {
				queryParameters['customfieldconditions'] = params.customfieldconditions;
			}

			if (params.page !== undefined) {
				queryParameters['page'] = params.page;
			}

			if (params.pageSize !== undefined) {
				queryParameters['pageSize'] = params.pageSize;
			}

			let fetchParams = {
				method: 'GET',
				headers: headerParams,

			};

			if (extraFetchParams) {
				fetchParams = assign(fetchParams, extraFetchParams);
			}

			let localVarPathWithQueryParameters = localVarPath + (localVarPath.indexOf('?') !== -1 ? '&' : '?') + querystring.stringify(queryParameters);

			return fetch(localVarPathWithQueryParameters, fetchParams).then((response) => {
				if (response.status >= 200 && response.status < 300) {
					return response.json();
				} else {
					let error = new Error(response.statusText);
					(error as any).response = response;
					throw error;
				}
			});
		}
		/**
		 *
		 * Delete Adjustment Types By Id
		 * @param id
		 */
		public procurementAdjustmentsTypesIdDelete (params: {  id: number; }, extraQueryParams?: any, extraFetchParams?: any ) : Promise<{}> {
			const localVarPath = this.basePath + '/procurement/adjustments/types/{id}'
				.replace('{' + 'id' + '}', String(params.id));

			let queryParameters: any = assign({}, extraQueryParams);
			let headerParams: any = assign({}, this.defaultHeaders);
			// verify required parameter 'id' is set
			if (params.id == null) {
				throw new Error('Missing required parameter id when calling procurementAdjustmentsTypesIdDelete');
			}
			let fetchParams = {
				method: 'DELETE',
				headers: headerParams,

			};

			if (extraFetchParams) {
				fetchParams = assign(fetchParams, extraFetchParams);
			}

			let localVarPathWithQueryParameters = localVarPath + (localVarPath.indexOf('?') !== -1 ? '&' : '?') + querystring.stringify(queryParameters);

			return fetch(localVarPathWithQueryParameters, fetchParams).then((response) => {
				if (response.status >= 200 && response.status < 300) {
					return response.json();
				} else {
					let error = new Error(response.statusText);
					(error as any).response = response;
					throw error;
				}
			});
		}
		/**
		 *
		 * Get Adjustment Types By Id
		 * @param id
		 */
		public procurementAdjustmentsTypesIdGet (params: {  id: number; }, extraQueryParams?: any, extraFetchParams?: any ) : Promise<AdjustmentType> {
			const localVarPath = this.basePath + '/procurement/adjustments/types/{id}'
				.replace('{' + 'id' + '}', String(params.id));

			let queryParameters: any = assign({}, extraQueryParams);
			let headerParams: any = assign({}, this.defaultHeaders);
			// verify required parameter 'id' is set
			if (params.id == null) {
				throw new Error('Missing required parameter id when calling procurementAdjustmentsTypesIdGet');
			}
			let fetchParams = {
				method: 'GET',
				headers: headerParams,

			};

			if (extraFetchParams) {
				fetchParams = assign(fetchParams, extraFetchParams);
			}

			let localVarPathWithQueryParameters = localVarPath + (localVarPath.indexOf('?') !== -1 ? '&' : '?') + querystring.stringify(queryParameters);

			return fetch(localVarPathWithQueryParameters, fetchParams).then((response) => {
				if (response.status >= 200 && response.status < 300) {
					return response.json();
				} else {
					let error = new Error(response.statusText);
					(error as any).response = response;
					throw error;
				}
			});
		}
		/**
		 *
		 * Update Adjustment Types
		 * @param id
		 * @param operations
		 */
		public procurementAdjustmentsTypesIdPatch (params: {  id: number; operations: Array<PatchOperation>; }, extraQueryParams?: any, extraFetchParams?: any ) : Promise<AdjustmentType> {
			const localVarPath = this.basePath + '/procurement/adjustments/types/{id}'
				.replace('{' + 'id' + '}', String(params.id));

			let queryParameters: any = assign({}, extraQueryParams);
			let headerParams: any = assign({}, this.defaultHeaders);
			headerParams['Content-Type'] = 'application/json';

			// verify required parameter 'id' is set
			if (params.id == null) {
				throw new Error('Missing required parameter id when calling procurementAdjustmentsTypesIdPatch');
			}
			// verify required parameter 'operations' is set
			if (params.operations == null) {
				throw new Error('Missing required parameter operations when calling procurementAdjustmentsTypesIdPatch');
			}
			let fetchParams = {
				method: 'PATCH',
				headers: headerParams,
				body: JSON.stringify(params.operations),

			};

			if (extraFetchParams) {
				fetchParams = assign(fetchParams, extraFetchParams);
			}

			let localVarPathWithQueryParameters = localVarPath + (localVarPath.indexOf('?') !== -1 ? '&' : '?') + querystring.stringify(queryParameters);

			return fetch(localVarPathWithQueryParameters, fetchParams).then((response) => {
				if (response.status >= 200 && response.status < 300) {
					return response.json();
				} else {
					let error = new Error(response.statusText);
					(error as any).response = response;
					throw error;
				}
			});
		}
		/**
		 *
		 * Replace Adjustment Types
		 * @param id
		 * @param adjustmentTypes
		 */
		public procurementAdjustmentsTypesIdPut (params: {  id: number; adjustmentTypes: AdjustmentType; }, extraQueryParams?: any, extraFetchParams?: any ) : Promise<AdjustmentType> {
			const localVarPath = this.basePath + '/procurement/adjustments/types/{id}'
				.replace('{' + 'id' + '}', String(params.id));

			let queryParameters: any = assign({}, extraQueryParams);
			let headerParams: any = assign({}, this.defaultHeaders);
			headerParams['Content-Type'] = 'application/json';

			// verify required parameter 'id' is set
			if (params.id == null) {
				throw new Error('Missing required parameter id when calling procurementAdjustmentsTypesIdPut');
			}
			// verify required parameter 'adjustmentTypes' is set
			if (params.adjustmentTypes == null) {
				throw new Error('Missing required parameter adjustmentTypes when calling procurementAdjustmentsTypesIdPut');
			}
			let fetchParams = {
				method: 'PUT',
				headers: headerParams,
				body: JSON.stringify(params.adjustmentTypes),

			};

			if (extraFetchParams) {
				fetchParams = assign(fetchParams, extraFetchParams);
			}

			let localVarPathWithQueryParameters = localVarPath + (localVarPath.indexOf('?') !== -1 ? '&' : '?') + querystring.stringify(queryParameters);

			return fetch(localVarPathWithQueryParameters, fetchParams).then((response) => {
				if (response.status >= 200 && response.status < 300) {
					return response.json();
				} else {
					let error = new Error(response.statusText);
					(error as any).response = response;
					throw error;
				}
			});
		}
		/**
		 *
		 * Create Adjustment Types
		 * @param adjustmentTypes
		 */
		public procurementAdjustmentsTypesPost (params: {  adjustmentTypes: AdjustmentType; }, extraQueryParams?: any, extraFetchParams?: any ) : Promise<AdjustmentType> {
			const localVarPath = this.basePath + '/procurement/adjustments/types';

			let queryParameters: any = assign({}, extraQueryParams);
			let headerParams: any = assign({}, this.defaultHeaders);
			headerParams['Content-Type'] = 'application/json';

			// verify required parameter 'adjustmentTypes' is set
			if (params.adjustmentTypes == null) {
				throw new Error('Missing required parameter adjustmentTypes when calling procurementAdjustmentsTypesPost');
			}
			let fetchParams = {
				method: 'POST',
				headers: headerParams,
				body: JSON.stringify(params.adjustmentTypes),

			};

			if (extraFetchParams) {
				fetchParams = assign(fetchParams, extraFetchParams);
			}

			let localVarPathWithQueryParameters = localVarPath + (localVarPath.indexOf('?') !== -1 ? '&' : '?') + querystring.stringify(queryParameters);

			return fetch(localVarPathWithQueryParameters, fetchParams).then((response) => {
				if (response.status >= 200 && response.status < 300) {
					return response.json();
				} else {
					let error = new Error(response.statusText);
					(error as any).response = response;
					throw error;
				}
			});
		}
	}
//}
//export namespace  {
	'use strict';

	export class AdjustmentsApi {
		protected basePath = 'https://api-na.myconnectwise.net/v4_6_release/apis/3.0';
		public defaultHeaders : any = {};

		constructor(basePath?: string) {
			if (basePath) {
				this.basePath = basePath;
			}
		}

		/**
		 *
		 * Get Adjustment Count
		 * @param conditions
		 */
		public procurementAdjustmentsCountGet (params: {  conditions?: string; }, extraQueryParams?: any, extraFetchParams?: any ) : Promise<Count> {
			const localVarPath = this.basePath + '/procurement/adjustments/count';

			let queryParameters: any = assign({}, extraQueryParams);
			let headerParams: any = assign({}, this.defaultHeaders);
			if (params.conditions !== undefined) {
				queryParameters['conditions'] = params.conditions;
			}

			let fetchParams = {
				method: 'GET',
				headers: headerParams,

			};

			if (extraFetchParams) {
				fetchParams = assign(fetchParams, extraFetchParams);
			}

			let localVarPathWithQueryParameters = localVarPath + (localVarPath.indexOf('?') !== -1 ? '&' : '?') + querystring.stringify(queryParameters);

			return fetch(localVarPathWithQueryParameters, fetchParams).then((response) => {
				if (response.status >= 200 && response.status < 300) {
					return response.json();
				} else {
					let error = new Error(response.statusText);
					(error as any).response = response;
					throw error;
				}
			});
		}
		/**
		 *
		 * Get Adjustment
		 * @param conditions
		 * @param orderBy
		 * @param childconditions
		 * @param customfieldconditions
		 * @param page
		 * @param pageSize
		 */
		public procurementAdjustmentsGet (params: {  conditions?: string; orderBy?: string; childconditions?: string; customfieldconditions?: string; page?: number; pageSize?: number; }, extraQueryParams?: any, extraFetchParams?: any ) : Promise<Array<Adjustment>> {
			const localVarPath = this.basePath + '/procurement/adjustments';

			let queryParameters: any = assign({}, extraQueryParams);
			let headerParams: any = assign({}, this.defaultHeaders);
			if (params.conditions !== undefined) {
				queryParameters['conditions'] = params.conditions;
			}

			if (params.orderBy !== undefined) {
				queryParameters['orderBy'] = params.orderBy;
			}

			if (params.childconditions !== undefined) {
				queryParameters['childconditions'] = params.childconditions;
			}

			if (params.customfieldconditions !== undefined) {
				queryParameters['customfieldconditions'] = params.customfieldconditions;
			}

			if (params.page !== undefined) {
				queryParameters['page'] = params.page;
			}

			if (params.pageSize !== undefined) {
				queryParameters['pageSize'] = params.pageSize;
			}

			let fetchParams = {
				method: 'GET',
				headers: headerParams,

			};

			if (extraFetchParams) {
				fetchParams = assign(fetchParams, extraFetchParams);
			}

			let localVarPathWithQueryParameters = localVarPath + (localVarPath.indexOf('?') !== -1 ? '&' : '?') + querystring.stringify(queryParameters);

			return fetch(localVarPathWithQueryParameters, fetchParams).then((response) => {
				if (response.status >= 200 && response.status < 300) {
					return response.json();
				} else {
					let error = new Error(response.statusText);
					(error as any).response = response;
					throw error;
				}
			});
		}
		/**
		 *
		 * Delete Adjustment By Id
		 * @param id
		 */
		public procurementAdjustmentsIdDelete (params: {  id: number; }, extraQueryParams?: any, extraFetchParams?: any ) : Promise<{}> {
			const localVarPath = this.basePath + '/procurement/adjustments/{id}'
				.replace('{' + 'id' + '}', String(params.id));

			let queryParameters: any = assign({}, extraQueryParams);
			let headerParams: any = assign({}, this.defaultHeaders);
			// verify required parameter 'id' is set
			if (params.id == null) {
				throw new Error('Missing required parameter id when calling procurementAdjustmentsIdDelete');
			}
			let fetchParams = {
				method: 'DELETE',
				headers: headerParams,

			};

			if (extraFetchParams) {
				fetchParams = assign(fetchParams, extraFetchParams);
			}

			let localVarPathWithQueryParameters = localVarPath + (localVarPath.indexOf('?') !== -1 ? '&' : '?') + querystring.stringify(queryParameters);

			return fetch(localVarPathWithQueryParameters, fetchParams).then((response) => {
				if (response.status >= 200 && response.status < 300) {
					return response.json();
				} else {
					let error = new Error(response.statusText);
					(error as any).response = response;
					throw error;
				}
			});
		}
		/**
		 *
		 * Get Adjustment By Id
		 * @param id
		 */
		public procurementAdjustmentsIdGet (params: {  id: number; }, extraQueryParams?: any, extraFetchParams?: any ) : Promise<Adjustment> {
			const localVarPath = this.basePath + '/procurement/adjustments/{id}'
				.replace('{' + 'id' + '}', String(params.id));

			let queryParameters: any = assign({}, extraQueryParams);
			let headerParams: any = assign({}, this.defaultHeaders);
			// verify required parameter 'id' is set
			if (params.id == null) {
				throw new Error('Missing required parameter id when calling procurementAdjustmentsIdGet');
			}
			let fetchParams = {
				method: 'GET',
				headers: headerParams,

			};

			if (extraFetchParams) {
				fetchParams = assign(fetchParams, extraFetchParams);
			}

			let localVarPathWithQueryParameters = localVarPath + (localVarPath.indexOf('?') !== -1 ? '&' : '?') + querystring.stringify(queryParameters);

			return fetch(localVarPathWithQueryParameters, fetchParams).then((response) => {
				if (response.status >= 200 && response.status < 300) {
					return response.json();
				} else {
					let error = new Error(response.statusText);
					(error as any).response = response;
					throw error;
				}
			});
		}
		/**
		 *
		 * Update Adjustment
		 * @param id
		 * @param operations
		 */
		public procurementAdjustmentsIdPatch (params: {  id: number; operations: Array<PatchOperation>; }, extraQueryParams?: any, extraFetchParams?: any ) : Promise<Adjustment> {
			const localVarPath = this.basePath + '/procurement/adjustments/{id}'
				.replace('{' + 'id' + '}', String(params.id));

			let queryParameters: any = assign({}, extraQueryParams);
			let headerParams: any = assign({}, this.defaultHeaders);
			headerParams['Content-Type'] = 'application/json';

			// verify required parameter 'id' is set
			if (params.id == null) {
				throw new Error('Missing required parameter id when calling procurementAdjustmentsIdPatch');
			}
			// verify required parameter 'operations' is set
			if (params.operations == null) {
				throw new Error('Missing required parameter operations when calling procurementAdjustmentsIdPatch');
			}
			let fetchParams = {
				method: 'PATCH',
				headers: headerParams,
				body: JSON.stringify(params.operations),

			};

			if (extraFetchParams) {
				fetchParams = assign(fetchParams, extraFetchParams);
			}

			let localVarPathWithQueryParameters = localVarPath + (localVarPath.indexOf('?') !== -1 ? '&' : '?') + querystring.stringify(queryParameters);

			return fetch(localVarPathWithQueryParameters, fetchParams).then((response) => {
				if (response.status >= 200 && response.status < 300) {
					return response.json();
				} else {
					let error = new Error(response.statusText);
					(error as any).response = response;
					throw error;
				}
			});
		}
		/**
		 *
		 * Replace Adjustment
		 * @param id
		 * @param adjustment
		 */
		public procurementAdjustmentsIdPut (params: {  id: number; adjustment: Adjustment; }, extraQueryParams?: any, extraFetchParams?: any ) : Promise<Adjustment> {
			const localVarPath = this.basePath + '/procurement/adjustments/{id}'
				.replace('{' + 'id' + '}', String(params.id));

			let queryParameters: any = assign({}, extraQueryParams);
			let headerParams: any = assign({}, this.defaultHeaders);
			headerParams['Content-Type'] = 'application/json';

			// verify required parameter 'id' is set
			if (params.id == null) {
				throw new Error('Missing required parameter id when calling procurementAdjustmentsIdPut');
			}
			// verify required parameter 'adjustment' is set
			if (params.adjustment == null) {
				throw new Error('Missing required parameter adjustment when calling procurementAdjustmentsIdPut');
			}
			let fetchParams = {
				method: 'PUT',
				headers: headerParams,
				body: JSON.stringify(params.adjustment),

			};

			if (extraFetchParams) {
				fetchParams = assign(fetchParams, extraFetchParams);
			}

			let localVarPathWithQueryParameters = localVarPath + (localVarPath.indexOf('?') !== -1 ? '&' : '?') + querystring.stringify(queryParameters);

			return fetch(localVarPathWithQueryParameters, fetchParams).then((response) => {
				if (response.status >= 200 && response.status < 300) {
					return response.json();
				} else {
					let error = new Error(response.statusText);
					(error as any).response = response;
					throw error;
				}
			});
		}
		/**
		 *
		 * Create Adjustment
		 * @param adjustment
		 */
		public procurementAdjustmentsPost (params: {  adjustment: Adjustment; }, extraQueryParams?: any, extraFetchParams?: any ) : Promise<Adjustment> {
			const localVarPath = this.basePath + '/procurement/adjustments';

			let queryParameters: any = assign({}, extraQueryParams);
			let headerParams: any = assign({}, this.defaultHeaders);
			headerParams['Content-Type'] = 'application/json';

			// verify required parameter 'adjustment' is set
			if (params.adjustment == null) {
				throw new Error('Missing required parameter adjustment when calling procurementAdjustmentsPost');
			}
			let fetchParams = {
				method: 'POST',
				headers: headerParams,
				body: JSON.stringify(params.adjustment),

			};

			if (extraFetchParams) {
				fetchParams = assign(fetchParams, extraFetchParams);
			}

			let localVarPathWithQueryParameters = localVarPath + (localVarPath.indexOf('?') !== -1 ? '&' : '?') + querystring.stringify(queryParameters);

			return fetch(localVarPathWithQueryParameters, fetchParams).then((response) => {
				if (response.status >= 200 && response.status < 300) {
					return response.json();
				} else {
					let error = new Error(response.statusText);
					(error as any).response = response;
					throw error;
				}
			});
		}
	}
//}
//export namespace  {
	'use strict';

	export class AgreementAdditionsApi {
		protected basePath = 'https://api-na.myconnectwise.net/v4_6_release/apis/3.0';
		public defaultHeaders : any = {};

		constructor(basePath?: string) {
			if (basePath) {
				this.basePath = basePath;
			}
		}

		/**
		 *
		 * Delete Addition By Id
		 * @param id
		 * @param additionId
		 */
		public financeAgreementsIdAdditionsAdditionIdDelete (params: {  id: number; additionId: number; }, extraQueryParams?: any, extraFetchParams?: any ) : Promise<{}> {
			const localVarPath = this.basePath + '/finance/agreements/{id}/additions/{additionId}'
				.replace('{' + 'id' + '}', String(params.id))
				.replace('{' + 'additionId' + '}', String(params.additionId));

			let queryParameters: any = assign({}, extraQueryParams);
			let headerParams: any = assign({}, this.defaultHeaders);
			// verify required parameter 'id' is set
			if (params.id == null) {
				throw new Error('Missing required parameter id when calling financeAgreementsIdAdditionsAdditionIdDelete');
			}
			// verify required parameter 'additionId' is set
			if (params.additionId == null) {
				throw new Error('Missing required parameter additionId when calling financeAgreementsIdAdditionsAdditionIdDelete');
			}
			let fetchParams = {
				method: 'DELETE',
				headers: headerParams,

			};

			if (extraFetchParams) {
				fetchParams = assign(fetchParams, extraFetchParams);
			}

			let localVarPathWithQueryParameters = localVarPath + (localVarPath.indexOf('?') !== -1 ? '&' : '?') + querystring.stringify(queryParameters);

			return fetch(localVarPathWithQueryParameters, fetchParams).then((response) => {
				if (response.status >= 200 && response.status < 300) {
					return response.json();
				} else {
					let error = new Error(response.statusText);
					(error as any).response = response;
					throw error;
				}
			});
		}
		/**
		 *
		 * Get Addition By Id
		 * @param id
		 * @param additionId
		 */
		public financeAgreementsIdAdditionsAdditionIdGet (params: {  id: number; additionId: number; }, extraQueryParams?: any, extraFetchParams?: any ) : Promise<Addition> {
			const localVarPath = this.basePath + '/finance/agreements/{id}/additions/{additionId}'
				.replace('{' + 'id' + '}', String(params.id))
				.replace('{' + 'additionId' + '}', String(params.additionId));

			let queryParameters: any = assign({}, extraQueryParams);
			let headerParams: any = assign({}, this.defaultHeaders);
			// verify required parameter 'id' is set
			if (params.id == null) {
				throw new Error('Missing required parameter id when calling financeAgreementsIdAdditionsAdditionIdGet');
			}
			// verify required parameter 'additionId' is set
			if (params.additionId == null) {
				throw new Error('Missing required parameter additionId when calling financeAgreementsIdAdditionsAdditionIdGet');
			}
			let fetchParams = {
				method: 'GET',
				headers: headerParams,

			};

			if (extraFetchParams) {
				fetchParams = assign(fetchParams, extraFetchParams);
			}

			let localVarPathWithQueryParameters = localVarPath + (localVarPath.indexOf('?') !== -1 ? '&' : '?') + querystring.stringify(queryParameters);

			return fetch(localVarPathWithQueryParameters, fetchParams).then((response) => {
				if (response.status >= 200 && response.status < 300) {
					return response.json();
				} else {
					let error = new Error(response.statusText);
					(error as any).response = response;
					throw error;
				}
			});
		}
		/**
		 *
		 * Update Addition
		 * @param id
		 * @param additionId
		 * @param operations
		 */
		public financeAgreementsIdAdditionsAdditionIdPatch (params: {  id: number; additionId: number; operations: Array<PatchOperation>; }, extraQueryParams?: any, extraFetchParams?: any ) : Promise<Addition> {
			const localVarPath = this.basePath + '/finance/agreements/{id}/additions/{additionId}'
				.replace('{' + 'id' + '}', String(params.id))
				.replace('{' + 'additionId' + '}', String(params.additionId));

			let queryParameters: any = assign({}, extraQueryParams);
			let headerParams: any = assign({}, this.defaultHeaders);
			headerParams['Content-Type'] = 'application/json';

			// verify required parameter 'id' is set
			if (params.id == null) {
				throw new Error('Missing required parameter id when calling financeAgreementsIdAdditionsAdditionIdPatch');
			}
			// verify required parameter 'additionId' is set
			if (params.additionId == null) {
				throw new Error('Missing required parameter additionId when calling financeAgreementsIdAdditionsAdditionIdPatch');
			}
			// verify required parameter 'operations' is set
			if (params.operations == null) {
				throw new Error('Missing required parameter operations when calling financeAgreementsIdAdditionsAdditionIdPatch');
			}
			let fetchParams = {
				method: 'PATCH',
				headers: headerParams,
				body: JSON.stringify(params.operations),

			};

			if (extraFetchParams) {
				fetchParams = assign(fetchParams, extraFetchParams);
			}

			let localVarPathWithQueryParameters = localVarPath + (localVarPath.indexOf('?') !== -1 ? '&' : '?') + querystring.stringify(queryParameters);

			return fetch(localVarPathWithQueryParameters, fetchParams).then((response) => {
				if (response.status >= 200 && response.status < 300) {
					return response.json();
				} else {
					let error = new Error(response.statusText);
					(error as any).response = response;
					throw error;
				}
			});
		}
		/**
		 *
		 * Replace Addition
		 * @param id
		 * @param additionId
		 * @param addition
		 */
		public financeAgreementsIdAdditionsAdditionIdPut (params: {  id: number; additionId: number; addition: Addition; }, extraQueryParams?: any, extraFetchParams?: any ) : Promise<Addition> {
			const localVarPath = this.basePath + '/finance/agreements/{id}/additions/{additionId}'
				.replace('{' + 'id' + '}', String(params.id))
				.replace('{' + 'additionId' + '}', String(params.additionId));

			let queryParameters: any = assign({}, extraQueryParams);
			let headerParams: any = assign({}, this.defaultHeaders);
			headerParams['Content-Type'] = 'application/json';

			// verify required parameter 'id' is set
			if (params.id == null) {
				throw new Error('Missing required parameter id when calling financeAgreementsIdAdditionsAdditionIdPut');
			}
			// verify required parameter 'additionId' is set
			if (params.additionId == null) {
				throw new Error('Missing required parameter additionId when calling financeAgreementsIdAdditionsAdditionIdPut');
			}
			// verify required parameter 'addition' is set
			if (params.addition == null) {
				throw new Error('Missing required parameter addition when calling financeAgreementsIdAdditionsAdditionIdPut');
			}
			let fetchParams = {
				method: 'PUT',
				headers: headerParams,
				body: JSON.stringify(params.addition),

			};

			if (extraFetchParams) {
				fetchParams = assign(fetchParams, extraFetchParams);
			}

			let localVarPathWithQueryParameters = localVarPath + (localVarPath.indexOf('?') !== -1 ? '&' : '?') + querystring.stringify(queryParameters);

			return fetch(localVarPathWithQueryParameters, fetchParams).then((response) => {
				if (response.status >= 200 && response.status < 300) {
					return response.json();
				} else {
					let error = new Error(response.statusText);
					(error as any).response = response;
					throw error;
				}
			});
		}
		/**
		 *
		 * Get Additions Count
		 * @param id
		 * @param conditions
		 * @param customFieldConditions
		 */
		public financeAgreementsIdAdditionsCountGet (params: {  id: number; conditions?: string; customFieldConditions?: string; }, extraQueryParams?: any, extraFetchParams?: any ) : Promise<Count> {
			const localVarPath = this.basePath + '/finance/agreements/{id}/additions/count'
				.replace('{' + 'id' + '}', String(params.id));

			let queryParameters: any = assign({}, extraQueryParams);
			let headerParams: any = assign({}, this.defaultHeaders);
			// verify required parameter 'id' is set
			if (params.id == null) {
				throw new Error('Missing required parameter id when calling financeAgreementsIdAdditionsCountGet');
			}
			if (params.conditions !== undefined) {
				queryParameters['conditions'] = params.conditions;
			}

			if (params.customFieldConditions !== undefined) {
				queryParameters['customFieldConditions'] = params.customFieldConditions;
			}

			let fetchParams = {
				method: 'GET',
				headers: headerParams,

			};

			if (extraFetchParams) {
				fetchParams = assign(fetchParams, extraFetchParams);
			}

			let localVarPathWithQueryParameters = localVarPath + (localVarPath.indexOf('?') !== -1 ? '&' : '?') + querystring.stringify(queryParameters);

			return fetch(localVarPathWithQueryParameters, fetchParams).then((response) => {
				if (response.status >= 200 && response.status < 300) {
					return response.json();
				} else {
					let error = new Error(response.statusText);
					(error as any).response = response;
					throw error;
				}
			});
		}
		/**
		 *
		 * Get Additions
		 * @param id
		 * @param conditions
		 * @param orderBy
		 * @param childconditions
		 * @param customfieldconditions
		 * @param page
		 * @param pageSize
		 */
		public financeAgreementsIdAdditionsGet (params: {  id: number; conditions?: string; orderBy?: string; childconditions?: string; customfieldconditions?: string; page?: number; pageSize?: number; }, extraQueryParams?: any, extraFetchParams?: any ) : Promise<Array<Addition>> {
			const localVarPath = this.basePath + '/finance/agreements/{id}/additions'
				.replace('{' + 'id' + '}', String(params.id));

			let queryParameters: any = assign({}, extraQueryParams);
			let headerParams: any = assign({}, this.defaultHeaders);
			// verify required parameter 'id' is set
			if (params.id == null) {
				throw new Error('Missing required parameter id when calling financeAgreementsIdAdditionsGet');
			}
			if (params.conditions !== undefined) {
				queryParameters['conditions'] = params.conditions;
			}

			if (params.orderBy !== undefined) {
				queryParameters['orderBy'] = params.orderBy;
			}

			if (params.childconditions !== undefined) {
				queryParameters['childconditions'] = params.childconditions;
			}

			if (params.customfieldconditions !== undefined) {
				queryParameters['customfieldconditions'] = params.customfieldconditions;
			}

			if (params.page !== undefined) {
				queryParameters['page'] = params.page;
			}

			if (params.pageSize !== undefined) {
				queryParameters['pageSize'] = params.pageSize;
			}

			let fetchParams = {
				method: 'GET',
				headers: headerParams,

			};

			if (extraFetchParams) {
				fetchParams = assign(fetchParams, extraFetchParams);
			}

			let localVarPathWithQueryParameters = localVarPath + (localVarPath.indexOf('?') !== -1 ? '&' : '?') + querystring.stringify(queryParameters);

			return fetch(localVarPathWithQueryParameters, fetchParams).then((response) => {
				if (response.status >= 200 && response.status < 300) {
					return response.json();
				} else {
					let error = new Error(response.statusText);
					(error as any).response = response;
					throw error;
				}
			});
		}
		/**
		 *
		 * Create Addition
		 * @param id
		 * @param addition
		 */
		public financeAgreementsIdAdditionsPost (params: {  id: number; addition: Addition; }, extraQueryParams?: any, extraFetchParams?: any ) : Promise<Addition> {
			const localVarPath = this.basePath + '/finance/agreements/{id}/additions'
				.replace('{' + 'id' + '}', String(params.id));

			let queryParameters: any = assign({}, extraQueryParams);
			let headerParams: any = assign({}, this.defaultHeaders);
			headerParams['Content-Type'] = 'application/json';

			// verify required parameter 'id' is set
			if (params.id == null) {
				throw new Error('Missing required parameter id when calling financeAgreementsIdAdditionsPost');
			}
			// verify required parameter 'addition' is set
			if (params.addition == null) {
				throw new Error('Missing required parameter addition when calling financeAgreementsIdAdditionsPost');
			}
			let fetchParams = {
				method: 'POST',
				headers: headerParams,
				body: JSON.stringify(params.addition),

			};

			if (extraFetchParams) {
				fetchParams = assign(fetchParams, extraFetchParams);
			}

			let localVarPathWithQueryParameters = localVarPath + (localVarPath.indexOf('?') !== -1 ? '&' : '?') + querystring.stringify(queryParameters);

			return fetch(localVarPathWithQueryParameters, fetchParams).then((response) => {
				if (response.status >= 200 && response.status < 300) {
					return response.json();
				} else {
					let error = new Error(response.statusText);
					(error as any).response = response;
					throw error;
				}
			});
		}
	}
//}
//export namespace  {
	'use strict';

	export class AgreementAdjustmentsApi {
		protected basePath = 'https://api-na.myconnectwise.net/v4_6_release/apis/3.0';
		public defaultHeaders : any = {};

		constructor(basePath?: string) {
			if (basePath) {
				this.basePath = basePath;
			}
		}

		/**
		 *
		 * Delete Adjustment By Id
		 * @param id
		 * @param adjustmentId
		 */
		public financeAgreementsIdAdjustmentsAdjustmentIdDelete (params: {  id: number; adjustmentId: number; }, extraQueryParams?: any, extraFetchParams?: any ) : Promise<{}> {
			const localVarPath = this.basePath + '/finance/agreements/{id}/adjustments/{adjustmentId}'
				.replace('{' + 'id' + '}', String(params.id))
				.replace('{' + 'adjustmentId' + '}', String(params.adjustmentId));

			let queryParameters: any = assign({}, extraQueryParams);
			let headerParams: any = assign({}, this.defaultHeaders);
			// verify required parameter 'id' is set
			if (params.id == null) {
				throw new Error('Missing required parameter id when calling financeAgreementsIdAdjustmentsAdjustmentIdDelete');
			}
			// verify required parameter 'adjustmentId' is set
			if (params.adjustmentId == null) {
				throw new Error('Missing required parameter adjustmentId when calling financeAgreementsIdAdjustmentsAdjustmentIdDelete');
			}
			let fetchParams = {
				method: 'DELETE',
				headers: headerParams,

			};

			if (extraFetchParams) {
				fetchParams = assign(fetchParams, extraFetchParams);
			}

			let localVarPathWithQueryParameters = localVarPath + (localVarPath.indexOf('?') !== -1 ? '&' : '?') + querystring.stringify(queryParameters);

			return fetch(localVarPathWithQueryParameters, fetchParams).then((response) => {
				if (response.status >= 200 && response.status < 300) {
					return response.json();
				} else {
					let error = new Error(response.statusText);
					(error as any).response = response;
					throw error;
				}
			});
		}
		/**
		 *
		 * Get Adjustment By Id
		 * @param id
		 * @param adjustmentId
		 */
		public financeAgreementsIdAdjustmentsAdjustmentIdGet (params: {  id: number; adjustmentId: number; }, extraQueryParams?: any, extraFetchParams?: any ) : Promise<Adjustment> {
			const localVarPath = this.basePath + '/finance/agreements/{id}/adjustments/{adjustmentId}'
				.replace('{' + 'id' + '}', String(params.id))
				.replace('{' + 'adjustmentId' + '}', String(params.adjustmentId));

			let queryParameters: any = assign({}, extraQueryParams);
			let headerParams: any = assign({}, this.defaultHeaders);
			// verify required parameter 'id' is set
			if (params.id == null) {
				throw new Error('Missing required parameter id when calling financeAgreementsIdAdjustmentsAdjustmentIdGet');
			}
			// verify required parameter 'adjustmentId' is set
			if (params.adjustmentId == null) {
				throw new Error('Missing required parameter adjustmentId when calling financeAgreementsIdAdjustmentsAdjustmentIdGet');
			}
			let fetchParams = {
				method: 'GET',
				headers: headerParams,

			};

			if (extraFetchParams) {
				fetchParams = assign(fetchParams, extraFetchParams);
			}

			let localVarPathWithQueryParameters = localVarPath + (localVarPath.indexOf('?') !== -1 ? '&' : '?') + querystring.stringify(queryParameters);

			return fetch(localVarPathWithQueryParameters, fetchParams).then((response) => {
				if (response.status >= 200 && response.status < 300) {
					return response.json();
				} else {
					let error = new Error(response.statusText);
					(error as any).response = response;
					throw error;
				}
			});
		}
		/**
		 *
		 * Update Adjustment
		 * @param id
		 * @param adjustmentId
		 * @param operations
		 */
		public financeAgreementsIdAdjustmentsAdjustmentIdPatch (params: {  id: number; adjustmentId: number; operations: Array<PatchOperation>; }, extraQueryParams?: any, extraFetchParams?: any ) : Promise<Adjustment> {
			const localVarPath = this.basePath + '/finance/agreements/{id}/adjustments/{adjustmentId}'
				.replace('{' + 'id' + '}', String(params.id))
				.replace('{' + 'adjustmentId' + '}', String(params.adjustmentId));

			let queryParameters: any = assign({}, extraQueryParams);
			let headerParams: any = assign({}, this.defaultHeaders);
			headerParams['Content-Type'] = 'application/json';

			// verify required parameter 'id' is set
			if (params.id == null) {
				throw new Error('Missing required parameter id when calling financeAgreementsIdAdjustmentsAdjustmentIdPatch');
			}
			// verify required parameter 'adjustmentId' is set
			if (params.adjustmentId == null) {
				throw new Error('Missing required parameter adjustmentId when calling financeAgreementsIdAdjustmentsAdjustmentIdPatch');
			}
			// verify required parameter 'operations' is set
			if (params.operations == null) {
				throw new Error('Missing required parameter operations when calling financeAgreementsIdAdjustmentsAdjustmentIdPatch');
			}
			let fetchParams = {
				method: 'PATCH',
				headers: headerParams,
				body: JSON.stringify(params.operations),

			};

			if (extraFetchParams) {
				fetchParams = assign(fetchParams, extraFetchParams);
			}

			let localVarPathWithQueryParameters = localVarPath + (localVarPath.indexOf('?') !== -1 ? '&' : '?') + querystring.stringify(queryParameters);

			return fetch(localVarPathWithQueryParameters, fetchParams).then((response) => {
				if (response.status >= 200 && response.status < 300) {
					return response.json();
				} else {
					let error = new Error(response.statusText);
					(error as any).response = response;
					throw error;
				}
			});
		}
		/**
		 *
		 * Replace Adjustment
		 * @param id
		 * @param adjustmentId
		 * @param adjustment
		 */
		public financeAgreementsIdAdjustmentsAdjustmentIdPut (params: {  id: number; adjustmentId: number; adjustment: Adjustment; }, extraQueryParams?: any, extraFetchParams?: any ) : Promise<Adjustment> {
			const localVarPath = this.basePath + '/finance/agreements/{id}/adjustments/{adjustmentId}'
				.replace('{' + 'id' + '}', String(params.id))
				.replace('{' + 'adjustmentId' + '}', String(params.adjustmentId));

			let queryParameters: any = assign({}, extraQueryParams);
			let headerParams: any = assign({}, this.defaultHeaders);
			headerParams['Content-Type'] = 'application/json';

			// verify required parameter 'id' is set
			if (params.id == null) {
				throw new Error('Missing required parameter id when calling financeAgreementsIdAdjustmentsAdjustmentIdPut');
			}
			// verify required parameter 'adjustmentId' is set
			if (params.adjustmentId == null) {
				throw new Error('Missing required parameter adjustmentId when calling financeAgreementsIdAdjustmentsAdjustmentIdPut');
			}
			// verify required parameter 'adjustment' is set
			if (params.adjustment == null) {
				throw new Error('Missing required parameter adjustment when calling financeAgreementsIdAdjustmentsAdjustmentIdPut');
			}
			let fetchParams = {
				method: 'PUT',
				headers: headerParams,
				body: JSON.stringify(params.adjustment),

			};

			if (extraFetchParams) {
				fetchParams = assign(fetchParams, extraFetchParams);
			}

			let localVarPathWithQueryParameters = localVarPath + (localVarPath.indexOf('?') !== -1 ? '&' : '?') + querystring.stringify(queryParameters);

			return fetch(localVarPathWithQueryParameters, fetchParams).then((response) => {
				if (response.status >= 200 && response.status < 300) {
					return response.json();
				} else {
					let error = new Error(response.statusText);
					(error as any).response = response;
					throw error;
				}
			});
		}
		/**
		 *
		 * Get Adjustments Count
		 * @param id
		 * @param conditions
		 * @param customFieldConditions
		 */
		public financeAgreementsIdAdjustmentsCountGet (params: {  id: number; conditions?: string; customFieldConditions?: string; }, extraQueryParams?: any, extraFetchParams?: any ) : Promise<Count> {
			const localVarPath = this.basePath + '/finance/agreements/{id}/adjustments/count'
				.replace('{' + 'id' + '}', String(params.id));

			let queryParameters: any = assign({}, extraQueryParams);
			let headerParams: any = assign({}, this.defaultHeaders);
			// verify required parameter 'id' is set
			if (params.id == null) {
				throw new Error('Missing required parameter id when calling financeAgreementsIdAdjustmentsCountGet');
			}
			if (params.conditions !== undefined) {
				queryParameters['conditions'] = params.conditions;
			}

			if (params.customFieldConditions !== undefined) {
				queryParameters['customFieldConditions'] = params.customFieldConditions;
			}

			let fetchParams = {
				method: 'GET',
				headers: headerParams,

			};

			if (extraFetchParams) {
				fetchParams = assign(fetchParams, extraFetchParams);
			}

			let localVarPathWithQueryParameters = localVarPath + (localVarPath.indexOf('?') !== -1 ? '&' : '?') + querystring.stringify(queryParameters);

			return fetch(localVarPathWithQueryParameters, fetchParams).then((response) => {
				if (response.status >= 200 && response.status < 300) {
					return response.json();
				} else {
					let error = new Error(response.statusText);
					(error as any).response = response;
					throw error;
				}
			});
		}
		/**
		 *
		 * Get Adjustments
		 * @param id
		 * @param conditions
		 * @param orderBy
		 * @param childconditions
		 * @param customfieldconditions
		 * @param page
		 * @param pageSize
		 */
		public financeAgreementsIdAdjustmentsGet (params: {  id: number; conditions?: string; orderBy?: string; childconditions?: string; customfieldconditions?: string; page?: number; pageSize?: number; }, extraQueryParams?: any, extraFetchParams?: any ) : Promise<Array<Adjustment>> {
			const localVarPath = this.basePath + '/finance/agreements/{id}/adjustments'
				.replace('{' + 'id' + '}', String(params.id));

			let queryParameters: any = assign({}, extraQueryParams);
			let headerParams: any = assign({}, this.defaultHeaders);
			// verify required parameter 'id' is set
			if (params.id == null) {
				throw new Error('Missing required parameter id when calling financeAgreementsIdAdjustmentsGet');
			}
			if (params.conditions !== undefined) {
				queryParameters['conditions'] = params.conditions;
			}

			if (params.orderBy !== undefined) {
				queryParameters['orderBy'] = params.orderBy;
			}

			if (params.childconditions !== undefined) {
				queryParameters['childconditions'] = params.childconditions;
			}

			if (params.customfieldconditions !== undefined) {
				queryParameters['customfieldconditions'] = params.customfieldconditions;
			}

			if (params.page !== undefined) {
				queryParameters['page'] = params.page;
			}

			if (params.pageSize !== undefined) {
				queryParameters['pageSize'] = params.pageSize;
			}

			let fetchParams = {
				method: 'GET',
				headers: headerParams,

			};

			if (extraFetchParams) {
				fetchParams = assign(fetchParams, extraFetchParams);
			}

			let localVarPathWithQueryParameters = localVarPath + (localVarPath.indexOf('?') !== -1 ? '&' : '?') + querystring.stringify(queryParameters);

			return fetch(localVarPathWithQueryParameters, fetchParams).then((response) => {
				if (response.status >= 200 && response.status < 300) {
					return response.json();
				} else {
					let error = new Error(response.statusText);
					(error as any).response = response;
					throw error;
				}
			});
		}
		/**
		 *
		 * Create Adjustment
		 * @param id
		 * @param adjustment
		 */
		public financeAgreementsIdAdjustmentsPost (params: {  id: number; adjustment: Adjustment; }, extraQueryParams?: any, extraFetchParams?: any ) : Promise<Adjustment> {
			const localVarPath = this.basePath + '/finance/agreements/{id}/adjustments'
				.replace('{' + 'id' + '}', String(params.id));

			let queryParameters: any = assign({}, extraQueryParams);
			let headerParams: any = assign({}, this.defaultHeaders);
			headerParams['Content-Type'] = 'application/json';

			// verify required parameter 'id' is set
			if (params.id == null) {
				throw new Error('Missing required parameter id when calling financeAgreementsIdAdjustmentsPost');
			}
			// verify required parameter 'adjustment' is set
			if (params.adjustment == null) {
				throw new Error('Missing required parameter adjustment when calling financeAgreementsIdAdjustmentsPost');
			}
			let fetchParams = {
				method: 'POST',
				headers: headerParams,
				body: JSON.stringify(params.adjustment),

			};

			if (extraFetchParams) {
				fetchParams = assign(fetchParams, extraFetchParams);
			}

			let localVarPathWithQueryParameters = localVarPath + (localVarPath.indexOf('?') !== -1 ? '&' : '?') + querystring.stringify(queryParameters);

			return fetch(localVarPathWithQueryParameters, fetchParams).then((response) => {
				if (response.status >= 200 && response.status < 300) {
					return response.json();
				} else {
					let error = new Error(response.statusText);
					(error as any).response = response;
					throw error;
				}
			});
		}
	}
//}
//export namespace  {
	'use strict';

	export class AgreementBoardDefaultsApi {
		protected basePath = 'https://api-na.myconnectwise.net/v4_6_release/apis/3.0';
		public defaultHeaders : any = {};

		constructor(basePath?: string) {
			if (basePath) {
				this.basePath = basePath;
			}
		}

		/**
		 *
		 * Delete Board Default By Id
		 * @param id
		 * @param boardDefaultId
		 */
		public financeAgreementsIdBoardDefaultsBoardDefaultIdDelete (params: {  id: number; boardDefaultId: number; }, extraQueryParams?: any, extraFetchParams?: any ) : Promise<{}> {
			const localVarPath = this.basePath + '/finance/agreements/{id}/boardDefaults/{boardDefaultId}'
				.replace('{' + 'id' + '}', String(params.id))
				.replace('{' + 'boardDefaultId' + '}', String(params.boardDefaultId));

			let queryParameters: any = assign({}, extraQueryParams);
			let headerParams: any = assign({}, this.defaultHeaders);
			// verify required parameter 'id' is set
			if (params.id == null) {
				throw new Error('Missing required parameter id when calling financeAgreementsIdBoardDefaultsBoardDefaultIdDelete');
			}
			// verify required parameter 'boardDefaultId' is set
			if (params.boardDefaultId == null) {
				throw new Error('Missing required parameter boardDefaultId when calling financeAgreementsIdBoardDefaultsBoardDefaultIdDelete');
			}
			let fetchParams = {
				method: 'DELETE',
				headers: headerParams,

			};

			if (extraFetchParams) {
				fetchParams = assign(fetchParams, extraFetchParams);
			}

			let localVarPathWithQueryParameters = localVarPath + (localVarPath.indexOf('?') !== -1 ? '&' : '?') + querystring.stringify(queryParameters);

			return fetch(localVarPathWithQueryParameters, fetchParams).then((response) => {
				if (response.status >= 200 && response.status < 300) {
					return response.json();
				} else {
					let error = new Error(response.statusText);
					(error as any).response = response;
					throw error;
				}
			});
		}
		/**
		 *
		 * Get Board Default By Id
		 * @param id
		 * @param boardDefaultId
		 */
		public financeAgreementsIdBoardDefaultsBoardDefaultIdGet (params: {  id: number; boardDefaultId: number; }, extraQueryParams?: any, extraFetchParams?: any ) : Promise<BoardDefault> {
			const localVarPath = this.basePath + '/finance/agreements/{id}/boardDefaults/{boardDefaultId}'
				.replace('{' + 'id' + '}', String(params.id))
				.replace('{' + 'boardDefaultId' + '}', String(params.boardDefaultId));

			let queryParameters: any = assign({}, extraQueryParams);
			let headerParams: any = assign({}, this.defaultHeaders);
			// verify required parameter 'id' is set
			if (params.id == null) {
				throw new Error('Missing required parameter id when calling financeAgreementsIdBoardDefaultsBoardDefaultIdGet');
			}
			// verify required parameter 'boardDefaultId' is set
			if (params.boardDefaultId == null) {
				throw new Error('Missing required parameter boardDefaultId when calling financeAgreementsIdBoardDefaultsBoardDefaultIdGet');
			}
			let fetchParams = {
				method: 'GET',
				headers: headerParams,

			};

			if (extraFetchParams) {
				fetchParams = assign(fetchParams, extraFetchParams);
			}

			let localVarPathWithQueryParameters = localVarPath + (localVarPath.indexOf('?') !== -1 ? '&' : '?') + querystring.stringify(queryParameters);

			return fetch(localVarPathWithQueryParameters, fetchParams).then((response) => {
				if (response.status >= 200 && response.status < 300) {
					return response.json();
				} else {
					let error = new Error(response.statusText);
					(error as any).response = response;
					throw error;
				}
			});
		}
		/**
		 *
		 * Update Board Default
		 * @param id
		 * @param boardDefaultId
		 * @param operations
		 */
		public financeAgreementsIdBoardDefaultsBoardDefaultIdPatch (params: {  id: number; boardDefaultId: number; operations: Array<PatchOperation>; }, extraQueryParams?: any, extraFetchParams?: any ) : Promise<BoardDefault> {
			const localVarPath = this.basePath + '/finance/agreements/{id}/boardDefaults/{boardDefaultId}'
				.replace('{' + 'id' + '}', String(params.id))
				.replace('{' + 'boardDefaultId' + '}', String(params.boardDefaultId));

			let queryParameters: any = assign({}, extraQueryParams);
			let headerParams: any = assign({}, this.defaultHeaders);
			headerParams['Content-Type'] = 'application/json';

			// verify required parameter 'id' is set
			if (params.id == null) {
				throw new Error('Missing required parameter id when calling financeAgreementsIdBoardDefaultsBoardDefaultIdPatch');
			}
			// verify required parameter 'boardDefaultId' is set
			if (params.boardDefaultId == null) {
				throw new Error('Missing required parameter boardDefaultId when calling financeAgreementsIdBoardDefaultsBoardDefaultIdPatch');
			}
			// verify required parameter 'operations' is set
			if (params.operations == null) {
				throw new Error('Missing required parameter operations when calling financeAgreementsIdBoardDefaultsBoardDefaultIdPatch');
			}
			let fetchParams = {
				method: 'PATCH',
				headers: headerParams,
				body: JSON.stringify(params.operations),

			};

			if (extraFetchParams) {
				fetchParams = assign(fetchParams, extraFetchParams);
			}

			let localVarPathWithQueryParameters = localVarPath + (localVarPath.indexOf('?') !== -1 ? '&' : '?') + querystring.stringify(queryParameters);

			return fetch(localVarPathWithQueryParameters, fetchParams).then((response) => {
				if (response.status >= 200 && response.status < 300) {
					return response.json();
				} else {
					let error = new Error(response.statusText);
					(error as any).response = response;
					throw error;
				}
			});
		}
		/**
		 *
		 * Replace Board Default
		 * @param id
		 * @param boardDefaultId
		 * @param boardDefault
		 */
		public financeAgreementsIdBoardDefaultsBoardDefaultIdPut (params: {  id: number; boardDefaultId: number; boardDefault: BoardDefault; }, extraQueryParams?: any, extraFetchParams?: any ) : Promise<BoardDefault> {
			const localVarPath = this.basePath + '/finance/agreements/{id}/boardDefaults/{boardDefaultId}'
				.replace('{' + 'id' + '}', String(params.id))
				.replace('{' + 'boardDefaultId' + '}', String(params.boardDefaultId));

			let queryParameters: any = assign({}, extraQueryParams);
			let headerParams: any = assign({}, this.defaultHeaders);
			headerParams['Content-Type'] = 'application/json';

			// verify required parameter 'id' is set
			if (params.id == null) {
				throw new Error('Missing required parameter id when calling financeAgreementsIdBoardDefaultsBoardDefaultIdPut');
			}
			// verify required parameter 'boardDefaultId' is set
			if (params.boardDefaultId == null) {
				throw new Error('Missing required parameter boardDefaultId when calling financeAgreementsIdBoardDefaultsBoardDefaultIdPut');
			}
			// verify required parameter 'boardDefault' is set
			if (params.boardDefault == null) {
				throw new Error('Missing required parameter boardDefault when calling financeAgreementsIdBoardDefaultsBoardDefaultIdPut');
			}
			let fetchParams = {
				method: 'PUT',
				headers: headerParams,
				body: JSON.stringify(params.boardDefault),

			};

			if (extraFetchParams) {
				fetchParams = assign(fetchParams, extraFetchParams);
			}

			let localVarPathWithQueryParameters = localVarPath + (localVarPath.indexOf('?') !== -1 ? '&' : '?') + querystring.stringify(queryParameters);

			return fetch(localVarPathWithQueryParameters, fetchParams).then((response) => {
				if (response.status >= 200 && response.status < 300) {
					return response.json();
				} else {
					let error = new Error(response.statusText);
					(error as any).response = response;
					throw error;
				}
			});
		}
		/**
		 *
		 * Get Board Defaults Count
		 * @param id
		 * @param conditions
		 */
		public financeAgreementsIdBoardDefaultsCountGet (params: {  id: number; conditions?: string; }, extraQueryParams?: any, extraFetchParams?: any ) : Promise<Count> {
			const localVarPath = this.basePath + '/finance/agreements/{id}/boardDefaults/count'
				.replace('{' + 'id' + '}', String(params.id));

			let queryParameters: any = assign({}, extraQueryParams);
			let headerParams: any = assign({}, this.defaultHeaders);
			// verify required parameter 'id' is set
			if (params.id == null) {
				throw new Error('Missing required parameter id when calling financeAgreementsIdBoardDefaultsCountGet');
			}
			if (params.conditions !== undefined) {
				queryParameters['conditions'] = params.conditions;
			}

			let fetchParams = {
				method: 'GET',
				headers: headerParams,

			};

			if (extraFetchParams) {
				fetchParams = assign(fetchParams, extraFetchParams);
			}

			let localVarPathWithQueryParameters = localVarPath + (localVarPath.indexOf('?') !== -1 ? '&' : '?') + querystring.stringify(queryParameters);

			return fetch(localVarPathWithQueryParameters, fetchParams).then((response) => {
				if (response.status >= 200 && response.status < 300) {
					return response.json();
				} else {
					let error = new Error(response.statusText);
					(error as any).response = response;
					throw error;
				}
			});
		}
		/**
		 *
		 * Get Board Defaults
		 * @param id
		 * @param conditions
		 * @param orderBy
		 * @param childconditions
		 * @param customfieldconditions
		 * @param page
		 * @param pageSize
		 */
		public financeAgreementsIdBoardDefaultsGet (params: {  id: number; conditions?: string; orderBy?: string; childconditions?: string; customfieldconditions?: string; page?: number; pageSize?: number; }, extraQueryParams?: any, extraFetchParams?: any ) : Promise<Array<BoardDefault>> {
			const localVarPath = this.basePath + '/finance/agreements/{id}/boardDefaults'
				.replace('{' + 'id' + '}', String(params.id));

			let queryParameters: any = assign({}, extraQueryParams);
			let headerParams: any = assign({}, this.defaultHeaders);
			// verify required parameter 'id' is set
			if (params.id == null) {
				throw new Error('Missing required parameter id when calling financeAgreementsIdBoardDefaultsGet');
			}
			if (params.conditions !== undefined) {
				queryParameters['conditions'] = params.conditions;
			}

			if (params.orderBy !== undefined) {
				queryParameters['orderBy'] = params.orderBy;
			}

			if (params.childconditions !== undefined) {
				queryParameters['childconditions'] = params.childconditions;
			}

			if (params.customfieldconditions !== undefined) {
				queryParameters['customfieldconditions'] = params.customfieldconditions;
			}

			if (params.page !== undefined) {
				queryParameters['page'] = params.page;
			}

			if (params.pageSize !== undefined) {
				queryParameters['pageSize'] = params.pageSize;
			}

			let fetchParams = {
				method: 'GET',
				headers: headerParams,

			};

			if (extraFetchParams) {
				fetchParams = assign(fetchParams, extraFetchParams);
			}

			let localVarPathWithQueryParameters = localVarPath + (localVarPath.indexOf('?') !== -1 ? '&' : '?') + querystring.stringify(queryParameters);

			return fetch(localVarPathWithQueryParameters, fetchParams).then((response) => {
				if (response.status >= 200 && response.status < 300) {
					return response.json();
				} else {
					let error = new Error(response.statusText);
					(error as any).response = response;
					throw error;
				}
			});
		}
		/**
		 *
		 * Create Board Default
		 * @param id
		 * @param boardDefault
		 */
		public financeAgreementsIdBoardDefaultsPost (params: {  id: number; boardDefault: BoardDefault; }, extraQueryParams?: any, extraFetchParams?: any ) : Promise<BoardDefault> {
			const localVarPath = this.basePath + '/finance/agreements/{id}/boardDefaults'
				.replace('{' + 'id' + '}', String(params.id));

			let queryParameters: any = assign({}, extraQueryParams);
			let headerParams: any = assign({}, this.defaultHeaders);
			headerParams['Content-Type'] = 'application/json';

			// verify required parameter 'id' is set
			if (params.id == null) {
				throw new Error('Missing required parameter id when calling financeAgreementsIdBoardDefaultsPost');
			}
			// verify required parameter 'boardDefault' is set
			if (params.boardDefault == null) {
				throw new Error('Missing required parameter boardDefault when calling financeAgreementsIdBoardDefaultsPost');
			}
			let fetchParams = {
				method: 'POST',
				headers: headerParams,
				body: JSON.stringify(params.boardDefault),

			};

			if (extraFetchParams) {
				fetchParams = assign(fetchParams, extraFetchParams);
			}

			let localVarPathWithQueryParameters = localVarPath + (localVarPath.indexOf('?') !== -1 ? '&' : '?') + querystring.stringify(queryParameters);

			return fetch(localVarPathWithQueryParameters, fetchParams).then((response) => {
				if (response.status >= 200 && response.status < 300) {
					return response.json();
				} else {
					let error = new Error(response.statusText);
					(error as any).response = response;
					throw error;
				}
			});
		}
	}
//}
//export namespace  {
	'use strict';

	export class AgreementSitesApi {
		protected basePath = 'https://api-na.myconnectwise.net/v4_6_release/apis/3.0';
		public defaultHeaders : any = {};

		constructor(basePath?: string) {
			if (basePath) {
				this.basePath = basePath;
			}
		}

		/**
		 *
		 * Get Sites Count
		 * @param id
		 * @param conditions
		 */
		public financeAgreementsIdSitesCountGet (params: {  id: number; conditions?: string; }, extraQueryParams?: any, extraFetchParams?: any ) : Promise<Count> {
			const localVarPath = this.basePath + '/finance/agreements/{id}/sites/count'
				.replace('{' + 'id' + '}', String(params.id));

			let queryParameters: any = assign({}, extraQueryParams);
			let headerParams: any = assign({}, this.defaultHeaders);
			// verify required parameter 'id' is set
			if (params.id == null) {
				throw new Error('Missing required parameter id when calling financeAgreementsIdSitesCountGet');
			}
			if (params.conditions !== undefined) {
				queryParameters['conditions'] = params.conditions;
			}

			let fetchParams = {
				method: 'GET',
				headers: headerParams,

			};

			if (extraFetchParams) {
				fetchParams = assign(fetchParams, extraFetchParams);
			}

			let localVarPathWithQueryParameters = localVarPath + (localVarPath.indexOf('?') !== -1 ? '&' : '?') + querystring.stringify(queryParameters);

			return fetch(localVarPathWithQueryParameters, fetchParams).then((response) => {
				if (response.status >= 200 && response.status < 300) {
					return response.json();
				} else {
					let error = new Error(response.statusText);
					(error as any).response = response;
					throw error;
				}
			});
		}
		/**
		 *
		 * Get Sites
		 * @param id
		 * @param conditions
		 * @param orderBy
		 * @param childconditions
		 * @param customfieldconditions
		 * @param page
		 * @param pageSize
		 */
		public financeAgreementsIdSitesGet (params: {  id: number; conditions?: string; orderBy?: string; childconditions?: string; customfieldconditions?: string; page?: number; pageSize?: number; }, extraQueryParams?: any, extraFetchParams?: any ) : Promise<Array<AgreementSite>> {
			const localVarPath = this.basePath + '/finance/agreements/{id}/sites'
				.replace('{' + 'id' + '}', String(params.id));

			let queryParameters: any = assign({}, extraQueryParams);
			let headerParams: any = assign({}, this.defaultHeaders);
			// verify required parameter 'id' is set
			if (params.id == null) {
				throw new Error('Missing required parameter id when calling financeAgreementsIdSitesGet');
			}
			if (params.conditions !== undefined) {
				queryParameters['conditions'] = params.conditions;
			}

			if (params.orderBy !== undefined) {
				queryParameters['orderBy'] = params.orderBy;
			}

			if (params.childconditions !== undefined) {
				queryParameters['childconditions'] = params.childconditions;
			}

			if (params.customfieldconditions !== undefined) {
				queryParameters['customfieldconditions'] = params.customfieldconditions;
			}

			if (params.page !== undefined) {
				queryParameters['page'] = params.page;
			}

			if (params.pageSize !== undefined) {
				queryParameters['pageSize'] = params.pageSize;
			}

			let fetchParams = {
				method: 'GET',
				headers: headerParams,

			};

			if (extraFetchParams) {
				fetchParams = assign(fetchParams, extraFetchParams);
			}

			let localVarPathWithQueryParameters = localVarPath + (localVarPath.indexOf('?') !== -1 ? '&' : '?') + querystring.stringify(queryParameters);

			return fetch(localVarPathWithQueryParameters, fetchParams).then((response) => {
				if (response.status >= 200 && response.status < 300) {
					return response.json();
				} else {
					let error = new Error(response.statusText);
					(error as any).response = response;
					throw error;
				}
			});
		}
		/**
		 *
		 * Create Site
		 * @param id
		 * @param site
		 */
		public financeAgreementsIdSitesPost (params: {  id: number; site: AgreementSite; }, extraQueryParams?: any, extraFetchParams?: any ) : Promise<AgreementSite> {
			const localVarPath = this.basePath + '/finance/agreements/{id}/sites'
				.replace('{' + 'id' + '}', String(params.id));

			let queryParameters: any = assign({}, extraQueryParams);
			let headerParams: any = assign({}, this.defaultHeaders);
			headerParams['Content-Type'] = 'application/json';

			// verify required parameter 'id' is set
			if (params.id == null) {
				throw new Error('Missing required parameter id when calling financeAgreementsIdSitesPost');
			}
			// verify required parameter 'site' is set
			if (params.site == null) {
				throw new Error('Missing required parameter site when calling financeAgreementsIdSitesPost');
			}
			let fetchParams = {
				method: 'POST',
				headers: headerParams,
				body: JSON.stringify(params.site),

			};

			if (extraFetchParams) {
				fetchParams = assign(fetchParams, extraFetchParams);
			}

			let localVarPathWithQueryParameters = localVarPath + (localVarPath.indexOf('?') !== -1 ? '&' : '?') + querystring.stringify(queryParameters);

			return fetch(localVarPathWithQueryParameters, fetchParams).then((response) => {
				if (response.status >= 200 && response.status < 300) {
					return response.json();
				} else {
					let error = new Error(response.statusText);
					(error as any).response = response;
					throw error;
				}
			});
		}
		/**
		 *
		 * Delete Site By Id
		 * @param id
		 * @param siteId
		 */
		public financeAgreementsIdSitesSiteIdDelete (params: {  id: number; siteId: number; }, extraQueryParams?: any, extraFetchParams?: any ) : Promise<{}> {
			const localVarPath = this.basePath + '/finance/agreements/{id}/sites/{siteId}'
				.replace('{' + 'id' + '}', String(params.id))
				.replace('{' + 'siteId' + '}', String(params.siteId));

			let queryParameters: any = assign({}, extraQueryParams);
			let headerParams: any = assign({}, this.defaultHeaders);
			// verify required parameter 'id' is set
			if (params.id == null) {
				throw new Error('Missing required parameter id when calling financeAgreementsIdSitesSiteIdDelete');
			}
			// verify required parameter 'siteId' is set
			if (params.siteId == null) {
				throw new Error('Missing required parameter siteId when calling financeAgreementsIdSitesSiteIdDelete');
			}
			let fetchParams = {
				method: 'DELETE',
				headers: headerParams,

			};

			if (extraFetchParams) {
				fetchParams = assign(fetchParams, extraFetchParams);
			}

			let localVarPathWithQueryParameters = localVarPath + (localVarPath.indexOf('?') !== -1 ? '&' : '?') + querystring.stringify(queryParameters);

			return fetch(localVarPathWithQueryParameters, fetchParams).then((response) => {
				if (response.status >= 200 && response.status < 300) {
					return response.json();
				} else {
					let error = new Error(response.statusText);
					(error as any).response = response;
					throw error;
				}
			});
		}
		/**
		 *
		 * Get Site By Id
		 * @param id
		 * @param siteId
		 */
		public financeAgreementsIdSitesSiteIdGet (params: {  id: number; siteId: number; }, extraQueryParams?: any, extraFetchParams?: any ) : Promise<AgreementSite> {
			const localVarPath = this.basePath + '/finance/agreements/{id}/sites/{siteId}'
				.replace('{' + 'id' + '}', String(params.id))
				.replace('{' + 'siteId' + '}', String(params.siteId));

			let queryParameters: any = assign({}, extraQueryParams);
			let headerParams: any = assign({}, this.defaultHeaders);
			// verify required parameter 'id' is set
			if (params.id == null) {
				throw new Error('Missing required parameter id when calling financeAgreementsIdSitesSiteIdGet');
			}
			// verify required parameter 'siteId' is set
			if (params.siteId == null) {
				throw new Error('Missing required parameter siteId when calling financeAgreementsIdSitesSiteIdGet');
			}
			let fetchParams = {
				method: 'GET',
				headers: headerParams,

			};

			if (extraFetchParams) {
				fetchParams = assign(fetchParams, extraFetchParams);
			}

			let localVarPathWithQueryParameters = localVarPath + (localVarPath.indexOf('?') !== -1 ? '&' : '?') + querystring.stringify(queryParameters);

			return fetch(localVarPathWithQueryParameters, fetchParams).then((response) => {
				if (response.status >= 200 && response.status < 300) {
					return response.json();
				} else {
					let error = new Error(response.statusText);
					(error as any).response = response;
					throw error;
				}
			});
		}
		/**
		 *
		 * Update Site
		 * @param id
		 * @param siteId
		 * @param operations
		 */
		public financeAgreementsIdSitesSiteIdPatch (params: {  id: number; siteId: number; operations: Array<PatchOperation>; }, extraQueryParams?: any, extraFetchParams?: any ) : Promise<AgreementSite> {
			const localVarPath = this.basePath + '/finance/agreements/{id}/sites/{siteId}'
				.replace('{' + 'id' + '}', String(params.id))
				.replace('{' + 'siteId' + '}', String(params.siteId));

			let queryParameters: any = assign({}, extraQueryParams);
			let headerParams: any = assign({}, this.defaultHeaders);
			headerParams['Content-Type'] = 'application/json';

			// verify required parameter 'id' is set
			if (params.id == null) {
				throw new Error('Missing required parameter id when calling financeAgreementsIdSitesSiteIdPatch');
			}
			// verify required parameter 'siteId' is set
			if (params.siteId == null) {
				throw new Error('Missing required parameter siteId when calling financeAgreementsIdSitesSiteIdPatch');
			}
			// verify required parameter 'operations' is set
			if (params.operations == null) {
				throw new Error('Missing required parameter operations when calling financeAgreementsIdSitesSiteIdPatch');
			}
			let fetchParams = {
				method: 'PATCH',
				headers: headerParams,
				body: JSON.stringify(params.operations),

			};

			if (extraFetchParams) {
				fetchParams = assign(fetchParams, extraFetchParams);
			}

			let localVarPathWithQueryParameters = localVarPath + (localVarPath.indexOf('?') !== -1 ? '&' : '?') + querystring.stringify(queryParameters);

			return fetch(localVarPathWithQueryParameters, fetchParams).then((response) => {
				if (response.status >= 200 && response.status < 300) {
					return response.json();
				} else {
					let error = new Error(response.statusText);
					(error as any).response = response;
					throw error;
				}
			});
		}
		/**
		 *
		 * Replace Site
		 * @param id
		 * @param siteId
		 * @param site
		 */
		public financeAgreementsIdSitesSiteIdPut (params: {  id: number; siteId: number; site: AgreementSite; }, extraQueryParams?: any, extraFetchParams?: any ) : Promise<AgreementSite> {
			const localVarPath = this.basePath + '/finance/agreements/{id}/sites/{siteId}'
				.replace('{' + 'id' + '}', String(params.id))
				.replace('{' + 'siteId' + '}', String(params.siteId));

			let queryParameters: any = assign({}, extraQueryParams);
			let headerParams: any = assign({}, this.defaultHeaders);
			headerParams['Content-Type'] = 'application/json';

			// verify required parameter 'id' is set
			if (params.id == null) {
				throw new Error('Missing required parameter id when calling financeAgreementsIdSitesSiteIdPut');
			}
			// verify required parameter 'siteId' is set
			if (params.siteId == null) {
				throw new Error('Missing required parameter siteId when calling financeAgreementsIdSitesSiteIdPut');
			}
			// verify required parameter 'site' is set
			if (params.site == null) {
				throw new Error('Missing required parameter site when calling financeAgreementsIdSitesSiteIdPut');
			}
			let fetchParams = {
				method: 'PUT',
				headers: headerParams,
				body: JSON.stringify(params.site),

			};

			if (extraFetchParams) {
				fetchParams = assign(fetchParams, extraFetchParams);
			}

			let localVarPathWithQueryParameters = localVarPath + (localVarPath.indexOf('?') !== -1 ? '&' : '?') + querystring.stringify(queryParameters);

			return fetch(localVarPathWithQueryParameters, fetchParams).then((response) => {
				if (response.status >= 200 && response.status < 300) {
					return response.json();
				} else {
					let error = new Error(response.statusText);
					(error as any).response = response;
					throw error;
				}
			});
		}
	}
//}
//export namespace  {
	'use strict';

	export class AgreementTypesApi {
		protected basePath = 'https://api-na.myconnectwise.net/v4_6_release/apis/3.0';
		public defaultHeaders : any = {};

		constructor(basePath?: string) {
			if (basePath) {
				this.basePath = basePath;
			}
		}

		/**
		 *
		 * Get Agreement Types Count
		 * @param conditions
		 */
		public financeAgreementsTypesCountGet (params: {  conditions?: string; }, extraQueryParams?: any, extraFetchParams?: any ) : Promise<Count> {
			const localVarPath = this.basePath + '/finance/agreements/types/count';

			let queryParameters: any = assign({}, extraQueryParams);
			let headerParams: any = assign({}, this.defaultHeaders);
			if (params.conditions !== undefined) {
				queryParameters['conditions'] = params.conditions;
			}

			let fetchParams = {
				method: 'GET',
				headers: headerParams,

			};

			if (extraFetchParams) {
				fetchParams = assign(fetchParams, extraFetchParams);
			}

			let localVarPathWithQueryParameters = localVarPath + (localVarPath.indexOf('?') !== -1 ? '&' : '?') + querystring.stringify(queryParameters);

			return fetch(localVarPathWithQueryParameters, fetchParams).then((response) => {
				if (response.status >= 200 && response.status < 300) {
					return response.json();
				} else {
					let error = new Error(response.statusText);
					(error as any).response = response;
					throw error;
				}
			});
		}
		/**
		 *
		 * Get Agreement Types
		 * @param conditions
		 * @param orderBy
		 * @param childconditions
		 * @param customfieldconditions
		 * @param page
		 * @param pageSize
		 */
		public financeAgreementsTypesGet (params: {  conditions?: string; orderBy?: string; childconditions?: string; customfieldconditions?: string; page?: number; pageSize?: number; }, extraQueryParams?: any, extraFetchParams?: any ) : Promise<Array<AgreementType>> {
			const localVarPath = this.basePath + '/finance/agreements/types';

			let queryParameters: any = assign({}, extraQueryParams);
			let headerParams: any = assign({}, this.defaultHeaders);
			if (params.conditions !== undefined) {
				queryParameters['conditions'] = params.conditions;
			}

			if (params.orderBy !== undefined) {
				queryParameters['orderBy'] = params.orderBy;
			}

			if (params.childconditions !== undefined) {
				queryParameters['childconditions'] = params.childconditions;
			}

			if (params.customfieldconditions !== undefined) {
				queryParameters['customfieldconditions'] = params.customfieldconditions;
			}

			if (params.page !== undefined) {
				queryParameters['page'] = params.page;
			}

			if (params.pageSize !== undefined) {
				queryParameters['pageSize'] = params.pageSize;
			}

			let fetchParams = {
				method: 'GET',
				headers: headerParams,

			};

			if (extraFetchParams) {
				fetchParams = assign(fetchParams, extraFetchParams);
			}

			let localVarPathWithQueryParameters = localVarPath + (localVarPath.indexOf('?') !== -1 ? '&' : '?') + querystring.stringify(queryParameters);

			return fetch(localVarPathWithQueryParameters, fetchParams).then((response) => {
				if (response.status >= 200 && response.status < 300) {
					return response.json();
				} else {
					let error = new Error(response.statusText);
					(error as any).response = response;
					throw error;
				}
			});
		}
		/**
		 *
		 * Delete Agreement Type By Id
		 * @param id
		 */
		public financeAgreementsTypesIdDelete (params: {  id: number; }, extraQueryParams?: any, extraFetchParams?: any ) : Promise<{}> {
			const localVarPath = this.basePath + '/finance/agreements/types/{id}'
				.replace('{' + 'id' + '}', String(params.id));

			let queryParameters: any = assign({}, extraQueryParams);
			let headerParams: any = assign({}, this.defaultHeaders);
			// verify required parameter 'id' is set
			if (params.id == null) {
				throw new Error('Missing required parameter id when calling financeAgreementsTypesIdDelete');
			}
			let fetchParams = {
				method: 'DELETE',
				headers: headerParams,

			};

			if (extraFetchParams) {
				fetchParams = assign(fetchParams, extraFetchParams);
			}

			let localVarPathWithQueryParameters = localVarPath + (localVarPath.indexOf('?') !== -1 ? '&' : '?') + querystring.stringify(queryParameters);

			return fetch(localVarPathWithQueryParameters, fetchParams).then((response) => {
				if (response.status >= 200 && response.status < 300) {
					return response.json();
				} else {
					let error = new Error(response.statusText);
					(error as any).response = response;
					throw error;
				}
			});
		}
		/**
		 *
		 * Get Agreement Type By Id
		 * @param id
		 */
		public financeAgreementsTypesIdGet (params: {  id: number; }, extraQueryParams?: any, extraFetchParams?: any ) : Promise<AgreementType> {
			const localVarPath = this.basePath + '/finance/agreements/types/{id}'
				.replace('{' + 'id' + '}', String(params.id));

			let queryParameters: any = assign({}, extraQueryParams);
			let headerParams: any = assign({}, this.defaultHeaders);
			// verify required parameter 'id' is set
			if (params.id == null) {
				throw new Error('Missing required parameter id when calling financeAgreementsTypesIdGet');
			}
			let fetchParams = {
				method: 'GET',
				headers: headerParams,

			};

			if (extraFetchParams) {
				fetchParams = assign(fetchParams, extraFetchParams);
			}

			let localVarPathWithQueryParameters = localVarPath + (localVarPath.indexOf('?') !== -1 ? '&' : '?') + querystring.stringify(queryParameters);

			return fetch(localVarPathWithQueryParameters, fetchParams).then((response) => {
				if (response.status >= 200 && response.status < 300) {
					return response.json();
				} else {
					let error = new Error(response.statusText);
					(error as any).response = response;
					throw error;
				}
			});
		}
		/**
		 *
		 * Update Agreement Type
		 * @param id
		 * @param operations
		 */
		public financeAgreementsTypesIdPatch (params: {  id: number; operations: Array<PatchOperation>; }, extraQueryParams?: any, extraFetchParams?: any ) : Promise<AgreementType> {
			const localVarPath = this.basePath + '/finance/agreements/types/{id}'
				.replace('{' + 'id' + '}', String(params.id));

			let queryParameters: any = assign({}, extraQueryParams);
			let headerParams: any = assign({}, this.defaultHeaders);
			headerParams['Content-Type'] = 'application/json';

			// verify required parameter 'id' is set
			if (params.id == null) {
				throw new Error('Missing required parameter id when calling financeAgreementsTypesIdPatch');
			}
			// verify required parameter 'operations' is set
			if (params.operations == null) {
				throw new Error('Missing required parameter operations when calling financeAgreementsTypesIdPatch');
			}
			let fetchParams = {
				method: 'PATCH',
				headers: headerParams,
				body: JSON.stringify(params.operations),

			};

			if (extraFetchParams) {
				fetchParams = assign(fetchParams, extraFetchParams);
			}

			let localVarPathWithQueryParameters = localVarPath + (localVarPath.indexOf('?') !== -1 ? '&' : '?') + querystring.stringify(queryParameters);

			return fetch(localVarPathWithQueryParameters, fetchParams).then((response) => {
				if (response.status >= 200 && response.status < 300) {
					return response.json();
				} else {
					let error = new Error(response.statusText);
					(error as any).response = response;
					throw error;
				}
			});
		}
		/**
		 *
		 * Replace Agreement Type
		 * @param id
		 * @param agreementType
		 */
		public financeAgreementsTypesIdPut (params: {  id: number; agreementType: AgreementType; }, extraQueryParams?: any, extraFetchParams?: any ) : Promise<AgreementType> {
			const localVarPath = this.basePath + '/finance/agreements/types/{id}'
				.replace('{' + 'id' + '}', String(params.id));

			let queryParameters: any = assign({}, extraQueryParams);
			let headerParams: any = assign({}, this.defaultHeaders);
			headerParams['Content-Type'] = 'application/json';

			// verify required parameter 'id' is set
			if (params.id == null) {
				throw new Error('Missing required parameter id when calling financeAgreementsTypesIdPut');
			}
			// verify required parameter 'agreementType' is set
			if (params.agreementType == null) {
				throw new Error('Missing required parameter agreementType when calling financeAgreementsTypesIdPut');
			}
			let fetchParams = {
				method: 'PUT',
				headers: headerParams,
				body: JSON.stringify(params.agreementType),

			};

			if (extraFetchParams) {
				fetchParams = assign(fetchParams, extraFetchParams);
			}

			let localVarPathWithQueryParameters = localVarPath + (localVarPath.indexOf('?') !== -1 ? '&' : '?') + querystring.stringify(queryParameters);

			return fetch(localVarPathWithQueryParameters, fetchParams).then((response) => {
				if (response.status >= 200 && response.status < 300) {
					return response.json();
				} else {
					let error = new Error(response.statusText);
					(error as any).response = response;
					throw error;
				}
			});
		}
		/**
		 *
		 * Create Agreement Type
		 * @param agreementType
		 */
		public financeAgreementsTypesPost (params: {  agreementType: AgreementType; }, extraQueryParams?: any, extraFetchParams?: any ) : Promise<AgreementType> {
			const localVarPath = this.basePath + '/finance/agreements/types';

			let queryParameters: any = assign({}, extraQueryParams);
			let headerParams: any = assign({}, this.defaultHeaders);
			headerParams['Content-Type'] = 'application/json';

			// verify required parameter 'agreementType' is set
			if (params.agreementType == null) {
				throw new Error('Missing required parameter agreementType when calling financeAgreementsTypesPost');
			}
			let fetchParams = {
				method: 'POST',
				headers: headerParams,
				body: JSON.stringify(params.agreementType),

			};

			if (extraFetchParams) {
				fetchParams = assign(fetchParams, extraFetchParams);
			}

			let localVarPathWithQueryParameters = localVarPath + (localVarPath.indexOf('?') !== -1 ? '&' : '?') + querystring.stringify(queryParameters);

			return fetch(localVarPathWithQueryParameters, fetchParams).then((response) => {
				if (response.status >= 200 && response.status < 300) {
					return response.json();
				} else {
					let error = new Error(response.statusText);
					(error as any).response = response;
					throw error;
				}
			});
		}
	}
//}
//export namespace  {
	'use strict';

	export class AgreementWorkRoleExclusionsApi {
		protected basePath = 'https://api-na.myconnectwise.net/v4_6_release/apis/3.0';
		public defaultHeaders : any = {};

		constructor(basePath?: string) {
			if (basePath) {
				this.basePath = basePath;
			}
		}

		/**
		 *
		 * Get Work Role Exclusions Count
		 * @param id
		 * @param conditions
		 */
		public financeAgreementsIdWorkRoleExclusionsCountGet (params: {  id: number; conditions?: string; }, extraQueryParams?: any, extraFetchParams?: any ) : Promise<Count> {
			const localVarPath = this.basePath + '/finance/agreements/{id}/workRoleExclusions/count'
				.replace('{' + 'id' + '}', String(params.id));

			let queryParameters: any = assign({}, extraQueryParams);
			let headerParams: any = assign({}, this.defaultHeaders);
			// verify required parameter 'id' is set
			if (params.id == null) {
				throw new Error('Missing required parameter id when calling financeAgreementsIdWorkRoleExclusionsCountGet');
			}
			if (params.conditions !== undefined) {
				queryParameters['conditions'] = params.conditions;
			}

			let fetchParams = {
				method: 'GET',
				headers: headerParams,

			};

			if (extraFetchParams) {
				fetchParams = assign(fetchParams, extraFetchParams);
			}

			let localVarPathWithQueryParameters = localVarPath + (localVarPath.indexOf('?') !== -1 ? '&' : '?') + querystring.stringify(queryParameters);

			return fetch(localVarPathWithQueryParameters, fetchParams).then((response) => {
				if (response.status >= 200 && response.status < 300) {
					return response.json();
				} else {
					let error = new Error(response.statusText);
					(error as any).response = response;
					throw error;
				}
			});
		}
		/**
		 *
		 * Get Work Role Exclusions
		 * @param id
		 * @param conditions
		 * @param orderBy
		 * @param childconditions
		 * @param customfieldconditions
		 * @param page
		 * @param pageSize
		 */
		public financeAgreementsIdWorkRoleExclusionsGet (params: {  id: number; conditions?: string; orderBy?: string; childconditions?: string; customfieldconditions?: string; page?: number; pageSize?: number; }, extraQueryParams?: any, extraFetchParams?: any ) : Promise<Array<AgreementWorkRoleExclusion>> {
			const localVarPath = this.basePath + '/finance/agreements/{id}/workRoleExclusions'
				.replace('{' + 'id' + '}', String(params.id));

			let queryParameters: any = assign({}, extraQueryParams);
			let headerParams: any = assign({}, this.defaultHeaders);
			// verify required parameter 'id' is set
			if (params.id == null) {
				throw new Error('Missing required parameter id when calling financeAgreementsIdWorkRoleExclusionsGet');
			}
			if (params.conditions !== undefined) {
				queryParameters['conditions'] = params.conditions;
			}

			if (params.orderBy !== undefined) {
				queryParameters['orderBy'] = params.orderBy;
			}

			if (params.childconditions !== undefined) {
				queryParameters['childconditions'] = params.childconditions;
			}

			if (params.customfieldconditions !== undefined) {
				queryParameters['customfieldconditions'] = params.customfieldconditions;
			}

			if (params.page !== undefined) {
				queryParameters['page'] = params.page;
			}

			if (params.pageSize !== undefined) {
				queryParameters['pageSize'] = params.pageSize;
			}

			let fetchParams = {
				method: 'GET',
				headers: headerParams,

			};

			if (extraFetchParams) {
				fetchParams = assign(fetchParams, extraFetchParams);
			}

			let localVarPathWithQueryParameters = localVarPath + (localVarPath.indexOf('?') !== -1 ? '&' : '?') + querystring.stringify(queryParameters);

			return fetch(localVarPathWithQueryParameters, fetchParams).then((response) => {
				if (response.status >= 200 && response.status < 300) {
					return response.json();
				} else {
					let error = new Error(response.statusText);
					(error as any).response = response;
					throw error;
				}
			});
		}
		/**
		 *
		 * Create Work Role Exclusion
		 * @param id
		 * @param workRoleExclusion
		 */
		public financeAgreementsIdWorkRoleExclusionsPost (params: {  id: number; workRoleExclusion: AgreementWorkRoleExclusion; }, extraQueryParams?: any, extraFetchParams?: any ) : Promise<AgreementWorkRoleExclusion> {
			const localVarPath = this.basePath + '/finance/agreements/{id}/workRoleExclusions'
				.replace('{' + 'id' + '}', String(params.id));

			let queryParameters: any = assign({}, extraQueryParams);
			let headerParams: any = assign({}, this.defaultHeaders);
			headerParams['Content-Type'] = 'application/json';

			// verify required parameter 'id' is set
			if (params.id == null) {
				throw new Error('Missing required parameter id when calling financeAgreementsIdWorkRoleExclusionsPost');
			}
			// verify required parameter 'workRoleExclusion' is set
			if (params.workRoleExclusion == null) {
				throw new Error('Missing required parameter workRoleExclusion when calling financeAgreementsIdWorkRoleExclusionsPost');
			}
			let fetchParams = {
				method: 'POST',
				headers: headerParams,
				body: JSON.stringify(params.workRoleExclusion),

			};

			if (extraFetchParams) {
				fetchParams = assign(fetchParams, extraFetchParams);
			}

			let localVarPathWithQueryParameters = localVarPath + (localVarPath.indexOf('?') !== -1 ? '&' : '?') + querystring.stringify(queryParameters);

			return fetch(localVarPathWithQueryParameters, fetchParams).then((response) => {
				if (response.status >= 200 && response.status < 300) {
					return response.json();
				} else {
					let error = new Error(response.statusText);
					(error as any).response = response;
					throw error;
				}
			});
		}
		/**
		 *
		 * Delete Work Role Exclusion By Id
		 * @param id
		 * @param workRoleExclusionId
		 */
		public financeAgreementsIdWorkRoleExclusionsWorkRoleExclusionIdDelete (params: {  id: number; workRoleExclusionId: number; }, extraQueryParams?: any, extraFetchParams?: any ) : Promise<{}> {
			const localVarPath = this.basePath + '/finance/agreements/{id}/workRoleExclusions/{workRoleExclusionId}'
				.replace('{' + 'id' + '}', String(params.id))
				.replace('{' + 'workRoleExclusionId' + '}', String(params.workRoleExclusionId));

			let queryParameters: any = assign({}, extraQueryParams);
			let headerParams: any = assign({}, this.defaultHeaders);
			// verify required parameter 'id' is set
			if (params.id == null) {
				throw new Error('Missing required parameter id when calling financeAgreementsIdWorkRoleExclusionsWorkRoleExclusionIdDelete');
			}
			// verify required parameter 'workRoleExclusionId' is set
			if (params.workRoleExclusionId == null) {
				throw new Error('Missing required parameter workRoleExclusionId when calling financeAgreementsIdWorkRoleExclusionsWorkRoleExclusionIdDelete');
			}
			let fetchParams = {
				method: 'DELETE',
				headers: headerParams,

			};

			if (extraFetchParams) {
				fetchParams = assign(fetchParams, extraFetchParams);
			}

			let localVarPathWithQueryParameters = localVarPath + (localVarPath.indexOf('?') !== -1 ? '&' : '?') + querystring.stringify(queryParameters);

			return fetch(localVarPathWithQueryParameters, fetchParams).then((response) => {
				if (response.status >= 200 && response.status < 300) {
					return response.json();
				} else {
					let error = new Error(response.statusText);
					(error as any).response = response;
					throw error;
				}
			});
		}
	}
//}
//export namespace  {
	'use strict';

	export class AgreementWorkRolesApi {
		protected basePath = 'https://api-na.myconnectwise.net/v4_6_release/apis/3.0';
		public defaultHeaders : any = {};

		constructor(basePath?: string) {
			if (basePath) {
				this.basePath = basePath;
			}
		}

		/**
		 *
		 * Get Work Roles Count
		 * @param id
		 * @param conditions
		 */
		public financeAgreementsIdWorkrolesCountGet (params: {  id: number; conditions?: string; }, extraQueryParams?: any, extraFetchParams?: any ) : Promise<Count> {
			const localVarPath = this.basePath + '/finance/agreements/{id}/workroles/count'
				.replace('{' + 'id' + '}', String(params.id));

			let queryParameters: any = assign({}, extraQueryParams);
			let headerParams: any = assign({}, this.defaultHeaders);
			// verify required parameter 'id' is set
			if (params.id == null) {
				throw new Error('Missing required parameter id when calling financeAgreementsIdWorkrolesCountGet');
			}
			if (params.conditions !== undefined) {
				queryParameters['conditions'] = params.conditions;
			}

			let fetchParams = {
				method: 'GET',
				headers: headerParams,

			};

			if (extraFetchParams) {
				fetchParams = assign(fetchParams, extraFetchParams);
			}

			let localVarPathWithQueryParameters = localVarPath + (localVarPath.indexOf('?') !== -1 ? '&' : '?') + querystring.stringify(queryParameters);

			return fetch(localVarPathWithQueryParameters, fetchParams).then((response) => {
				if (response.status >= 200 && response.status < 300) {
					return response.json();
				} else {
					let error = new Error(response.statusText);
					(error as any).response = response;
					throw error;
				}
			});
		}
		/**
		 *
		 * Get Work Roles
		 * @param id
		 * @param conditions
		 * @param orderBy
		 * @param childconditions
		 * @param customfieldconditions
		 * @param page
		 * @param pageSize
		 */
		public financeAgreementsIdWorkrolesGet (params: {  id: number; conditions?: string; orderBy?: string; childconditions?: string; customfieldconditions?: string; page?: number; pageSize?: number; }, extraQueryParams?: any, extraFetchParams?: any ) : Promise<Array<AgreementWorkRole>> {
			const localVarPath = this.basePath + '/finance/agreements/{id}/workroles'
				.replace('{' + 'id' + '}', String(params.id));

			let queryParameters: any = assign({}, extraQueryParams);
			let headerParams: any = assign({}, this.defaultHeaders);
			// verify required parameter 'id' is set
			if (params.id == null) {
				throw new Error('Missing required parameter id when calling financeAgreementsIdWorkrolesGet');
			}
			if (params.conditions !== undefined) {
				queryParameters['conditions'] = params.conditions;
			}

			if (params.orderBy !== undefined) {
				queryParameters['orderBy'] = params.orderBy;
			}

			if (params.childconditions !== undefined) {
				queryParameters['childconditions'] = params.childconditions;
			}

			if (params.customfieldconditions !== undefined) {
				queryParameters['customfieldconditions'] = params.customfieldconditions;
			}

			if (params.page !== undefined) {
				queryParameters['page'] = params.page;
			}

			if (params.pageSize !== undefined) {
				queryParameters['pageSize'] = params.pageSize;
			}

			let fetchParams = {
				method: 'GET',
				headers: headerParams,

			};

			if (extraFetchParams) {
				fetchParams = assign(fetchParams, extraFetchParams);
			}

			let localVarPathWithQueryParameters = localVarPath + (localVarPath.indexOf('?') !== -1 ? '&' : '?') + querystring.stringify(queryParameters);

			return fetch(localVarPathWithQueryParameters, fetchParams).then((response) => {
				if (response.status >= 200 && response.status < 300) {
					return response.json();
				} else {
					let error = new Error(response.statusText);
					(error as any).response = response;
					throw error;
				}
			});
		}
		/**
		 *
		 * Create Work Role
		 * @param id
		 * @param workRole
		 */
		public financeAgreementsIdWorkrolesPost (params: {  id: number; workRole: AgreementWorkRole; }, extraQueryParams?: any, extraFetchParams?: any ) : Promise<AgreementWorkRole> {
			const localVarPath = this.basePath + '/finance/agreements/{id}/workroles'
				.replace('{' + 'id' + '}', String(params.id));

			let queryParameters: any = assign({}, extraQueryParams);
			let headerParams: any = assign({}, this.defaultHeaders);
			headerParams['Content-Type'] = 'application/json';

			// verify required parameter 'id' is set
			if (params.id == null) {
				throw new Error('Missing required parameter id when calling financeAgreementsIdWorkrolesPost');
			}
			// verify required parameter 'workRole' is set
			if (params.workRole == null) {
				throw new Error('Missing required parameter workRole when calling financeAgreementsIdWorkrolesPost');
			}
			let fetchParams = {
				method: 'POST',
				headers: headerParams,
				body: JSON.stringify(params.workRole),

			};

			if (extraFetchParams) {
				fetchParams = assign(fetchParams, extraFetchParams);
			}

			let localVarPathWithQueryParameters = localVarPath + (localVarPath.indexOf('?') !== -1 ? '&' : '?') + querystring.stringify(queryParameters);

			return fetch(localVarPathWithQueryParameters, fetchParams).then((response) => {
				if (response.status >= 200 && response.status < 300) {
					return response.json();
				} else {
					let error = new Error(response.statusText);
					(error as any).response = response;
					throw error;
				}
			});
		}
		/**
		 *
		 * Delete Work Role By Id
		 * @param id
		 * @param workRoleId
		 */
		public financeAgreementsIdWorkrolesWorkRoleIdDelete (params: {  id: number; workRoleId: number; }, extraQueryParams?: any, extraFetchParams?: any ) : Promise<{}> {
			const localVarPath = this.basePath + '/finance/agreements/{id}/workroles/{workRoleId}'
				.replace('{' + 'id' + '}', String(params.id))
				.replace('{' + 'workRoleId' + '}', String(params.workRoleId));

			let queryParameters: any = assign({}, extraQueryParams);
			let headerParams: any = assign({}, this.defaultHeaders);
			// verify required parameter 'id' is set
			if (params.id == null) {
				throw new Error('Missing required parameter id when calling financeAgreementsIdWorkrolesWorkRoleIdDelete');
			}
			// verify required parameter 'workRoleId' is set
			if (params.workRoleId == null) {
				throw new Error('Missing required parameter workRoleId when calling financeAgreementsIdWorkrolesWorkRoleIdDelete');
			}
			let fetchParams = {
				method: 'DELETE',
				headers: headerParams,

			};

			if (extraFetchParams) {
				fetchParams = assign(fetchParams, extraFetchParams);
			}

			let localVarPathWithQueryParameters = localVarPath + (localVarPath.indexOf('?') !== -1 ? '&' : '?') + querystring.stringify(queryParameters);

			return fetch(localVarPathWithQueryParameters, fetchParams).then((response) => {
				if (response.status >= 200 && response.status < 300) {
					return response.json();
				} else {
					let error = new Error(response.statusText);
					(error as any).response = response;
					throw error;
				}
			});
		}
		/**
		 *
		 * Get Work Role By Id
		 * @param id
		 * @param workRoleId
		 */
		public financeAgreementsIdWorkrolesWorkRoleIdGet (params: {  id: number; workRoleId: number; }, extraQueryParams?: any, extraFetchParams?: any ) : Promise<AgreementWorkRole> {
			const localVarPath = this.basePath + '/finance/agreements/{id}/workroles/{workRoleId}'
				.replace('{' + 'id' + '}', String(params.id))
				.replace('{' + 'workRoleId' + '}', String(params.workRoleId));

			let queryParameters: any = assign({}, extraQueryParams);
			let headerParams: any = assign({}, this.defaultHeaders);
			// verify required parameter 'id' is set
			if (params.id == null) {
				throw new Error('Missing required parameter id when calling financeAgreementsIdWorkrolesWorkRoleIdGet');
			}
			// verify required parameter 'workRoleId' is set
			if (params.workRoleId == null) {
				throw new Error('Missing required parameter workRoleId when calling financeAgreementsIdWorkrolesWorkRoleIdGet');
			}
			let fetchParams = {
				method: 'GET',
				headers: headerParams,

			};

			if (extraFetchParams) {
				fetchParams = assign(fetchParams, extraFetchParams);
			}

			let localVarPathWithQueryParameters = localVarPath + (localVarPath.indexOf('?') !== -1 ? '&' : '?') + querystring.stringify(queryParameters);

			return fetch(localVarPathWithQueryParameters, fetchParams).then((response) => {
				if (response.status >= 200 && response.status < 300) {
					return response.json();
				} else {
					let error = new Error(response.statusText);
					(error as any).response = response;
					throw error;
				}
			});
		}
		/**
		 *
		 * Update Work Role
		 * @param id
		 * @param workRoleId
		 * @param operations
		 */
		public financeAgreementsIdWorkrolesWorkRoleIdPatch (params: {  id: number; workRoleId: number; operations: Array<PatchOperation>; }, extraQueryParams?: any, extraFetchParams?: any ) : Promise<AgreementWorkRole> {
			const localVarPath = this.basePath + '/finance/agreements/{id}/workroles/{workRoleId}'
				.replace('{' + 'id' + '}', String(params.id))
				.replace('{' + 'workRoleId' + '}', String(params.workRoleId));

			let queryParameters: any = assign({}, extraQueryParams);
			let headerParams: any = assign({}, this.defaultHeaders);
			headerParams['Content-Type'] = 'application/json';

			// verify required parameter 'id' is set
			if (params.id == null) {
				throw new Error('Missing required parameter id when calling financeAgreementsIdWorkrolesWorkRoleIdPatch');
			}
			// verify required parameter 'workRoleId' is set
			if (params.workRoleId == null) {
				throw new Error('Missing required parameter workRoleId when calling financeAgreementsIdWorkrolesWorkRoleIdPatch');
			}
			// verify required parameter 'operations' is set
			if (params.operations == null) {
				throw new Error('Missing required parameter operations when calling financeAgreementsIdWorkrolesWorkRoleIdPatch');
			}
			let fetchParams = {
				method: 'PATCH',
				headers: headerParams,
				body: JSON.stringify(params.operations),

			};

			if (extraFetchParams) {
				fetchParams = assign(fetchParams, extraFetchParams);
			}

			let localVarPathWithQueryParameters = localVarPath + (localVarPath.indexOf('?') !== -1 ? '&' : '?') + querystring.stringify(queryParameters);

			return fetch(localVarPathWithQueryParameters, fetchParams).then((response) => {
				if (response.status >= 200 && response.status < 300) {
					return response.json();
				} else {
					let error = new Error(response.statusText);
					(error as any).response = response;
					throw error;
				}
			});
		}
		/**
		 *
		 * Replace Work Role
		 * @param id
		 * @param workRoleId
		 * @param workRole
		 */
		public financeAgreementsIdWorkrolesWorkRoleIdPut (params: {  id: number; workRoleId: number; workRole: AgreementWorkRole; }, extraQueryParams?: any, extraFetchParams?: any ) : Promise<AgreementWorkRole> {
			const localVarPath = this.basePath + '/finance/agreements/{id}/workroles/{workRoleId}'
				.replace('{' + 'id' + '}', String(params.id))
				.replace('{' + 'workRoleId' + '}', String(params.workRoleId));

			let queryParameters: any = assign({}, extraQueryParams);
			let headerParams: any = assign({}, this.defaultHeaders);
			headerParams['Content-Type'] = 'application/json';

			// verify required parameter 'id' is set
			if (params.id == null) {
				throw new Error('Missing required parameter id when calling financeAgreementsIdWorkrolesWorkRoleIdPut');
			}
			// verify required parameter 'workRoleId' is set
			if (params.workRoleId == null) {
				throw new Error('Missing required parameter workRoleId when calling financeAgreementsIdWorkrolesWorkRoleIdPut');
			}
			// verify required parameter 'workRole' is set
			if (params.workRole == null) {
				throw new Error('Missing required parameter workRole when calling financeAgreementsIdWorkrolesWorkRoleIdPut');
			}
			let fetchParams = {
				method: 'PUT',
				headers: headerParams,
				body: JSON.stringify(params.workRole),

			};

			if (extraFetchParams) {
				fetchParams = assign(fetchParams, extraFetchParams);
			}

			let localVarPathWithQueryParameters = localVarPath + (localVarPath.indexOf('?') !== -1 ? '&' : '?') + querystring.stringify(queryParameters);

			return fetch(localVarPathWithQueryParameters, fetchParams).then((response) => {
				if (response.status >= 200 && response.status < 300) {
					return response.json();
				} else {
					let error = new Error(response.statusText);
					(error as any).response = response;
					throw error;
				}
			});
		}
	}
//}
//export namespace  {
	'use strict';

	export class AgreementWorkTypeExclusionsApi {
		protected basePath = 'https://api-na.myconnectwise.net/v4_6_release/apis/3.0';
		public defaultHeaders : any = {};

		constructor(basePath?: string) {
			if (basePath) {
				this.basePath = basePath;
			}
		}

		/**
		 *
		 * Get Work Type Exclusions Count
		 * @param id
		 * @param conditions
		 */
		public financeAgreementsIdWorkTypeExclusionsCountGet (params: {  id: number; conditions?: string; }, extraQueryParams?: any, extraFetchParams?: any ) : Promise<Count> {
			const localVarPath = this.basePath + '/finance/agreements/{id}/workTypeExclusions/count'
				.replace('{' + 'id' + '}', String(params.id));

			let queryParameters: any = assign({}, extraQueryParams);
			let headerParams: any = assign({}, this.defaultHeaders);
			// verify required parameter 'id' is set
			if (params.id == null) {
				throw new Error('Missing required parameter id when calling financeAgreementsIdWorkTypeExclusionsCountGet');
			}
			if (params.conditions !== undefined) {
				queryParameters['conditions'] = params.conditions;
			}

			let fetchParams = {
				method: 'GET',
				headers: headerParams,

			};

			if (extraFetchParams) {
				fetchParams = assign(fetchParams, extraFetchParams);
			}

			let localVarPathWithQueryParameters = localVarPath + (localVarPath.indexOf('?') !== -1 ? '&' : '?') + querystring.stringify(queryParameters);

			return fetch(localVarPathWithQueryParameters, fetchParams).then((response) => {
				if (response.status >= 200 && response.status < 300) {
					return response.json();
				} else {
					let error = new Error(response.statusText);
					(error as any).response = response;
					throw error;
				}
			});
		}
		/**
		 *
		 * Get Work Type Exclusions
		 * @param id
		 * @param conditions
		 * @param orderBy
		 * @param childconditions
		 * @param customfieldconditions
		 * @param page
		 * @param pageSize
		 */
		public financeAgreementsIdWorkTypeExclusionsGet (params: {  id: number; conditions?: string; orderBy?: string; childconditions?: string; customfieldconditions?: string; page?: number; pageSize?: number; }, extraQueryParams?: any, extraFetchParams?: any ) : Promise<Array<AgreementWorkTypeExclusion>> {
			const localVarPath = this.basePath + '/finance/agreements/{id}/workTypeExclusions'
				.replace('{' + 'id' + '}', String(params.id));

			let queryParameters: any = assign({}, extraQueryParams);
			let headerParams: any = assign({}, this.defaultHeaders);
			// verify required parameter 'id' is set
			if (params.id == null) {
				throw new Error('Missing required parameter id when calling financeAgreementsIdWorkTypeExclusionsGet');
			}
			if (params.conditions !== undefined) {
				queryParameters['conditions'] = params.conditions;
			}

			if (params.orderBy !== undefined) {
				queryParameters['orderBy'] = params.orderBy;
			}

			if (params.childconditions !== undefined) {
				queryParameters['childconditions'] = params.childconditions;
			}

			if (params.customfieldconditions !== undefined) {
				queryParameters['customfieldconditions'] = params.customfieldconditions;
			}

			if (params.page !== undefined) {
				queryParameters['page'] = params.page;
			}

			if (params.pageSize !== undefined) {
				queryParameters['pageSize'] = params.pageSize;
			}

			let fetchParams = {
				method: 'GET',
				headers: headerParams,

			};

			if (extraFetchParams) {
				fetchParams = assign(fetchParams, extraFetchParams);
			}

			let localVarPathWithQueryParameters = localVarPath + (localVarPath.indexOf('?') !== -1 ? '&' : '?') + querystring.stringify(queryParameters);

			return fetch(localVarPathWithQueryParameters, fetchParams).then((response) => {
				if (response.status >= 200 && response.status < 300) {
					return response.json();
				} else {
					let error = new Error(response.statusText);
					(error as any).response = response;
					throw error;
				}
			});
		}
		/**
		 *
		 * Create Work Type Exclusion
		 * @param id
		 * @param workTypeExclusion
		 */
		public financeAgreementsIdWorkTypeExclusionsPost (params: {  id: number; workTypeExclusion: AgreementWorkTypeExclusion; }, extraQueryParams?: any, extraFetchParams?: any ) : Promise<AgreementWorkTypeExclusion> {
			const localVarPath = this.basePath + '/finance/agreements/{id}/workTypeExclusions'
				.replace('{' + 'id' + '}', String(params.id));

			let queryParameters: any = assign({}, extraQueryParams);
			let headerParams: any = assign({}, this.defaultHeaders);
			headerParams['Content-Type'] = 'application/json';

			// verify required parameter 'id' is set
			if (params.id == null) {
				throw new Error('Missing required parameter id when calling financeAgreementsIdWorkTypeExclusionsPost');
			}
			// verify required parameter 'workTypeExclusion' is set
			if (params.workTypeExclusion == null) {
				throw new Error('Missing required parameter workTypeExclusion when calling financeAgreementsIdWorkTypeExclusionsPost');
			}
			let fetchParams = {
				method: 'POST',
				headers: headerParams,
				body: JSON.stringify(params.workTypeExclusion),

			};

			if (extraFetchParams) {
				fetchParams = assign(fetchParams, extraFetchParams);
			}

			let localVarPathWithQueryParameters = localVarPath + (localVarPath.indexOf('?') !== -1 ? '&' : '?') + querystring.stringify(queryParameters);

			return fetch(localVarPathWithQueryParameters, fetchParams).then((response) => {
				if (response.status >= 200 && response.status < 300) {
					return response.json();
				} else {
					let error = new Error(response.statusText);
					(error as any).response = response;
					throw error;
				}
			});
		}
		/**
		 *
		 * Delete Work Type Exclusion By Id
		 * @param id
		 * @param workTypeExclusionId
		 */
		public financeAgreementsIdWorkTypeExclusionsWorkTypeExclusionIdDelete (params: {  id: number; workTypeExclusionId: number; }, extraQueryParams?: any, extraFetchParams?: any ) : Promise<{}> {
			const localVarPath = this.basePath + '/finance/agreements/{id}/workTypeExclusions/{workTypeExclusionId}'
				.replace('{' + 'id' + '}', String(params.id))
				.replace('{' + 'workTypeExclusionId' + '}', String(params.workTypeExclusionId));

			let queryParameters: any = assign({}, extraQueryParams);
			let headerParams: any = assign({}, this.defaultHeaders);
			// verify required parameter 'id' is set
			if (params.id == null) {
				throw new Error('Missing required parameter id when calling financeAgreementsIdWorkTypeExclusionsWorkTypeExclusionIdDelete');
			}
			// verify required parameter 'workTypeExclusionId' is set
			if (params.workTypeExclusionId == null) {
				throw new Error('Missing required parameter workTypeExclusionId when calling financeAgreementsIdWorkTypeExclusionsWorkTypeExclusionIdDelete');
			}
			let fetchParams = {
				method: 'DELETE',
				headers: headerParams,

			};

			if (extraFetchParams) {
				fetchParams = assign(fetchParams, extraFetchParams);
			}

			let localVarPathWithQueryParameters = localVarPath + (localVarPath.indexOf('?') !== -1 ? '&' : '?') + querystring.stringify(queryParameters);

			return fetch(localVarPathWithQueryParameters, fetchParams).then((response) => {
				if (response.status >= 200 && response.status < 300) {
					return response.json();
				} else {
					let error = new Error(response.statusText);
					(error as any).response = response;
					throw error;
				}
			});
		}
	}
//}
//export namespace  {
	'use strict';

	export class AgreementWorkTypesApi {
		protected basePath = 'https://api-na.myconnectwise.net/v4_6_release/apis/3.0';
		public defaultHeaders : any = {};

		constructor(basePath?: string) {
			if (basePath) {
				this.basePath = basePath;
			}
		}

		/**
		 *
		 * Get Work Types Count
		 * @param id
		 * @param conditions
		 */
		public financeAgreementsIdWorktypesCountGet (params: {  id: number; conditions?: string; }, extraQueryParams?: any, extraFetchParams?: any ) : Promise<Count> {
			const localVarPath = this.basePath + '/finance/agreements/{id}/worktypes/count'
				.replace('{' + 'id' + '}', String(params.id));

			let queryParameters: any = assign({}, extraQueryParams);
			let headerParams: any = assign({}, this.defaultHeaders);
			// verify required parameter 'id' is set
			if (params.id == null) {
				throw new Error('Missing required parameter id when calling financeAgreementsIdWorktypesCountGet');
			}
			if (params.conditions !== undefined) {
				queryParameters['conditions'] = params.conditions;
			}

			let fetchParams = {
				method: 'GET',
				headers: headerParams,

			};

			if (extraFetchParams) {
				fetchParams = assign(fetchParams, extraFetchParams);
			}

			let localVarPathWithQueryParameters = localVarPath + (localVarPath.indexOf('?') !== -1 ? '&' : '?') + querystring.stringify(queryParameters);

			return fetch(localVarPathWithQueryParameters, fetchParams).then((response) => {
				if (response.status >= 200 && response.status < 300) {
					return response.json();
				} else {
					let error = new Error(response.statusText);
					(error as any).response = response;
					throw error;
				}
			});
		}
		/**
		 *
		 * Get Work Types
		 * @param id
		 * @param conditions
		 * @param orderBy
		 * @param childconditions
		 * @param customfieldconditions
		 * @param page
		 * @param pageSize
		 */
		public financeAgreementsIdWorktypesGet (params: {  id: number; conditions?: string; orderBy?: string; childconditions?: string; customfieldconditions?: string; page?: number; pageSize?: number; }, extraQueryParams?: any, extraFetchParams?: any ) : Promise<Array<AgreementWorkType>> {
			const localVarPath = this.basePath + '/finance/agreements/{id}/worktypes'
				.replace('{' + 'id' + '}', String(params.id));

			let queryParameters: any = assign({}, extraQueryParams);
			let headerParams: any = assign({}, this.defaultHeaders);
			// verify required parameter 'id' is set
			if (params.id == null) {
				throw new Error('Missing required parameter id when calling financeAgreementsIdWorktypesGet');
			}
			if (params.conditions !== undefined) {
				queryParameters['conditions'] = params.conditions;
			}

			if (params.orderBy !== undefined) {
				queryParameters['orderBy'] = params.orderBy;
			}

			if (params.childconditions !== undefined) {
				queryParameters['childconditions'] = params.childconditions;
			}

			if (params.customfieldconditions !== undefined) {
				queryParameters['customfieldconditions'] = params.customfieldconditions;
			}

			if (params.page !== undefined) {
				queryParameters['page'] = params.page;
			}

			if (params.pageSize !== undefined) {
				queryParameters['pageSize'] = params.pageSize;
			}

			let fetchParams = {
				method: 'GET',
				headers: headerParams,

			};

			if (extraFetchParams) {
				fetchParams = assign(fetchParams, extraFetchParams);
			}

			let localVarPathWithQueryParameters = localVarPath + (localVarPath.indexOf('?') !== -1 ? '&' : '?') + querystring.stringify(queryParameters);

			return fetch(localVarPathWithQueryParameters, fetchParams).then((response) => {
				if (response.status >= 200 && response.status < 300) {
					return response.json();
				} else {
					let error = new Error(response.statusText);
					(error as any).response = response;
					throw error;
				}
			});
		}
		/**
		 *
		 * Create Work Type
		 * @param id
		 * @param workType
		 */
		public financeAgreementsIdWorktypesPost (params: {  id: number; workType: AgreementWorkType; }, extraQueryParams?: any, extraFetchParams?: any ) : Promise<AgreementWorkType> {
			const localVarPath = this.basePath + '/finance/agreements/{id}/worktypes'
				.replace('{' + 'id' + '}', String(params.id));

			let queryParameters: any = assign({}, extraQueryParams);
			let headerParams: any = assign({}, this.defaultHeaders);
			headerParams['Content-Type'] = 'application/json';

			// verify required parameter 'id' is set
			if (params.id == null) {
				throw new Error('Missing required parameter id when calling financeAgreementsIdWorktypesPost');
			}
			// verify required parameter 'workType' is set
			if (params.workType == null) {
				throw new Error('Missing required parameter workType when calling financeAgreementsIdWorktypesPost');
			}
			let fetchParams = {
				method: 'POST',
				headers: headerParams,
				body: JSON.stringify(params.workType),

			};

			if (extraFetchParams) {
				fetchParams = assign(fetchParams, extraFetchParams);
			}

			let localVarPathWithQueryParameters = localVarPath + (localVarPath.indexOf('?') !== -1 ? '&' : '?') + querystring.stringify(queryParameters);

			return fetch(localVarPathWithQueryParameters, fetchParams).then((response) => {
				if (response.status >= 200 && response.status < 300) {
					return response.json();
				} else {
					let error = new Error(response.statusText);
					(error as any).response = response;
					throw error;
				}
			});
		}
		/**
		 *
		 * Delete Work Type By Id
		 * @param id
		 * @param worktypeId
		 */
		public financeAgreementsIdWorktypesWorktypeIdDelete (params: {  id: number; worktypeId: number; }, extraQueryParams?: any, extraFetchParams?: any ) : Promise<{}> {
			const localVarPath = this.basePath + '/finance/agreements/{id}/worktypes/{worktypeId}'
				.replace('{' + 'id' + '}', String(params.id))
				.replace('{' + 'worktypeId' + '}', String(params.worktypeId));

			let queryParameters: any = assign({}, extraQueryParams);
			let headerParams: any = assign({}, this.defaultHeaders);
			// verify required parameter 'id' is set
			if (params.id == null) {
				throw new Error('Missing required parameter id when calling financeAgreementsIdWorktypesWorktypeIdDelete');
			}
			// verify required parameter 'worktypeId' is set
			if (params.worktypeId == null) {
				throw new Error('Missing required parameter worktypeId when calling financeAgreementsIdWorktypesWorktypeIdDelete');
			}
			let fetchParams = {
				method: 'DELETE',
				headers: headerParams,

			};

			if (extraFetchParams) {
				fetchParams = assign(fetchParams, extraFetchParams);
			}

			let localVarPathWithQueryParameters = localVarPath + (localVarPath.indexOf('?') !== -1 ? '&' : '?') + querystring.stringify(queryParameters);

			return fetch(localVarPathWithQueryParameters, fetchParams).then((response) => {
				if (response.status >= 200 && response.status < 300) {
					return response.json();
				} else {
					let error = new Error(response.statusText);
					(error as any).response = response;
					throw error;
				}
			});
		}
		/**
		 *
		 * Get Work Type By Id
		 * @param id
		 * @param worktypeId
		 */
		public financeAgreementsIdWorktypesWorktypeIdGet (params: {  id: number; worktypeId: number; }, extraQueryParams?: any, extraFetchParams?: any ) : Promise<AgreementWorkType> {
			const localVarPath = this.basePath + '/finance/agreements/{id}/worktypes/{worktypeId}'
				.replace('{' + 'id' + '}', String(params.id))
				.replace('{' + 'worktypeId' + '}', String(params.worktypeId));

			let queryParameters: any = assign({}, extraQueryParams);
			let headerParams: any = assign({}, this.defaultHeaders);
			// verify required parameter 'id' is set
			if (params.id == null) {
				throw new Error('Missing required parameter id when calling financeAgreementsIdWorktypesWorktypeIdGet');
			}
			// verify required parameter 'worktypeId' is set
			if (params.worktypeId == null) {
				throw new Error('Missing required parameter worktypeId when calling financeAgreementsIdWorktypesWorktypeIdGet');
			}
			let fetchParams = {
				method: 'GET',
				headers: headerParams,

			};

			if (extraFetchParams) {
				fetchParams = assign(fetchParams, extraFetchParams);
			}

			let localVarPathWithQueryParameters = localVarPath + (localVarPath.indexOf('?') !== -1 ? '&' : '?') + querystring.stringify(queryParameters);

			return fetch(localVarPathWithQueryParameters, fetchParams).then((response) => {
				if (response.status >= 200 && response.status < 300) {
					return response.json();
				} else {
					let error = new Error(response.statusText);
					(error as any).response = response;
					throw error;
				}
			});
		}
		/**
		 *
		 * Update Work Type
		 * @param id
		 * @param worktypeId
		 * @param operations
		 */
		public financeAgreementsIdWorktypesWorktypeIdPatch (params: {  id: number; worktypeId: number; operations: Array<PatchOperation>; }, extraQueryParams?: any, extraFetchParams?: any ) : Promise<AgreementWorkType> {
			const localVarPath = this.basePath + '/finance/agreements/{id}/worktypes/{worktypeId}'
				.replace('{' + 'id' + '}', String(params.id))
				.replace('{' + 'worktypeId' + '}', String(params.worktypeId));

			let queryParameters: any = assign({}, extraQueryParams);
			let headerParams: any = assign({}, this.defaultHeaders);
			headerParams['Content-Type'] = 'application/json';

			// verify required parameter 'id' is set
			if (params.id == null) {
				throw new Error('Missing required parameter id when calling financeAgreementsIdWorktypesWorktypeIdPatch');
			}
			// verify required parameter 'worktypeId' is set
			if (params.worktypeId == null) {
				throw new Error('Missing required parameter worktypeId when calling financeAgreementsIdWorktypesWorktypeIdPatch');
			}
			// verify required parameter 'operations' is set
			if (params.operations == null) {
				throw new Error('Missing required parameter operations when calling financeAgreementsIdWorktypesWorktypeIdPatch');
			}
			let fetchParams = {
				method: 'PATCH',
				headers: headerParams,
				body: JSON.stringify(params.operations),

			};

			if (extraFetchParams) {
				fetchParams = assign(fetchParams, extraFetchParams);
			}

			let localVarPathWithQueryParameters = localVarPath + (localVarPath.indexOf('?') !== -1 ? '&' : '?') + querystring.stringify(queryParameters);

			return fetch(localVarPathWithQueryParameters, fetchParams).then((response) => {
				if (response.status >= 200 && response.status < 300) {
					return response.json();
				} else {
					let error = new Error(response.statusText);
					(error as any).response = response;
					throw error;
				}
			});
		}
		/**
		 *
		 * Replace Work Type
		 * @param id
		 * @param worktypeId
		 * @param workType
		 */
		public financeAgreementsIdWorktypesWorktypeIdPut (params: {  id: number; worktypeId: number; workType: AgreementWorkType; }, extraQueryParams?: any, extraFetchParams?: any ) : Promise<AgreementWorkType> {
			const localVarPath = this.basePath + '/finance/agreements/{id}/worktypes/{worktypeId}'
				.replace('{' + 'id' + '}', String(params.id))
				.replace('{' + 'worktypeId' + '}', String(params.worktypeId));

			let queryParameters: any = assign({}, extraQueryParams);
			let headerParams: any = assign({}, this.defaultHeaders);
			headerParams['Content-Type'] = 'application/json';

			// verify required parameter 'id' is set
			if (params.id == null) {
				throw new Error('Missing required parameter id when calling financeAgreementsIdWorktypesWorktypeIdPut');
			}
			// verify required parameter 'worktypeId' is set
			if (params.worktypeId == null) {
				throw new Error('Missing required parameter worktypeId when calling financeAgreementsIdWorktypesWorktypeIdPut');
			}
			// verify required parameter 'workType' is set
			if (params.workType == null) {
				throw new Error('Missing required parameter workType when calling financeAgreementsIdWorktypesWorktypeIdPut');
			}
			let fetchParams = {
				method: 'PUT',
				headers: headerParams,
				body: JSON.stringify(params.workType),

			};

			if (extraFetchParams) {
				fetchParams = assign(fetchParams, extraFetchParams);
			}

			let localVarPathWithQueryParameters = localVarPath + (localVarPath.indexOf('?') !== -1 ? '&' : '?') + querystring.stringify(queryParameters);

			return fetch(localVarPathWithQueryParameters, fetchParams).then((response) => {
				if (response.status >= 200 && response.status < 300) {
					return response.json();
				} else {
					let error = new Error(response.statusText);
					(error as any).response = response;
					throw error;
				}
			});
		}
	}
//}
//export namespace  {
	'use strict';

	export class AgreementsApi {
		protected basePath = 'https://api-na.myconnectwise.net/v4_6_release/apis/3.0';
		public defaultHeaders : any = {};

		constructor(basePath?: string) {
			if (basePath) {
				this.basePath = basePath;
			}
		}

		/**
		 *
		 * Get Agreements Count
		 * @param conditions
		 * @param customFieldConditions
		 */
		public financeAgreementsCountGet (params: {  conditions?: string; customFieldConditions?: string; }, extraQueryParams?: any, extraFetchParams?: any ) : Promise<Count> {
			const localVarPath = this.basePath + '/finance/agreements/count';

			let queryParameters: any = assign({}, extraQueryParams);
			let headerParams: any = assign({}, this.defaultHeaders);
			if (params.conditions !== undefined) {
				queryParameters['conditions'] = params.conditions;
			}

			if (params.customFieldConditions !== undefined) {
				queryParameters['customFieldConditions'] = params.customFieldConditions;
			}

			let fetchParams = {
				method: 'GET',
				headers: headerParams,

			};

			if (extraFetchParams) {
				fetchParams = assign(fetchParams, extraFetchParams);
			}

			let localVarPathWithQueryParameters = localVarPath + (localVarPath.indexOf('?') !== -1 ? '&' : '?') + querystring.stringify(queryParameters);

			return fetch(localVarPathWithQueryParameters, fetchParams).then((response) => {
				if (response.status >= 200 && response.status < 300) {
					return response.json();
				} else {
					let error = new Error(response.statusText);
					(error as any).response = response;
					throw error;
				}
			});
		}
		/**
		 *
		 * Get Agreements
		 * @param conditions
		 * @param orderBy
		 * @param childconditions
		 * @param customfieldconditions
		 * @param page
		 * @param pageSize
		 */
		public financeAgreementsGet (params: {  conditions?: string; orderBy?: string; childconditions?: string; customfieldconditions?: string; page?: number; pageSize?: number; }, extraQueryParams?: any, extraFetchParams?: any ) : Promise<Array<Agreement>> {
			const localVarPath = this.basePath + '/finance/agreements';

			let queryParameters: any = assign({}, extraQueryParams);
			let headerParams: any = assign({}, this.defaultHeaders);
			if (params.conditions !== undefined) {
				queryParameters['conditions'] = params.conditions;
			}

			if (params.orderBy !== undefined) {
				queryParameters['orderBy'] = params.orderBy;
			}

			if (params.childconditions !== undefined) {
				queryParameters['childconditions'] = params.childconditions;
			}

			if (params.customfieldconditions !== undefined) {
				queryParameters['customfieldconditions'] = params.customfieldconditions;
			}

			if (params.page !== undefined) {
				queryParameters['page'] = params.page;
			}

			if (params.pageSize !== undefined) {
				queryParameters['pageSize'] = params.pageSize;
			}

			let fetchParams = {
				method: 'GET',
				headers: headerParams,

			};

			if (extraFetchParams) {
				fetchParams = assign(fetchParams, extraFetchParams);
			}

			let localVarPathWithQueryParameters = localVarPath + (localVarPath.indexOf('?') !== -1 ? '&' : '?') + querystring.stringify(queryParameters);

			return fetch(localVarPathWithQueryParameters, fetchParams).then((response) => {
				if (response.status >= 200 && response.status < 300) {
					return response.json();
				} else {
					let error = new Error(response.statusText);
					(error as any).response = response;
					throw error;
				}
			});
		}
		/**
		 *
		 * Delete Configuration Association
		 * @param id
		 * @param configurationId
		 */
		public financeAgreementsIdConfigurationsConfigurationIdDelete (params: {  id: number; configurationId: number; }, extraQueryParams?: any, extraFetchParams?: any ) : Promise<{}> {
			const localVarPath = this.basePath + '/finance/agreements/{id}/configurations/{configurationId}'
				.replace('{' + 'id' + '}', String(params.id))
				.replace('{' + 'configurationId' + '}', String(params.configurationId));

			let queryParameters: any = assign({}, extraQueryParams);
			let headerParams: any = assign({}, this.defaultHeaders);
			// verify required parameter 'id' is set
			if (params.id == null) {
				throw new Error('Missing required parameter id when calling financeAgreementsIdConfigurationsConfigurationIdDelete');
			}
			// verify required parameter 'configurationId' is set
			if (params.configurationId == null) {
				throw new Error('Missing required parameter configurationId when calling financeAgreementsIdConfigurationsConfigurationIdDelete');
			}
			let fetchParams = {
				method: 'DELETE',
				headers: headerParams,

			};

			if (extraFetchParams) {
				fetchParams = assign(fetchParams, extraFetchParams);
			}

			let localVarPathWithQueryParameters = localVarPath + (localVarPath.indexOf('?') !== -1 ? '&' : '?') + querystring.stringify(queryParameters);

			return fetch(localVarPathWithQueryParameters, fetchParams).then((response) => {
				if (response.status >= 200 && response.status < 300) {
					return response.json();
				} else {
					let error = new Error(response.statusText);
					(error as any).response = response;
					throw error;
				}
			});
		}
		/**
		 *
		 * Get Configuration Association
		 * @param id
		 * @param configurationId
		 */
		public financeAgreementsIdConfigurationsConfigurationIdGet (params: {  id: number; configurationId: number; }, extraQueryParams?: any, extraFetchParams?: any ) : Promise<ConfigurationReference> {
			const localVarPath = this.basePath + '/finance/agreements/{id}/configurations/{configurationId}'
				.replace('{' + 'id' + '}', String(params.id))
				.replace('{' + 'configurationId' + '}', String(params.configurationId));

			let queryParameters: any = assign({}, extraQueryParams);
			let headerParams: any = assign({}, this.defaultHeaders);
			// verify required parameter 'id' is set
			if (params.id == null) {
				throw new Error('Missing required parameter id when calling financeAgreementsIdConfigurationsConfigurationIdGet');
			}
			// verify required parameter 'configurationId' is set
			if (params.configurationId == null) {
				throw new Error('Missing required parameter configurationId when calling financeAgreementsIdConfigurationsConfigurationIdGet');
			}
			let fetchParams = {
				method: 'GET',
				headers: headerParams,

			};

			if (extraFetchParams) {
				fetchParams = assign(fetchParams, extraFetchParams);
			}

			let localVarPathWithQueryParameters = localVarPath + (localVarPath.indexOf('?') !== -1 ? '&' : '?') + querystring.stringify(queryParameters);

			return fetch(localVarPathWithQueryParameters, fetchParams).then((response) => {
				if (response.status >= 200 && response.status < 300) {
					return response.json();
				} else {
					let error = new Error(response.statusText);
					(error as any).response = response;
					throw error;
				}
			});
		}
		/**
		 *
		 * Get Agreement Configurations Count
		 * @param id
		 */
		public financeAgreementsIdConfigurationsCountGet (params: {  id: number; }, extraQueryParams?: any, extraFetchParams?: any ) : Promise<Count> {
			const localVarPath = this.basePath + '/finance/agreements/{id}/configurations/count'
				.replace('{' + 'id' + '}', String(params.id));

			let queryParameters: any = assign({}, extraQueryParams);
			let headerParams: any = assign({}, this.defaultHeaders);
			// verify required parameter 'id' is set
			if (params.id == null) {
				throw new Error('Missing required parameter id when calling financeAgreementsIdConfigurationsCountGet');
			}
			let fetchParams = {
				method: 'GET',
				headers: headerParams,

			};

			if (extraFetchParams) {
				fetchParams = assign(fetchParams, extraFetchParams);
			}

			let localVarPathWithQueryParameters = localVarPath + (localVarPath.indexOf('?') !== -1 ? '&' : '?') + querystring.stringify(queryParameters);

			return fetch(localVarPathWithQueryParameters, fetchParams).then((response) => {
				if (response.status >= 200 && response.status < 300) {
					return response.json();
				} else {
					let error = new Error(response.statusText);
					(error as any).response = response;
					throw error;
				}
			});
		}
		/**
		 *
		 * Get Agreement Configurations
		 * @param id
		 * @param page
		 * @param pageSize
		 */
		public financeAgreementsIdConfigurationsGet (params: {  id: number; page?: number; pageSize?: number; }, extraQueryParams?: any, extraFetchParams?: any ) : Promise<Array<ConfigurationReference>> {
			const localVarPath = this.basePath + '/finance/agreements/{id}/configurations'
				.replace('{' + 'id' + '}', String(params.id));

			let queryParameters: any = assign({}, extraQueryParams);
			let headerParams: any = assign({}, this.defaultHeaders);
			// verify required parameter 'id' is set
			if (params.id == null) {
				throw new Error('Missing required parameter id when calling financeAgreementsIdConfigurationsGet');
			}
			if (params.page !== undefined) {
				queryParameters['page'] = params.page;
			}

			if (params.pageSize !== undefined) {
				queryParameters['pageSize'] = params.pageSize;
			}

			let fetchParams = {
				method: 'GET',
				headers: headerParams,

			};

			if (extraFetchParams) {
				fetchParams = assign(fetchParams, extraFetchParams);
			}

			let localVarPathWithQueryParameters = localVarPath + (localVarPath.indexOf('?') !== -1 ? '&' : '?') + querystring.stringify(queryParameters);

			return fetch(localVarPathWithQueryParameters, fetchParams).then((response) => {
				if (response.status >= 200 && response.status < 300) {
					return response.json();
				} else {
					let error = new Error(response.statusText);
					(error as any).response = response;
					throw error;
				}
			});
		}
		/**
		 *
		 * Create Configuration Association
		 * @param id
		 * @param configuration
		 */
		public financeAgreementsIdConfigurationsPost (params: {  id: number; configuration: ConfigurationReference; }, extraQueryParams?: any, extraFetchParams?: any ) : Promise<ConfigurationReference> {
			const localVarPath = this.basePath + '/finance/agreements/{id}/configurations'
				.replace('{' + 'id' + '}', String(params.id));

			let queryParameters: any = assign({}, extraQueryParams);
			let headerParams: any = assign({}, this.defaultHeaders);
			headerParams['Content-Type'] = 'application/json';

			// verify required parameter 'id' is set
			if (params.id == null) {
				throw new Error('Missing required parameter id when calling financeAgreementsIdConfigurationsPost');
			}
			// verify required parameter 'configuration' is set
			if (params.configuration == null) {
				throw new Error('Missing required parameter configuration when calling financeAgreementsIdConfigurationsPost');
			}
			let fetchParams = {
				method: 'POST',
				headers: headerParams,
				body: JSON.stringify(params.configuration),

			};

			if (extraFetchParams) {
				fetchParams = assign(fetchParams, extraFetchParams);
			}

			let localVarPathWithQueryParameters = localVarPath + (localVarPath.indexOf('?') !== -1 ? '&' : '?') + querystring.stringify(queryParameters);

			return fetch(localVarPathWithQueryParameters, fetchParams).then((response) => {
				if (response.status >= 200 && response.status < 300) {
					return response.json();
				} else {
					let error = new Error(response.statusText);
					(error as any).response = response;
					throw error;
				}
			});
		}
		/**
		 *
		 * Delete Agreement By Id
		 * @param id
		 */
		public financeAgreementsIdDelete (params: {  id: number; }, extraQueryParams?: any, extraFetchParams?: any ) : Promise<{}> {
			const localVarPath = this.basePath + '/finance/agreements/{id}'
				.replace('{' + 'id' + '}', String(params.id));

			let queryParameters: any = assign({}, extraQueryParams);
			let headerParams: any = assign({}, this.defaultHeaders);
			// verify required parameter 'id' is set
			if (params.id == null) {
				throw new Error('Missing required parameter id when calling financeAgreementsIdDelete');
			}
			let fetchParams = {
				method: 'DELETE',
				headers: headerParams,

			};

			if (extraFetchParams) {
				fetchParams = assign(fetchParams, extraFetchParams);
			}

			let localVarPathWithQueryParameters = localVarPath + (localVarPath.indexOf('?') !== -1 ? '&' : '?') + querystring.stringify(queryParameters);

			return fetch(localVarPathWithQueryParameters, fetchParams).then((response) => {
				if (response.status >= 200 && response.status < 300) {
					return response.json();
				} else {
					let error = new Error(response.statusText);
					(error as any).response = response;
					throw error;
				}
			});
		}
		/**
		 *
		 * Get Agreement By Id
		 * @param id
		 */
		public financeAgreementsIdGet (params: {  id: number; }, extraQueryParams?: any, extraFetchParams?: any ) : Promise<Agreement> {
			const localVarPath = this.basePath + '/finance/agreements/{id}'
				.replace('{' + 'id' + '}', String(params.id));

			let queryParameters: any = assign({}, extraQueryParams);
			let headerParams: any = assign({}, this.defaultHeaders);
			// verify required parameter 'id' is set
			if (params.id == null) {
				throw new Error('Missing required parameter id when calling financeAgreementsIdGet');
			}
			let fetchParams = {
				method: 'GET',
				headers: headerParams,

			};

			if (extraFetchParams) {
				fetchParams = assign(fetchParams, extraFetchParams);
			}

			let localVarPathWithQueryParameters = localVarPath + (localVarPath.indexOf('?') !== -1 ? '&' : '?') + querystring.stringify(queryParameters);

			return fetch(localVarPathWithQueryParameters, fetchParams).then((response) => {
				if (response.status >= 200 && response.status < 300) {
					return response.json();
				} else {
					let error = new Error(response.statusText);
					(error as any).response = response;
					throw error;
				}
			});
		}
		/**
		 *
		 * Update Agreement
		 * @param id
		 * @param operations
		 */
		public financeAgreementsIdPatch (params: {  id: number; operations: Array<PatchOperation>; }, extraQueryParams?: any, extraFetchParams?: any ) : Promise<Agreement> {
			const localVarPath = this.basePath + '/finance/agreements/{id}'
				.replace('{' + 'id' + '}', String(params.id));

			let queryParameters: any = assign({}, extraQueryParams);
			let headerParams: any = assign({}, this.defaultHeaders);
			headerParams['Content-Type'] = 'application/json';

			// verify required parameter 'id' is set
			if (params.id == null) {
				throw new Error('Missing required parameter id when calling financeAgreementsIdPatch');
			}
			// verify required parameter 'operations' is set
			if (params.operations == null) {
				throw new Error('Missing required parameter operations when calling financeAgreementsIdPatch');
			}
			let fetchParams = {
				method: 'PATCH',
				headers: headerParams,
				body: JSON.stringify(params.operations),

			};

			if (extraFetchParams) {
				fetchParams = assign(fetchParams, extraFetchParams);
			}

			let localVarPathWithQueryParameters = localVarPath + (localVarPath.indexOf('?') !== -1 ? '&' : '?') + querystring.stringify(queryParameters);

			return fetch(localVarPathWithQueryParameters, fetchParams).then((response) => {
				if (response.status >= 200 && response.status < 300) {
					return response.json();
				} else {
					let error = new Error(response.statusText);
					(error as any).response = response;
					throw error;
				}
			});
		}
		/**
		 *
		 * Replace Agreement
		 * @param id
		 * @param agreement
		 */
		public financeAgreementsIdPut (params: {  id: number; agreement: Agreement; }, extraQueryParams?: any, extraFetchParams?: any ) : Promise<Agreement> {
			const localVarPath = this.basePath + '/finance/agreements/{id}'
				.replace('{' + 'id' + '}', String(params.id));

			let queryParameters: any = assign({}, extraQueryParams);
			let headerParams: any = assign({}, this.defaultHeaders);
			headerParams['Content-Type'] = 'application/json';

			// verify required parameter 'id' is set
			if (params.id == null) {
				throw new Error('Missing required parameter id when calling financeAgreementsIdPut');
			}
			// verify required parameter 'agreement' is set
			if (params.agreement == null) {
				throw new Error('Missing required parameter agreement when calling financeAgreementsIdPut');
			}
			let fetchParams = {
				method: 'PUT',
				headers: headerParams,
				body: JSON.stringify(params.agreement),

			};

			if (extraFetchParams) {
				fetchParams = assign(fetchParams, extraFetchParams);
			}

			let localVarPathWithQueryParameters = localVarPath + (localVarPath.indexOf('?') !== -1 ? '&' : '?') + querystring.stringify(queryParameters);

			return fetch(localVarPathWithQueryParameters, fetchParams).then((response) => {
				if (response.status >= 200 && response.status < 300) {
					return response.json();
				} else {
					let error = new Error(response.statusText);
					(error as any).response = response;
					throw error;
				}
			});
		}
		/**
		 *
		 * Create Agreement
		 * @param agreement
		 */
		public financeAgreementsPost (params: {  agreement: Agreement; }, extraQueryParams?: any, extraFetchParams?: any ) : Promise<Agreement> {
			const localVarPath = this.basePath + '/finance/agreements';

			let queryParameters: any = assign({}, extraQueryParams);
			let headerParams: any = assign({}, this.defaultHeaders);
			headerParams['Content-Type'] = 'application/json';

			// verify required parameter 'agreement' is set
			if (params.agreement == null) {
				throw new Error('Missing required parameter agreement when calling financeAgreementsPost');
			}
			let fetchParams = {
				method: 'POST',
				headers: headerParams,
				body: JSON.stringify(params.agreement),

			};

			if (extraFetchParams) {
				fetchParams = assign(fetchParams, extraFetchParams);
			}

			let localVarPathWithQueryParameters = localVarPath + (localVarPath.indexOf('?') !== -1 ? '&' : '?') + querystring.stringify(queryParameters);

			return fetch(localVarPathWithQueryParameters, fetchParams).then((response) => {
				if (response.status >= 200 && response.status < 300) {
					return response.json();
				} else {
					let error = new Error(response.statusText);
					(error as any).response = response;
					throw error;
				}
			});
		}
	}
//}
//export namespace  {
	'use strict';

	export class AuditTrailApi {
		protected basePath = 'https://api-na.myconnectwise.net/v4_6_release/apis/3.0';
		public defaultHeaders : any = {};

		constructor(basePath?: string) {
			if (basePath) {
				this.basePath = basePath;
			}
		}

		/**
		 *
		 * Get Members Count
		 * @param type
		 * @param id
		 * @param deviceIdentifier
		 */
		public systemAudittrailCountGet (params: {  type?: string; id?: number; deviceIdentifier?: string; }, extraQueryParams?: any, extraFetchParams?: any ) : Promise<Count> {
			const localVarPath = this.basePath + '/system/audittrail/count';

			let queryParameters: any = assign({}, extraQueryParams);
			let headerParams: any = assign({}, this.defaultHeaders);
			if (params.type !== undefined) {
				queryParameters['type'] = params.type;
			}

			if (params.id !== undefined) {
				queryParameters['id'] = params.id;
			}

			if (params.deviceIdentifier !== undefined) {
				queryParameters['deviceIdentifier'] = params.deviceIdentifier;
			}

			let fetchParams = {
				method: 'GET',
				headers: headerParams,

			};

			if (extraFetchParams) {
				fetchParams = assign(fetchParams, extraFetchParams);
			}

			let localVarPathWithQueryParameters = localVarPath + (localVarPath.indexOf('?') !== -1 ? '&' : '?') + querystring.stringify(queryParameters);

			return fetch(localVarPathWithQueryParameters, fetchParams).then((response) => {
				if (response.status >= 200 && response.status < 300) {
					return response.json();
				} else {
					let error = new Error(response.statusText);
					(error as any).response = response;
					throw error;
				}
			});
		}
		/**
		 *
		 * Get Audit Trail
		 * @param type
		 * @param id
		 * @param deviceIdentifier
		 * @param page
		 * @param pageSize
		 */
		public systemAudittrailGet (params: {  type?: string; id?: number; deviceIdentifier?: string; page?: number; pageSize?: number; }, extraQueryParams?: any, extraFetchParams?: any ) : Promise<Array<AuditTrailEntry>> {
			const localVarPath = this.basePath + '/system/audittrail';

			let queryParameters: any = assign({}, extraQueryParams);
			let headerParams: any = assign({}, this.defaultHeaders);
			if (params.type !== undefined) {
				queryParameters['type'] = params.type;
			}

			if (params.id !== undefined) {
				queryParameters['id'] = params.id;
			}

			if (params.deviceIdentifier !== undefined) {
				queryParameters['deviceIdentifier'] = params.deviceIdentifier;
			}

			if (params.page !== undefined) {
				queryParameters['page'] = params.page;
			}

			if (params.pageSize !== undefined) {
				queryParameters['pageSize'] = params.pageSize;
			}

			let fetchParams = {
				method: 'GET',
				headers: headerParams,

			};

			if (extraFetchParams) {
				fetchParams = assign(fetchParams, extraFetchParams);
			}

			let localVarPathWithQueryParameters = localVarPath + (localVarPath.indexOf('?') !== -1 ? '&' : '?') + querystring.stringify(queryParameters);

			return fetch(localVarPathWithQueryParameters, fetchParams).then((response) => {
				if (response.status >= 200 && response.status < 300) {
					return response.json();
				} else {
					let error = new Error(response.statusText);
					(error as any).response = response;
					throw error;
				}
			});
		}
	}
//}
//export namespace  {
	'use strict';

	export class BatchApi {
		protected basePath = 'https://api-na.myconnectwise.net/v4_6_release/apis/3.0';
		public defaultHeaders : any = {};

		constructor(basePath?: string) {
			if (basePath) {
				this.basePath = basePath;
			}
		}

		/**
		 *
		 * Process Batch Requests
		 * @param request
		 */
		public systemBatchPost (params: {  request: BatchRequest; }, extraQueryParams?: any, extraFetchParams?: any ) : Promise<BatchResponse> {
			const localVarPath = this.basePath + '/system/batch';

			let queryParameters: any = assign({}, extraQueryParams);
			let headerParams: any = assign({}, this.defaultHeaders);
			headerParams['Content-Type'] = 'application/json';

			// verify required parameter 'request' is set
			if (params.request == null) {
				throw new Error('Missing required parameter request when calling systemBatchPost');
			}
			let fetchParams = {
				method: 'POST',
				headers: headerParams,
				body: JSON.stringify(params.request),

			};

			if (extraFetchParams) {
				fetchParams = assign(fetchParams, extraFetchParams);
			}

			let localVarPathWithQueryParameters = localVarPath + (localVarPath.indexOf('?') !== -1 ? '&' : '?') + querystring.stringify(queryParameters);

			return fetch(localVarPathWithQueryParameters, fetchParams).then((response) => {
				if (response.status >= 200 && response.status < 300) {
					return response.json();
				} else {
					let error = new Error(response.statusText);
					(error as any).response = response;
					throw error;
				}
			});
		}
	}
//}
//export namespace  {
	'use strict';

	export class BoardExcludedMembersApi {
		protected basePath = 'https://api-na.myconnectwise.net/v4_6_release/apis/3.0';
		public defaultHeaders : any = {};

		constructor(basePath?: string) {
			if (basePath) {
				this.basePath = basePath;
			}
		}

		/**
		 *
		 * Get Excluded Members Count
		 * @param id
		 * @param conditions
		 */
		public serviceBoardsIdExcludedMembersCountGet (params: {  id: number; conditions?: string; }, extraQueryParams?: any, extraFetchParams?: any ) : Promise<Count> {
			const localVarPath = this.basePath + '/service/boards/{id}/excludedMembers/count'
				.replace('{' + 'id' + '}', String(params.id));

			let queryParameters: any = assign({}, extraQueryParams);
			let headerParams: any = assign({}, this.defaultHeaders);
			// verify required parameter 'id' is set
			if (params.id == null) {
				throw new Error('Missing required parameter id when calling serviceBoardsIdExcludedMembersCountGet');
			}
			if (params.conditions !== undefined) {
				queryParameters['conditions'] = params.conditions;
			}

			let fetchParams = {
				method: 'GET',
				headers: headerParams,

			};

			if (extraFetchParams) {
				fetchParams = assign(fetchParams, extraFetchParams);
			}

			let localVarPathWithQueryParameters = localVarPath + (localVarPath.indexOf('?') !== -1 ? '&' : '?') + querystring.stringify(queryParameters);

			return fetch(localVarPathWithQueryParameters, fetchParams).then((response) => {
				if (response.status >= 200 && response.status < 300) {
					return response.json();
				} else {
					let error = new Error(response.statusText);
					(error as any).response = response;
					throw error;
				}
			});
		}
		/**
		 *
		 * Delete Excluded Member By Id
		 * @param id
		 * @param excludedMemberId
		 */
		public serviceBoardsIdExcludedMembersExcludedMemberIdDelete (params: {  id: number; excludedMemberId: number; }, extraQueryParams?: any, extraFetchParams?: any ) : Promise<{}> {
			const localVarPath = this.basePath + '/service/boards/{id}/excludedMembers/{excludedMemberId}'
				.replace('{' + 'id' + '}', String(params.id))
				.replace('{' + 'excludedMemberId' + '}', String(params.excludedMemberId));

			let queryParameters: any = assign({}, extraQueryParams);
			let headerParams: any = assign({}, this.defaultHeaders);
			// verify required parameter 'id' is set
			if (params.id == null) {
				throw new Error('Missing required parameter id when calling serviceBoardsIdExcludedMembersExcludedMemberIdDelete');
			}
			// verify required parameter 'excludedMemberId' is set
			if (params.excludedMemberId == null) {
				throw new Error('Missing required parameter excludedMemberId when calling serviceBoardsIdExcludedMembersExcludedMemberIdDelete');
			}
			let fetchParams = {
				method: 'DELETE',
				headers: headerParams,

			};

			if (extraFetchParams) {
				fetchParams = assign(fetchParams, extraFetchParams);
			}

			let localVarPathWithQueryParameters = localVarPath + (localVarPath.indexOf('?') !== -1 ? '&' : '?') + querystring.stringify(queryParameters);

			return fetch(localVarPathWithQueryParameters, fetchParams).then((response) => {
				if (response.status >= 200 && response.status < 300) {
					return response.json();
				} else {
					let error = new Error(response.statusText);
					(error as any).response = response;
					throw error;
				}
			});
		}
		/**
		 *
		 * Get Excluded Member By Id
		 * @param id
		 * @param excludedMemberId
		 */
		public serviceBoardsIdExcludedMembersExcludedMemberIdGet (params: {  id: number; excludedMemberId: number; }, extraQueryParams?: any, extraFetchParams?: any ) : Promise<ExcludedMember> {
			const localVarPath = this.basePath + '/service/boards/{id}/excludedMembers/{excludedMemberId}'
				.replace('{' + 'id' + '}', String(params.id))
				.replace('{' + 'excludedMemberId' + '}', String(params.excludedMemberId));

			let queryParameters: any = assign({}, extraQueryParams);
			let headerParams: any = assign({}, this.defaultHeaders);
			// verify required parameter 'id' is set
			if (params.id == null) {
				throw new Error('Missing required parameter id when calling serviceBoardsIdExcludedMembersExcludedMemberIdGet');
			}
			// verify required parameter 'excludedMemberId' is set
			if (params.excludedMemberId == null) {
				throw new Error('Missing required parameter excludedMemberId when calling serviceBoardsIdExcludedMembersExcludedMemberIdGet');
			}
			let fetchParams = {
				method: 'GET',
				headers: headerParams,

			};

			if (extraFetchParams) {
				fetchParams = assign(fetchParams, extraFetchParams);
			}

			let localVarPathWithQueryParameters = localVarPath + (localVarPath.indexOf('?') !== -1 ? '&' : '?') + querystring.stringify(queryParameters);

			return fetch(localVarPathWithQueryParameters, fetchParams).then((response) => {
				if (response.status >= 200 && response.status < 300) {
					return response.json();
				} else {
					let error = new Error(response.statusText);
					(error as any).response = response;
					throw error;
				}
			});
		}
		/**
		 *
		 * Get Excluded Members
		 * @param id
		 * @param conditions
		 * @param orderBy
		 * @param childconditions
		 * @param customfieldconditions
		 * @param page
		 * @param pageSize
		 */
		public serviceBoardsIdExcludedMembersGet (params: {  id: number; conditions?: string; orderBy?: string; childconditions?: string; customfieldconditions?: string; page?: number; pageSize?: number; }, extraQueryParams?: any, extraFetchParams?: any ) : Promise<Array<ExcludedMember>> {
			const localVarPath = this.basePath + '/service/boards/{id}/excludedMembers'
				.replace('{' + 'id' + '}', String(params.id));

			let queryParameters: any = assign({}, extraQueryParams);
			let headerParams: any = assign({}, this.defaultHeaders);
			// verify required parameter 'id' is set
			if (params.id == null) {
				throw new Error('Missing required parameter id when calling serviceBoardsIdExcludedMembersGet');
			}
			if (params.conditions !== undefined) {
				queryParameters['conditions'] = params.conditions;
			}

			if (params.orderBy !== undefined) {
				queryParameters['orderBy'] = params.orderBy;
			}

			if (params.childconditions !== undefined) {
				queryParameters['childconditions'] = params.childconditions;
			}

			if (params.customfieldconditions !== undefined) {
				queryParameters['customfieldconditions'] = params.customfieldconditions;
			}

			if (params.page !== undefined) {
				queryParameters['page'] = params.page;
			}

			if (params.pageSize !== undefined) {
				queryParameters['pageSize'] = params.pageSize;
			}

			let fetchParams = {
				method: 'GET',
				headers: headerParams,

			};

			if (extraFetchParams) {
				fetchParams = assign(fetchParams, extraFetchParams);
			}

			let localVarPathWithQueryParameters = localVarPath + (localVarPath.indexOf('?') !== -1 ? '&' : '?') + querystring.stringify(queryParameters);

			return fetch(localVarPathWithQueryParameters, fetchParams).then((response) => {
				if (response.status >= 200 && response.status < 300) {
					return response.json();
				} else {
					let error = new Error(response.statusText);
					(error as any).response = response;
					throw error;
				}
			});
		}
		/**
		 *
		 * Create Excluded Member
		 * @param id
		 * @param excludedMember
		 */
		public serviceBoardsIdExcludedMembersPost (params: {  id: number; excludedMember: ExcludedMember; }, extraQueryParams?: any, extraFetchParams?: any ) : Promise<ExcludedMember> {
			const localVarPath = this.basePath + '/service/boards/{id}/excludedMembers'
				.replace('{' + 'id' + '}', String(params.id));

			let queryParameters: any = assign({}, extraQueryParams);
			let headerParams: any = assign({}, this.defaultHeaders);
			headerParams['Content-Type'] = 'application/json';

			// verify required parameter 'id' is set
			if (params.id == null) {
				throw new Error('Missing required parameter id when calling serviceBoardsIdExcludedMembersPost');
			}
			// verify required parameter 'excludedMember' is set
			if (params.excludedMember == null) {
				throw new Error('Missing required parameter excludedMember when calling serviceBoardsIdExcludedMembersPost');
			}
			let fetchParams = {
				method: 'POST',
				headers: headerParams,
				body: JSON.stringify(params.excludedMember),

			};

			if (extraFetchParams) {
				fetchParams = assign(fetchParams, extraFetchParams);
			}

			let localVarPathWithQueryParameters = localVarPath + (localVarPath.indexOf('?') !== -1 ? '&' : '?') + querystring.stringify(queryParameters);

			return fetch(localVarPathWithQueryParameters, fetchParams).then((response) => {
				if (response.status >= 200 && response.status < 300) {
					return response.json();
				} else {
					let error = new Error(response.statusText);
					(error as any).response = response;
					throw error;
				}
			});
		}
	}
//}
//export namespace  {
	'use strict';

	export class BoardItemsApi {
		protected basePath = 'https://api-na.myconnectwise.net/v4_6_release/apis/3.0';
		public defaultHeaders : any = {};

		constructor(basePath?: string) {
			if (basePath) {
				this.basePath = basePath;
			}
		}

		/**
		 *
		 * Get Items Count
		 * @param id
		 * @param conditions
		 */
		public serviceBoardsIdItemsCountGet (params: {  id: number; conditions?: string; }, extraQueryParams?: any, extraFetchParams?: any ) : Promise<Count> {
			const localVarPath = this.basePath + '/service/boards/{id}/items/count'
				.replace('{' + 'id' + '}', String(params.id));

			let queryParameters: any = assign({}, extraQueryParams);
			let headerParams: any = assign({}, this.defaultHeaders);
			// verify required parameter 'id' is set
			if (params.id == null) {
				throw new Error('Missing required parameter id when calling serviceBoardsIdItemsCountGet');
			}
			if (params.conditions !== undefined) {
				queryParameters['conditions'] = params.conditions;
			}

			let fetchParams = {
				method: 'GET',
				headers: headerParams,

			};

			if (extraFetchParams) {
				fetchParams = assign(fetchParams, extraFetchParams);
			}

			let localVarPathWithQueryParameters = localVarPath + (localVarPath.indexOf('?') !== -1 ? '&' : '?') + querystring.stringify(queryParameters);

			return fetch(localVarPathWithQueryParameters, fetchParams).then((response) => {
				if (response.status >= 200 && response.status < 300) {
					return response.json();
				} else {
					let error = new Error(response.statusText);
					(error as any).response = response;
					throw error;
				}
			});
		}
		/**
		 *
		 * Get Items
		 * @param id
		 * @param conditions
		 * @param orderBy
		 * @param childconditions
		 * @param customfieldconditions
		 * @param page
		 * @param pageSize
		 */
		public serviceBoardsIdItemsGet (params: {  id: number; conditions?: string; orderBy?: string; childconditions?: string; customfieldconditions?: string; page?: number; pageSize?: number; }, extraQueryParams?: any, extraFetchParams?: any ) : Promise<Array<Item>> {
			const localVarPath = this.basePath + '/service/boards/{id}/items'
				.replace('{' + 'id' + '}', String(params.id));

			let queryParameters: any = assign({}, extraQueryParams);
			let headerParams: any = assign({}, this.defaultHeaders);
			// verify required parameter 'id' is set
			if (params.id == null) {
				throw new Error('Missing required parameter id when calling serviceBoardsIdItemsGet');
			}
			if (params.conditions !== undefined) {
				queryParameters['conditions'] = params.conditions;
			}

			if (params.orderBy !== undefined) {
				queryParameters['orderBy'] = params.orderBy;
			}

			if (params.childconditions !== undefined) {
				queryParameters['childconditions'] = params.childconditions;
			}

			if (params.customfieldconditions !== undefined) {
				queryParameters['customfieldconditions'] = params.customfieldconditions;
			}

			if (params.page !== undefined) {
				queryParameters['page'] = params.page;
			}

			if (params.pageSize !== undefined) {
				queryParameters['pageSize'] = params.pageSize;
			}

			let fetchParams = {
				method: 'GET',
				headers: headerParams,

			};

			if (extraFetchParams) {
				fetchParams = assign(fetchParams, extraFetchParams);
			}

			let localVarPathWithQueryParameters = localVarPath + (localVarPath.indexOf('?') !== -1 ? '&' : '?') + querystring.stringify(queryParameters);

			return fetch(localVarPathWithQueryParameters, fetchParams).then((response) => {
				if (response.status >= 200 && response.status < 300) {
					return response.json();
				} else {
					let error = new Error(response.statusText);
					(error as any).response = response;
					throw error;
				}
			});
		}
		/**
		 *
		 * Delete Item By Id
		 * @param id
		 * @param itemId
		 */
		public serviceBoardsIdItemsItemIdDelete (params: {  id: number; itemId: number; }, extraQueryParams?: any, extraFetchParams?: any ) : Promise<{}> {
			const localVarPath = this.basePath + '/service/boards/{id}/items/{itemId}'
				.replace('{' + 'id' + '}', String(params.id))
				.replace('{' + 'itemId' + '}', String(params.itemId));

			let queryParameters: any = assign({}, extraQueryParams);
			let headerParams: any = assign({}, this.defaultHeaders);
			// verify required parameter 'id' is set
			if (params.id == null) {
				throw new Error('Missing required parameter id when calling serviceBoardsIdItemsItemIdDelete');
			}
			// verify required parameter 'itemId' is set
			if (params.itemId == null) {
				throw new Error('Missing required parameter itemId when calling serviceBoardsIdItemsItemIdDelete');
			}
			let fetchParams = {
				method: 'DELETE',
				headers: headerParams,

			};

			if (extraFetchParams) {
				fetchParams = assign(fetchParams, extraFetchParams);
			}

			let localVarPathWithQueryParameters = localVarPath + (localVarPath.indexOf('?') !== -1 ? '&' : '?') + querystring.stringify(queryParameters);

			return fetch(localVarPathWithQueryParameters, fetchParams).then((response) => {
				if (response.status >= 200 && response.status < 300) {
					return response.json();
				} else {
					let error = new Error(response.statusText);
					(error as any).response = response;
					throw error;
				}
			});
		}
		/**
		 *
		 * Get Item By Id
		 * @param id
		 * @param itemId
		 */
		public serviceBoardsIdItemsItemIdGet (params: {  id: number; itemId: number; }, extraQueryParams?: any, extraFetchParams?: any ) : Promise<Item> {
			const localVarPath = this.basePath + '/service/boards/{id}/items/{itemId}'
				.replace('{' + 'id' + '}', String(params.id))
				.replace('{' + 'itemId' + '}', String(params.itemId));

			let queryParameters: any = assign({}, extraQueryParams);
			let headerParams: any = assign({}, this.defaultHeaders);
			// verify required parameter 'id' is set
			if (params.id == null) {
				throw new Error('Missing required parameter id when calling serviceBoardsIdItemsItemIdGet');
			}
			// verify required parameter 'itemId' is set
			if (params.itemId == null) {
				throw new Error('Missing required parameter itemId when calling serviceBoardsIdItemsItemIdGet');
			}
			let fetchParams = {
				method: 'GET',
				headers: headerParams,

			};

			if (extraFetchParams) {
				fetchParams = assign(fetchParams, extraFetchParams);
			}

			let localVarPathWithQueryParameters = localVarPath + (localVarPath.indexOf('?') !== -1 ? '&' : '?') + querystring.stringify(queryParameters);

			return fetch(localVarPathWithQueryParameters, fetchParams).then((response) => {
				if (response.status >= 200 && response.status < 300) {
					return response.json();
				} else {
					let error = new Error(response.statusText);
					(error as any).response = response;
					throw error;
				}
			});
		}
		/**
		 *
		 * Update Item
		 * @param id
		 * @param itemId
		 * @param operations
		 */
		public serviceBoardsIdItemsItemIdPatch (params: {  id: number; itemId: number; operations: Array<PatchOperation>; }, extraQueryParams?: any, extraFetchParams?: any ) : Promise<Item> {
			const localVarPath = this.basePath + '/service/boards/{id}/items/{itemId}'
				.replace('{' + 'id' + '}', String(params.id))
				.replace('{' + 'itemId' + '}', String(params.itemId));

			let queryParameters: any = assign({}, extraQueryParams);
			let headerParams: any = assign({}, this.defaultHeaders);
			headerParams['Content-Type'] = 'application/json';

			// verify required parameter 'id' is set
			if (params.id == null) {
				throw new Error('Missing required parameter id when calling serviceBoardsIdItemsItemIdPatch');
			}
			// verify required parameter 'itemId' is set
			if (params.itemId == null) {
				throw new Error('Missing required parameter itemId when calling serviceBoardsIdItemsItemIdPatch');
			}
			// verify required parameter 'operations' is set
			if (params.operations == null) {
				throw new Error('Missing required parameter operations when calling serviceBoardsIdItemsItemIdPatch');
			}
			let fetchParams = {
				method: 'PATCH',
				headers: headerParams,
				body: JSON.stringify(params.operations),

			};

			if (extraFetchParams) {
				fetchParams = assign(fetchParams, extraFetchParams);
			}

			let localVarPathWithQueryParameters = localVarPath + (localVarPath.indexOf('?') !== -1 ? '&' : '?') + querystring.stringify(queryParameters);

			return fetch(localVarPathWithQueryParameters, fetchParams).then((response) => {
				if (response.status >= 200 && response.status < 300) {
					return response.json();
				} else {
					let error = new Error(response.statusText);
					(error as any).response = response;
					throw error;
				}
			});
		}
		/**
		 *
		 * Replace Item
		 * @param id
		 * @param itemId
		 * @param item
		 */
		public serviceBoardsIdItemsItemIdPut (params: {  id: number; itemId: number; item: Item; }, extraQueryParams?: any, extraFetchParams?: any ) : Promise<Item> {
			const localVarPath = this.basePath + '/service/boards/{id}/items/{itemId}'
				.replace('{' + 'id' + '}', String(params.id))
				.replace('{' + 'itemId' + '}', String(params.itemId));

			let queryParameters: any = assign({}, extraQueryParams);
			let headerParams: any = assign({}, this.defaultHeaders);
			headerParams['Content-Type'] = 'application/json';

			// verify required parameter 'id' is set
			if (params.id == null) {
				throw new Error('Missing required parameter id when calling serviceBoardsIdItemsItemIdPut');
			}
			// verify required parameter 'itemId' is set
			if (params.itemId == null) {
				throw new Error('Missing required parameter itemId when calling serviceBoardsIdItemsItemIdPut');
			}
			// verify required parameter 'item' is set
			if (params.item == null) {
				throw new Error('Missing required parameter item when calling serviceBoardsIdItemsItemIdPut');
			}
			let fetchParams = {
				method: 'PUT',
				headers: headerParams,
				body: JSON.stringify(params.item),

			};

			if (extraFetchParams) {
				fetchParams = assign(fetchParams, extraFetchParams);
			}

			let localVarPathWithQueryParameters = localVarPath + (localVarPath.indexOf('?') !== -1 ? '&' : '?') + querystring.stringify(queryParameters);

			return fetch(localVarPathWithQueryParameters, fetchParams).then((response) => {
				if (response.status >= 200 && response.status < 300) {
					return response.json();
				} else {
					let error = new Error(response.statusText);
					(error as any).response = response;
					throw error;
				}
			});
		}
		/**
		 *
		 * Create Item
		 * @param id
		 * @param item
		 */
		public serviceBoardsIdItemsPost (params: {  id: number; item: Item; }, extraQueryParams?: any, extraFetchParams?: any ) : Promise<Item> {
			const localVarPath = this.basePath + '/service/boards/{id}/items'
				.replace('{' + 'id' + '}', String(params.id));

			let queryParameters: any = assign({}, extraQueryParams);
			let headerParams: any = assign({}, this.defaultHeaders);
			headerParams['Content-Type'] = 'application/json';

			// verify required parameter 'id' is set
			if (params.id == null) {
				throw new Error('Missing required parameter id when calling serviceBoardsIdItemsPost');
			}
			// verify required parameter 'item' is set
			if (params.item == null) {
				throw new Error('Missing required parameter item when calling serviceBoardsIdItemsPost');
			}
			let fetchParams = {
				method: 'POST',
				headers: headerParams,
				body: JSON.stringify(params.item),

			};

			if (extraFetchParams) {
				fetchParams = assign(fetchParams, extraFetchParams);
			}

			let localVarPathWithQueryParameters = localVarPath + (localVarPath.indexOf('?') !== -1 ? '&' : '?') + querystring.stringify(queryParameters);

			return fetch(localVarPathWithQueryParameters, fetchParams).then((response) => {
				if (response.status >= 200 && response.status < 300) {
					return response.json();
				} else {
					let error = new Error(response.statusText);
					(error as any).response = response;
					throw error;
				}
			});
		}
	}
//}
//export namespace  {
	'use strict';

	export class BoardStatusesApi {
		protected basePath = 'https://api-na.myconnectwise.net/v4_6_release/apis/3.0';
		public defaultHeaders : any = {};

		constructor(basePath?: string) {
			if (basePath) {
				this.basePath = basePath;
			}
		}

		/**
		 *
		 * Get Statuses Count
		 * @param id
		 * @param conditions
		 */
		public serviceBoardsIdStatusesCountGet (params: {  id: number; conditions?: string; }, extraQueryParams?: any, extraFetchParams?: any ) : Promise<Count> {
			const localVarPath = this.basePath + '/service/boards/{id}/statuses/count'
				.replace('{' + 'id' + '}', String(params.id));

			let queryParameters: any = assign({}, extraQueryParams);
			let headerParams: any = assign({}, this.defaultHeaders);
			// verify required parameter 'id' is set
			if (params.id == null) {
				throw new Error('Missing required parameter id when calling serviceBoardsIdStatusesCountGet');
			}
			if (params.conditions !== undefined) {
				queryParameters['conditions'] = params.conditions;
			}

			let fetchParams = {
				method: 'GET',
				headers: headerParams,

			};

			if (extraFetchParams) {
				fetchParams = assign(fetchParams, extraFetchParams);
			}

			let localVarPathWithQueryParameters = localVarPath + (localVarPath.indexOf('?') !== -1 ? '&' : '?') + querystring.stringify(queryParameters);

			return fetch(localVarPathWithQueryParameters, fetchParams).then((response) => {
				if (response.status >= 200 && response.status < 300) {
					return response.json();
				} else {
					let error = new Error(response.statusText);
					(error as any).response = response;
					throw error;
				}
			});
		}
		/**
		 *
		 * Get Statuses
		 * @param id
		 * @param conditions
		 * @param orderBy
		 * @param childconditions
		 * @param customfieldconditions
		 * @param page
		 * @param pageSize
		 */
		public serviceBoardsIdStatusesGet (params: {  id: number; conditions?: string; orderBy?: string; childconditions?: string; customfieldconditions?: string; page?: number; pageSize?: number; }, extraQueryParams?: any, extraFetchParams?: any ) : Promise<Array<Status>> {
			const localVarPath = this.basePath + '/service/boards/{id}/statuses'
				.replace('{' + 'id' + '}', String(params.id));

			let queryParameters: any = assign({}, extraQueryParams);
			let headerParams: any = assign({}, this.defaultHeaders);
			// verify required parameter 'id' is set
			if (params.id == null) {
				throw new Error('Missing required parameter id when calling serviceBoardsIdStatusesGet');
			}
			if (params.conditions !== undefined) {
				queryParameters['conditions'] = params.conditions;
			}

			if (params.orderBy !== undefined) {
				queryParameters['orderBy'] = params.orderBy;
			}

			if (params.childconditions !== undefined) {
				queryParameters['childconditions'] = params.childconditions;
			}

			if (params.customfieldconditions !== undefined) {
				queryParameters['customfieldconditions'] = params.customfieldconditions;
			}

			if (params.page !== undefined) {
				queryParameters['page'] = params.page;
			}

			if (params.pageSize !== undefined) {
				queryParameters['pageSize'] = params.pageSize;
			}

			let fetchParams = {
				method: 'GET',
				headers: headerParams,

			};

			if (extraFetchParams) {
				fetchParams = assign(fetchParams, extraFetchParams);
			}

			let localVarPathWithQueryParameters = localVarPath + (localVarPath.indexOf('?') !== -1 ? '&' : '?') + querystring.stringify(queryParameters);

			return fetch(localVarPathWithQueryParameters, fetchParams).then((response) => {
				if (response.status >= 200 && response.status < 300) {
					return response.json();
				} else {
					let error = new Error(response.statusText);
					(error as any).response = response;
					throw error;
				}
			});
		}
		/**
		 *
		 * Create Statuses
		 * @param id
		 * @param status
		 */
		public serviceBoardsIdStatusesPost (params: {  id: number; status: Status; }, extraQueryParams?: any, extraFetchParams?: any ) : Promise<Status> {
			const localVarPath = this.basePath + '/service/boards/{id}/statuses'
				.replace('{' + 'id' + '}', String(params.id));

			let queryParameters: any = assign({}, extraQueryParams);
			let headerParams: any = assign({}, this.defaultHeaders);
			headerParams['Content-Type'] = 'application/json';

			// verify required parameter 'id' is set
			if (params.id == null) {
				throw new Error('Missing required parameter id when calling serviceBoardsIdStatusesPost');
			}
			// verify required parameter 'status' is set
			if (params.status == null) {
				throw new Error('Missing required parameter status when calling serviceBoardsIdStatusesPost');
			}
			let fetchParams = {
				method: 'POST',
				headers: headerParams,
				body: JSON.stringify(params.status),

			};

			if (extraFetchParams) {
				fetchParams = assign(fetchParams, extraFetchParams);
			}

			let localVarPathWithQueryParameters = localVarPath + (localVarPath.indexOf('?') !== -1 ? '&' : '?') + querystring.stringify(queryParameters);

			return fetch(localVarPathWithQueryParameters, fetchParams).then((response) => {
				if (response.status >= 200 && response.status < 300) {
					return response.json();
				} else {
					let error = new Error(response.statusText);
					(error as any).response = response;
					throw error;
				}
			});
		}
		/**
		 *
		 * Delete Status By Id
		 * @param id
		 * @param statusId
		 */
		public serviceBoardsIdStatusesStatusIdDelete (params: {  id: number; statusId: number; }, extraQueryParams?: any, extraFetchParams?: any ) : Promise<{}> {
			const localVarPath = this.basePath + '/service/boards/{id}/statuses/{statusId}'
				.replace('{' + 'id' + '}', String(params.id))
				.replace('{' + 'statusId' + '}', String(params.statusId));

			let queryParameters: any = assign({}, extraQueryParams);
			let headerParams: any = assign({}, this.defaultHeaders);
			// verify required parameter 'id' is set
			if (params.id == null) {
				throw new Error('Missing required parameter id when calling serviceBoardsIdStatusesStatusIdDelete');
			}
			// verify required parameter 'statusId' is set
			if (params.statusId == null) {
				throw new Error('Missing required parameter statusId when calling serviceBoardsIdStatusesStatusIdDelete');
			}
			let fetchParams = {
				method: 'DELETE',
				headers: headerParams,

			};

			if (extraFetchParams) {
				fetchParams = assign(fetchParams, extraFetchParams);
			}

			let localVarPathWithQueryParameters = localVarPath + (localVarPath.indexOf('?') !== -1 ? '&' : '?') + querystring.stringify(queryParameters);

			return fetch(localVarPathWithQueryParameters, fetchParams).then((response) => {
				if (response.status >= 200 && response.status < 300) {
					return response.json();
				} else {
					let error = new Error(response.statusText);
					(error as any).response = response;
					throw error;
				}
			});
		}
		/**
		 *
		 * Get Status By Id
		 * @param id
		 * @param statusId
		 */
		public serviceBoardsIdStatusesStatusIdGet (params: {  id: number; statusId: number; }, extraQueryParams?: any, extraFetchParams?: any ) : Promise<Status> {
			const localVarPath = this.basePath + '/service/boards/{id}/statuses/{statusId}'
				.replace('{' + 'id' + '}', String(params.id))
				.replace('{' + 'statusId' + '}', String(params.statusId));

			let queryParameters: any = assign({}, extraQueryParams);
			let headerParams: any = assign({}, this.defaultHeaders);
			// verify required parameter 'id' is set
			if (params.id == null) {
				throw new Error('Missing required parameter id when calling serviceBoardsIdStatusesStatusIdGet');
			}
			// verify required parameter 'statusId' is set
			if (params.statusId == null) {
				throw new Error('Missing required parameter statusId when calling serviceBoardsIdStatusesStatusIdGet');
			}
			let fetchParams = {
				method: 'GET',
				headers: headerParams,

			};

			if (extraFetchParams) {
				fetchParams = assign(fetchParams, extraFetchParams);
			}

			let localVarPathWithQueryParameters = localVarPath + (localVarPath.indexOf('?') !== -1 ? '&' : '?') + querystring.stringify(queryParameters);

			return fetch(localVarPathWithQueryParameters, fetchParams).then((response) => {
				if (response.status >= 200 && response.status < 300) {
					return response.json();
				} else {
					let error = new Error(response.statusText);
					(error as any).response = response;
					throw error;
				}
			});
		}
		/**
		 *
		 * Update Status
		 * @param id
		 * @param statusId
		 * @param operations
		 */
		public serviceBoardsIdStatusesStatusIdPatch (params: {  id: number; statusId: number; operations: Array<PatchOperation>; }, extraQueryParams?: any, extraFetchParams?: any ) : Promise<Status> {
			const localVarPath = this.basePath + '/service/boards/{id}/statuses/{statusId}'
				.replace('{' + 'id' + '}', String(params.id))
				.replace('{' + 'statusId' + '}', String(params.statusId));

			let queryParameters: any = assign({}, extraQueryParams);
			let headerParams: any = assign({}, this.defaultHeaders);
			headerParams['Content-Type'] = 'application/json';

			// verify required parameter 'id' is set
			if (params.id == null) {
				throw new Error('Missing required parameter id when calling serviceBoardsIdStatusesStatusIdPatch');
			}
			// verify required parameter 'statusId' is set
			if (params.statusId == null) {
				throw new Error('Missing required parameter statusId when calling serviceBoardsIdStatusesStatusIdPatch');
			}
			// verify required parameter 'operations' is set
			if (params.operations == null) {
				throw new Error('Missing required parameter operations when calling serviceBoardsIdStatusesStatusIdPatch');
			}
			let fetchParams = {
				method: 'PATCH',
				headers: headerParams,
				body: JSON.stringify(params.operations),

			};

			if (extraFetchParams) {
				fetchParams = assign(fetchParams, extraFetchParams);
			}

			let localVarPathWithQueryParameters = localVarPath + (localVarPath.indexOf('?') !== -1 ? '&' : '?') + querystring.stringify(queryParameters);

			return fetch(localVarPathWithQueryParameters, fetchParams).then((response) => {
				if (response.status >= 200 && response.status < 300) {
					return response.json();
				} else {
					let error = new Error(response.statusText);
					(error as any).response = response;
					throw error;
				}
			});
		}
		/**
		 *
		 * Replace Statuses
		 * @param id
		 * @param statusId
		 * @param status
		 */
		public serviceBoardsIdStatusesStatusIdPut (params: {  id: number; statusId: number; status: Status; }, extraQueryParams?: any, extraFetchParams?: any ) : Promise<Status> {
			const localVarPath = this.basePath + '/service/boards/{id}/statuses/{statusId}'
				.replace('{' + 'id' + '}', String(params.id))
				.replace('{' + 'statusId' + '}', String(params.statusId));

			let queryParameters: any = assign({}, extraQueryParams);
			let headerParams: any = assign({}, this.defaultHeaders);
			headerParams['Content-Type'] = 'application/json';

			// verify required parameter 'id' is set
			if (params.id == null) {
				throw new Error('Missing required parameter id when calling serviceBoardsIdStatusesStatusIdPut');
			}
			// verify required parameter 'statusId' is set
			if (params.statusId == null) {
				throw new Error('Missing required parameter statusId when calling serviceBoardsIdStatusesStatusIdPut');
			}
			// verify required parameter 'status' is set
			if (params.status == null) {
				throw new Error('Missing required parameter status when calling serviceBoardsIdStatusesStatusIdPut');
			}
			let fetchParams = {
				method: 'PUT',
				headers: headerParams,
				body: JSON.stringify(params.status),

			};

			if (extraFetchParams) {
				fetchParams = assign(fetchParams, extraFetchParams);
			}

			let localVarPathWithQueryParameters = localVarPath + (localVarPath.indexOf('?') !== -1 ? '&' : '?') + querystring.stringify(queryParameters);

			return fetch(localVarPathWithQueryParameters, fetchParams).then((response) => {
				if (response.status >= 200 && response.status < 300) {
					return response.json();
				} else {
					let error = new Error(response.statusText);
					(error as any).response = response;
					throw error;
				}
			});
		}
	}
//}
//export namespace  {
	'use strict';

	export class BoardSubTypesApi {
		protected basePath = 'https://api-na.myconnectwise.net/v4_6_release/apis/3.0';
		public defaultHeaders : any = {};

		constructor(basePath?: string) {
			if (basePath) {
				this.basePath = basePath;
			}
		}

		/**
		 *
		 * Get Subtypes Count
		 * @param id
		 * @param conditions
		 */
		public serviceBoardsIdSubtypesCountGet (params: {  id: number; conditions?: string; }, extraQueryParams?: any, extraFetchParams?: any ) : Promise<Count> {
			const localVarPath = this.basePath + '/service/boards/{id}/subtypes/count'
				.replace('{' + 'id' + '}', String(params.id));

			let queryParameters: any = assign({}, extraQueryParams);
			let headerParams: any = assign({}, this.defaultHeaders);
			// verify required parameter 'id' is set
			if (params.id == null) {
				throw new Error('Missing required parameter id when calling serviceBoardsIdSubtypesCountGet');
			}
			if (params.conditions !== undefined) {
				queryParameters['conditions'] = params.conditions;
			}

			let fetchParams = {
				method: 'GET',
				headers: headerParams,

			};

			if (extraFetchParams) {
				fetchParams = assign(fetchParams, extraFetchParams);
			}

			let localVarPathWithQueryParameters = localVarPath + (localVarPath.indexOf('?') !== -1 ? '&' : '?') + querystring.stringify(queryParameters);

			return fetch(localVarPathWithQueryParameters, fetchParams).then((response) => {
				if (response.status >= 200 && response.status < 300) {
					return response.json();
				} else {
					let error = new Error(response.statusText);
					(error as any).response = response;
					throw error;
				}
			});
		}
		/**
		 *
		 * Get Subtypes
		 * @param id
		 * @param conditions
		 * @param orderBy
		 * @param childconditions
		 * @param customfieldconditions
		 * @param page
		 * @param pageSize
		 */
		public serviceBoardsIdSubtypesGet (params: {  id: number; conditions?: string; orderBy?: string; childconditions?: string; customfieldconditions?: string; page?: number; pageSize?: number; }, extraQueryParams?: any, extraFetchParams?: any ) : Promise<Array<SubType>> {
			const localVarPath = this.basePath + '/service/boards/{id}/subtypes'
				.replace('{' + 'id' + '}', String(params.id));

			let queryParameters: any = assign({}, extraQueryParams);
			let headerParams: any = assign({}, this.defaultHeaders);
			// verify required parameter 'id' is set
			if (params.id == null) {
				throw new Error('Missing required parameter id when calling serviceBoardsIdSubtypesGet');
			}
			if (params.conditions !== undefined) {
				queryParameters['conditions'] = params.conditions;
			}

			if (params.orderBy !== undefined) {
				queryParameters['orderBy'] = params.orderBy;
			}

			if (params.childconditions !== undefined) {
				queryParameters['childconditions'] = params.childconditions;
			}

			if (params.customfieldconditions !== undefined) {
				queryParameters['customfieldconditions'] = params.customfieldconditions;
			}

			if (params.page !== undefined) {
				queryParameters['page'] = params.page;
			}

			if (params.pageSize !== undefined) {
				queryParameters['pageSize'] = params.pageSize;
			}

			let fetchParams = {
				method: 'GET',
				headers: headerParams,

			};

			if (extraFetchParams) {
				fetchParams = assign(fetchParams, extraFetchParams);
			}

			let localVarPathWithQueryParameters = localVarPath + (localVarPath.indexOf('?') !== -1 ? '&' : '?') + querystring.stringify(queryParameters);

			return fetch(localVarPathWithQueryParameters, fetchParams).then((response) => {
				if (response.status >= 200 && response.status < 300) {
					return response.json();
				} else {
					let error = new Error(response.statusText);
					(error as any).response = response;
					throw error;
				}
			});
		}
		/**
		 *
		 * Create Subtype
		 * @param id
		 * @param subType
		 */
		public serviceBoardsIdSubtypesPost (params: {  id: number; subType: SubType; }, extraQueryParams?: any, extraFetchParams?: any ) : Promise<SubType> {
			const localVarPath = this.basePath + '/service/boards/{id}/subtypes'
				.replace('{' + 'id' + '}', String(params.id));

			let queryParameters: any = assign({}, extraQueryParams);
			let headerParams: any = assign({}, this.defaultHeaders);
			headerParams['Content-Type'] = 'application/json';

			// verify required parameter 'id' is set
			if (params.id == null) {
				throw new Error('Missing required parameter id when calling serviceBoardsIdSubtypesPost');
			}
			// verify required parameter 'subType' is set
			if (params.subType == null) {
				throw new Error('Missing required parameter subType when calling serviceBoardsIdSubtypesPost');
			}
			let fetchParams = {
				method: 'POST',
				headers: headerParams,
				body: JSON.stringify(params.subType),

			};

			if (extraFetchParams) {
				fetchParams = assign(fetchParams, extraFetchParams);
			}

			let localVarPathWithQueryParameters = localVarPath + (localVarPath.indexOf('?') !== -1 ? '&' : '?') + querystring.stringify(queryParameters);

			return fetch(localVarPathWithQueryParameters, fetchParams).then((response) => {
				if (response.status >= 200 && response.status < 300) {
					return response.json();
				} else {
					let error = new Error(response.statusText);
					(error as any).response = response;
					throw error;
				}
			});
		}
		/**
		 *
		 * Delete Subtype By Id
		 * @param id
		 * @param subtypeId
		 */
		public serviceBoardsIdSubtypesSubtypeIdDelete (params: {  id: number; subtypeId: number; }, extraQueryParams?: any, extraFetchParams?: any ) : Promise<{}> {
			const localVarPath = this.basePath + '/service/boards/{id}/subtypes/{subtypeId}'
				.replace('{' + 'id' + '}', String(params.id))
				.replace('{' + 'subtypeId' + '}', String(params.subtypeId));

			let queryParameters: any = assign({}, extraQueryParams);
			let headerParams: any = assign({}, this.defaultHeaders);
			// verify required parameter 'id' is set
			if (params.id == null) {
				throw new Error('Missing required parameter id when calling serviceBoardsIdSubtypesSubtypeIdDelete');
			}
			// verify required parameter 'subtypeId' is set
			if (params.subtypeId == null) {
				throw new Error('Missing required parameter subtypeId when calling serviceBoardsIdSubtypesSubtypeIdDelete');
			}
			let fetchParams = {
				method: 'DELETE',
				headers: headerParams,

			};

			if (extraFetchParams) {
				fetchParams = assign(fetchParams, extraFetchParams);
			}

			let localVarPathWithQueryParameters = localVarPath + (localVarPath.indexOf('?') !== -1 ? '&' : '?') + querystring.stringify(queryParameters);

			return fetch(localVarPathWithQueryParameters, fetchParams).then((response) => {
				if (response.status >= 200 && response.status < 300) {
					return response.json();
				} else {
					let error = new Error(response.statusText);
					(error as any).response = response;
					throw error;
				}
			});
		}
		/**
		 *
		 * Get Subtype By Id
		 * @param id
		 * @param subtypeId
		 */
		public serviceBoardsIdSubtypesSubtypeIdGet (params: {  id: number; subtypeId: number; }, extraQueryParams?: any, extraFetchParams?: any ) : Promise<SubType> {
			const localVarPath = this.basePath + '/service/boards/{id}/subtypes/{subtypeId}'
				.replace('{' + 'id' + '}', String(params.id))
				.replace('{' + 'subtypeId' + '}', String(params.subtypeId));

			let queryParameters: any = assign({}, extraQueryParams);
			let headerParams: any = assign({}, this.defaultHeaders);
			// verify required parameter 'id' is set
			if (params.id == null) {
				throw new Error('Missing required parameter id when calling serviceBoardsIdSubtypesSubtypeIdGet');
			}
			// verify required parameter 'subtypeId' is set
			if (params.subtypeId == null) {
				throw new Error('Missing required parameter subtypeId when calling serviceBoardsIdSubtypesSubtypeIdGet');
			}
			let fetchParams = {
				method: 'GET',
				headers: headerParams,

			};

			if (extraFetchParams) {
				fetchParams = assign(fetchParams, extraFetchParams);
			}

			let localVarPathWithQueryParameters = localVarPath + (localVarPath.indexOf('?') !== -1 ? '&' : '?') + querystring.stringify(queryParameters);

			return fetch(localVarPathWithQueryParameters, fetchParams).then((response) => {
				if (response.status >= 200 && response.status < 300) {
					return response.json();
				} else {
					let error = new Error(response.statusText);
					(error as any).response = response;
					throw error;
				}
			});
		}
		/**
		 *
		 * Update Subtype
		 * @param id
		 * @param subtypeId
		 * @param operations
		 */
		public serviceBoardsIdSubtypesSubtypeIdPatch (params: {  id: number; subtypeId: number; operations: Array<PatchOperation>; }, extraQueryParams?: any, extraFetchParams?: any ) : Promise<SubType> {
			const localVarPath = this.basePath + '/service/boards/{id}/subtypes/{subtypeId}'
				.replace('{' + 'id' + '}', String(params.id))
				.replace('{' + 'subtypeId' + '}', String(params.subtypeId));

			let queryParameters: any = assign({}, extraQueryParams);
			let headerParams: any = assign({}, this.defaultHeaders);
			headerParams['Content-Type'] = 'application/json';

			// verify required parameter 'id' is set
			if (params.id == null) {
				throw new Error('Missing required parameter id when calling serviceBoardsIdSubtypesSubtypeIdPatch');
			}
			// verify required parameter 'subtypeId' is set
			if (params.subtypeId == null) {
				throw new Error('Missing required parameter subtypeId when calling serviceBoardsIdSubtypesSubtypeIdPatch');
			}
			// verify required parameter 'operations' is set
			if (params.operations == null) {
				throw new Error('Missing required parameter operations when calling serviceBoardsIdSubtypesSubtypeIdPatch');
			}
			let fetchParams = {
				method: 'PATCH',
				headers: headerParams,
				body: JSON.stringify(params.operations),

			};

			if (extraFetchParams) {
				fetchParams = assign(fetchParams, extraFetchParams);
			}

			let localVarPathWithQueryParameters = localVarPath + (localVarPath.indexOf('?') !== -1 ? '&' : '?') + querystring.stringify(queryParameters);

			return fetch(localVarPathWithQueryParameters, fetchParams).then((response) => {
				if (response.status >= 200 && response.status < 300) {
					return response.json();
				} else {
					let error = new Error(response.statusText);
					(error as any).response = response;
					throw error;
				}
			});
		}
		/**
		 *
		 * Replace Subtype
		 * @param id
		 * @param subtypeId
		 * @param subType
		 */
		public serviceBoardsIdSubtypesSubtypeIdPut (params: {  id: number; subtypeId: number; subType: SubType; }, extraQueryParams?: any, extraFetchParams?: any ) : Promise<SubType> {
			const localVarPath = this.basePath + '/service/boards/{id}/subtypes/{subtypeId}'
				.replace('{' + 'id' + '}', String(params.id))
				.replace('{' + 'subtypeId' + '}', String(params.subtypeId));

			let queryParameters: any = assign({}, extraQueryParams);
			let headerParams: any = assign({}, this.defaultHeaders);
			headerParams['Content-Type'] = 'application/json';

			// verify required parameter 'id' is set
			if (params.id == null) {
				throw new Error('Missing required parameter id when calling serviceBoardsIdSubtypesSubtypeIdPut');
			}
			// verify required parameter 'subtypeId' is set
			if (params.subtypeId == null) {
				throw new Error('Missing required parameter subtypeId when calling serviceBoardsIdSubtypesSubtypeIdPut');
			}
			// verify required parameter 'subType' is set
			if (params.subType == null) {
				throw new Error('Missing required parameter subType when calling serviceBoardsIdSubtypesSubtypeIdPut');
			}
			let fetchParams = {
				method: 'PUT',
				headers: headerParams,
				body: JSON.stringify(params.subType),

			};

			if (extraFetchParams) {
				fetchParams = assign(fetchParams, extraFetchParams);
			}

			let localVarPathWithQueryParameters = localVarPath + (localVarPath.indexOf('?') !== -1 ? '&' : '?') + querystring.stringify(queryParameters);

			return fetch(localVarPathWithQueryParameters, fetchParams).then((response) => {
				if (response.status >= 200 && response.status < 300) {
					return response.json();
				} else {
					let error = new Error(response.statusText);
					(error as any).response = response;
					throw error;
				}
			});
		}
	}
//}
//export namespace  {
	'use strict';

	export class BoardSubtypeAssociationsApi {
		protected basePath = 'https://api-na.myconnectwise.net/v4_6_release/apis/3.0';
		public defaultHeaders : any = {};

		constructor(basePath?: string) {
			if (basePath) {
				this.basePath = basePath;
			}
		}

		/**
		 *
		 * Delete Subtype Association By Id
		 * @param boardId
		 * @param subtypeId
		 * @param associationId
		 */
		public serviceBoardsBoardIdSubTypesSubtypeIdAssociationsAssociationIdDelete (params: {  boardId: number; subtypeId: number; associationId: number; }, extraQueryParams?: any, extraFetchParams?: any ) : Promise<{}> {
			const localVarPath = this.basePath + '/service/boards/{boardId}/subTypes/{subtypeId}/associations/{associationId}'
				.replace('{' + 'boardId' + '}', String(params.boardId))
				.replace('{' + 'subtypeId' + '}', String(params.subtypeId))
				.replace('{' + 'associationId' + '}', String(params.associationId));

			let queryParameters: any = assign({}, extraQueryParams);
			let headerParams: any = assign({}, this.defaultHeaders);
			// verify required parameter 'boardId' is set
			if (params.boardId == null) {
				throw new Error('Missing required parameter boardId when calling serviceBoardsBoardIdSubTypesSubtypeIdAssociationsAssociationIdDelete');
			}
			// verify required parameter 'subtypeId' is set
			if (params.subtypeId == null) {
				throw new Error('Missing required parameter subtypeId when calling serviceBoardsBoardIdSubTypesSubtypeIdAssociationsAssociationIdDelete');
			}
			// verify required parameter 'associationId' is set
			if (params.associationId == null) {
				throw new Error('Missing required parameter associationId when calling serviceBoardsBoardIdSubTypesSubtypeIdAssociationsAssociationIdDelete');
			}
			let fetchParams = {
				method: 'DELETE',
				headers: headerParams,

			};

			if (extraFetchParams) {
				fetchParams = assign(fetchParams, extraFetchParams);
			}

			let localVarPathWithQueryParameters = localVarPath + (localVarPath.indexOf('?') !== -1 ? '&' : '?') + querystring.stringify(queryParameters);

			return fetch(localVarPathWithQueryParameters, fetchParams).then((response) => {
				if (response.status >= 200 && response.status < 300) {
					return response.json();
				} else {
					let error = new Error(response.statusText);
					(error as any).response = response;
					throw error;
				}
			});
		}
		/**
		 *
		 * Get Subtype Association By Id
		 * @param boardId
		 * @param subtypeId
		 * @param associationId
		 */
		public serviceBoardsBoardIdSubTypesSubtypeIdAssociationsAssociationIdGet (params: {  boardId: number; subtypeId: number; associationId: number; }, extraQueryParams?: any, extraFetchParams?: any ) : Promise<SubtypeAssociation> {
			const localVarPath = this.basePath + '/service/boards/{boardId}/subTypes/{subtypeId}/associations/{associationId}'
				.replace('{' + 'boardId' + '}', String(params.boardId))
				.replace('{' + 'subtypeId' + '}', String(params.subtypeId))
				.replace('{' + 'associationId' + '}', String(params.associationId));

			let queryParameters: any = assign({}, extraQueryParams);
			let headerParams: any = assign({}, this.defaultHeaders);
			// verify required parameter 'boardId' is set
			if (params.boardId == null) {
				throw new Error('Missing required parameter boardId when calling serviceBoardsBoardIdSubTypesSubtypeIdAssociationsAssociationIdGet');
			}
			// verify required parameter 'subtypeId' is set
			if (params.subtypeId == null) {
				throw new Error('Missing required parameter subtypeId when calling serviceBoardsBoardIdSubTypesSubtypeIdAssociationsAssociationIdGet');
			}
			// verify required parameter 'associationId' is set
			if (params.associationId == null) {
				throw new Error('Missing required parameter associationId when calling serviceBoardsBoardIdSubTypesSubtypeIdAssociationsAssociationIdGet');
			}
			let fetchParams = {
				method: 'GET',
				headers: headerParams,

			};

			if (extraFetchParams) {
				fetchParams = assign(fetchParams, extraFetchParams);
			}

			let localVarPathWithQueryParameters = localVarPath + (localVarPath.indexOf('?') !== -1 ? '&' : '?') + querystring.stringify(queryParameters);

			return fetch(localVarPathWithQueryParameters, fetchParams).then((response) => {
				if (response.status >= 200 && response.status < 300) {
					return response.json();
				} else {
					let error = new Error(response.statusText);
					(error as any).response = response;
					throw error;
				}
			});
		}
		/**
		 *
		 * Get Subtype Association Count
		 * @param boardId
		 * @param subtypeId
		 * @param conditions
		 */
		public serviceBoardsBoardIdSubTypesSubtypeIdAssociationsCountGet (params: {  boardId: number; subtypeId: number; conditions?: string; }, extraQueryParams?: any, extraFetchParams?: any ) : Promise<Count> {
			const localVarPath = this.basePath + '/service/boards/{boardId}/subTypes/{subtypeId}/associations/count'
				.replace('{' + 'boardId' + '}', String(params.boardId))
				.replace('{' + 'subtypeId' + '}', String(params.subtypeId));

			let queryParameters: any = assign({}, extraQueryParams);
			let headerParams: any = assign({}, this.defaultHeaders);
			// verify required parameter 'boardId' is set
			if (params.boardId == null) {
				throw new Error('Missing required parameter boardId when calling serviceBoardsBoardIdSubTypesSubtypeIdAssociationsCountGet');
			}
			// verify required parameter 'subtypeId' is set
			if (params.subtypeId == null) {
				throw new Error('Missing required parameter subtypeId when calling serviceBoardsBoardIdSubTypesSubtypeIdAssociationsCountGet');
			}
			if (params.conditions !== undefined) {
				queryParameters['conditions'] = params.conditions;
			}

			let fetchParams = {
				method: 'GET',
				headers: headerParams,

			};

			if (extraFetchParams) {
				fetchParams = assign(fetchParams, extraFetchParams);
			}

			let localVarPathWithQueryParameters = localVarPath + (localVarPath.indexOf('?') !== -1 ? '&' : '?') + querystring.stringify(queryParameters);

			return fetch(localVarPathWithQueryParameters, fetchParams).then((response) => {
				if (response.status >= 200 && response.status < 300) {
					return response.json();
				} else {
					let error = new Error(response.statusText);
					(error as any).response = response;
					throw error;
				}
			});
		}
		/**
		 *
		 * Get Subtype Association
		 * @param boardId
		 * @param subtypeId
		 * @param conditions
		 * @param orderBy
		 * @param childconditions
		 * @param customfieldconditions
		 * @param page
		 * @param pageSize
		 */
		public serviceBoardsBoardIdSubTypesSubtypeIdAssociationsGet (params: {  boardId: number; subtypeId: number; conditions?: string; orderBy?: string; childconditions?: string; customfieldconditions?: string; page?: number; pageSize?: number; }, extraQueryParams?: any, extraFetchParams?: any ) : Promise<Array<SubtypeAssociation>> {
			const localVarPath = this.basePath + '/service/boards/{boardId}/subTypes/{subtypeId}/associations'
				.replace('{' + 'boardId' + '}', String(params.boardId))
				.replace('{' + 'subtypeId' + '}', String(params.subtypeId));

			let queryParameters: any = assign({}, extraQueryParams);
			let headerParams: any = assign({}, this.defaultHeaders);
			// verify required parameter 'boardId' is set
			if (params.boardId == null) {
				throw new Error('Missing required parameter boardId when calling serviceBoardsBoardIdSubTypesSubtypeIdAssociationsGet');
			}
			// verify required parameter 'subtypeId' is set
			if (params.subtypeId == null) {
				throw new Error('Missing required parameter subtypeId when calling serviceBoardsBoardIdSubTypesSubtypeIdAssociationsGet');
			}
			if (params.conditions !== undefined) {
				queryParameters['conditions'] = params.conditions;
			}

			if (params.orderBy !== undefined) {
				queryParameters['orderBy'] = params.orderBy;
			}

			if (params.childconditions !== undefined) {
				queryParameters['childconditions'] = params.childconditions;
			}

			if (params.customfieldconditions !== undefined) {
				queryParameters['customfieldconditions'] = params.customfieldconditions;
			}

			if (params.page !== undefined) {
				queryParameters['page'] = params.page;
			}

			if (params.pageSize !== undefined) {
				queryParameters['pageSize'] = params.pageSize;
			}

			let fetchParams = {
				method: 'GET',
				headers: headerParams,

			};

			if (extraFetchParams) {
				fetchParams = assign(fetchParams, extraFetchParams);
			}

			let localVarPathWithQueryParameters = localVarPath + (localVarPath.indexOf('?') !== -1 ? '&' : '?') + querystring.stringify(queryParameters);

			return fetch(localVarPathWithQueryParameters, fetchParams).then((response) => {
				if (response.status >= 200 && response.status < 300) {
					return response.json();
				} else {
					let error = new Error(response.statusText);
					(error as any).response = response;
					throw error;
				}
			});
		}
		/**
		 *
		 * Create Subtype Association
		 * @param boardId
		 * @param subtypeId
		 * @param subtypeAssociation
		 */
		public serviceBoardsBoardIdSubTypesSubtypeIdAssociationsPost (params: {  boardId: number; subtypeId: number; subtypeAssociation: SubtypeAssociation; }, extraQueryParams?: any, extraFetchParams?: any ) : Promise<SubtypeAssociation> {
			const localVarPath = this.basePath + '/service/boards/{boardId}/subTypes/{subtypeId}/associations'
				.replace('{' + 'boardId' + '}', String(params.boardId))
				.replace('{' + 'subtypeId' + '}', String(params.subtypeId));

			let queryParameters: any = assign({}, extraQueryParams);
			let headerParams: any = assign({}, this.defaultHeaders);
			headerParams['Content-Type'] = 'application/json';

			// verify required parameter 'boardId' is set
			if (params.boardId == null) {
				throw new Error('Missing required parameter boardId when calling serviceBoardsBoardIdSubTypesSubtypeIdAssociationsPost');
			}
			// verify required parameter 'subtypeId' is set
			if (params.subtypeId == null) {
				throw new Error('Missing required parameter subtypeId when calling serviceBoardsBoardIdSubTypesSubtypeIdAssociationsPost');
			}
			// verify required parameter 'subtypeAssociation' is set
			if (params.subtypeAssociation == null) {
				throw new Error('Missing required parameter subtypeAssociation when calling serviceBoardsBoardIdSubTypesSubtypeIdAssociationsPost');
			}
			let fetchParams = {
				method: 'POST',
				headers: headerParams,
				body: JSON.stringify(params.subtypeAssociation),

			};

			if (extraFetchParams) {
				fetchParams = assign(fetchParams, extraFetchParams);
			}

			let localVarPathWithQueryParameters = localVarPath + (localVarPath.indexOf('?') !== -1 ? '&' : '?') + querystring.stringify(queryParameters);

			return fetch(localVarPathWithQueryParameters, fetchParams).then((response) => {
				if (response.status >= 200 && response.status < 300) {
					return response.json();
				} else {
					let error = new Error(response.statusText);
					(error as any).response = response;
					throw error;
				}
			});
		}
	}
//}
//export namespace  {
	'use strict';

	export class BoardTeamsApi {
		protected basePath = 'https://api-na.myconnectwise.net/v4_6_release/apis/3.0';
		public defaultHeaders : any = {};

		constructor(basePath?: string) {
			if (basePath) {
				this.basePath = basePath;
			}
		}

		/**
		 *
		 * Get Teams Count
		 * @param id
		 * @param conditions
		 */
		public serviceBoardsIdTeamsCountGet (params: {  id: number; conditions?: string; }, extraQueryParams?: any, extraFetchParams?: any ) : Promise<Count> {
			const localVarPath = this.basePath + '/service/boards/{id}/teams/count'
				.replace('{' + 'id' + '}', String(params.id));

			let queryParameters: any = assign({}, extraQueryParams);
			let headerParams: any = assign({}, this.defaultHeaders);
			// verify required parameter 'id' is set
			if (params.id == null) {
				throw new Error('Missing required parameter id when calling serviceBoardsIdTeamsCountGet');
			}
			if (params.conditions !== undefined) {
				queryParameters['conditions'] = params.conditions;
			}

			let fetchParams = {
				method: 'GET',
				headers: headerParams,

			};

			if (extraFetchParams) {
				fetchParams = assign(fetchParams, extraFetchParams);
			}

			let localVarPathWithQueryParameters = localVarPath + (localVarPath.indexOf('?') !== -1 ? '&' : '?') + querystring.stringify(queryParameters);

			return fetch(localVarPathWithQueryParameters, fetchParams).then((response) => {
				if (response.status >= 200 && response.status < 300) {
					return response.json();
				} else {
					let error = new Error(response.statusText);
					(error as any).response = response;
					throw error;
				}
			});
		}
		/**
		 *
		 * Get Teams
		 * @param id
		 * @param conditions
		 * @param orderBy
		 * @param childconditions
		 * @param customfieldconditions
		 * @param page
		 * @param pageSize
		 */
		public serviceBoardsIdTeamsGet (params: {  id: number; conditions?: string; orderBy?: string; childconditions?: string; customfieldconditions?: string; page?: number; pageSize?: number; }, extraQueryParams?: any, extraFetchParams?: any ) : Promise<Array<Team>> {
			const localVarPath = this.basePath + '/service/boards/{id}/teams'
				.replace('{' + 'id' + '}', String(params.id));

			let queryParameters: any = assign({}, extraQueryParams);
			let headerParams: any = assign({}, this.defaultHeaders);
			// verify required parameter 'id' is set
			if (params.id == null) {
				throw new Error('Missing required parameter id when calling serviceBoardsIdTeamsGet');
			}
			if (params.conditions !== undefined) {
				queryParameters['conditions'] = params.conditions;
			}

			if (params.orderBy !== undefined) {
				queryParameters['orderBy'] = params.orderBy;
			}

			if (params.childconditions !== undefined) {
				queryParameters['childconditions'] = params.childconditions;
			}

			if (params.customfieldconditions !== undefined) {
				queryParameters['customfieldconditions'] = params.customfieldconditions;
			}

			if (params.page !== undefined) {
				queryParameters['page'] = params.page;
			}

			if (params.pageSize !== undefined) {
				queryParameters['pageSize'] = params.pageSize;
			}

			let fetchParams = {
				method: 'GET',
				headers: headerParams,

			};

			if (extraFetchParams) {
				fetchParams = assign(fetchParams, extraFetchParams);
			}

			let localVarPathWithQueryParameters = localVarPath + (localVarPath.indexOf('?') !== -1 ? '&' : '?') + querystring.stringify(queryParameters);

			return fetch(localVarPathWithQueryParameters, fetchParams).then((response) => {
				if (response.status >= 200 && response.status < 300) {
					return response.json();
				} else {
					let error = new Error(response.statusText);
					(error as any).response = response;
					throw error;
				}
			});
		}
		/**
		 *
		 * Create Team
		 * @param id
		 * @param team
		 */
		public serviceBoardsIdTeamsPost (params: {  id: number; team: Team; }, extraQueryParams?: any, extraFetchParams?: any ) : Promise<Team> {
			const localVarPath = this.basePath + '/service/boards/{id}/teams'
				.replace('{' + 'id' + '}', String(params.id));

			let queryParameters: any = assign({}, extraQueryParams);
			let headerParams: any = assign({}, this.defaultHeaders);
			headerParams['Content-Type'] = 'application/json';

			// verify required parameter 'id' is set
			if (params.id == null) {
				throw new Error('Missing required parameter id when calling serviceBoardsIdTeamsPost');
			}
			// verify required parameter 'team' is set
			if (params.team == null) {
				throw new Error('Missing required parameter team when calling serviceBoardsIdTeamsPost');
			}
			let fetchParams = {
				method: 'POST',
				headers: headerParams,
				body: JSON.stringify(params.team),

			};

			if (extraFetchParams) {
				fetchParams = assign(fetchParams, extraFetchParams);
			}

			let localVarPathWithQueryParameters = localVarPath + (localVarPath.indexOf('?') !== -1 ? '&' : '?') + querystring.stringify(queryParameters);

			return fetch(localVarPathWithQueryParameters, fetchParams).then((response) => {
				if (response.status >= 200 && response.status < 300) {
					return response.json();
				} else {
					let error = new Error(response.statusText);
					(error as any).response = response;
					throw error;
				}
			});
		}
		/**
		 *
		 * Delete Team By Id
		 * @param id
		 * @param teamId
		 */
		public serviceBoardsIdTeamsTeamIdDelete (params: {  id: number; teamId: number; }, extraQueryParams?: any, extraFetchParams?: any ) : Promise<{}> {
			const localVarPath = this.basePath + '/service/boards/{id}/teams/{teamId}'
				.replace('{' + 'id' + '}', String(params.id))
				.replace('{' + 'teamId' + '}', String(params.teamId));

			let queryParameters: any = assign({}, extraQueryParams);
			let headerParams: any = assign({}, this.defaultHeaders);
			// verify required parameter 'id' is set
			if (params.id == null) {
				throw new Error('Missing required parameter id when calling serviceBoardsIdTeamsTeamIdDelete');
			}
			// verify required parameter 'teamId' is set
			if (params.teamId == null) {
				throw new Error('Missing required parameter teamId when calling serviceBoardsIdTeamsTeamIdDelete');
			}
			let fetchParams = {
				method: 'DELETE',
				headers: headerParams,

			};

			if (extraFetchParams) {
				fetchParams = assign(fetchParams, extraFetchParams);
			}

			let localVarPathWithQueryParameters = localVarPath + (localVarPath.indexOf('?') !== -1 ? '&' : '?') + querystring.stringify(queryParameters);

			return fetch(localVarPathWithQueryParameters, fetchParams).then((response) => {
				if (response.status >= 200 && response.status < 300) {
					return response.json();
				} else {
					let error = new Error(response.statusText);
					(error as any).response = response;
					throw error;
				}
			});
		}
		/**
		 *
		 * Get Team By Id
		 * @param id
		 * @param teamId
		 */
		public serviceBoardsIdTeamsTeamIdGet (params: {  id: number; teamId: number; }, extraQueryParams?: any, extraFetchParams?: any ) : Promise<Team> {
			const localVarPath = this.basePath + '/service/boards/{id}/teams/{teamId}'
				.replace('{' + 'id' + '}', String(params.id))
				.replace('{' + 'teamId' + '}', String(params.teamId));

			let queryParameters: any = assign({}, extraQueryParams);
			let headerParams: any = assign({}, this.defaultHeaders);
			// verify required parameter 'id' is set
			if (params.id == null) {
				throw new Error('Missing required parameter id when calling serviceBoardsIdTeamsTeamIdGet');
			}
			// verify required parameter 'teamId' is set
			if (params.teamId == null) {
				throw new Error('Missing required parameter teamId when calling serviceBoardsIdTeamsTeamIdGet');
			}
			let fetchParams = {
				method: 'GET',
				headers: headerParams,

			};

			if (extraFetchParams) {
				fetchParams = assign(fetchParams, extraFetchParams);
			}

			let localVarPathWithQueryParameters = localVarPath + (localVarPath.indexOf('?') !== -1 ? '&' : '?') + querystring.stringify(queryParameters);

			return fetch(localVarPathWithQueryParameters, fetchParams).then((response) => {
				if (response.status >= 200 && response.status < 300) {
					return response.json();
				} else {
					let error = new Error(response.statusText);
					(error as any).response = response;
					throw error;
				}
			});
		}
		/**
		 *
		 * Update Team
		 * @param id
		 * @param teamId
		 * @param operations
		 */
		public serviceBoardsIdTeamsTeamIdPatch (params: {  id: number; teamId: number; operations: Array<PatchOperation>; }, extraQueryParams?: any, extraFetchParams?: any ) : Promise<Team> {
			const localVarPath = this.basePath + '/service/boards/{id}/teams/{teamId}'
				.replace('{' + 'id' + '}', String(params.id))
				.replace('{' + 'teamId' + '}', String(params.teamId));

			let queryParameters: any = assign({}, extraQueryParams);
			let headerParams: any = assign({}, this.defaultHeaders);
			headerParams['Content-Type'] = 'application/json';

			// verify required parameter 'id' is set
			if (params.id == null) {
				throw new Error('Missing required parameter id when calling serviceBoardsIdTeamsTeamIdPatch');
			}
			// verify required parameter 'teamId' is set
			if (params.teamId == null) {
				throw new Error('Missing required parameter teamId when calling serviceBoardsIdTeamsTeamIdPatch');
			}
			// verify required parameter 'operations' is set
			if (params.operations == null) {
				throw new Error('Missing required parameter operations when calling serviceBoardsIdTeamsTeamIdPatch');
			}
			let fetchParams = {
				method: 'PATCH',
				headers: headerParams,
				body: JSON.stringify(params.operations),

			};

			if (extraFetchParams) {
				fetchParams = assign(fetchParams, extraFetchParams);
			}

			let localVarPathWithQueryParameters = localVarPath + (localVarPath.indexOf('?') !== -1 ? '&' : '?') + querystring.stringify(queryParameters);

			return fetch(localVarPathWithQueryParameters, fetchParams).then((response) => {
				if (response.status >= 200 && response.status < 300) {
					return response.json();
				} else {
					let error = new Error(response.statusText);
					(error as any).response = response;
					throw error;
				}
			});
		}
		/**
		 *
		 * Replace Team
		 * @param id
		 * @param teamId
		 * @param team
		 */
		public serviceBoardsIdTeamsTeamIdPut (params: {  id: number; teamId: number; team: Team; }, extraQueryParams?: any, extraFetchParams?: any ) : Promise<Team> {
			const localVarPath = this.basePath + '/service/boards/{id}/teams/{teamId}'
				.replace('{' + 'id' + '}', String(params.id))
				.replace('{' + 'teamId' + '}', String(params.teamId));

			let queryParameters: any = assign({}, extraQueryParams);
			let headerParams: any = assign({}, this.defaultHeaders);
			headerParams['Content-Type'] = 'application/json';

			// verify required parameter 'id' is set
			if (params.id == null) {
				throw new Error('Missing required parameter id when calling serviceBoardsIdTeamsTeamIdPut');
			}
			// verify required parameter 'teamId' is set
			if (params.teamId == null) {
				throw new Error('Missing required parameter teamId when calling serviceBoardsIdTeamsTeamIdPut');
			}
			// verify required parameter 'team' is set
			if (params.team == null) {
				throw new Error('Missing required parameter team when calling serviceBoardsIdTeamsTeamIdPut');
			}
			let fetchParams = {
				method: 'PUT',
				headers: headerParams,
				body: JSON.stringify(params.team),

			};

			if (extraFetchParams) {
				fetchParams = assign(fetchParams, extraFetchParams);
			}

			let localVarPathWithQueryParameters = localVarPath + (localVarPath.indexOf('?') !== -1 ? '&' : '?') + querystring.stringify(queryParameters);

			return fetch(localVarPathWithQueryParameters, fetchParams).then((response) => {
				if (response.status >= 200 && response.status < 300) {
					return response.json();
				} else {
					let error = new Error(response.statusText);
					(error as any).response = response;
					throw error;
				}
			});
		}
	}
//}
//export namespace  {
	'use strict';

	export class BoardTypesApi {
		protected basePath = 'https://api-na.myconnectwise.net/v4_6_release/apis/3.0';
		public defaultHeaders : any = {};

		constructor(basePath?: string) {
			if (basePath) {
				this.basePath = basePath;
			}
		}

		/**
		 *
		 * Get Types Count
		 * @param id
		 * @param conditions
		 */
		public serviceBoardsIdTypesCountGet (params: {  id: number; conditions?: string; }, extraQueryParams?: any, extraFetchParams?: any ) : Promise<Count> {
			const localVarPath = this.basePath + '/service/boards/{id}/types/count'
				.replace('{' + 'id' + '}', String(params.id));

			let queryParameters: any = assign({}, extraQueryParams);
			let headerParams: any = assign({}, this.defaultHeaders);
			// verify required parameter 'id' is set
			if (params.id == null) {
				throw new Error('Missing required parameter id when calling serviceBoardsIdTypesCountGet');
			}
			if (params.conditions !== undefined) {
				queryParameters['conditions'] = params.conditions;
			}

			let fetchParams = {
				method: 'GET',
				headers: headerParams,

			};

			if (extraFetchParams) {
				fetchParams = assign(fetchParams, extraFetchParams);
			}

			let localVarPathWithQueryParameters = localVarPath + (localVarPath.indexOf('?') !== -1 ? '&' : '?') + querystring.stringify(queryParameters);

			return fetch(localVarPathWithQueryParameters, fetchParams).then((response) => {
				if (response.status >= 200 && response.status < 300) {
					return response.json();
				} else {
					let error = new Error(response.statusText);
					(error as any).response = response;
					throw error;
				}
			});
		}
		/**
		 *
		 * Get Types
		 * @param id
		 * @param conditions
		 * @param orderBy
		 * @param childconditions
		 * @param customfieldconditions
		 * @param page
		 * @param pageSize
		 */
		public serviceBoardsIdTypesGet (params: {  id: number; conditions?: string; orderBy?: string; childconditions?: string; customfieldconditions?: string; page?: number; pageSize?: number; }, extraQueryParams?: any, extraFetchParams?: any ) : Promise<Array<Type>> {
			const localVarPath = this.basePath + '/service/boards/{id}/types'
				.replace('{' + 'id' + '}', String(params.id));

			let queryParameters: any = assign({}, extraQueryParams);
			let headerParams: any = assign({}, this.defaultHeaders);
			// verify required parameter 'id' is set
			if (params.id == null) {
				throw new Error('Missing required parameter id when calling serviceBoardsIdTypesGet');
			}
			if (params.conditions !== undefined) {
				queryParameters['conditions'] = params.conditions;
			}

			if (params.orderBy !== undefined) {
				queryParameters['orderBy'] = params.orderBy;
			}

			if (params.childconditions !== undefined) {
				queryParameters['childconditions'] = params.childconditions;
			}

			if (params.customfieldconditions !== undefined) {
				queryParameters['customfieldconditions'] = params.customfieldconditions;
			}

			if (params.page !== undefined) {
				queryParameters['page'] = params.page;
			}

			if (params.pageSize !== undefined) {
				queryParameters['pageSize'] = params.pageSize;
			}

			let fetchParams = {
				method: 'GET',
				headers: headerParams,

			};

			if (extraFetchParams) {
				fetchParams = assign(fetchParams, extraFetchParams);
			}

			let localVarPathWithQueryParameters = localVarPath + (localVarPath.indexOf('?') !== -1 ? '&' : '?') + querystring.stringify(queryParameters);

			return fetch(localVarPathWithQueryParameters, fetchParams).then((response) => {
				if (response.status >= 200 && response.status < 300) {
					return response.json();
				} else {
					let error = new Error(response.statusText);
					(error as any).response = response;
					throw error;
				}
			});
		}
		/**
		 *
		 * Create Type
		 * @param id
		 * @param type
		 */
		public serviceBoardsIdTypesPost (params: {  id: number; type: Type; }, extraQueryParams?: any, extraFetchParams?: any ) : Promise<Type> {
			const localVarPath = this.basePath + '/service/boards/{id}/types'
				.replace('{' + 'id' + '}', String(params.id));

			let queryParameters: any = assign({}, extraQueryParams);
			let headerParams: any = assign({}, this.defaultHeaders);
			headerParams['Content-Type'] = 'application/json';

			// verify required parameter 'id' is set
			if (params.id == null) {
				throw new Error('Missing required parameter id when calling serviceBoardsIdTypesPost');
			}
			// verify required parameter 'type' is set
			if (params.type == null) {
				throw new Error('Missing required parameter type when calling serviceBoardsIdTypesPost');
			}
			let fetchParams = {
				method: 'POST',
				headers: headerParams,
				body: JSON.stringify(params.type),

			};

			if (extraFetchParams) {
				fetchParams = assign(fetchParams, extraFetchParams);
			}

			let localVarPathWithQueryParameters = localVarPath + (localVarPath.indexOf('?') !== -1 ? '&' : '?') + querystring.stringify(queryParameters);

			return fetch(localVarPathWithQueryParameters, fetchParams).then((response) => {
				if (response.status >= 200 && response.status < 300) {
					return response.json();
				} else {
					let error = new Error(response.statusText);
					(error as any).response = response;
					throw error;
				}
			});
		}
		/**
		 *
		 * Delete Type By Id
		 * @param id
		 * @param typeId
		 */
		public serviceBoardsIdTypesTypeIdDelete (params: {  id: number; typeId: number; }, extraQueryParams?: any, extraFetchParams?: any ) : Promise<{}> {
			const localVarPath = this.basePath + '/service/boards/{id}/types/{typeId}'
				.replace('{' + 'id' + '}', String(params.id))
				.replace('{' + 'typeId' + '}', String(params.typeId));

			let queryParameters: any = assign({}, extraQueryParams);
			let headerParams: any = assign({}, this.defaultHeaders);
			// verify required parameter 'id' is set
			if (params.id == null) {
				throw new Error('Missing required parameter id when calling serviceBoardsIdTypesTypeIdDelete');
			}
			// verify required parameter 'typeId' is set
			if (params.typeId == null) {
				throw new Error('Missing required parameter typeId when calling serviceBoardsIdTypesTypeIdDelete');
			}
			let fetchParams = {
				method: 'DELETE',
				headers: headerParams,

			};

			if (extraFetchParams) {
				fetchParams = assign(fetchParams, extraFetchParams);
			}

			let localVarPathWithQueryParameters = localVarPath + (localVarPath.indexOf('?') !== -1 ? '&' : '?') + querystring.stringify(queryParameters);

			return fetch(localVarPathWithQueryParameters, fetchParams).then((response) => {
				if (response.status >= 200 && response.status < 300) {
					return response.json();
				} else {
					let error = new Error(response.statusText);
					(error as any).response = response;
					throw error;
				}
			});
		}
		/**
		 *
		 * Get Type By Id
		 * @param id
		 * @param typeId
		 */
		public serviceBoardsIdTypesTypeIdGet (params: {  id: number; typeId: number; }, extraQueryParams?: any, extraFetchParams?: any ) : Promise<Type> {
			const localVarPath = this.basePath + '/service/boards/{id}/types/{typeId}'
				.replace('{' + 'id' + '}', String(params.id))
				.replace('{' + 'typeId' + '}', String(params.typeId));

			let queryParameters: any = assign({}, extraQueryParams);
			let headerParams: any = assign({}, this.defaultHeaders);
			// verify required parameter 'id' is set
			if (params.id == null) {
				throw new Error('Missing required parameter id when calling serviceBoardsIdTypesTypeIdGet');
			}
			// verify required parameter 'typeId' is set
			if (params.typeId == null) {
				throw new Error('Missing required parameter typeId when calling serviceBoardsIdTypesTypeIdGet');
			}
			let fetchParams = {
				method: 'GET',
				headers: headerParams,

			};

			if (extraFetchParams) {
				fetchParams = assign(fetchParams, extraFetchParams);
			}

			let localVarPathWithQueryParameters = localVarPath + (localVarPath.indexOf('?') !== -1 ? '&' : '?') + querystring.stringify(queryParameters);

			return fetch(localVarPathWithQueryParameters, fetchParams).then((response) => {
				if (response.status >= 200 && response.status < 300) {
					return response.json();
				} else {
					let error = new Error(response.statusText);
					(error as any).response = response;
					throw error;
				}
			});
		}
		/**
		 *
		 * Update Types
		 * @param id
		 * @param typeId
		 * @param operations
		 */
		public serviceBoardsIdTypesTypeIdPatch (params: {  id: number; typeId: number; operations: Array<PatchOperation>; }, extraQueryParams?: any, extraFetchParams?: any ) : Promise<Type> {
			const localVarPath = this.basePath + '/service/boards/{id}/types/{typeId}'
				.replace('{' + 'id' + '}', String(params.id))
				.replace('{' + 'typeId' + '}', String(params.typeId));

			let queryParameters: any = assign({}, extraQueryParams);
			let headerParams: any = assign({}, this.defaultHeaders);
			headerParams['Content-Type'] = 'application/json';

			// verify required parameter 'id' is set
			if (params.id == null) {
				throw new Error('Missing required parameter id when calling serviceBoardsIdTypesTypeIdPatch');
			}
			// verify required parameter 'typeId' is set
			if (params.typeId == null) {
				throw new Error('Missing required parameter typeId when calling serviceBoardsIdTypesTypeIdPatch');
			}
			// verify required parameter 'operations' is set
			if (params.operations == null) {
				throw new Error('Missing required parameter operations when calling serviceBoardsIdTypesTypeIdPatch');
			}
			let fetchParams = {
				method: 'PATCH',
				headers: headerParams,
				body: JSON.stringify(params.operations),

			};

			if (extraFetchParams) {
				fetchParams = assign(fetchParams, extraFetchParams);
			}

			let localVarPathWithQueryParameters = localVarPath + (localVarPath.indexOf('?') !== -1 ? '&' : '?') + querystring.stringify(queryParameters);

			return fetch(localVarPathWithQueryParameters, fetchParams).then((response) => {
				if (response.status >= 200 && response.status < 300) {
					return response.json();
				} else {
					let error = new Error(response.statusText);
					(error as any).response = response;
					throw error;
				}
			});
		}
		/**
		 *
		 * Replace Types
		 * @param id
		 * @param typeId
		 * @param type
		 */
		public serviceBoardsIdTypesTypeIdPut (params: {  id: number; typeId: number; type: Type; }, extraQueryParams?: any, extraFetchParams?: any ) : Promise<Type> {
			const localVarPath = this.basePath + '/service/boards/{id}/types/{typeId}'
				.replace('{' + 'id' + '}', String(params.id))
				.replace('{' + 'typeId' + '}', String(params.typeId));

			let queryParameters: any = assign({}, extraQueryParams);
			let headerParams: any = assign({}, this.defaultHeaders);
			headerParams['Content-Type'] = 'application/json';

			// verify required parameter 'id' is set
			if (params.id == null) {
				throw new Error('Missing required parameter id when calling serviceBoardsIdTypesTypeIdPut');
			}
			// verify required parameter 'typeId' is set
			if (params.typeId == null) {
				throw new Error('Missing required parameter typeId when calling serviceBoardsIdTypesTypeIdPut');
			}
			// verify required parameter 'type' is set
			if (params.type == null) {
				throw new Error('Missing required parameter type when calling serviceBoardsIdTypesTypeIdPut');
			}
			let fetchParams = {
				method: 'PUT',
				headers: headerParams,
				body: JSON.stringify(params.type),

			};

			if (extraFetchParams) {
				fetchParams = assign(fetchParams, extraFetchParams);
			}

			let localVarPathWithQueryParameters = localVarPath + (localVarPath.indexOf('?') !== -1 ? '&' : '?') + querystring.stringify(queryParameters);

			return fetch(localVarPathWithQueryParameters, fetchParams).then((response) => {
				if (response.status >= 200 && response.status < 300) {
					return response.json();
				} else {
					let error = new Error(response.statusText);
					(error as any).response = response;
					throw error;
				}
			});
		}
		/**
		 *
		 * Get Sub Type Association
		 * @param id
		 * @param typeId
		 */
		public serviceBoardsIdTypesTypeIdSubTypeAssociationGet (params: {  id: number; typeId: number; }, extraQueryParams?: any, extraFetchParams?: any ) : Promise<number> {
			const localVarPath = this.basePath + '/service/boards/{id}/types/{typeId}/subTypeAssociation'
				.replace('{' + 'id' + '}', String(params.id))
				.replace('{' + 'typeId' + '}', String(params.typeId));

			let queryParameters: any = assign({}, extraQueryParams);
			let headerParams: any = assign({}, this.defaultHeaders);
			// verify required parameter 'id' is set
			if (params.id == null) {
				throw new Error('Missing required parameter id when calling serviceBoardsIdTypesTypeIdSubTypeAssociationGet');
			}
			// verify required parameter 'typeId' is set
			if (params.typeId == null) {
				throw new Error('Missing required parameter typeId when calling serviceBoardsIdTypesTypeIdSubTypeAssociationGet');
			}
			let fetchParams = {
				method: 'GET',
				headers: headerParams,

			};

			if (extraFetchParams) {
				fetchParams = assign(fetchParams, extraFetchParams);
			}

			let localVarPathWithQueryParameters = localVarPath + (localVarPath.indexOf('?') !== -1 ? '&' : '?') + querystring.stringify(queryParameters);

			return fetch(localVarPathWithQueryParameters, fetchParams).then((response) => {
				if (response.status >= 200 && response.status < 300) {
					return response.json();
				} else {
					let error = new Error(response.statusText);
					(error as any).response = response;
					throw error;
				}
			});
		}
	}
//}
//export namespace  {
	'use strict';

	export class BoardsApi {
		protected basePath = 'https://api-na.myconnectwise.net/v4_6_release/apis/3.0';
		public defaultHeaders : any = {};

		constructor(basePath?: string) {
			if (basePath) {
				this.basePath = basePath;
			}
		}

		/**
		 *
		 * Get Boards Count
		 * @param conditions
		 */
		public serviceBoardsCountGet (params: {  conditions?: string; }, extraQueryParams?: any, extraFetchParams?: any ) : Promise<Count> {
			const localVarPath = this.basePath + '/service/boards/count';

			let queryParameters: any = assign({}, extraQueryParams);
			let headerParams: any = assign({}, this.defaultHeaders);
			if (params.conditions !== undefined) {
				queryParameters['conditions'] = params.conditions;
			}

			let fetchParams = {
				method: 'GET',
				headers: headerParams,

			};

			if (extraFetchParams) {
				fetchParams = assign(fetchParams, extraFetchParams);
			}

			let localVarPathWithQueryParameters = localVarPath + (localVarPath.indexOf('?') !== -1 ? '&' : '?') + querystring.stringify(queryParameters);

			return fetch(localVarPathWithQueryParameters, fetchParams).then((response) => {
				if (response.status >= 200 && response.status < 300) {
					return response.json();
				} else {
					let error = new Error(response.statusText);
					(error as any).response = response;
					throw error;
				}
			});
		}
		/**
		 *
		 * Get Boards
		 * @param conditions
		 * @param orderBy
		 * @param childconditions
		 * @param customfieldconditions
		 * @param page
		 * @param pageSize
		 */
		public serviceBoardsGet (params: {  conditions?: string; orderBy?: string; childconditions?: string; customfieldconditions?: string; page?: number; pageSize?: number; }, extraQueryParams?: any, extraFetchParams?: any ) : Promise<Array<Board>> {
			const localVarPath = this.basePath + '/service/boards';

			let queryParameters: any = assign({}, extraQueryParams);
			let headerParams: any = assign({}, this.defaultHeaders);
			if (params.conditions !== undefined) {
				queryParameters['conditions'] = params.conditions;
			}

			if (params.orderBy !== undefined) {
				queryParameters['orderBy'] = params.orderBy;
			}

			if (params.childconditions !== undefined) {
				queryParameters['childconditions'] = params.childconditions;
			}

			if (params.customfieldconditions !== undefined) {
				queryParameters['customfieldconditions'] = params.customfieldconditions;
			}

			if (params.page !== undefined) {
				queryParameters['page'] = params.page;
			}

			if (params.pageSize !== undefined) {
				queryParameters['pageSize'] = params.pageSize;
			}

			let fetchParams = {
				method: 'GET',
				headers: headerParams,

			};

			if (extraFetchParams) {
				fetchParams = assign(fetchParams, extraFetchParams);
			}

			let localVarPathWithQueryParameters = localVarPath + (localVarPath.indexOf('?') !== -1 ? '&' : '?') + querystring.stringify(queryParameters);

			return fetch(localVarPathWithQueryParameters, fetchParams).then((response) => {
				if (response.status >= 200 && response.status < 300) {
					return response.json();
				} else {
					let error = new Error(response.statusText);
					(error as any).response = response;
					throw error;
				}
			});
		}
		/**
		 *
		 * Delete Board By Id
		 * @param id
		 */
		public serviceBoardsIdDelete (params: {  id: number; }, extraQueryParams?: any, extraFetchParams?: any ) : Promise<{}> {
			const localVarPath = this.basePath + '/service/boards/{id}'
				.replace('{' + 'id' + '}', String(params.id));

			let queryParameters: any = assign({}, extraQueryParams);
			let headerParams: any = assign({}, this.defaultHeaders);
			// verify required parameter 'id' is set
			if (params.id == null) {
				throw new Error('Missing required parameter id when calling serviceBoardsIdDelete');
			}
			let fetchParams = {
				method: 'DELETE',
				headers: headerParams,

			};

			if (extraFetchParams) {
				fetchParams = assign(fetchParams, extraFetchParams);
			}

			let localVarPathWithQueryParameters = localVarPath + (localVarPath.indexOf('?') !== -1 ? '&' : '?') + querystring.stringify(queryParameters);

			return fetch(localVarPathWithQueryParameters, fetchParams).then((response) => {
				if (response.status >= 200 && response.status < 300) {
					return response.json();
				} else {
					let error = new Error(response.statusText);
					(error as any).response = response;
					throw error;
				}
			});
		}
		/**
		 *
		 * Get Board By Id
		 * @param id
		 */
		public serviceBoardsIdGet (params: {  id: number; }, extraQueryParams?: any, extraFetchParams?: any ) : Promise<Board> {
			const localVarPath = this.basePath + '/service/boards/{id}'
				.replace('{' + 'id' + '}', String(params.id));

			let queryParameters: any = assign({}, extraQueryParams);
			let headerParams: any = assign({}, this.defaultHeaders);
			// verify required parameter 'id' is set
			if (params.id == null) {
				throw new Error('Missing required parameter id when calling serviceBoardsIdGet');
			}
			let fetchParams = {
				method: 'GET',
				headers: headerParams,

			};

			if (extraFetchParams) {
				fetchParams = assign(fetchParams, extraFetchParams);
			}

			let localVarPathWithQueryParameters = localVarPath + (localVarPath.indexOf('?') !== -1 ? '&' : '?') + querystring.stringify(queryParameters);

			return fetch(localVarPathWithQueryParameters, fetchParams).then((response) => {
				if (response.status >= 200 && response.status < 300) {
					return response.json();
				} else {
					let error = new Error(response.statusText);
					(error as any).response = response;
					throw error;
				}
			});
		}
		/**
		 *
		 * Update Board
		 * @param id
		 * @param operations
		 */
		public serviceBoardsIdPatch (params: {  id: number; operations: Array<PatchOperation>; }, extraQueryParams?: any, extraFetchParams?: any ) : Promise<Board> {
			const localVarPath = this.basePath + '/service/boards/{id}'
				.replace('{' + 'id' + '}', String(params.id));

			let queryParameters: any = assign({}, extraQueryParams);
			let headerParams: any = assign({}, this.defaultHeaders);
			headerParams['Content-Type'] = 'application/json';

			// verify required parameter 'id' is set
			if (params.id == null) {
				throw new Error('Missing required parameter id when calling serviceBoardsIdPatch');
			}
			// verify required parameter 'operations' is set
			if (params.operations == null) {
				throw new Error('Missing required parameter operations when calling serviceBoardsIdPatch');
			}
			let fetchParams = {
				method: 'PATCH',
				headers: headerParams,
				body: JSON.stringify(params.operations),

			};

			if (extraFetchParams) {
				fetchParams = assign(fetchParams, extraFetchParams);
			}

			let localVarPathWithQueryParameters = localVarPath + (localVarPath.indexOf('?') !== -1 ? '&' : '?') + querystring.stringify(queryParameters);

			return fetch(localVarPathWithQueryParameters, fetchParams).then((response) => {
				if (response.status >= 200 && response.status < 300) {
					return response.json();
				} else {
					let error = new Error(response.statusText);
					(error as any).response = response;
					throw error;
				}
			});
		}
		/**
		 *
		 * Replace Board
		 * @param id
		 * @param board
		 */
		public serviceBoardsIdPut (params: {  id: number; board: Board; }, extraQueryParams?: any, extraFetchParams?: any ) : Promise<Board> {
			const localVarPath = this.basePath + '/service/boards/{id}'
				.replace('{' + 'id' + '}', String(params.id));

			let queryParameters: any = assign({}, extraQueryParams);
			let headerParams: any = assign({}, this.defaultHeaders);
			headerParams['Content-Type'] = 'application/json';

			// verify required parameter 'id' is set
			if (params.id == null) {
				throw new Error('Missing required parameter id when calling serviceBoardsIdPut');
			}
			// verify required parameter 'board' is set
			if (params.board == null) {
				throw new Error('Missing required parameter board when calling serviceBoardsIdPut');
			}
			let fetchParams = {
				method: 'PUT',
				headers: headerParams,
				body: JSON.stringify(params.board),

			};

			if (extraFetchParams) {
				fetchParams = assign(fetchParams, extraFetchParams);
			}

			let localVarPathWithQueryParameters = localVarPath + (localVarPath.indexOf('?') !== -1 ? '&' : '?') + querystring.stringify(queryParameters);

			return fetch(localVarPathWithQueryParameters, fetchParams).then((response) => {
				if (response.status >= 200 && response.status < 300) {
					return response.json();
				} else {
					let error = new Error(response.statusText);
					(error as any).response = response;
					throw error;
				}
			});
		}
		/**
		 *
		 * Create Board
		 * @param board
		 */
		public serviceBoardsPost (params: {  board: Board; }, extraQueryParams?: any, extraFetchParams?: any ) : Promise<Board> {
			const localVarPath = this.basePath + '/service/boards';

			let queryParameters: any = assign({}, extraQueryParams);
			let headerParams: any = assign({}, this.defaultHeaders);
			headerParams['Content-Type'] = 'application/json';

			// verify required parameter 'board' is set
			if (params.board == null) {
				throw new Error('Missing required parameter board when calling serviceBoardsPost');
			}
			let fetchParams = {
				method: 'POST',
				headers: headerParams,
				body: JSON.stringify(params.board),

			};

			if (extraFetchParams) {
				fetchParams = assign(fetchParams, extraFetchParams);
			}

			let localVarPathWithQueryParameters = localVarPath + (localVarPath.indexOf('?') !== -1 ? '&' : '?') + querystring.stringify(queryParameters);

			return fetch(localVarPathWithQueryParameters, fetchParams).then((response) => {
				if (response.status >= 200 && response.status < 300) {
					return response.json();
				} else {
					let error = new Error(response.statusText);
					(error as any).response = response;
					throw error;
				}
			});
		}
	}
//}
//export namespace  {
	'use strict';

	export class CallbacksApi {
		protected basePath = 'https://api-na.myconnectwise.net/v4_6_release/apis/3.0';
		public defaultHeaders : any = {};

		constructor(basePath?: string) {
			if (basePath) {
				this.basePath = basePath;
			}
		}

		/**
		 *
		 * Get Callback Entries Count
		 * @param conditions
		 */
		public systemCallbacksCountGet (params: {  conditions?: string; }, extraQueryParams?: any, extraFetchParams?: any ) : Promise<Count> {
			const localVarPath = this.basePath + '/system/callbacks/count';

			let queryParameters: any = assign({}, extraQueryParams);
			let headerParams: any = assign({}, this.defaultHeaders);
			if (params.conditions !== undefined) {
				queryParameters['conditions'] = params.conditions;
			}

			let fetchParams = {
				method: 'GET',
				headers: headerParams,

			};

			if (extraFetchParams) {
				fetchParams = assign(fetchParams, extraFetchParams);
			}

			let localVarPathWithQueryParameters = localVarPath + (localVarPath.indexOf('?') !== -1 ? '&' : '?') + querystring.stringify(queryParameters);

			return fetch(localVarPathWithQueryParameters, fetchParams).then((response) => {
				if (response.status >= 200 && response.status < 300) {
					return response.json();
				} else {
					let error = new Error(response.statusText);
					(error as any).response = response;
					throw error;
				}
			});
		}
		/**
		 *
		 * Get Callback Entries
		 * @param conditions
		 * @param orderBy
		 * @param childconditions
		 * @param customfieldconditions
		 * @param page
		 * @param pageSize
		 */
		public systemCallbacksGet (params: {  conditions?: string; orderBy?: string; childconditions?: string; customfieldconditions?: string; page?: number; pageSize?: number; }, extraQueryParams?: any, extraFetchParams?: any ) : Promise<Array<CallbackEntry>> {
			const localVarPath = this.basePath + '/system/callbacks';

			let queryParameters: any = assign({}, extraQueryParams);
			let headerParams: any = assign({}, this.defaultHeaders);
			if (params.conditions !== undefined) {
				queryParameters['conditions'] = params.conditions;
			}

			if (params.orderBy !== undefined) {
				queryParameters['orderBy'] = params.orderBy;
			}

			if (params.childconditions !== undefined) {
				queryParameters['childconditions'] = params.childconditions;
			}

			if (params.customfieldconditions !== undefined) {
				queryParameters['customfieldconditions'] = params.customfieldconditions;
			}

			if (params.page !== undefined) {
				queryParameters['page'] = params.page;
			}

			if (params.pageSize !== undefined) {
				queryParameters['pageSize'] = params.pageSize;
			}

			let fetchParams = {
				method: 'GET',
				headers: headerParams,

			};

			if (extraFetchParams) {
				fetchParams = assign(fetchParams, extraFetchParams);
			}

			let localVarPathWithQueryParameters = localVarPath + (localVarPath.indexOf('?') !== -1 ? '&' : '?') + querystring.stringify(queryParameters);

			return fetch(localVarPathWithQueryParameters, fetchParams).then((response) => {
				if (response.status >= 200 && response.status < 300) {
					return response.json();
				} else {
					let error = new Error(response.statusText);
					(error as any).response = response;
					throw error;
				}
			});
		}
		/**
		 *
		 * Delete Callback Entry By Id
		 * @param id
		 */
		public systemCallbacksIdDelete (params: {  id: number; }, extraQueryParams?: any, extraFetchParams?: any ) : Promise<{}> {
			const localVarPath = this.basePath + '/system/callbacks/{id}'
				.replace('{' + 'id' + '}', String(params.id));

			let queryParameters: any = assign({}, extraQueryParams);
			let headerParams: any = assign({}, this.defaultHeaders);
			// verify required parameter 'id' is set
			if (params.id == null) {
				throw new Error('Missing required parameter id when calling systemCallbacksIdDelete');
			}
			let fetchParams = {
				method: 'DELETE',
				headers: headerParams,

			};

			if (extraFetchParams) {
				fetchParams = assign(fetchParams, extraFetchParams);
			}

			let localVarPathWithQueryParameters = localVarPath + (localVarPath.indexOf('?') !== -1 ? '&' : '?') + querystring.stringify(queryParameters);

			return fetch(localVarPathWithQueryParameters, fetchParams).then((response) => {
				if (response.status >= 200 && response.status < 300) {
					return response.json();
				} else {
					let error = new Error(response.statusText);
					(error as any).response = response;
					throw error;
				}
			});
		}
		/**
		 *
		 * Get Callback Entry By Id
		 * @param id
		 */
		public systemCallbacksIdGet (params: {  id: number; }, extraQueryParams?: any, extraFetchParams?: any ) : Promise<CallbackEntry> {
			const localVarPath = this.basePath + '/system/callbacks/{id}'
				.replace('{' + 'id' + '}', String(params.id));

			let queryParameters: any = assign({}, extraQueryParams);
			let headerParams: any = assign({}, this.defaultHeaders);
			// verify required parameter 'id' is set
			if (params.id == null) {
				throw new Error('Missing required parameter id when calling systemCallbacksIdGet');
			}
			let fetchParams = {
				method: 'GET',
				headers: headerParams,

			};

			if (extraFetchParams) {
				fetchParams = assign(fetchParams, extraFetchParams);
			}

			let localVarPathWithQueryParameters = localVarPath + (localVarPath.indexOf('?') !== -1 ? '&' : '?') + querystring.stringify(queryParameters);

			return fetch(localVarPathWithQueryParameters, fetchParams).then((response) => {
				if (response.status >= 200 && response.status < 300) {
					return response.json();
				} else {
					let error = new Error(response.statusText);
					(error as any).response = response;
					throw error;
				}
			});
		}
		/**
		 *
		 * Update Callback Entry
		 * @param id
		 * @param operations
		 */
		public systemCallbacksIdPatch (params: {  id: number; operations: Array<PatchOperation>; }, extraQueryParams?: any, extraFetchParams?: any ) : Promise<CallbackEntry> {
			const localVarPath = this.basePath + '/system/callbacks/{id}'
				.replace('{' + 'id' + '}', String(params.id));

			let queryParameters: any = assign({}, extraQueryParams);
			let headerParams: any = assign({}, this.defaultHeaders);
			headerParams['Content-Type'] = 'application/json';

			// verify required parameter 'id' is set
			if (params.id == null) {
				throw new Error('Missing required parameter id when calling systemCallbacksIdPatch');
			}
			// verify required parameter 'operations' is set
			if (params.operations == null) {
				throw new Error('Missing required parameter operations when calling systemCallbacksIdPatch');
			}
			let fetchParams = {
				method: 'PATCH',
				headers: headerParams,
				body: JSON.stringify(params.operations),

			};

			if (extraFetchParams) {
				fetchParams = assign(fetchParams, extraFetchParams);
			}

			let localVarPathWithQueryParameters = localVarPath + (localVarPath.indexOf('?') !== -1 ? '&' : '?') + querystring.stringify(queryParameters);

			return fetch(localVarPathWithQueryParameters, fetchParams).then((response) => {
				if (response.status >= 200 && response.status < 300) {
					return response.json();
				} else {
					let error = new Error(response.statusText);
					(error as any).response = response;
					throw error;
				}
			});
		}
		/**
		 *
		 * Replace Callback Entry
		 * @param id
		 * @param callbackEntry
		 */
		public systemCallbacksIdPut (params: {  id: number; callbackEntry: CallbackEntry; }, extraQueryParams?: any, extraFetchParams?: any ) : Promise<CallbackEntry> {
			const localVarPath = this.basePath + '/system/callbacks/{id}'
				.replace('{' + 'id' + '}', String(params.id));

			let queryParameters: any = assign({}, extraQueryParams);
			let headerParams: any = assign({}, this.defaultHeaders);
			headerParams['Content-Type'] = 'application/json';

			// verify required parameter 'id' is set
			if (params.id == null) {
				throw new Error('Missing required parameter id when calling systemCallbacksIdPut');
			}
			// verify required parameter 'callbackEntry' is set
			if (params.callbackEntry == null) {
				throw new Error('Missing required parameter callbackEntry when calling systemCallbacksIdPut');
			}
			let fetchParams = {
				method: 'PUT',
				headers: headerParams,
				body: JSON.stringify(params.callbackEntry),

			};

			if (extraFetchParams) {
				fetchParams = assign(fetchParams, extraFetchParams);
			}

			let localVarPathWithQueryParameters = localVarPath + (localVarPath.indexOf('?') !== -1 ? '&' : '?') + querystring.stringify(queryParameters);

			return fetch(localVarPathWithQueryParameters, fetchParams).then((response) => {
				if (response.status >= 200 && response.status < 300) {
					return response.json();
				} else {
					let error = new Error(response.statusText);
					(error as any).response = response;
					throw error;
				}
			});
		}
		/**
		 *
		 * Create Callback Entry
		 * @param callbackEntry
		 */
		public systemCallbacksPost (params: {  callbackEntry: CallbackEntry; }, extraQueryParams?: any, extraFetchParams?: any ) : Promise<CallbackEntry> {
			const localVarPath = this.basePath + '/system/callbacks';

			let queryParameters: any = assign({}, extraQueryParams);
			let headerParams: any = assign({}, this.defaultHeaders);
			headerParams['Content-Type'] = 'application/json';

			// verify required parameter 'callbackEntry' is set
			if (params.callbackEntry == null) {
				throw new Error('Missing required parameter callbackEntry when calling systemCallbacksPost');
			}
			let fetchParams = {
				method: 'POST',
				headers: headerParams,
				body: JSON.stringify(params.callbackEntry),

			};

			if (extraFetchParams) {
				fetchParams = assign(fetchParams, extraFetchParams);
			}

			let localVarPathWithQueryParameters = localVarPath + (localVarPath.indexOf('?') !== -1 ? '&' : '?') + querystring.stringify(queryParameters);

			return fetch(localVarPathWithQueryParameters, fetchParams).then((response) => {
				if (response.status >= 200 && response.status < 300) {
					return response.json();
				} else {
					let error = new Error(response.statusText);
					(error as any).response = response;
					throw error;
				}
			});
		}
	}
//}
//export namespace  {
	'use strict';

	export class CampaignAuditsApi {
		protected basePath = 'https://api-na.myconnectwise.net/v4_6_release/apis/3.0';
		public defaultHeaders : any = {};

		constructor(basePath?: string) {
			if (basePath) {
				this.basePath = basePath;
			}
		}

		/**
		 *
		 * Delete Campaign Audit By Id
		 * @param id
		 * @param auditId
		 */
		public marketingCampaignsIdAuditsAuditIdDelete (params: {  id: number; auditId: number; }, extraQueryParams?: any, extraFetchParams?: any ) : Promise<{}> {
			const localVarPath = this.basePath + '/marketing/campaigns/{id}/audits/{auditId}'
				.replace('{' + 'id' + '}', String(params.id))
				.replace('{' + 'auditId' + '}', String(params.auditId));

			let queryParameters: any = assign({}, extraQueryParams);
			let headerParams: any = assign({}, this.defaultHeaders);
			// verify required parameter 'id' is set
			if (params.id == null) {
				throw new Error('Missing required parameter id when calling marketingCampaignsIdAuditsAuditIdDelete');
			}
			// verify required parameter 'auditId' is set
			if (params.auditId == null) {
				throw new Error('Missing required parameter auditId when calling marketingCampaignsIdAuditsAuditIdDelete');
			}
			let fetchParams = {
				method: 'DELETE',
				headers: headerParams,

			};

			if (extraFetchParams) {
				fetchParams = assign(fetchParams, extraFetchParams);
			}

			let localVarPathWithQueryParameters = localVarPath + (localVarPath.indexOf('?') !== -1 ? '&' : '?') + querystring.stringify(queryParameters);

			return fetch(localVarPathWithQueryParameters, fetchParams).then((response) => {
				if (response.status >= 200 && response.status < 300) {
					return response.json();
				} else {
					let error = new Error(response.statusText);
					(error as any).response = response;
					throw error;
				}
			});
		}
		/**
		 *
		 * Get Campaign Audit By Id
		 * @param id
		 * @param auditId
		 */
		public marketingCampaignsIdAuditsAuditIdGet (params: {  id: number; auditId: number; }, extraQueryParams?: any, extraFetchParams?: any ) : Promise<CampaignAudit> {
			const localVarPath = this.basePath + '/marketing/campaigns/{id}/audits/{auditId}'
				.replace('{' + 'id' + '}', String(params.id))
				.replace('{' + 'auditId' + '}', String(params.auditId));

			let queryParameters: any = assign({}, extraQueryParams);
			let headerParams: any = assign({}, this.defaultHeaders);
			// verify required parameter 'id' is set
			if (params.id == null) {
				throw new Error('Missing required parameter id when calling marketingCampaignsIdAuditsAuditIdGet');
			}
			// verify required parameter 'auditId' is set
			if (params.auditId == null) {
				throw new Error('Missing required parameter auditId when calling marketingCampaignsIdAuditsAuditIdGet');
			}
			let fetchParams = {
				method: 'GET',
				headers: headerParams,

			};

			if (extraFetchParams) {
				fetchParams = assign(fetchParams, extraFetchParams);
			}

			let localVarPathWithQueryParameters = localVarPath + (localVarPath.indexOf('?') !== -1 ? '&' : '?') + querystring.stringify(queryParameters);

			return fetch(localVarPathWithQueryParameters, fetchParams).then((response) => {
				if (response.status >= 200 && response.status < 300) {
					return response.json();
				} else {
					let error = new Error(response.statusText);
					(error as any).response = response;
					throw error;
				}
			});
		}
		/**
		 *
		 * Update Campaign Audit
		 * @param id
		 * @param auditId
		 * @param operations
		 */
		public marketingCampaignsIdAuditsAuditIdPatch (params: {  id: number; auditId: number; operations: Array<PatchOperation>; }, extraQueryParams?: any, extraFetchParams?: any ) : Promise<CampaignAudit> {
			const localVarPath = this.basePath + '/marketing/campaigns/{id}/audits/{auditId}'
				.replace('{' + 'id' + '}', String(params.id))
				.replace('{' + 'auditId' + '}', String(params.auditId));

			let queryParameters: any = assign({}, extraQueryParams);
			let headerParams: any = assign({}, this.defaultHeaders);
			headerParams['Content-Type'] = 'application/json';

			// verify required parameter 'id' is set
			if (params.id == null) {
				throw new Error('Missing required parameter id when calling marketingCampaignsIdAuditsAuditIdPatch');
			}
			// verify required parameter 'auditId' is set
			if (params.auditId == null) {
				throw new Error('Missing required parameter auditId when calling marketingCampaignsIdAuditsAuditIdPatch');
			}
			// verify required parameter 'operations' is set
			if (params.operations == null) {
				throw new Error('Missing required parameter operations when calling marketingCampaignsIdAuditsAuditIdPatch');
			}
			let fetchParams = {
				method: 'PATCH',
				headers: headerParams,
				body: JSON.stringify(params.operations),

			};

			if (extraFetchParams) {
				fetchParams = assign(fetchParams, extraFetchParams);
			}

			let localVarPathWithQueryParameters = localVarPath + (localVarPath.indexOf('?') !== -1 ? '&' : '?') + querystring.stringify(queryParameters);

			return fetch(localVarPathWithQueryParameters, fetchParams).then((response) => {
				if (response.status >= 200 && response.status < 300) {
					return response.json();
				} else {
					let error = new Error(response.statusText);
					(error as any).response = response;
					throw error;
				}
			});
		}
		/**
		 *
		 * Replace Campaign Audit
		 * @param id
		 * @param auditId
		 * @param campaignAudit
		 */
		public marketingCampaignsIdAuditsAuditIdPut (params: {  id: number; auditId: number; campaignAudit: CampaignAudit; }, extraQueryParams?: any, extraFetchParams?: any ) : Promise<CampaignAudit> {
			const localVarPath = this.basePath + '/marketing/campaigns/{id}/audits/{auditId}'
				.replace('{' + 'id' + '}', String(params.id))
				.replace('{' + 'auditId' + '}', String(params.auditId));

			let queryParameters: any = assign({}, extraQueryParams);
			let headerParams: any = assign({}, this.defaultHeaders);
			headerParams['Content-Type'] = 'application/json';

			// verify required parameter 'id' is set
			if (params.id == null) {
				throw new Error('Missing required parameter id when calling marketingCampaignsIdAuditsAuditIdPut');
			}
			// verify required parameter 'auditId' is set
			if (params.auditId == null) {
				throw new Error('Missing required parameter auditId when calling marketingCampaignsIdAuditsAuditIdPut');
			}
			// verify required parameter 'campaignAudit' is set
			if (params.campaignAudit == null) {
				throw new Error('Missing required parameter campaignAudit when calling marketingCampaignsIdAuditsAuditIdPut');
			}
			let fetchParams = {
				method: 'PUT',
				headers: headerParams,
				body: JSON.stringify(params.campaignAudit),

			};

			if (extraFetchParams) {
				fetchParams = assign(fetchParams, extraFetchParams);
			}

			let localVarPathWithQueryParameters = localVarPath + (localVarPath.indexOf('?') !== -1 ? '&' : '?') + querystring.stringify(queryParameters);

			return fetch(localVarPathWithQueryParameters, fetchParams).then((response) => {
				if (response.status >= 200 && response.status < 300) {
					return response.json();
				} else {
					let error = new Error(response.statusText);
					(error as any).response = response;
					throw error;
				}
			});
		}
		/**
		 *
		 * Get Campaign Audits Count
		 * @param id
		 * @param conditions
		 */
		public marketingCampaignsIdAuditsCountGet (params: {  id: number; conditions?: string; }, extraQueryParams?: any, extraFetchParams?: any ) : Promise<Count> {
			const localVarPath = this.basePath + '/marketing/campaigns/{id}/audits/count'
				.replace('{' + 'id' + '}', String(params.id));

			let queryParameters: any = assign({}, extraQueryParams);
			let headerParams: any = assign({}, this.defaultHeaders);
			// verify required parameter 'id' is set
			if (params.id == null) {
				throw new Error('Missing required parameter id when calling marketingCampaignsIdAuditsCountGet');
			}
			if (params.conditions !== undefined) {
				queryParameters['conditions'] = params.conditions;
			}

			let fetchParams = {
				method: 'GET',
				headers: headerParams,

			};

			if (extraFetchParams) {
				fetchParams = assign(fetchParams, extraFetchParams);
			}

			let localVarPathWithQueryParameters = localVarPath + (localVarPath.indexOf('?') !== -1 ? '&' : '?') + querystring.stringify(queryParameters);

			return fetch(localVarPathWithQueryParameters, fetchParams).then((response) => {
				if (response.status >= 200 && response.status < 300) {
					return response.json();
				} else {
					let error = new Error(response.statusText);
					(error as any).response = response;
					throw error;
				}
			});
		}
		/**
		 *
		 * Get Campaign Audits
		 * @param id
		 * @param conditions
		 * @param orderBy
		 * @param childconditions
		 * @param customfieldconditions
		 * @param page
		 * @param pageSize
		 */
		public marketingCampaignsIdAuditsGet (params: {  id: number; conditions?: string; orderBy?: string; childconditions?: string; customfieldconditions?: string; page?: number; pageSize?: number; }, extraQueryParams?: any, extraFetchParams?: any ) : Promise<Array<CampaignAudit>> {
			const localVarPath = this.basePath + '/marketing/campaigns/{id}/audits'
				.replace('{' + 'id' + '}', String(params.id));

			let queryParameters: any = assign({}, extraQueryParams);
			let headerParams: any = assign({}, this.defaultHeaders);
			// verify required parameter 'id' is set
			if (params.id == null) {
				throw new Error('Missing required parameter id when calling marketingCampaignsIdAuditsGet');
			}
			if (params.conditions !== undefined) {
				queryParameters['conditions'] = params.conditions;
			}

			if (params.orderBy !== undefined) {
				queryParameters['orderBy'] = params.orderBy;
			}

			if (params.childconditions !== undefined) {
				queryParameters['childconditions'] = params.childconditions;
			}

			if (params.customfieldconditions !== undefined) {
				queryParameters['customfieldconditions'] = params.customfieldconditions;
			}

			if (params.page !== undefined) {
				queryParameters['page'] = params.page;
			}

			if (params.pageSize !== undefined) {
				queryParameters['pageSize'] = params.pageSize;
			}

			let fetchParams = {
				method: 'GET',
				headers: headerParams,

			};

			if (extraFetchParams) {
				fetchParams = assign(fetchParams, extraFetchParams);
			}

			let localVarPathWithQueryParameters = localVarPath + (localVarPath.indexOf('?') !== -1 ? '&' : '?') + querystring.stringify(queryParameters);

			return fetch(localVarPathWithQueryParameters, fetchParams).then((response) => {
				if (response.status >= 200 && response.status < 300) {
					return response.json();
				} else {
					let error = new Error(response.statusText);
					(error as any).response = response;
					throw error;
				}
			});
		}
		/**
		 *
		 * Create Campaign Audit
		 * @param id
		 * @param campaignAudit
		 */
		public marketingCampaignsIdAuditsPost (params: {  id: number; campaignAudit: CampaignAudit; }, extraQueryParams?: any, extraFetchParams?: any ) : Promise<CampaignAudit> {
			const localVarPath = this.basePath + '/marketing/campaigns/{id}/audits'
				.replace('{' + 'id' + '}', String(params.id));

			let queryParameters: any = assign({}, extraQueryParams);
			let headerParams: any = assign({}, this.defaultHeaders);
			headerParams['Content-Type'] = 'application/json';

			// verify required parameter 'id' is set
			if (params.id == null) {
				throw new Error('Missing required parameter id when calling marketingCampaignsIdAuditsPost');
			}
			// verify required parameter 'campaignAudit' is set
			if (params.campaignAudit == null) {
				throw new Error('Missing required parameter campaignAudit when calling marketingCampaignsIdAuditsPost');
			}
			let fetchParams = {
				method: 'POST',
				headers: headerParams,
				body: JSON.stringify(params.campaignAudit),

			};

			if (extraFetchParams) {
				fetchParams = assign(fetchParams, extraFetchParams);
			}

			let localVarPathWithQueryParameters = localVarPath + (localVarPath.indexOf('?') !== -1 ? '&' : '?') + querystring.stringify(queryParameters);

			return fetch(localVarPathWithQueryParameters, fetchParams).then((response) => {
				if (response.status >= 200 && response.status < 300) {
					return response.json();
				} else {
					let error = new Error(response.statusText);
					(error as any).response = response;
					throw error;
				}
			});
		}
	}
//}
//export namespace  {
	'use strict';

	export class CampaignEmailsOpenedApi {
		protected basePath = 'https://api-na.myconnectwise.net/v4_6_release/apis/3.0';
		public defaultHeaders : any = {};

		constructor(basePath?: string) {
			if (basePath) {
				this.basePath = basePath;
			}
		}

		/**
		 *
		 * Get Emails Opened Count
		 * @param id
		 * @param conditions
		 */
		public marketingCampaignsIdEmailsOpenedCountGet (params: {  id: number; conditions?: string; }, extraQueryParams?: any, extraFetchParams?: any ) : Promise<Count> {
			const localVarPath = this.basePath + '/marketing/campaigns/{id}/emailsOpened/count'
				.replace('{' + 'id' + '}', String(params.id));

			let queryParameters: any = assign({}, extraQueryParams);
			let headerParams: any = assign({}, this.defaultHeaders);
			// verify required parameter 'id' is set
			if (params.id == null) {
				throw new Error('Missing required parameter id when calling marketingCampaignsIdEmailsOpenedCountGet');
			}
			if (params.conditions !== undefined) {
				queryParameters['conditions'] = params.conditions;
			}

			let fetchParams = {
				method: 'GET',
				headers: headerParams,

			};

			if (extraFetchParams) {
				fetchParams = assign(fetchParams, extraFetchParams);
			}

			let localVarPathWithQueryParameters = localVarPath + (localVarPath.indexOf('?') !== -1 ? '&' : '?') + querystring.stringify(queryParameters);

			return fetch(localVarPathWithQueryParameters, fetchParams).then((response) => {
				if (response.status >= 200 && response.status < 300) {
					return response.json();
				} else {
					let error = new Error(response.statusText);
					(error as any).response = response;
					throw error;
				}
			});
		}
		/**
		 *
		 * Delete Email Opened By Id
		 * @param id
		 * @param emailOpenedId
		 */
		public marketingCampaignsIdEmailsOpenedEmailOpenedIdDelete (params: {  id: number; emailOpenedId: number; }, extraQueryParams?: any, extraFetchParams?: any ) : Promise<{}> {
			const localVarPath = this.basePath + '/marketing/campaigns/{id}/emailsOpened/{emailOpenedId}'
				.replace('{' + 'id' + '}', String(params.id))
				.replace('{' + 'emailOpenedId' + '}', String(params.emailOpenedId));

			let queryParameters: any = assign({}, extraQueryParams);
			let headerParams: any = assign({}, this.defaultHeaders);
			// verify required parameter 'id' is set
			if (params.id == null) {
				throw new Error('Missing required parameter id when calling marketingCampaignsIdEmailsOpenedEmailOpenedIdDelete');
			}
			// verify required parameter 'emailOpenedId' is set
			if (params.emailOpenedId == null) {
				throw new Error('Missing required parameter emailOpenedId when calling marketingCampaignsIdEmailsOpenedEmailOpenedIdDelete');
			}
			let fetchParams = {
				method: 'DELETE',
				headers: headerParams,

			};

			if (extraFetchParams) {
				fetchParams = assign(fetchParams, extraFetchParams);
			}

			let localVarPathWithQueryParameters = localVarPath + (localVarPath.indexOf('?') !== -1 ? '&' : '?') + querystring.stringify(queryParameters);

			return fetch(localVarPathWithQueryParameters, fetchParams).then((response) => {
				if (response.status >= 200 && response.status < 300) {
					return response.json();
				} else {
					let error = new Error(response.statusText);
					(error as any).response = response;
					throw error;
				}
			});
		}
		/**
		 *
		 * Get Email Opened By Id
		 * @param id
		 * @param emailOpenedId
		 */
		public marketingCampaignsIdEmailsOpenedEmailOpenedIdGet (params: {  id: number; emailOpenedId: number; }, extraQueryParams?: any, extraFetchParams?: any ) : Promise<EmailOpened> {
			const localVarPath = this.basePath + '/marketing/campaigns/{id}/emailsOpened/{emailOpenedId}'
				.replace('{' + 'id' + '}', String(params.id))
				.replace('{' + 'emailOpenedId' + '}', String(params.emailOpenedId));

			let queryParameters: any = assign({}, extraQueryParams);
			let headerParams: any = assign({}, this.defaultHeaders);
			// verify required parameter 'id' is set
			if (params.id == null) {
				throw new Error('Missing required parameter id when calling marketingCampaignsIdEmailsOpenedEmailOpenedIdGet');
			}
			// verify required parameter 'emailOpenedId' is set
			if (params.emailOpenedId == null) {
				throw new Error('Missing required parameter emailOpenedId when calling marketingCampaignsIdEmailsOpenedEmailOpenedIdGet');
			}
			let fetchParams = {
				method: 'GET',
				headers: headerParams,

			};

			if (extraFetchParams) {
				fetchParams = assign(fetchParams, extraFetchParams);
			}

			let localVarPathWithQueryParameters = localVarPath + (localVarPath.indexOf('?') !== -1 ? '&' : '?') + querystring.stringify(queryParameters);

			return fetch(localVarPathWithQueryParameters, fetchParams).then((response) => {
				if (response.status >= 200 && response.status < 300) {
					return response.json();
				} else {
					let error = new Error(response.statusText);
					(error as any).response = response;
					throw error;
				}
			});
		}
		/**
		 *
		 * Update Email Opened
		 * @param id
		 * @param emailOpenedId
		 * @param operations
		 */
		public marketingCampaignsIdEmailsOpenedEmailOpenedIdPatch (params: {  id: number; emailOpenedId: number; operations: Array<PatchOperation>; }, extraQueryParams?: any, extraFetchParams?: any ) : Promise<EmailOpened> {
			const localVarPath = this.basePath + '/marketing/campaigns/{id}/emailsOpened/{emailOpenedId}'
				.replace('{' + 'id' + '}', String(params.id))
				.replace('{' + 'emailOpenedId' + '}', String(params.emailOpenedId));

			let queryParameters: any = assign({}, extraQueryParams);
			let headerParams: any = assign({}, this.defaultHeaders);
			headerParams['Content-Type'] = 'application/json';

			// verify required parameter 'id' is set
			if (params.id == null) {
				throw new Error('Missing required parameter id when calling marketingCampaignsIdEmailsOpenedEmailOpenedIdPatch');
			}
			// verify required parameter 'emailOpenedId' is set
			if (params.emailOpenedId == null) {
				throw new Error('Missing required parameter emailOpenedId when calling marketingCampaignsIdEmailsOpenedEmailOpenedIdPatch');
			}
			// verify required parameter 'operations' is set
			if (params.operations == null) {
				throw new Error('Missing required parameter operations when calling marketingCampaignsIdEmailsOpenedEmailOpenedIdPatch');
			}
			let fetchParams = {
				method: 'PATCH',
				headers: headerParams,
				body: JSON.stringify(params.operations),

			};

			if (extraFetchParams) {
				fetchParams = assign(fetchParams, extraFetchParams);
			}

			let localVarPathWithQueryParameters = localVarPath + (localVarPath.indexOf('?') !== -1 ? '&' : '?') + querystring.stringify(queryParameters);

			return fetch(localVarPathWithQueryParameters, fetchParams).then((response) => {
				if (response.status >= 200 && response.status < 300) {
					return response.json();
				} else {
					let error = new Error(response.statusText);
					(error as any).response = response;
					throw error;
				}
			});
		}
		/**
		 *
		 * Replace Email Opened
		 * @param id
		 * @param emailOpenedId
		 * @param emailOpened
		 */
		public marketingCampaignsIdEmailsOpenedEmailOpenedIdPut (params: {  id: number; emailOpenedId: number; emailOpened: EmailOpened; }, extraQueryParams?: any, extraFetchParams?: any ) : Promise<EmailOpened> {
			const localVarPath = this.basePath + '/marketing/campaigns/{id}/emailsOpened/{emailOpenedId}'
				.replace('{' + 'id' + '}', String(params.id))
				.replace('{' + 'emailOpenedId' + '}', String(params.emailOpenedId));

			let queryParameters: any = assign({}, extraQueryParams);
			let headerParams: any = assign({}, this.defaultHeaders);
			headerParams['Content-Type'] = 'application/json';

			// verify required parameter 'id' is set
			if (params.id == null) {
				throw new Error('Missing required parameter id when calling marketingCampaignsIdEmailsOpenedEmailOpenedIdPut');
			}
			// verify required parameter 'emailOpenedId' is set
			if (params.emailOpenedId == null) {
				throw new Error('Missing required parameter emailOpenedId when calling marketingCampaignsIdEmailsOpenedEmailOpenedIdPut');
			}
			// verify required parameter 'emailOpened' is set
			if (params.emailOpened == null) {
				throw new Error('Missing required parameter emailOpened when calling marketingCampaignsIdEmailsOpenedEmailOpenedIdPut');
			}
			let fetchParams = {
				method: 'PUT',
				headers: headerParams,
				body: JSON.stringify(params.emailOpened),

			};

			if (extraFetchParams) {
				fetchParams = assign(fetchParams, extraFetchParams);
			}

			let localVarPathWithQueryParameters = localVarPath + (localVarPath.indexOf('?') !== -1 ? '&' : '?') + querystring.stringify(queryParameters);

			return fetch(localVarPathWithQueryParameters, fetchParams).then((response) => {
				if (response.status >= 200 && response.status < 300) {
					return response.json();
				} else {
					let error = new Error(response.statusText);
					(error as any).response = response;
					throw error;
				}
			});
		}
		/**
		 *
		 * Get Emails Opened
		 * @param id
		 * @param conditions
		 * @param orderBy
		 * @param childconditions
		 * @param customfieldconditions
		 * @param page
		 * @param pageSize
		 */
		public marketingCampaignsIdEmailsOpenedGet (params: {  id: number; conditions?: string; orderBy?: string; childconditions?: string; customfieldconditions?: string; page?: number; pageSize?: number; }, extraQueryParams?: any, extraFetchParams?: any ) : Promise<Array<EmailOpened>> {
			const localVarPath = this.basePath + '/marketing/campaigns/{id}/emailsOpened'
				.replace('{' + 'id' + '}', String(params.id));

			let queryParameters: any = assign({}, extraQueryParams);
			let headerParams: any = assign({}, this.defaultHeaders);
			// verify required parameter 'id' is set
			if (params.id == null) {
				throw new Error('Missing required parameter id when calling marketingCampaignsIdEmailsOpenedGet');
			}
			if (params.conditions !== undefined) {
				queryParameters['conditions'] = params.conditions;
			}

			if (params.orderBy !== undefined) {
				queryParameters['orderBy'] = params.orderBy;
			}

			if (params.childconditions !== undefined) {
				queryParameters['childconditions'] = params.childconditions;
			}

			if (params.customfieldconditions !== undefined) {
				queryParameters['customfieldconditions'] = params.customfieldconditions;
			}

			if (params.page !== undefined) {
				queryParameters['page'] = params.page;
			}

			if (params.pageSize !== undefined) {
				queryParameters['pageSize'] = params.pageSize;
			}

			let fetchParams = {
				method: 'GET',
				headers: headerParams,

			};

			if (extraFetchParams) {
				fetchParams = assign(fetchParams, extraFetchParams);
			}

			let localVarPathWithQueryParameters = localVarPath + (localVarPath.indexOf('?') !== -1 ? '&' : '?') + querystring.stringify(queryParameters);

			return fetch(localVarPathWithQueryParameters, fetchParams).then((response) => {
				if (response.status >= 200 && response.status < 300) {
					return response.json();
				} else {
					let error = new Error(response.statusText);
					(error as any).response = response;
					throw error;
				}
			});
		}
		/**
		 *
		 * Create Email Opened
		 * @param id
		 * @param emailOpened
		 */
		public marketingCampaignsIdEmailsOpenedPost (params: {  id: number; emailOpened: EmailOpened; }, extraQueryParams?: any, extraFetchParams?: any ) : Promise<EmailOpened> {
			const localVarPath = this.basePath + '/marketing/campaigns/{id}/emailsOpened'
				.replace('{' + 'id' + '}', String(params.id));

			let queryParameters: any = assign({}, extraQueryParams);
			let headerParams: any = assign({}, this.defaultHeaders);
			headerParams['Content-Type'] = 'application/json';

			// verify required parameter 'id' is set
			if (params.id == null) {
				throw new Error('Missing required parameter id when calling marketingCampaignsIdEmailsOpenedPost');
			}
			// verify required parameter 'emailOpened' is set
			if (params.emailOpened == null) {
				throw new Error('Missing required parameter emailOpened when calling marketingCampaignsIdEmailsOpenedPost');
			}
			let fetchParams = {
				method: 'POST',
				headers: headerParams,
				body: JSON.stringify(params.emailOpened),

			};

			if (extraFetchParams) {
				fetchParams = assign(fetchParams, extraFetchParams);
			}

			let localVarPathWithQueryParameters = localVarPath + (localVarPath.indexOf('?') !== -1 ? '&' : '?') + querystring.stringify(queryParameters);

			return fetch(localVarPathWithQueryParameters, fetchParams).then((response) => {
				if (response.status >= 200 && response.status < 300) {
					return response.json();
				} else {
					let error = new Error(response.statusText);
					(error as any).response = response;
					throw error;
				}
			});
		}
	}
//}
//export namespace  {
	'use strict';

	export class CampaignFormsSubmittedApi {
		protected basePath = 'https://api-na.myconnectwise.net/v4_6_release/apis/3.0';
		public defaultHeaders : any = {};

		constructor(basePath?: string) {
			if (basePath) {
				this.basePath = basePath;
			}
		}

		/**
		 *
		 * Get Forms Submitted Count
		 * @param id
		 * @param conditions
		 */
		public marketingCampaignsIdFormsSubmittedCountGet (params: {  id: number; conditions?: string; }, extraQueryParams?: any, extraFetchParams?: any ) : Promise<Count> {
			const localVarPath = this.basePath + '/marketing/campaigns/{id}/formsSubmitted/count'
				.replace('{' + 'id' + '}', String(params.id));

			let queryParameters: any = assign({}, extraQueryParams);
			let headerParams: any = assign({}, this.defaultHeaders);
			// verify required parameter 'id' is set
			if (params.id == null) {
				throw new Error('Missing required parameter id when calling marketingCampaignsIdFormsSubmittedCountGet');
			}
			if (params.conditions !== undefined) {
				queryParameters['conditions'] = params.conditions;
			}

			let fetchParams = {
				method: 'GET',
				headers: headerParams,

			};

			if (extraFetchParams) {
				fetchParams = assign(fetchParams, extraFetchParams);
			}

			let localVarPathWithQueryParameters = localVarPath + (localVarPath.indexOf('?') !== -1 ? '&' : '?') + querystring.stringify(queryParameters);

			return fetch(localVarPathWithQueryParameters, fetchParams).then((response) => {
				if (response.status >= 200 && response.status < 300) {
					return response.json();
				} else {
					let error = new Error(response.statusText);
					(error as any).response = response;
					throw error;
				}
			});
		}
		/**
		 *
		 * Delete Form Submitted By Id
		 * @param id
		 * @param formSubmittedId
		 */
		public marketingCampaignsIdFormsSubmittedFormSubmittedIdDelete (params: {  id: number; formSubmittedId: number; }, extraQueryParams?: any, extraFetchParams?: any ) : Promise<{}> {
			const localVarPath = this.basePath + '/marketing/campaigns/{id}/formsSubmitted/{formSubmittedId}'
				.replace('{' + 'id' + '}', String(params.id))
				.replace('{' + 'formSubmittedId' + '}', String(params.formSubmittedId));

			let queryParameters: any = assign({}, extraQueryParams);
			let headerParams: any = assign({}, this.defaultHeaders);
			// verify required parameter 'id' is set
			if (params.id == null) {
				throw new Error('Missing required parameter id when calling marketingCampaignsIdFormsSubmittedFormSubmittedIdDelete');
			}
			// verify required parameter 'formSubmittedId' is set
			if (params.formSubmittedId == null) {
				throw new Error('Missing required parameter formSubmittedId when calling marketingCampaignsIdFormsSubmittedFormSubmittedIdDelete');
			}
			let fetchParams = {
				method: 'DELETE',
				headers: headerParams,

			};

			if (extraFetchParams) {
				fetchParams = assign(fetchParams, extraFetchParams);
			}

			let localVarPathWithQueryParameters = localVarPath + (localVarPath.indexOf('?') !== -1 ? '&' : '?') + querystring.stringify(queryParameters);

			return fetch(localVarPathWithQueryParameters, fetchParams).then((response) => {
				if (response.status >= 200 && response.status < 300) {
					return response.json();
				} else {
					let error = new Error(response.statusText);
					(error as any).response = response;
					throw error;
				}
			});
		}
		/**
		 *
		 * Get Form Submitted By Id
		 * @param id
		 * @param formSubmittedId
		 */
		public marketingCampaignsIdFormsSubmittedFormSubmittedIdGet (params: {  id: number; formSubmittedId: number; }, extraQueryParams?: any, extraFetchParams?: any ) : Promise<FormSubmitted> {
			const localVarPath = this.basePath + '/marketing/campaigns/{id}/formsSubmitted/{formSubmittedId}'
				.replace('{' + 'id' + '}', String(params.id))
				.replace('{' + 'formSubmittedId' + '}', String(params.formSubmittedId));

			let queryParameters: any = assign({}, extraQueryParams);
			let headerParams: any = assign({}, this.defaultHeaders);
			// verify required parameter 'id' is set
			if (params.id == null) {
				throw new Error('Missing required parameter id when calling marketingCampaignsIdFormsSubmittedFormSubmittedIdGet');
			}
			// verify required parameter 'formSubmittedId' is set
			if (params.formSubmittedId == null) {
				throw new Error('Missing required parameter formSubmittedId when calling marketingCampaignsIdFormsSubmittedFormSubmittedIdGet');
			}
			let fetchParams = {
				method: 'GET',
				headers: headerParams,

			};

			if (extraFetchParams) {
				fetchParams = assign(fetchParams, extraFetchParams);
			}

			let localVarPathWithQueryParameters = localVarPath + (localVarPath.indexOf('?') !== -1 ? '&' : '?') + querystring.stringify(queryParameters);

			return fetch(localVarPathWithQueryParameters, fetchParams).then((response) => {
				if (response.status >= 200 && response.status < 300) {
					return response.json();
				} else {
					let error = new Error(response.statusText);
					(error as any).response = response;
					throw error;
				}
			});
		}
		/**
		 *
		 * Update Form Submitted
		 * @param id
		 * @param formSubmittedId
		 * @param operations
		 */
		public marketingCampaignsIdFormsSubmittedFormSubmittedIdPatch (params: {  id: number; formSubmittedId: number; operations: Array<PatchOperation>; }, extraQueryParams?: any, extraFetchParams?: any ) : Promise<FormSubmitted> {
			const localVarPath = this.basePath + '/marketing/campaigns/{id}/formsSubmitted/{formSubmittedId}'
				.replace('{' + 'id' + '}', String(params.id))
				.replace('{' + 'formSubmittedId' + '}', String(params.formSubmittedId));

			let queryParameters: any = assign({}, extraQueryParams);
			let headerParams: any = assign({}, this.defaultHeaders);
			headerParams['Content-Type'] = 'application/json';

			// verify required parameter 'id' is set
			if (params.id == null) {
				throw new Error('Missing required parameter id when calling marketingCampaignsIdFormsSubmittedFormSubmittedIdPatch');
			}
			// verify required parameter 'formSubmittedId' is set
			if (params.formSubmittedId == null) {
				throw new Error('Missing required parameter formSubmittedId when calling marketingCampaignsIdFormsSubmittedFormSubmittedIdPatch');
			}
			// verify required parameter 'operations' is set
			if (params.operations == null) {
				throw new Error('Missing required parameter operations when calling marketingCampaignsIdFormsSubmittedFormSubmittedIdPatch');
			}
			let fetchParams = {
				method: 'PATCH',
				headers: headerParams,
				body: JSON.stringify(params.operations),

			};

			if (extraFetchParams) {
				fetchParams = assign(fetchParams, extraFetchParams);
			}

			let localVarPathWithQueryParameters = localVarPath + (localVarPath.indexOf('?') !== -1 ? '&' : '?') + querystring.stringify(queryParameters);

			return fetch(localVarPathWithQueryParameters, fetchParams).then((response) => {
				if (response.status >= 200 && response.status < 300) {
					return response.json();
				} else {
					let error = new Error(response.statusText);
					(error as any).response = response;
					throw error;
				}
			});
		}
		/**
		 *
		 * Replace Form Submitted
		 * @param id
		 * @param formSubmittedId
		 * @param formSubmitted
		 */
		public marketingCampaignsIdFormsSubmittedFormSubmittedIdPut (params: {  id: number; formSubmittedId: number; formSubmitted: FormSubmitted; }, extraQueryParams?: any, extraFetchParams?: any ) : Promise<FormSubmitted> {
			const localVarPath = this.basePath + '/marketing/campaigns/{id}/formsSubmitted/{formSubmittedId}'
				.replace('{' + 'id' + '}', String(params.id))
				.replace('{' + 'formSubmittedId' + '}', String(params.formSubmittedId));

			let queryParameters: any = assign({}, extraQueryParams);
			let headerParams: any = assign({}, this.defaultHeaders);
			headerParams['Content-Type'] = 'application/json';

			// verify required parameter 'id' is set
			if (params.id == null) {
				throw new Error('Missing required parameter id when calling marketingCampaignsIdFormsSubmittedFormSubmittedIdPut');
			}
			// verify required parameter 'formSubmittedId' is set
			if (params.formSubmittedId == null) {
				throw new Error('Missing required parameter formSubmittedId when calling marketingCampaignsIdFormsSubmittedFormSubmittedIdPut');
			}
			// verify required parameter 'formSubmitted' is set
			if (params.formSubmitted == null) {
				throw new Error('Missing required parameter formSubmitted when calling marketingCampaignsIdFormsSubmittedFormSubmittedIdPut');
			}
			let fetchParams = {
				method: 'PUT',
				headers: headerParams,
				body: JSON.stringify(params.formSubmitted),

			};

			if (extraFetchParams) {
				fetchParams = assign(fetchParams, extraFetchParams);
			}

			let localVarPathWithQueryParameters = localVarPath + (localVarPath.indexOf('?') !== -1 ? '&' : '?') + querystring.stringify(queryParameters);

			return fetch(localVarPathWithQueryParameters, fetchParams).then((response) => {
				if (response.status >= 200 && response.status < 300) {
					return response.json();
				} else {
					let error = new Error(response.statusText);
					(error as any).response = response;
					throw error;
				}
			});
		}
		/**
		 *
		 * Get Forms Submitted
		 * @param id
		 * @param conditions
		 * @param orderBy
		 * @param childconditions
		 * @param customfieldconditions
		 * @param page
		 * @param pageSize
		 */
		public marketingCampaignsIdFormsSubmittedGet (params: {  id: number; conditions?: string; orderBy?: string; childconditions?: string; customfieldconditions?: string; page?: number; pageSize?: number; }, extraQueryParams?: any, extraFetchParams?: any ) : Promise<Array<FormSubmitted>> {
			const localVarPath = this.basePath + '/marketing/campaigns/{id}/formsSubmitted'
				.replace('{' + 'id' + '}', String(params.id));

			let queryParameters: any = assign({}, extraQueryParams);
			let headerParams: any = assign({}, this.defaultHeaders);
			// verify required parameter 'id' is set
			if (params.id == null) {
				throw new Error('Missing required parameter id when calling marketingCampaignsIdFormsSubmittedGet');
			}
			if (params.conditions !== undefined) {
				queryParameters['conditions'] = params.conditions;
			}

			if (params.orderBy !== undefined) {
				queryParameters['orderBy'] = params.orderBy;
			}

			if (params.childconditions !== undefined) {
				queryParameters['childconditions'] = params.childconditions;
			}

			if (params.customfieldconditions !== undefined) {
				queryParameters['customfieldconditions'] = params.customfieldconditions;
			}

			if (params.page !== undefined) {
				queryParameters['page'] = params.page;
			}

			if (params.pageSize !== undefined) {
				queryParameters['pageSize'] = params.pageSize;
			}

			let fetchParams = {
				method: 'GET',
				headers: headerParams,

			};

			if (extraFetchParams) {
				fetchParams = assign(fetchParams, extraFetchParams);
			}

			let localVarPathWithQueryParameters = localVarPath + (localVarPath.indexOf('?') !== -1 ? '&' : '?') + querystring.stringify(queryParameters);

			return fetch(localVarPathWithQueryParameters, fetchParams).then((response) => {
				if (response.status >= 200 && response.status < 300) {
					return response.json();
				} else {
					let error = new Error(response.statusText);
					(error as any).response = response;
					throw error;
				}
			});
		}
		/**
		 *
		 * Create Form Submitted
		 * @param id
		 * @param formSubmitted
		 */
		public marketingCampaignsIdFormsSubmittedPost (params: {  id: number; formSubmitted: FormSubmitted; }, extraQueryParams?: any, extraFetchParams?: any ) : Promise<FormSubmitted> {
			const localVarPath = this.basePath + '/marketing/campaigns/{id}/formsSubmitted'
				.replace('{' + 'id' + '}', String(params.id));

			let queryParameters: any = assign({}, extraQueryParams);
			let headerParams: any = assign({}, this.defaultHeaders);
			headerParams['Content-Type'] = 'application/json';

			// verify required parameter 'id' is set
			if (params.id == null) {
				throw new Error('Missing required parameter id when calling marketingCampaignsIdFormsSubmittedPost');
			}
			// verify required parameter 'formSubmitted' is set
			if (params.formSubmitted == null) {
				throw new Error('Missing required parameter formSubmitted when calling marketingCampaignsIdFormsSubmittedPost');
			}
			let fetchParams = {
				method: 'POST',
				headers: headerParams,
				body: JSON.stringify(params.formSubmitted),

			};

			if (extraFetchParams) {
				fetchParams = assign(fetchParams, extraFetchParams);
			}

			let localVarPathWithQueryParameters = localVarPath + (localVarPath.indexOf('?') !== -1 ? '&' : '?') + querystring.stringify(queryParameters);

			return fetch(localVarPathWithQueryParameters, fetchParams).then((response) => {
				if (response.status >= 200 && response.status < 300) {
					return response.json();
				} else {
					let error = new Error(response.statusText);
					(error as any).response = response;
					throw error;
				}
			});
		}
	}
//}
//export namespace  {
	'use strict';

	export class CampaignLinksClickedApi {
		protected basePath = 'https://api-na.myconnectwise.net/v4_6_release/apis/3.0';
		public defaultHeaders : any = {};

		constructor(basePath?: string) {
			if (basePath) {
				this.basePath = basePath;
			}
		}

		/**
		 *
		 * Get Links Clicked Count
		 * @param id
		 * @param conditions
		 */
		public marketingCampaignsIdLinksClickedCountGet (params: {  id: number; conditions?: string; }, extraQueryParams?: any, extraFetchParams?: any ) : Promise<Count> {
			const localVarPath = this.basePath + '/marketing/campaigns/{id}/linksClicked/count'
				.replace('{' + 'id' + '}', String(params.id));

			let queryParameters: any = assign({}, extraQueryParams);
			let headerParams: any = assign({}, this.defaultHeaders);
			// verify required parameter 'id' is set
			if (params.id == null) {
				throw new Error('Missing required parameter id when calling marketingCampaignsIdLinksClickedCountGet');
			}
			if (params.conditions !== undefined) {
				queryParameters['conditions'] = params.conditions;
			}

			let fetchParams = {
				method: 'GET',
				headers: headerParams,

			};

			if (extraFetchParams) {
				fetchParams = assign(fetchParams, extraFetchParams);
			}

			let localVarPathWithQueryParameters = localVarPath + (localVarPath.indexOf('?') !== -1 ? '&' : '?') + querystring.stringify(queryParameters);

			return fetch(localVarPathWithQueryParameters, fetchParams).then((response) => {
				if (response.status >= 200 && response.status < 300) {
					return response.json();
				} else {
					let error = new Error(response.statusText);
					(error as any).response = response;
					throw error;
				}
			});
		}
		/**
		 *
		 * Get Links Clicked
		 * @param id
		 * @param conditions
		 * @param orderBy
		 * @param childconditions
		 * @param customfieldconditions
		 * @param page
		 * @param pageSize
		 */
		public marketingCampaignsIdLinksClickedGet (params: {  id: number; conditions?: string; orderBy?: string; childconditions?: string; customfieldconditions?: string; page?: number; pageSize?: number; }, extraQueryParams?: any, extraFetchParams?: any ) : Promise<Array<LinkClicked>> {
			const localVarPath = this.basePath + '/marketing/campaigns/{id}/linksClicked'
				.replace('{' + 'id' + '}', String(params.id));

			let queryParameters: any = assign({}, extraQueryParams);
			let headerParams: any = assign({}, this.defaultHeaders);
			// verify required parameter 'id' is set
			if (params.id == null) {
				throw new Error('Missing required parameter id when calling marketingCampaignsIdLinksClickedGet');
			}
			if (params.conditions !== undefined) {
				queryParameters['conditions'] = params.conditions;
			}

			if (params.orderBy !== undefined) {
				queryParameters['orderBy'] = params.orderBy;
			}

			if (params.childconditions !== undefined) {
				queryParameters['childconditions'] = params.childconditions;
			}

			if (params.customfieldconditions !== undefined) {
				queryParameters['customfieldconditions'] = params.customfieldconditions;
			}

			if (params.page !== undefined) {
				queryParameters['page'] = params.page;
			}

			if (params.pageSize !== undefined) {
				queryParameters['pageSize'] = params.pageSize;
			}

			let fetchParams = {
				method: 'GET',
				headers: headerParams,

			};

			if (extraFetchParams) {
				fetchParams = assign(fetchParams, extraFetchParams);
			}

			let localVarPathWithQueryParameters = localVarPath + (localVarPath.indexOf('?') !== -1 ? '&' : '?') + querystring.stringify(queryParameters);

			return fetch(localVarPathWithQueryParameters, fetchParams).then((response) => {
				if (response.status >= 200 && response.status < 300) {
					return response.json();
				} else {
					let error = new Error(response.statusText);
					(error as any).response = response;
					throw error;
				}
			});
		}
		/**
		 *
		 * Delete Link Clicked By Id
		 * @param id
		 * @param linkClickedId
		 */
		public marketingCampaignsIdLinksClickedLinkClickedIdDelete (params: {  id: number; linkClickedId: number; }, extraQueryParams?: any, extraFetchParams?: any ) : Promise<{}> {
			const localVarPath = this.basePath + '/marketing/campaigns/{id}/linksClicked/{linkClickedId}'
				.replace('{' + 'id' + '}', String(params.id))
				.replace('{' + 'linkClickedId' + '}', String(params.linkClickedId));

			let queryParameters: any = assign({}, extraQueryParams);
			let headerParams: any = assign({}, this.defaultHeaders);
			// verify required parameter 'id' is set
			if (params.id == null) {
				throw new Error('Missing required parameter id when calling marketingCampaignsIdLinksClickedLinkClickedIdDelete');
			}
			// verify required parameter 'linkClickedId' is set
			if (params.linkClickedId == null) {
				throw new Error('Missing required parameter linkClickedId when calling marketingCampaignsIdLinksClickedLinkClickedIdDelete');
			}
			let fetchParams = {
				method: 'DELETE',
				headers: headerParams,

			};

			if (extraFetchParams) {
				fetchParams = assign(fetchParams, extraFetchParams);
			}

			let localVarPathWithQueryParameters = localVarPath + (localVarPath.indexOf('?') !== -1 ? '&' : '?') + querystring.stringify(queryParameters);

			return fetch(localVarPathWithQueryParameters, fetchParams).then((response) => {
				if (response.status >= 200 && response.status < 300) {
					return response.json();
				} else {
					let error = new Error(response.statusText);
					(error as any).response = response;
					throw error;
				}
			});
		}
		/**
		 *
		 * Get Link Clicked By Id
		 * @param id
		 * @param linkClickedId
		 */
		public marketingCampaignsIdLinksClickedLinkClickedIdGet (params: {  id: number; linkClickedId: number; }, extraQueryParams?: any, extraFetchParams?: any ) : Promise<LinkClicked> {
			const localVarPath = this.basePath + '/marketing/campaigns/{id}/linksClicked/{linkClickedId}'
				.replace('{' + 'id' + '}', String(params.id))
				.replace('{' + 'linkClickedId' + '}', String(params.linkClickedId));

			let queryParameters: any = assign({}, extraQueryParams);
			let headerParams: any = assign({}, this.defaultHeaders);
			// verify required parameter 'id' is set
			if (params.id == null) {
				throw new Error('Missing required parameter id when calling marketingCampaignsIdLinksClickedLinkClickedIdGet');
			}
			// verify required parameter 'linkClickedId' is set
			if (params.linkClickedId == null) {
				throw new Error('Missing required parameter linkClickedId when calling marketingCampaignsIdLinksClickedLinkClickedIdGet');
			}
			let fetchParams = {
				method: 'GET',
				headers: headerParams,

			};

			if (extraFetchParams) {
				fetchParams = assign(fetchParams, extraFetchParams);
			}

			let localVarPathWithQueryParameters = localVarPath + (localVarPath.indexOf('?') !== -1 ? '&' : '?') + querystring.stringify(queryParameters);

			return fetch(localVarPathWithQueryParameters, fetchParams).then((response) => {
				if (response.status >= 200 && response.status < 300) {
					return response.json();
				} else {
					let error = new Error(response.statusText);
					(error as any).response = response;
					throw error;
				}
			});
		}
		/**
		 *
		 * Update Link Clicked
		 * @param id
		 * @param linkClickedId
		 * @param operations
		 */
		public marketingCampaignsIdLinksClickedLinkClickedIdPatch (params: {  id: number; linkClickedId: number; operations: Array<PatchOperation>; }, extraQueryParams?: any, extraFetchParams?: any ) : Promise<LinkClicked> {
			const localVarPath = this.basePath + '/marketing/campaigns/{id}/linksClicked/{linkClickedId}'
				.replace('{' + 'id' + '}', String(params.id))
				.replace('{' + 'linkClickedId' + '}', String(params.linkClickedId));

			let queryParameters: any = assign({}, extraQueryParams);
			let headerParams: any = assign({}, this.defaultHeaders);
			headerParams['Content-Type'] = 'application/json';

			// verify required parameter 'id' is set
			if (params.id == null) {
				throw new Error('Missing required parameter id when calling marketingCampaignsIdLinksClickedLinkClickedIdPatch');
			}
			// verify required parameter 'linkClickedId' is set
			if (params.linkClickedId == null) {
				throw new Error('Missing required parameter linkClickedId when calling marketingCampaignsIdLinksClickedLinkClickedIdPatch');
			}
			// verify required parameter 'operations' is set
			if (params.operations == null) {
				throw new Error('Missing required parameter operations when calling marketingCampaignsIdLinksClickedLinkClickedIdPatch');
			}
			let fetchParams = {
				method: 'PATCH',
				headers: headerParams,
				body: JSON.stringify(params.operations),

			};

			if (extraFetchParams) {
				fetchParams = assign(fetchParams, extraFetchParams);
			}

			let localVarPathWithQueryParameters = localVarPath + (localVarPath.indexOf('?') !== -1 ? '&' : '?') + querystring.stringify(queryParameters);

			return fetch(localVarPathWithQueryParameters, fetchParams).then((response) => {
				if (response.status >= 200 && response.status < 300) {
					return response.json();
				} else {
					let error = new Error(response.statusText);
					(error as any).response = response;
					throw error;
				}
			});
		}
		/**
		 *
		 * Replace Link Clicked
		 * @param id
		 * @param linkClickedId
		 * @param linkClicked
		 */
		public marketingCampaignsIdLinksClickedLinkClickedIdPut (params: {  id: number; linkClickedId: number; linkClicked: LinkClicked; }, extraQueryParams?: any, extraFetchParams?: any ) : Promise<LinkClicked> {
			const localVarPath = this.basePath + '/marketing/campaigns/{id}/linksClicked/{linkClickedId}'
				.replace('{' + 'id' + '}', String(params.id))
				.replace('{' + 'linkClickedId' + '}', String(params.linkClickedId));

			let queryParameters: any = assign({}, extraQueryParams);
			let headerParams: any = assign({}, this.defaultHeaders);
			headerParams['Content-Type'] = 'application/json';

			// verify required parameter 'id' is set
			if (params.id == null) {
				throw new Error('Missing required parameter id when calling marketingCampaignsIdLinksClickedLinkClickedIdPut');
			}
			// verify required parameter 'linkClickedId' is set
			if (params.linkClickedId == null) {
				throw new Error('Missing required parameter linkClickedId when calling marketingCampaignsIdLinksClickedLinkClickedIdPut');
			}
			// verify required parameter 'linkClicked' is set
			if (params.linkClicked == null) {
				throw new Error('Missing required parameter linkClicked when calling marketingCampaignsIdLinksClickedLinkClickedIdPut');
			}
			let fetchParams = {
				method: 'PUT',
				headers: headerParams,
				body: JSON.stringify(params.linkClicked),

			};

			if (extraFetchParams) {
				fetchParams = assign(fetchParams, extraFetchParams);
			}

			let localVarPathWithQueryParameters = localVarPath + (localVarPath.indexOf('?') !== -1 ? '&' : '?') + querystring.stringify(queryParameters);

			return fetch(localVarPathWithQueryParameters, fetchParams).then((response) => {
				if (response.status >= 200 && response.status < 300) {
					return response.json();
				} else {
					let error = new Error(response.statusText);
					(error as any).response = response;
					throw error;
				}
			});
		}
		/**
		 *
		 * Create Link Clicked
		 * @param id
		 * @param linkClicked
		 */
		public marketingCampaignsIdLinksClickedPost (params: {  id: number; linkClicked: LinkClicked; }, extraQueryParams?: any, extraFetchParams?: any ) : Promise<LinkClicked> {
			const localVarPath = this.basePath + '/marketing/campaigns/{id}/linksClicked'
				.replace('{' + 'id' + '}', String(params.id));

			let queryParameters: any = assign({}, extraQueryParams);
			let headerParams: any = assign({}, this.defaultHeaders);
			headerParams['Content-Type'] = 'application/json';

			// verify required parameter 'id' is set
			if (params.id == null) {
				throw new Error('Missing required parameter id when calling marketingCampaignsIdLinksClickedPost');
			}
			// verify required parameter 'linkClicked' is set
			if (params.linkClicked == null) {
				throw new Error('Missing required parameter linkClicked when calling marketingCampaignsIdLinksClickedPost');
			}
			let fetchParams = {
				method: 'POST',
				headers: headerParams,
				body: JSON.stringify(params.linkClicked),

			};

			if (extraFetchParams) {
				fetchParams = assign(fetchParams, extraFetchParams);
			}

			let localVarPathWithQueryParameters = localVarPath + (localVarPath.indexOf('?') !== -1 ? '&' : '?') + querystring.stringify(queryParameters);

			return fetch(localVarPathWithQueryParameters, fetchParams).then((response) => {
				if (response.status >= 200 && response.status < 300) {
					return response.json();
				} else {
					let error = new Error(response.statusText);
					(error as any).response = response;
					throw error;
				}
			});
		}
	}
//}
//export namespace  {
	'use strict';

	export class CampaignStatusesApi {
		protected basePath = 'https://api-na.myconnectwise.net/v4_6_release/apis/3.0';
		public defaultHeaders : any = {};

		constructor(basePath?: string) {
			if (basePath) {
				this.basePath = basePath;
			}
		}

		/**
		 *
		 * Get Campaign Statuses Count
		 * @param conditions
		 */
		public marketingCampaignsStatusesCountGet (params: {  conditions?: string; }, extraQueryParams?: any, extraFetchParams?: any ) : Promise<Count> {
			const localVarPath = this.basePath + '/marketing/campaigns/statuses/count';

			let queryParameters: any = assign({}, extraQueryParams);
			let headerParams: any = assign({}, this.defaultHeaders);
			if (params.conditions !== undefined) {
				queryParameters['conditions'] = params.conditions;
			}

			let fetchParams = {
				method: 'GET',
				headers: headerParams,

			};

			if (extraFetchParams) {
				fetchParams = assign(fetchParams, extraFetchParams);
			}

			let localVarPathWithQueryParameters = localVarPath + (localVarPath.indexOf('?') !== -1 ? '&' : '?') + querystring.stringify(queryParameters);

			return fetch(localVarPathWithQueryParameters, fetchParams).then((response) => {
				if (response.status >= 200 && response.status < 300) {
					return response.json();
				} else {
					let error = new Error(response.statusText);
					(error as any).response = response;
					throw error;
				}
			});
		}
		/**
		 *
		 * Get Campaign Statuses
		 * @param conditions
		 * @param orderBy
		 * @param childconditions
		 * @param customfieldconditions
		 * @param page
		 * @param pageSize
		 */
		public marketingCampaignsStatusesGet (params: {  conditions?: string; orderBy?: string; childconditions?: string; customfieldconditions?: string; page?: number; pageSize?: number; }, extraQueryParams?: any, extraFetchParams?: any ) : Promise<Array<CampaignStatus>> {
			const localVarPath = this.basePath + '/marketing/campaigns/statuses';

			let queryParameters: any = assign({}, extraQueryParams);
			let headerParams: any = assign({}, this.defaultHeaders);
			if (params.conditions !== undefined) {
				queryParameters['conditions'] = params.conditions;
			}

			if (params.orderBy !== undefined) {
				queryParameters['orderBy'] = params.orderBy;
			}

			if (params.childconditions !== undefined) {
				queryParameters['childconditions'] = params.childconditions;
			}

			if (params.customfieldconditions !== undefined) {
				queryParameters['customfieldconditions'] = params.customfieldconditions;
			}

			if (params.page !== undefined) {
				queryParameters['page'] = params.page;
			}

			if (params.pageSize !== undefined) {
				queryParameters['pageSize'] = params.pageSize;
			}

			let fetchParams = {
				method: 'GET',
				headers: headerParams,

			};

			if (extraFetchParams) {
				fetchParams = assign(fetchParams, extraFetchParams);
			}

			let localVarPathWithQueryParameters = localVarPath + (localVarPath.indexOf('?') !== -1 ? '&' : '?') + querystring.stringify(queryParameters);

			return fetch(localVarPathWithQueryParameters, fetchParams).then((response) => {
				if (response.status >= 200 && response.status < 300) {
					return response.json();
				} else {
					let error = new Error(response.statusText);
					(error as any).response = response;
					throw error;
				}
			});
		}
		/**
		 *
		 * Delete Campaign Status By Id
		 * @param id
		 */
		public marketingCampaignsStatusesIdDelete (params: {  id: number; }, extraQueryParams?: any, extraFetchParams?: any ) : Promise<{}> {
			const localVarPath = this.basePath + '/marketing/campaigns/statuses/{id}'
				.replace('{' + 'id' + '}', String(params.id));

			let queryParameters: any = assign({}, extraQueryParams);
			let headerParams: any = assign({}, this.defaultHeaders);
			// verify required parameter 'id' is set
			if (params.id == null) {
				throw new Error('Missing required parameter id when calling marketingCampaignsStatusesIdDelete');
			}
			let fetchParams = {
				method: 'DELETE',
				headers: headerParams,

			};

			if (extraFetchParams) {
				fetchParams = assign(fetchParams, extraFetchParams);
			}

			let localVarPathWithQueryParameters = localVarPath + (localVarPath.indexOf('?') !== -1 ? '&' : '?') + querystring.stringify(queryParameters);

			return fetch(localVarPathWithQueryParameters, fetchParams).then((response) => {
				if (response.status >= 200 && response.status < 300) {
					return response.json();
				} else {
					let error = new Error(response.statusText);
					(error as any).response = response;
					throw error;
				}
			});
		}
		/**
		 *
		 * Get Campaign Status By Id
		 * @param id
		 */
		public marketingCampaignsStatusesIdGet (params: {  id: number; }, extraQueryParams?: any, extraFetchParams?: any ) : Promise<CampaignStatus> {
			const localVarPath = this.basePath + '/marketing/campaigns/statuses/{id}'
				.replace('{' + 'id' + '}', String(params.id));

			let queryParameters: any = assign({}, extraQueryParams);
			let headerParams: any = assign({}, this.defaultHeaders);
			// verify required parameter 'id' is set
			if (params.id == null) {
				throw new Error('Missing required parameter id when calling marketingCampaignsStatusesIdGet');
			}
			let fetchParams = {
				method: 'GET',
				headers: headerParams,

			};

			if (extraFetchParams) {
				fetchParams = assign(fetchParams, extraFetchParams);
			}

			let localVarPathWithQueryParameters = localVarPath + (localVarPath.indexOf('?') !== -1 ? '&' : '?') + querystring.stringify(queryParameters);

			return fetch(localVarPathWithQueryParameters, fetchParams).then((response) => {
				if (response.status >= 200 && response.status < 300) {
					return response.json();
				} else {
					let error = new Error(response.statusText);
					(error as any).response = response;
					throw error;
				}
			});
		}
		/**
		 *
		 * Update Campaign Status
		 * @param id
		 * @param operations
		 */
		public marketingCampaignsStatusesIdPatch (params: {  id: number; operations: Array<PatchOperation>; }, extraQueryParams?: any, extraFetchParams?: any ) : Promise<CampaignStatus> {
			const localVarPath = this.basePath + '/marketing/campaigns/statuses/{id}'
				.replace('{' + 'id' + '}', String(params.id));

			let queryParameters: any = assign({}, extraQueryParams);
			let headerParams: any = assign({}, this.defaultHeaders);
			headerParams['Content-Type'] = 'application/json';

			// verify required parameter 'id' is set
			if (params.id == null) {
				throw new Error('Missing required parameter id when calling marketingCampaignsStatusesIdPatch');
			}
			// verify required parameter 'operations' is set
			if (params.operations == null) {
				throw new Error('Missing required parameter operations when calling marketingCampaignsStatusesIdPatch');
			}
			let fetchParams = {
				method: 'PATCH',
				headers: headerParams,
				body: JSON.stringify(params.operations),

			};

			if (extraFetchParams) {
				fetchParams = assign(fetchParams, extraFetchParams);
			}

			let localVarPathWithQueryParameters = localVarPath + (localVarPath.indexOf('?') !== -1 ? '&' : '?') + querystring.stringify(queryParameters);

			return fetch(localVarPathWithQueryParameters, fetchParams).then((response) => {
				if (response.status >= 200 && response.status < 300) {
					return response.json();
				} else {
					let error = new Error(response.statusText);
					(error as any).response = response;
					throw error;
				}
			});
		}
		/**
		 *
		 * Replace Campaign Status
		 * @param id
		 * @param campaignStatus
		 */
		public marketingCampaignsStatusesIdPut (params: {  id: number; campaignStatus: CampaignStatus; }, extraQueryParams?: any, extraFetchParams?: any ) : Promise<CampaignStatus> {
			const localVarPath = this.basePath + '/marketing/campaigns/statuses/{id}'
				.replace('{' + 'id' + '}', String(params.id));

			let queryParameters: any = assign({}, extraQueryParams);
			let headerParams: any = assign({}, this.defaultHeaders);
			headerParams['Content-Type'] = 'application/json';

			// verify required parameter 'id' is set
			if (params.id == null) {
				throw new Error('Missing required parameter id when calling marketingCampaignsStatusesIdPut');
			}
			// verify required parameter 'campaignStatus' is set
			if (params.campaignStatus == null) {
				throw new Error('Missing required parameter campaignStatus when calling marketingCampaignsStatusesIdPut');
			}
			let fetchParams = {
				method: 'PUT',
				headers: headerParams,
				body: JSON.stringify(params.campaignStatus),

			};

			if (extraFetchParams) {
				fetchParams = assign(fetchParams, extraFetchParams);
			}

			let localVarPathWithQueryParameters = localVarPath + (localVarPath.indexOf('?') !== -1 ? '&' : '?') + querystring.stringify(queryParameters);

			return fetch(localVarPathWithQueryParameters, fetchParams).then((response) => {
				if (response.status >= 200 && response.status < 300) {
					return response.json();
				} else {
					let error = new Error(response.statusText);
					(error as any).response = response;
					throw error;
				}
			});
		}
		/**
		 *
		 * Create Campaign Status
		 * @param campaignStatus
		 */
		public marketingCampaignsStatusesPost (params: {  campaignStatus: CampaignStatus; }, extraQueryParams?: any, extraFetchParams?: any ) : Promise<CampaignStatus> {
			const localVarPath = this.basePath + '/marketing/campaigns/statuses';

			let queryParameters: any = assign({}, extraQueryParams);
			let headerParams: any = assign({}, this.defaultHeaders);
			headerParams['Content-Type'] = 'application/json';

			// verify required parameter 'campaignStatus' is set
			if (params.campaignStatus == null) {
				throw new Error('Missing required parameter campaignStatus when calling marketingCampaignsStatusesPost');
			}
			let fetchParams = {
				method: 'POST',
				headers: headerParams,
				body: JSON.stringify(params.campaignStatus),

			};

			if (extraFetchParams) {
				fetchParams = assign(fetchParams, extraFetchParams);
			}

			let localVarPathWithQueryParameters = localVarPath + (localVarPath.indexOf('?') !== -1 ? '&' : '?') + querystring.stringify(queryParameters);

			return fetch(localVarPathWithQueryParameters, fetchParams).then((response) => {
				if (response.status >= 200 && response.status < 300) {
					return response.json();
				} else {
					let error = new Error(response.statusText);
					(error as any).response = response;
					throw error;
				}
			});
		}
	}
//}
//export namespace  {
	'use strict';

	export class CampaignSubTypesApi {
		protected basePath = 'https://api-na.myconnectwise.net/v4_6_release/apis/3.0';
		public defaultHeaders : any = {};

		constructor(basePath?: string) {
			if (basePath) {
				this.basePath = basePath;
			}
		}

		/**
		 *
		 * Get Campaign Sub Types Count
		 * @param id
		 * @param conditions
		 */
		public marketingCampaignsTypesIdSubTypesCountGet (params: {  id: number; conditions?: string; }, extraQueryParams?: any, extraFetchParams?: any ) : Promise<Count> {
			const localVarPath = this.basePath + '/marketing/campaigns/types/{id}/subTypes/count'
				.replace('{' + 'id' + '}', String(params.id));

			let queryParameters: any = assign({}, extraQueryParams);
			let headerParams: any = assign({}, this.defaultHeaders);
			// verify required parameter 'id' is set
			if (params.id == null) {
				throw new Error('Missing required parameter id when calling marketingCampaignsTypesIdSubTypesCountGet');
			}
			if (params.conditions !== undefined) {
				queryParameters['conditions'] = params.conditions;
			}

			let fetchParams = {
				method: 'GET',
				headers: headerParams,

			};

			if (extraFetchParams) {
				fetchParams = assign(fetchParams, extraFetchParams);
			}

			let localVarPathWithQueryParameters = localVarPath + (localVarPath.indexOf('?') !== -1 ? '&' : '?') + querystring.stringify(queryParameters);

			return fetch(localVarPathWithQueryParameters, fetchParams).then((response) => {
				if (response.status >= 200 && response.status < 300) {
					return response.json();
				} else {
					let error = new Error(response.statusText);
					(error as any).response = response;
					throw error;
				}
			});
		}
		/**
		 *
		 * Get Campaign Sub Types
		 * @param id
		 * @param conditions
		 * @param orderBy
		 * @param childconditions
		 * @param customfieldconditions
		 * @param page
		 * @param pageSize
		 */
		public marketingCampaignsTypesIdSubTypesGet (params: {  id: number; conditions?: string; orderBy?: string; childconditions?: string; customfieldconditions?: string; page?: number; pageSize?: number; }, extraQueryParams?: any, extraFetchParams?: any ) : Promise<Array<CampaignSubType>> {
			const localVarPath = this.basePath + '/marketing/campaigns/types/{id}/subTypes'
				.replace('{' + 'id' + '}', String(params.id));

			let queryParameters: any = assign({}, extraQueryParams);
			let headerParams: any = assign({}, this.defaultHeaders);
			// verify required parameter 'id' is set
			if (params.id == null) {
				throw new Error('Missing required parameter id when calling marketingCampaignsTypesIdSubTypesGet');
			}
			if (params.conditions !== undefined) {
				queryParameters['conditions'] = params.conditions;
			}

			if (params.orderBy !== undefined) {
				queryParameters['orderBy'] = params.orderBy;
			}

			if (params.childconditions !== undefined) {
				queryParameters['childconditions'] = params.childconditions;
			}

			if (params.customfieldconditions !== undefined) {
				queryParameters['customfieldconditions'] = params.customfieldconditions;
			}

			if (params.page !== undefined) {
				queryParameters['page'] = params.page;
			}

			if (params.pageSize !== undefined) {
				queryParameters['pageSize'] = params.pageSize;
			}

			let fetchParams = {
				method: 'GET',
				headers: headerParams,

			};

			if (extraFetchParams) {
				fetchParams = assign(fetchParams, extraFetchParams);
			}

			let localVarPathWithQueryParameters = localVarPath + (localVarPath.indexOf('?') !== -1 ? '&' : '?') + querystring.stringify(queryParameters);

			return fetch(localVarPathWithQueryParameters, fetchParams).then((response) => {
				if (response.status >= 200 && response.status < 300) {
					return response.json();
				} else {
					let error = new Error(response.statusText);
					(error as any).response = response;
					throw error;
				}
			});
		}
		/**
		 *
		 * Create Campaign Sub Type
		 * @param id
		 * @param campaignSubType
		 */
		public marketingCampaignsTypesIdSubTypesPost (params: {  id: number; campaignSubType: CampaignSubType; }, extraQueryParams?: any, extraFetchParams?: any ) : Promise<CampaignSubType> {
			const localVarPath = this.basePath + '/marketing/campaigns/types/{id}/subTypes'
				.replace('{' + 'id' + '}', String(params.id));

			let queryParameters: any = assign({}, extraQueryParams);
			let headerParams: any = assign({}, this.defaultHeaders);
			headerParams['Content-Type'] = 'application/json';

			// verify required parameter 'id' is set
			if (params.id == null) {
				throw new Error('Missing required parameter id when calling marketingCampaignsTypesIdSubTypesPost');
			}
			// verify required parameter 'campaignSubType' is set
			if (params.campaignSubType == null) {
				throw new Error('Missing required parameter campaignSubType when calling marketingCampaignsTypesIdSubTypesPost');
			}
			let fetchParams = {
				method: 'POST',
				headers: headerParams,
				body: JSON.stringify(params.campaignSubType),

			};

			if (extraFetchParams) {
				fetchParams = assign(fetchParams, extraFetchParams);
			}

			let localVarPathWithQueryParameters = localVarPath + (localVarPath.indexOf('?') !== -1 ? '&' : '?') + querystring.stringify(queryParameters);

			return fetch(localVarPathWithQueryParameters, fetchParams).then((response) => {
				if (response.status >= 200 && response.status < 300) {
					return response.json();
				} else {
					let error = new Error(response.statusText);
					(error as any).response = response;
					throw error;
				}
			});
		}
		/**
		 *
		 * Delete Campaign Sub Type By Id
		 * @param id
		 * @param subTypeId
		 */
		public marketingCampaignsTypesIdSubTypesSubTypeIdDelete (params: {  id: number; subTypeId: number; }, extraQueryParams?: any, extraFetchParams?: any ) : Promise<{}> {
			const localVarPath = this.basePath + '/marketing/campaigns/types/{id}/subTypes/{subTypeId}'
				.replace('{' + 'id' + '}', String(params.id))
				.replace('{' + 'subTypeId' + '}', String(params.subTypeId));

			let queryParameters: any = assign({}, extraQueryParams);
			let headerParams: any = assign({}, this.defaultHeaders);
			// verify required parameter 'id' is set
			if (params.id == null) {
				throw new Error('Missing required parameter id when calling marketingCampaignsTypesIdSubTypesSubTypeIdDelete');
			}
			// verify required parameter 'subTypeId' is set
			if (params.subTypeId == null) {
				throw new Error('Missing required parameter subTypeId when calling marketingCampaignsTypesIdSubTypesSubTypeIdDelete');
			}
			let fetchParams = {
				method: 'DELETE',
				headers: headerParams,

			};

			if (extraFetchParams) {
				fetchParams = assign(fetchParams, extraFetchParams);
			}

			let localVarPathWithQueryParameters = localVarPath + (localVarPath.indexOf('?') !== -1 ? '&' : '?') + querystring.stringify(queryParameters);

			return fetch(localVarPathWithQueryParameters, fetchParams).then((response) => {
				if (response.status >= 200 && response.status < 300) {
					return response.json();
				} else {
					let error = new Error(response.statusText);
					(error as any).response = response;
					throw error;
				}
			});
		}
		/**
		 *
		 * Get Campaign Sub Type By Id
		 * @param id
		 * @param subTypeId
		 */
		public marketingCampaignsTypesIdSubTypesSubTypeIdGet (params: {  id: number; subTypeId: number; }, extraQueryParams?: any, extraFetchParams?: any ) : Promise<CampaignSubType> {
			const localVarPath = this.basePath + '/marketing/campaigns/types/{id}/subTypes/{subTypeId}'
				.replace('{' + 'id' + '}', String(params.id))
				.replace('{' + 'subTypeId' + '}', String(params.subTypeId));

			let queryParameters: any = assign({}, extraQueryParams);
			let headerParams: any = assign({}, this.defaultHeaders);
			// verify required parameter 'id' is set
			if (params.id == null) {
				throw new Error('Missing required parameter id when calling marketingCampaignsTypesIdSubTypesSubTypeIdGet');
			}
			// verify required parameter 'subTypeId' is set
			if (params.subTypeId == null) {
				throw new Error('Missing required parameter subTypeId when calling marketingCampaignsTypesIdSubTypesSubTypeIdGet');
			}
			let fetchParams = {
				method: 'GET',
				headers: headerParams,

			};

			if (extraFetchParams) {
				fetchParams = assign(fetchParams, extraFetchParams);
			}

			let localVarPathWithQueryParameters = localVarPath + (localVarPath.indexOf('?') !== -1 ? '&' : '?') + querystring.stringify(queryParameters);

			return fetch(localVarPathWithQueryParameters, fetchParams).then((response) => {
				if (response.status >= 200 && response.status < 300) {
					return response.json();
				} else {
					let error = new Error(response.statusText);
					(error as any).response = response;
					throw error;
				}
			});
		}
		/**
		 *
		 * Update Campaign Sub Type
		 * @param id
		 * @param subTypeId
		 * @param operations
		 */
		public marketingCampaignsTypesIdSubTypesSubTypeIdPatch (params: {  id: number; subTypeId: number; operations: Array<PatchOperation>; }, extraQueryParams?: any, extraFetchParams?: any ) : Promise<CampaignSubType> {
			const localVarPath = this.basePath + '/marketing/campaigns/types/{id}/subTypes/{subTypeId}'
				.replace('{' + 'id' + '}', String(params.id))
				.replace('{' + 'subTypeId' + '}', String(params.subTypeId));

			let queryParameters: any = assign({}, extraQueryParams);
			let headerParams: any = assign({}, this.defaultHeaders);
			headerParams['Content-Type'] = 'application/json';

			// verify required parameter 'id' is set
			if (params.id == null) {
				throw new Error('Missing required parameter id when calling marketingCampaignsTypesIdSubTypesSubTypeIdPatch');
			}
			// verify required parameter 'subTypeId' is set
			if (params.subTypeId == null) {
				throw new Error('Missing required parameter subTypeId when calling marketingCampaignsTypesIdSubTypesSubTypeIdPatch');
			}
			// verify required parameter 'operations' is set
			if (params.operations == null) {
				throw new Error('Missing required parameter operations when calling marketingCampaignsTypesIdSubTypesSubTypeIdPatch');
			}
			let fetchParams = {
				method: 'PATCH',
				headers: headerParams,
				body: JSON.stringify(params.operations),

			};

			if (extraFetchParams) {
				fetchParams = assign(fetchParams, extraFetchParams);
			}

			let localVarPathWithQueryParameters = localVarPath + (localVarPath.indexOf('?') !== -1 ? '&' : '?') + querystring.stringify(queryParameters);

			return fetch(localVarPathWithQueryParameters, fetchParams).then((response) => {
				if (response.status >= 200 && response.status < 300) {
					return response.json();
				} else {
					let error = new Error(response.statusText);
					(error as any).response = response;
					throw error;
				}
			});
		}
		/**
		 *
		 * Replace Campaign Sub Type
		 * @param id
		 * @param subTypeId
		 * @param campaignSubType
		 */
		public marketingCampaignsTypesIdSubTypesSubTypeIdPut (params: {  id: number; subTypeId: number; campaignSubType: CampaignSubType; }, extraQueryParams?: any, extraFetchParams?: any ) : Promise<CampaignSubType> {
			const localVarPath = this.basePath + '/marketing/campaigns/types/{id}/subTypes/{subTypeId}'
				.replace('{' + 'id' + '}', String(params.id))
				.replace('{' + 'subTypeId' + '}', String(params.subTypeId));

			let queryParameters: any = assign({}, extraQueryParams);
			let headerParams: any = assign({}, this.defaultHeaders);
			headerParams['Content-Type'] = 'application/json';

			// verify required parameter 'id' is set
			if (params.id == null) {
				throw new Error('Missing required parameter id when calling marketingCampaignsTypesIdSubTypesSubTypeIdPut');
			}
			// verify required parameter 'subTypeId' is set
			if (params.subTypeId == null) {
				throw new Error('Missing required parameter subTypeId when calling marketingCampaignsTypesIdSubTypesSubTypeIdPut');
			}
			// verify required parameter 'campaignSubType' is set
			if (params.campaignSubType == null) {
				throw new Error('Missing required parameter campaignSubType when calling marketingCampaignsTypesIdSubTypesSubTypeIdPut');
			}
			let fetchParams = {
				method: 'PUT',
				headers: headerParams,
				body: JSON.stringify(params.campaignSubType),

			};

			if (extraFetchParams) {
				fetchParams = assign(fetchParams, extraFetchParams);
			}

			let localVarPathWithQueryParameters = localVarPath + (localVarPath.indexOf('?') !== -1 ? '&' : '?') + querystring.stringify(queryParameters);

			return fetch(localVarPathWithQueryParameters, fetchParams).then((response) => {
				if (response.status >= 200 && response.status < 300) {
					return response.json();
				} else {
					let error = new Error(response.statusText);
					(error as any).response = response;
					throw error;
				}
			});
		}
	}
//}
//export namespace  {
	'use strict';

	export class CampaignTypesApi {
		protected basePath = 'https://api-na.myconnectwise.net/v4_6_release/apis/3.0';
		public defaultHeaders : any = {};

		constructor(basePath?: string) {
			if (basePath) {
				this.basePath = basePath;
			}
		}

		/**
		 *
		 * Get Campaign Types Count
		 * @param conditions
		 */
		public marketingCampaignsTypesCountGet (params: {  conditions?: string; }, extraQueryParams?: any, extraFetchParams?: any ) : Promise<Count> {
			const localVarPath = this.basePath + '/marketing/campaigns/types/count';

			let queryParameters: any = assign({}, extraQueryParams);
			let headerParams: any = assign({}, this.defaultHeaders);
			if (params.conditions !== undefined) {
				queryParameters['conditions'] = params.conditions;
			}

			let fetchParams = {
				method: 'GET',
				headers: headerParams,

			};

			if (extraFetchParams) {
				fetchParams = assign(fetchParams, extraFetchParams);
			}

			let localVarPathWithQueryParameters = localVarPath + (localVarPath.indexOf('?') !== -1 ? '&' : '?') + querystring.stringify(queryParameters);

			return fetch(localVarPathWithQueryParameters, fetchParams).then((response) => {
				if (response.status >= 200 && response.status < 300) {
					return response.json();
				} else {
					let error = new Error(response.statusText);
					(error as any).response = response;
					throw error;
				}
			});
		}
		/**
		 *
		 * Get Campaign Types
		 * @param conditions
		 * @param orderBy
		 * @param childconditions
		 * @param customfieldconditions
		 * @param page
		 * @param pageSize
		 */
		public marketingCampaignsTypesGet (params: {  conditions?: string; orderBy?: string; childconditions?: string; customfieldconditions?: string; page?: number; pageSize?: number; }, extraQueryParams?: any, extraFetchParams?: any ) : Promise<Array<CampaignType>> {
			const localVarPath = this.basePath + '/marketing/campaigns/types';

			let queryParameters: any = assign({}, extraQueryParams);
			let headerParams: any = assign({}, this.defaultHeaders);
			if (params.conditions !== undefined) {
				queryParameters['conditions'] = params.conditions;
			}

			if (params.orderBy !== undefined) {
				queryParameters['orderBy'] = params.orderBy;
			}

			if (params.childconditions !== undefined) {
				queryParameters['childconditions'] = params.childconditions;
			}

			if (params.customfieldconditions !== undefined) {
				queryParameters['customfieldconditions'] = params.customfieldconditions;
			}

			if (params.page !== undefined) {
				queryParameters['page'] = params.page;
			}

			if (params.pageSize !== undefined) {
				queryParameters['pageSize'] = params.pageSize;
			}

			let fetchParams = {
				method: 'GET',
				headers: headerParams,

			};

			if (extraFetchParams) {
				fetchParams = assign(fetchParams, extraFetchParams);
			}

			let localVarPathWithQueryParameters = localVarPath + (localVarPath.indexOf('?') !== -1 ? '&' : '?') + querystring.stringify(queryParameters);

			return fetch(localVarPathWithQueryParameters, fetchParams).then((response) => {
				if (response.status >= 200 && response.status < 300) {
					return response.json();
				} else {
					let error = new Error(response.statusText);
					(error as any).response = response;
					throw error;
				}
			});
		}
		/**
		 *
		 * Delete Campaign Type By Id
		 * @param id
		 */
		public marketingCampaignsTypesIdDelete (params: {  id: number; }, extraQueryParams?: any, extraFetchParams?: any ) : Promise<{}> {
			const localVarPath = this.basePath + '/marketing/campaigns/types/{id}'
				.replace('{' + 'id' + '}', String(params.id));

			let queryParameters: any = assign({}, extraQueryParams);
			let headerParams: any = assign({}, this.defaultHeaders);
			// verify required parameter 'id' is set
			if (params.id == null) {
				throw new Error('Missing required parameter id when calling marketingCampaignsTypesIdDelete');
			}
			let fetchParams = {
				method: 'DELETE',
				headers: headerParams,

			};

			if (extraFetchParams) {
				fetchParams = assign(fetchParams, extraFetchParams);
			}

			let localVarPathWithQueryParameters = localVarPath + (localVarPath.indexOf('?') !== -1 ? '&' : '?') + querystring.stringify(queryParameters);

			return fetch(localVarPathWithQueryParameters, fetchParams).then((response) => {
				if (response.status >= 200 && response.status < 300) {
					return response.json();
				} else {
					let error = new Error(response.statusText);
					(error as any).response = response;
					throw error;
				}
			});
		}
		/**
		 *
		 * Get Campaign Type By Id
		 * @param id
		 */
		public marketingCampaignsTypesIdGet (params: {  id: number; }, extraQueryParams?: any, extraFetchParams?: any ) : Promise<CampaignType> {
			const localVarPath = this.basePath + '/marketing/campaigns/types/{id}'
				.replace('{' + 'id' + '}', String(params.id));

			let queryParameters: any = assign({}, extraQueryParams);
			let headerParams: any = assign({}, this.defaultHeaders);
			// verify required parameter 'id' is set
			if (params.id == null) {
				throw new Error('Missing required parameter id when calling marketingCampaignsTypesIdGet');
			}
			let fetchParams = {
				method: 'GET',
				headers: headerParams,

			};

			if (extraFetchParams) {
				fetchParams = assign(fetchParams, extraFetchParams);
			}

			let localVarPathWithQueryParameters = localVarPath + (localVarPath.indexOf('?') !== -1 ? '&' : '?') + querystring.stringify(queryParameters);

			return fetch(localVarPathWithQueryParameters, fetchParams).then((response) => {
				if (response.status >= 200 && response.status < 300) {
					return response.json();
				} else {
					let error = new Error(response.statusText);
					(error as any).response = response;
					throw error;
				}
			});
		}
		/**
		 *
		 * Update Campaign Type
		 * @param id
		 * @param operations
		 */
		public marketingCampaignsTypesIdPatch (params: {  id: number; operations: Array<PatchOperation>; }, extraQueryParams?: any, extraFetchParams?: any ) : Promise<CampaignType> {
			const localVarPath = this.basePath + '/marketing/campaigns/types/{id}'
				.replace('{' + 'id' + '}', String(params.id));

			let queryParameters: any = assign({}, extraQueryParams);
			let headerParams: any = assign({}, this.defaultHeaders);
			headerParams['Content-Type'] = 'application/json';

			// verify required parameter 'id' is set
			if (params.id == null) {
				throw new Error('Missing required parameter id when calling marketingCampaignsTypesIdPatch');
			}
			// verify required parameter 'operations' is set
			if (params.operations == null) {
				throw new Error('Missing required parameter operations when calling marketingCampaignsTypesIdPatch');
			}
			let fetchParams = {
				method: 'PATCH',
				headers: headerParams,
				body: JSON.stringify(params.operations),

			};

			if (extraFetchParams) {
				fetchParams = assign(fetchParams, extraFetchParams);
			}

			let localVarPathWithQueryParameters = localVarPath + (localVarPath.indexOf('?') !== -1 ? '&' : '?') + querystring.stringify(queryParameters);

			return fetch(localVarPathWithQueryParameters, fetchParams).then((response) => {
				if (response.status >= 200 && response.status < 300) {
					return response.json();
				} else {
					let error = new Error(response.statusText);
					(error as any).response = response;
					throw error;
				}
			});
		}
		/**
		 *
		 * Replace Campaign Type
		 * @param id
		 * @param campaignType
		 */
		public marketingCampaignsTypesIdPut (params: {  id: number; campaignType: CampaignType; }, extraQueryParams?: any, extraFetchParams?: any ) : Promise<CampaignType> {
			const localVarPath = this.basePath + '/marketing/campaigns/types/{id}'
				.replace('{' + 'id' + '}', String(params.id));

			let queryParameters: any = assign({}, extraQueryParams);
			let headerParams: any = assign({}, this.defaultHeaders);
			headerParams['Content-Type'] = 'application/json';

			// verify required parameter 'id' is set
			if (params.id == null) {
				throw new Error('Missing required parameter id when calling marketingCampaignsTypesIdPut');
			}
			// verify required parameter 'campaignType' is set
			if (params.campaignType == null) {
				throw new Error('Missing required parameter campaignType when calling marketingCampaignsTypesIdPut');
			}
			let fetchParams = {
				method: 'PUT',
				headers: headerParams,
				body: JSON.stringify(params.campaignType),

			};

			if (extraFetchParams) {
				fetchParams = assign(fetchParams, extraFetchParams);
			}

			let localVarPathWithQueryParameters = localVarPath + (localVarPath.indexOf('?') !== -1 ? '&' : '?') + querystring.stringify(queryParameters);

			return fetch(localVarPathWithQueryParameters, fetchParams).then((response) => {
				if (response.status >= 200 && response.status < 300) {
					return response.json();
				} else {
					let error = new Error(response.statusText);
					(error as any).response = response;
					throw error;
				}
			});
		}
		/**
		 *
		 * Create Campaign Type
		 * @param campaignType
		 */
		public marketingCampaignsTypesPost (params: {  campaignType: CampaignType; }, extraQueryParams?: any, extraFetchParams?: any ) : Promise<CampaignType> {
			const localVarPath = this.basePath + '/marketing/campaigns/types';

			let queryParameters: any = assign({}, extraQueryParams);
			let headerParams: any = assign({}, this.defaultHeaders);
			headerParams['Content-Type'] = 'application/json';

			// verify required parameter 'campaignType' is set
			if (params.campaignType == null) {
				throw new Error('Missing required parameter campaignType when calling marketingCampaignsTypesPost');
			}
			let fetchParams = {
				method: 'POST',
				headers: headerParams,
				body: JSON.stringify(params.campaignType),

			};

			if (extraFetchParams) {
				fetchParams = assign(fetchParams, extraFetchParams);
			}

			let localVarPathWithQueryParameters = localVarPath + (localVarPath.indexOf('?') !== -1 ? '&' : '?') + querystring.stringify(queryParameters);

			return fetch(localVarPathWithQueryParameters, fetchParams).then((response) => {
				if (response.status >= 200 && response.status < 300) {
					return response.json();
				} else {
					let error = new Error(response.statusText);
					(error as any).response = response;
					throw error;
				}
			});
		}
	}
//}
//export namespace  {
	'use strict';

	export class CampaignsApi {
		protected basePath = 'https://api-na.myconnectwise.net/v4_6_release/apis/3.0';
		public defaultHeaders : any = {};

		constructor(basePath?: string) {
			if (basePath) {
				this.basePath = basePath;
			}
		}

		/**
		 *
		 * Get Campaigns Count
		 * @param conditions
		 */
		public marketingCampaignsCountGet (params: {  conditions?: string; }, extraQueryParams?: any, extraFetchParams?: any ) : Promise<Count> {
			const localVarPath = this.basePath + '/marketing/campaigns/count';

			let queryParameters: any = assign({}, extraQueryParams);
			let headerParams: any = assign({}, this.defaultHeaders);
			if (params.conditions !== undefined) {
				queryParameters['conditions'] = params.conditions;
			}

			let fetchParams = {
				method: 'GET',
				headers: headerParams,

			};

			if (extraFetchParams) {
				fetchParams = assign(fetchParams, extraFetchParams);
			}

			let localVarPathWithQueryParameters = localVarPath + (localVarPath.indexOf('?') !== -1 ? '&' : '?') + querystring.stringify(queryParameters);

			return fetch(localVarPathWithQueryParameters, fetchParams).then((response) => {
				if (response.status >= 200 && response.status < 300) {
					return response.json();
				} else {
					let error = new Error(response.statusText);
					(error as any).response = response;
					throw error;
				}
			});
		}
		/**
		 *
		 * Get Campaigns
		 * @param conditions
		 * @param orderBy
		 * @param childconditions
		 * @param customfieldconditions
		 * @param page
		 * @param pageSize
		 */
		public marketingCampaignsGet (params: {  conditions?: string; orderBy?: string; childconditions?: string; customfieldconditions?: string; page?: number; pageSize?: number; }, extraQueryParams?: any, extraFetchParams?: any ) : Promise<Array<Campaign>> {
			const localVarPath = this.basePath + '/marketing/campaigns';

			let queryParameters: any = assign({}, extraQueryParams);
			let headerParams: any = assign({}, this.defaultHeaders);
			if (params.conditions !== undefined) {
				queryParameters['conditions'] = params.conditions;
			}

			if (params.orderBy !== undefined) {
				queryParameters['orderBy'] = params.orderBy;
			}

			if (params.childconditions !== undefined) {
				queryParameters['childconditions'] = params.childconditions;
			}

			if (params.customfieldconditions !== undefined) {
				queryParameters['customfieldconditions'] = params.customfieldconditions;
			}

			if (params.page !== undefined) {
				queryParameters['page'] = params.page;
			}

			if (params.pageSize !== undefined) {
				queryParameters['pageSize'] = params.pageSize;
			}

			let fetchParams = {
				method: 'GET',
				headers: headerParams,

			};

			if (extraFetchParams) {
				fetchParams = assign(fetchParams, extraFetchParams);
			}

			let localVarPathWithQueryParameters = localVarPath + (localVarPath.indexOf('?') !== -1 ? '&' : '?') + querystring.stringify(queryParameters);

			return fetch(localVarPathWithQueryParameters, fetchParams).then((response) => {
				if (response.status >= 200 && response.status < 300) {
					return response.json();
				} else {
					let error = new Error(response.statusText);
					(error as any).response = response;
					throw error;
				}
			});
		}
		/**
		 *
		 * Get Campaign Activities Count
		 * @param id
		 */
		public marketingCampaignsIdActivitiesCountGet (params: {  id: number; }, extraQueryParams?: any, extraFetchParams?: any ) : Promise<Count> {
			const localVarPath = this.basePath + '/marketing/campaigns/{id}/activities/count'
				.replace('{' + 'id' + '}', String(params.id));

			let queryParameters: any = assign({}, extraQueryParams);
			let headerParams: any = assign({}, this.defaultHeaders);
			// verify required parameter 'id' is set
			if (params.id == null) {
				throw new Error('Missing required parameter id when calling marketingCampaignsIdActivitiesCountGet');
			}
			let fetchParams = {
				method: 'GET',
				headers: headerParams,

			};

			if (extraFetchParams) {
				fetchParams = assign(fetchParams, extraFetchParams);
			}

			let localVarPathWithQueryParameters = localVarPath + (localVarPath.indexOf('?') !== -1 ? '&' : '?') + querystring.stringify(queryParameters);

			return fetch(localVarPathWithQueryParameters, fetchParams).then((response) => {
				if (response.status >= 200 && response.status < 300) {
					return response.json();
				} else {
					let error = new Error(response.statusText);
					(error as any).response = response;
					throw error;
				}
			});
		}
		/**
		 *
		 * Get Campaign Activities
		 * @param id
		 * @param page
		 * @param pageSize
		 */
		public marketingCampaignsIdActivitiesGet (params: {  id: number; page?: number; pageSize?: number; }, extraQueryParams?: any, extraFetchParams?: any ) : Promise<Array<ActivityReference>> {
			const localVarPath = this.basePath + '/marketing/campaigns/{id}/activities'
				.replace('{' + 'id' + '}', String(params.id));

			let queryParameters: any = assign({}, extraQueryParams);
			let headerParams: any = assign({}, this.defaultHeaders);
			// verify required parameter 'id' is set
			if (params.id == null) {
				throw new Error('Missing required parameter id when calling marketingCampaignsIdActivitiesGet');
			}
			if (params.page !== undefined) {
				queryParameters['page'] = params.page;
			}

			if (params.pageSize !== undefined) {
				queryParameters['pageSize'] = params.pageSize;
			}

			let fetchParams = {
				method: 'GET',
				headers: headerParams,

			};

			if (extraFetchParams) {
				fetchParams = assign(fetchParams, extraFetchParams);
			}

			let localVarPathWithQueryParameters = localVarPath + (localVarPath.indexOf('?') !== -1 ? '&' : '?') + querystring.stringify(queryParameters);

			return fetch(localVarPathWithQueryParameters, fetchParams).then((response) => {
				if (response.status >= 200 && response.status < 300) {
					return response.json();
				} else {
					let error = new Error(response.statusText);
					(error as any).response = response;
					throw error;
				}
			});
		}
		/**
		 *
		 * Delete Campaign By Id
		 * @param id
		 */
		public marketingCampaignsIdDelete (params: {  id: number; }, extraQueryParams?: any, extraFetchParams?: any ) : Promise<{}> {
			const localVarPath = this.basePath + '/marketing/campaigns/{id}'
				.replace('{' + 'id' + '}', String(params.id));

			let queryParameters: any = assign({}, extraQueryParams);
			let headerParams: any = assign({}, this.defaultHeaders);
			// verify required parameter 'id' is set
			if (params.id == null) {
				throw new Error('Missing required parameter id when calling marketingCampaignsIdDelete');
			}
			let fetchParams = {
				method: 'DELETE',
				headers: headerParams,

			};

			if (extraFetchParams) {
				fetchParams = assign(fetchParams, extraFetchParams);
			}

			let localVarPathWithQueryParameters = localVarPath + (localVarPath.indexOf('?') !== -1 ? '&' : '?') + querystring.stringify(queryParameters);

			return fetch(localVarPathWithQueryParameters, fetchParams).then((response) => {
				if (response.status >= 200 && response.status < 300) {
					return response.json();
				} else {
					let error = new Error(response.statusText);
					(error as any).response = response;
					throw error;
				}
			});
		}
		/**
		 *
		 * Get Campaign By Id
		 * @param id
		 */
		public marketingCampaignsIdGet (params: {  id: number; }, extraQueryParams?: any, extraFetchParams?: any ) : Promise<Campaign> {
			const localVarPath = this.basePath + '/marketing/campaigns/{id}'
				.replace('{' + 'id' + '}', String(params.id));

			let queryParameters: any = assign({}, extraQueryParams);
			let headerParams: any = assign({}, this.defaultHeaders);
			// verify required parameter 'id' is set
			if (params.id == null) {
				throw new Error('Missing required parameter id when calling marketingCampaignsIdGet');
			}
			let fetchParams = {
				method: 'GET',
				headers: headerParams,

			};

			if (extraFetchParams) {
				fetchParams = assign(fetchParams, extraFetchParams);
			}

			let localVarPathWithQueryParameters = localVarPath + (localVarPath.indexOf('?') !== -1 ? '&' : '?') + querystring.stringify(queryParameters);

			return fetch(localVarPathWithQueryParameters, fetchParams).then((response) => {
				if (response.status >= 200 && response.status < 300) {
					return response.json();
				} else {
					let error = new Error(response.statusText);
					(error as any).response = response;
					throw error;
				}
			});
		}
		/**
		 *
		 * Get Campaign Opportunities Count
		 * @param id
		 */
		public marketingCampaignsIdOpportunitiesCountGet (params: {  id: number; }, extraQueryParams?: any, extraFetchParams?: any ) : Promise<Count> {
			const localVarPath = this.basePath + '/marketing/campaigns/{id}/opportunities/count'
				.replace('{' + 'id' + '}', String(params.id));

			let queryParameters: any = assign({}, extraQueryParams);
			let headerParams: any = assign({}, this.defaultHeaders);
			// verify required parameter 'id' is set
			if (params.id == null) {
				throw new Error('Missing required parameter id when calling marketingCampaignsIdOpportunitiesCountGet');
			}
			let fetchParams = {
				method: 'GET',
				headers: headerParams,

			};

			if (extraFetchParams) {
				fetchParams = assign(fetchParams, extraFetchParams);
			}

			let localVarPathWithQueryParameters = localVarPath + (localVarPath.indexOf('?') !== -1 ? '&' : '?') + querystring.stringify(queryParameters);

			return fetch(localVarPathWithQueryParameters, fetchParams).then((response) => {
				if (response.status >= 200 && response.status < 300) {
					return response.json();
				} else {
					let error = new Error(response.statusText);
					(error as any).response = response;
					throw error;
				}
			});
		}
		/**
		 *
		 * Get Campaign Opportunities
		 * @param id
		 * @param page
		 * @param pageSize
		 */
		public marketingCampaignsIdOpportunitiesGet (params: {  id: number; page?: number; pageSize?: number; }, extraQueryParams?: any, extraFetchParams?: any ) : Promise<Array<OpportunityReference>> {
			const localVarPath = this.basePath + '/marketing/campaigns/{id}/opportunities'
				.replace('{' + 'id' + '}', String(params.id));

			let queryParameters: any = assign({}, extraQueryParams);
			let headerParams: any = assign({}, this.defaultHeaders);
			// verify required parameter 'id' is set
			if (params.id == null) {
				throw new Error('Missing required parameter id when calling marketingCampaignsIdOpportunitiesGet');
			}
			if (params.page !== undefined) {
				queryParameters['page'] = params.page;
			}

			if (params.pageSize !== undefined) {
				queryParameters['pageSize'] = params.pageSize;
			}

			let fetchParams = {
				method: 'GET',
				headers: headerParams,

			};

			if (extraFetchParams) {
				fetchParams = assign(fetchParams, extraFetchParams);
			}

			let localVarPathWithQueryParameters = localVarPath + (localVarPath.indexOf('?') !== -1 ? '&' : '?') + querystring.stringify(queryParameters);

			return fetch(localVarPathWithQueryParameters, fetchParams).then((response) => {
				if (response.status >= 200 && response.status < 300) {
					return response.json();
				} else {
					let error = new Error(response.statusText);
					(error as any).response = response;
					throw error;
				}
			});
		}
		/**
		 *
		 * Update Campaign
		 * @param id
		 * @param operations
		 */
		public marketingCampaignsIdPatch (params: {  id: number; operations: Array<PatchOperation>; }, extraQueryParams?: any, extraFetchParams?: any ) : Promise<Campaign> {
			const localVarPath = this.basePath + '/marketing/campaigns/{id}'
				.replace('{' + 'id' + '}', String(params.id));

			let queryParameters: any = assign({}, extraQueryParams);
			let headerParams: any = assign({}, this.defaultHeaders);
			headerParams['Content-Type'] = 'application/json';

			// verify required parameter 'id' is set
			if (params.id == null) {
				throw new Error('Missing required parameter id when calling marketingCampaignsIdPatch');
			}
			// verify required parameter 'operations' is set
			if (params.operations == null) {
				throw new Error('Missing required parameter operations when calling marketingCampaignsIdPatch');
			}
			let fetchParams = {
				method: 'PATCH',
				headers: headerParams,
				body: JSON.stringify(params.operations),

			};

			if (extraFetchParams) {
				fetchParams = assign(fetchParams, extraFetchParams);
			}

			let localVarPathWithQueryParameters = localVarPath + (localVarPath.indexOf('?') !== -1 ? '&' : '?') + querystring.stringify(queryParameters);

			return fetch(localVarPathWithQueryParameters, fetchParams).then((response) => {
				if (response.status >= 200 && response.status < 300) {
					return response.json();
				} else {
					let error = new Error(response.statusText);
					(error as any).response = response;
					throw error;
				}
			});
		}
		/**
		 *
		 * Replace Campaign
		 * @param id
		 * @param campaign
		 */
		public marketingCampaignsIdPut (params: {  id: number; campaign: Campaign; }, extraQueryParams?: any, extraFetchParams?: any ) : Promise<Campaign> {
			const localVarPath = this.basePath + '/marketing/campaigns/{id}'
				.replace('{' + 'id' + '}', String(params.id));

			let queryParameters: any = assign({}, extraQueryParams);
			let headerParams: any = assign({}, this.defaultHeaders);
			headerParams['Content-Type'] = 'application/json';

			// verify required parameter 'id' is set
			if (params.id == null) {
				throw new Error('Missing required parameter id when calling marketingCampaignsIdPut');
			}
			// verify required parameter 'campaign' is set
			if (params.campaign == null) {
				throw new Error('Missing required parameter campaign when calling marketingCampaignsIdPut');
			}
			let fetchParams = {
				method: 'PUT',
				headers: headerParams,
				body: JSON.stringify(params.campaign),

			};

			if (extraFetchParams) {
				fetchParams = assign(fetchParams, extraFetchParams);
			}

			let localVarPathWithQueryParameters = localVarPath + (localVarPath.indexOf('?') !== -1 ? '&' : '?') + querystring.stringify(queryParameters);

			return fetch(localVarPathWithQueryParameters, fetchParams).then((response) => {
				if (response.status >= 200 && response.status < 300) {
					return response.json();
				} else {
					let error = new Error(response.statusText);
					(error as any).response = response;
					throw error;
				}
			});
		}
		/**
		 *
		 * Create Campaign
		 * @param campaign
		 */
		public marketingCampaignsPost (params: {  campaign: Campaign; }, extraQueryParams?: any, extraFetchParams?: any ) : Promise<Campaign> {
			const localVarPath = this.basePath + '/marketing/campaigns';

			let queryParameters: any = assign({}, extraQueryParams);
			let headerParams: any = assign({}, this.defaultHeaders);
			headerParams['Content-Type'] = 'application/json';

			// verify required parameter 'campaign' is set
			if (params.campaign == null) {
				throw new Error('Missing required parameter campaign when calling marketingCampaignsPost');
			}
			let fetchParams = {
				method: 'POST',
				headers: headerParams,
				body: JSON.stringify(params.campaign),

			};

			if (extraFetchParams) {
				fetchParams = assign(fetchParams, extraFetchParams);
			}

			let localVarPathWithQueryParameters = localVarPath + (localVarPath.indexOf('?') !== -1 ? '&' : '?') + querystring.stringify(queryParameters);

			return fetch(localVarPathWithQueryParameters, fetchParams).then((response) => {
				if (response.status >= 200 && response.status < 300) {
					return response.json();
				} else {
					let error = new Error(response.statusText);
					(error as any).response = response;
					throw error;
				}
			});
		}
	}
//}
//export namespace  {
	'use strict';

	export class CatalogComponentsApi {
		protected basePath = 'https://api-na.myconnectwise.net/v4_6_release/apis/3.0';
		public defaultHeaders : any = {};

		constructor(basePath?: string) {
			if (basePath) {
				this.basePath = basePath;
			}
		}

		/**
		 *
		 * Delete Catalog Component By Id
		 * @param id
		 * @param componentId
		 */
		public procurementCatalogIdComponentsComponentIdDelete (params: {  id: number; componentId: number; }, extraQueryParams?: any, extraFetchParams?: any ) : Promise<{}> {
			const localVarPath = this.basePath + '/procurement/catalog/{id}/components/{componentId}'
				.replace('{' + 'id' + '}', String(params.id))
				.replace('{' + 'componentId' + '}', String(params.componentId));

			let queryParameters: any = assign({}, extraQueryParams);
			let headerParams: any = assign({}, this.defaultHeaders);
			// verify required parameter 'id' is set
			if (params.id == null) {
				throw new Error('Missing required parameter id when calling procurementCatalogIdComponentsComponentIdDelete');
			}
			// verify required parameter 'componentId' is set
			if (params.componentId == null) {
				throw new Error('Missing required parameter componentId when calling procurementCatalogIdComponentsComponentIdDelete');
			}
			let fetchParams = {
				method: 'DELETE',
				headers: headerParams,

			};

			if (extraFetchParams) {
				fetchParams = assign(fetchParams, extraFetchParams);
			}

			let localVarPathWithQueryParameters = localVarPath + (localVarPath.indexOf('?') !== -1 ? '&' : '?') + querystring.stringify(queryParameters);

			return fetch(localVarPathWithQueryParameters, fetchParams).then((response) => {
				if (response.status >= 200 && response.status < 300) {
					return response.json();
				} else {
					let error = new Error(response.statusText);
					(error as any).response = response;
					throw error;
				}
			});
		}
		/**
		 *
		 * Get Catalog Component By Id
		 * @param id
		 * @param componentId
		 */
		public procurementCatalogIdComponentsComponentIdGet (params: {  id: number; componentId: number; }, extraQueryParams?: any, extraFetchParams?: any ) : Promise<CatalogComponent> {
			const localVarPath = this.basePath + '/procurement/catalog/{id}/components/{componentId}'
				.replace('{' + 'id' + '}', String(params.id))
				.replace('{' + 'componentId' + '}', String(params.componentId));

			let queryParameters: any = assign({}, extraQueryParams);
			let headerParams: any = assign({}, this.defaultHeaders);
			// verify required parameter 'id' is set
			if (params.id == null) {
				throw new Error('Missing required parameter id when calling procurementCatalogIdComponentsComponentIdGet');
			}
			// verify required parameter 'componentId' is set
			if (params.componentId == null) {
				throw new Error('Missing required parameter componentId when calling procurementCatalogIdComponentsComponentIdGet');
			}
			let fetchParams = {
				method: 'GET',
				headers: headerParams,

			};

			if (extraFetchParams) {
				fetchParams = assign(fetchParams, extraFetchParams);
			}

			let localVarPathWithQueryParameters = localVarPath + (localVarPath.indexOf('?') !== -1 ? '&' : '?') + querystring.stringify(queryParameters);

			return fetch(localVarPathWithQueryParameters, fetchParams).then((response) => {
				if (response.status >= 200 && response.status < 300) {
					return response.json();
				} else {
					let error = new Error(response.statusText);
					(error as any).response = response;
					throw error;
				}
			});
		}
		/**
		 *
		 * Update Catalog Component
		 * @param id
		 * @param componentId
		 * @param operations
		 */
		public procurementCatalogIdComponentsComponentIdPatch (params: {  id: number; componentId: number; operations: Array<PatchOperation>; }, extraQueryParams?: any, extraFetchParams?: any ) : Promise<CatalogComponent> {
			const localVarPath = this.basePath + '/procurement/catalog/{id}/components/{componentId}'
				.replace('{' + 'id' + '}', String(params.id))
				.replace('{' + 'componentId' + '}', String(params.componentId));

			let queryParameters: any = assign({}, extraQueryParams);
			let headerParams: any = assign({}, this.defaultHeaders);
			headerParams['Content-Type'] = 'application/json';

			// verify required parameter 'id' is set
			if (params.id == null) {
				throw new Error('Missing required parameter id when calling procurementCatalogIdComponentsComponentIdPatch');
			}
			// verify required parameter 'componentId' is set
			if (params.componentId == null) {
				throw new Error('Missing required parameter componentId when calling procurementCatalogIdComponentsComponentIdPatch');
			}
			// verify required parameter 'operations' is set
			if (params.operations == null) {
				throw new Error('Missing required parameter operations when calling procurementCatalogIdComponentsComponentIdPatch');
			}
			let fetchParams = {
				method: 'PATCH',
				headers: headerParams,
				body: JSON.stringify(params.operations),

			};

			if (extraFetchParams) {
				fetchParams = assign(fetchParams, extraFetchParams);
			}

			let localVarPathWithQueryParameters = localVarPath + (localVarPath.indexOf('?') !== -1 ? '&' : '?') + querystring.stringify(queryParameters);

			return fetch(localVarPathWithQueryParameters, fetchParams).then((response) => {
				if (response.status >= 200 && response.status < 300) {
					return response.json();
				} else {
					let error = new Error(response.statusText);
					(error as any).response = response;
					throw error;
				}
			});
		}
		/**
		 *
		 * Replace Catalog Component
		 * @param id
		 * @param componentId
		 * @param catalogComponent
		 */
		public procurementCatalogIdComponentsComponentIdPut (params: {  id: number; componentId: number; catalogComponent: CatalogComponent; }, extraQueryParams?: any, extraFetchParams?: any ) : Promise<CatalogComponent> {
			const localVarPath = this.basePath + '/procurement/catalog/{id}/components/{componentId}'
				.replace('{' + 'id' + '}', String(params.id))
				.replace('{' + 'componentId' + '}', String(params.componentId));

			let queryParameters: any = assign({}, extraQueryParams);
			let headerParams: any = assign({}, this.defaultHeaders);
			headerParams['Content-Type'] = 'application/json';

			// verify required parameter 'id' is set
			if (params.id == null) {
				throw new Error('Missing required parameter id when calling procurementCatalogIdComponentsComponentIdPut');
			}
			// verify required parameter 'componentId' is set
			if (params.componentId == null) {
				throw new Error('Missing required parameter componentId when calling procurementCatalogIdComponentsComponentIdPut');
			}
			// verify required parameter 'catalogComponent' is set
			if (params.catalogComponent == null) {
				throw new Error('Missing required parameter catalogComponent when calling procurementCatalogIdComponentsComponentIdPut');
			}
			let fetchParams = {
				method: 'PUT',
				headers: headerParams,
				body: JSON.stringify(params.catalogComponent),

			};

			if (extraFetchParams) {
				fetchParams = assign(fetchParams, extraFetchParams);
			}

			let localVarPathWithQueryParameters = localVarPath + (localVarPath.indexOf('?') !== -1 ? '&' : '?') + querystring.stringify(queryParameters);

			return fetch(localVarPathWithQueryParameters, fetchParams).then((response) => {
				if (response.status >= 200 && response.status < 300) {
					return response.json();
				} else {
					let error = new Error(response.statusText);
					(error as any).response = response;
					throw error;
				}
			});
		}
		/**
		 *
		 * Get Catalog Components Count
		 * @param id
		 * @param conditions
		 */
		public procurementCatalogIdComponentsCountGet (params: {  id: number; conditions?: string; }, extraQueryParams?: any, extraFetchParams?: any ) : Promise<Count> {
			const localVarPath = this.basePath + '/procurement/catalog/{id}/components/count'
				.replace('{' + 'id' + '}', String(params.id));

			let queryParameters: any = assign({}, extraQueryParams);
			let headerParams: any = assign({}, this.defaultHeaders);
			// verify required parameter 'id' is set
			if (params.id == null) {
				throw new Error('Missing required parameter id when calling procurementCatalogIdComponentsCountGet');
			}
			if (params.conditions !== undefined) {
				queryParameters['conditions'] = params.conditions;
			}

			let fetchParams = {
				method: 'GET',
				headers: headerParams,

			};

			if (extraFetchParams) {
				fetchParams = assign(fetchParams, extraFetchParams);
			}

			let localVarPathWithQueryParameters = localVarPath + (localVarPath.indexOf('?') !== -1 ? '&' : '?') + querystring.stringify(queryParameters);

			return fetch(localVarPathWithQueryParameters, fetchParams).then((response) => {
				if (response.status >= 200 && response.status < 300) {
					return response.json();
				} else {
					let error = new Error(response.statusText);
					(error as any).response = response;
					throw error;
				}
			});
		}
		/**
		 *
		 * Get Catalog Components
		 * @param id
		 * @param conditions
		 * @param orderBy
		 * @param childconditions
		 * @param customfieldconditions
		 * @param page
		 * @param pageSize
		 */
		public procurementCatalogIdComponentsGet (params: {  id: number; conditions?: string; orderBy?: string; childconditions?: string; customfieldconditions?: string; page?: number; pageSize?: number; }, extraQueryParams?: any, extraFetchParams?: any ) : Promise<Array<CatalogComponent>> {
			const localVarPath = this.basePath + '/procurement/catalog/{id}/components'
				.replace('{' + 'id' + '}', String(params.id));

			let queryParameters: any = assign({}, extraQueryParams);
			let headerParams: any = assign({}, this.defaultHeaders);
			// verify required parameter 'id' is set
			if (params.id == null) {
				throw new Error('Missing required parameter id when calling procurementCatalogIdComponentsGet');
			}
			if (params.conditions !== undefined) {
				queryParameters['conditions'] = params.conditions;
			}

			if (params.orderBy !== undefined) {
				queryParameters['orderBy'] = params.orderBy;
			}

			if (params.childconditions !== undefined) {
				queryParameters['childconditions'] = params.childconditions;
			}

			if (params.customfieldconditions !== undefined) {
				queryParameters['customfieldconditions'] = params.customfieldconditions;
			}

			if (params.page !== undefined) {
				queryParameters['page'] = params.page;
			}

			if (params.pageSize !== undefined) {
				queryParameters['pageSize'] = params.pageSize;
			}

			let fetchParams = {
				method: 'GET',
				headers: headerParams,

			};

			if (extraFetchParams) {
				fetchParams = assign(fetchParams, extraFetchParams);
			}

			let localVarPathWithQueryParameters = localVarPath + (localVarPath.indexOf('?') !== -1 ? '&' : '?') + querystring.stringify(queryParameters);

			return fetch(localVarPathWithQueryParameters, fetchParams).then((response) => {
				if (response.status >= 200 && response.status < 300) {
					return response.json();
				} else {
					let error = new Error(response.statusText);
					(error as any).response = response;
					throw error;
				}
			});
		}
		/**
		 *
		 * Create Catalog Component
		 * @param id
		 * @param catalogComponent
		 */
		public procurementCatalogIdComponentsPost (params: {  id: number; catalogComponent: CatalogComponent; }, extraQueryParams?: any, extraFetchParams?: any ) : Promise<CatalogComponent> {
			const localVarPath = this.basePath + '/procurement/catalog/{id}/components'
				.replace('{' + 'id' + '}', String(params.id));

			let queryParameters: any = assign({}, extraQueryParams);
			let headerParams: any = assign({}, this.defaultHeaders);
			headerParams['Content-Type'] = 'application/json';

			// verify required parameter 'id' is set
			if (params.id == null) {
				throw new Error('Missing required parameter id when calling procurementCatalogIdComponentsPost');
			}
			// verify required parameter 'catalogComponent' is set
			if (params.catalogComponent == null) {
				throw new Error('Missing required parameter catalogComponent when calling procurementCatalogIdComponentsPost');
			}
			let fetchParams = {
				method: 'POST',
				headers: headerParams,
				body: JSON.stringify(params.catalogComponent),

			};

			if (extraFetchParams) {
				fetchParams = assign(fetchParams, extraFetchParams);
			}

			let localVarPathWithQueryParameters = localVarPath + (localVarPath.indexOf('?') !== -1 ? '&' : '?') + querystring.stringify(queryParameters);

			return fetch(localVarPathWithQueryParameters, fetchParams).then((response) => {
				if (response.status >= 200 && response.status < 300) {
					return response.json();
				} else {
					let error = new Error(response.statusText);
					(error as any).response = response;
					throw error;
				}
			});
		}
	}
//}
//export namespace  {
	'use strict';

	export class CatalogsItemApi {
		protected basePath = 'https://api-na.myconnectwise.net/v4_6_release/apis/3.0';
		public defaultHeaders : any = {};

		constructor(basePath?: string) {
			if (basePath) {
				this.basePath = basePath;
			}
		}

		/**
		 *
		 * Get Inventory Quantity On Hand
		 * @param catalogItemIdentifier
		 * @param warehouseBinId
		 */
		public procurementCatalogCatalogItemIdentifierQuantityOnHandGet (params: {  catalogItemIdentifier: string; warehouseBinId?: number; }, extraQueryParams?: any, extraFetchParams?: any ) : Promise<Count> {
			const localVarPath = this.basePath + '/procurement/catalog/{catalogItemIdentifier}/quantityOnHand'
				.replace('{' + 'catalogItemIdentifier' + '}', String(params.catalogItemIdentifier));

			let queryParameters: any = assign({}, extraQueryParams);
			let headerParams: any = assign({}, this.defaultHeaders);
			// verify required parameter 'catalogItemIdentifier' is set
			if (params.catalogItemIdentifier == null) {
				throw new Error('Missing required parameter catalogItemIdentifier when calling procurementCatalogCatalogItemIdentifierQuantityOnHandGet');
			}
			if (params.warehouseBinId !== undefined) {
				queryParameters['warehouseBinId'] = params.warehouseBinId;
			}

			let fetchParams = {
				method: 'GET',
				headers: headerParams,

			};

			if (extraFetchParams) {
				fetchParams = assign(fetchParams, extraFetchParams);
			}

			let localVarPathWithQueryParameters = localVarPath + (localVarPath.indexOf('?') !== -1 ? '&' : '?') + querystring.stringify(queryParameters);

			return fetch(localVarPathWithQueryParameters, fetchParams).then((response) => {
				if (response.status >= 200 && response.status < 300) {
					return response.json();
				} else {
					let error = new Error(response.statusText);
					(error as any).response = response;
					throw error;
				}
			});
		}
		/**
		 *
		 * Get Catalogs Count
		 * @param conditions
		 */
		public procurementCatalogCountGet (params: {  conditions?: string; }, extraQueryParams?: any, extraFetchParams?: any ) : Promise<Count> {
			const localVarPath = this.basePath + '/procurement/catalog/count';

			let queryParameters: any = assign({}, extraQueryParams);
			let headerParams: any = assign({}, this.defaultHeaders);
			if (params.conditions !== undefined) {
				queryParameters['conditions'] = params.conditions;
			}

			let fetchParams = {
				method: 'GET',
				headers: headerParams,

			};

			if (extraFetchParams) {
				fetchParams = assign(fetchParams, extraFetchParams);
			}

			let localVarPathWithQueryParameters = localVarPath + (localVarPath.indexOf('?') !== -1 ? '&' : '?') + querystring.stringify(queryParameters);

			return fetch(localVarPathWithQueryParameters, fetchParams).then((response) => {
				if (response.status >= 200 && response.status < 300) {
					return response.json();
				} else {
					let error = new Error(response.statusText);
					(error as any).response = response;
					throw error;
				}
			});
		}
		/**
		 *
		 * Get Catalogs
		 * @param conditions
		 * @param orderBy
		 * @param childconditions
		 * @param customfieldconditions
		 * @param page
		 * @param pageSize
		 */
		public procurementCatalogGet (params: {  conditions?: string; orderBy?: string; childconditions?: string; customfieldconditions?: string; page?: number; pageSize?: number; }, extraQueryParams?: any, extraFetchParams?: any ) : Promise<Array<CatalogItem>> {
			const localVarPath = this.basePath + '/procurement/catalog';

			let queryParameters: any = assign({}, extraQueryParams);
			let headerParams: any = assign({}, this.defaultHeaders);
			if (params.conditions !== undefined) {
				queryParameters['conditions'] = params.conditions;
			}

			if (params.orderBy !== undefined) {
				queryParameters['orderBy'] = params.orderBy;
			}

			if (params.childconditions !== undefined) {
				queryParameters['childconditions'] = params.childconditions;
			}

			if (params.customfieldconditions !== undefined) {
				queryParameters['customfieldconditions'] = params.customfieldconditions;
			}

			if (params.page !== undefined) {
				queryParameters['page'] = params.page;
			}

			if (params.pageSize !== undefined) {
				queryParameters['pageSize'] = params.pageSize;
			}

			let fetchParams = {
				method: 'GET',
				headers: headerParams,

			};

			if (extraFetchParams) {
				fetchParams = assign(fetchParams, extraFetchParams);
			}

			let localVarPathWithQueryParameters = localVarPath + (localVarPath.indexOf('?') !== -1 ? '&' : '?') + querystring.stringify(queryParameters);

			return fetch(localVarPathWithQueryParameters, fetchParams).then((response) => {
				if (response.status >= 200 && response.status < 300) {
					return response.json();
				} else {
					let error = new Error(response.statusText);
					(error as any).response = response;
					throw error;
				}
			});
		}
		/**
		 *
		 * Delete Catalog By Id
		 * @param id
		 */
		public procurementCatalogIdDelete (params: {  id: number; }, extraQueryParams?: any, extraFetchParams?: any ) : Promise<{}> {
			const localVarPath = this.basePath + '/procurement/catalog/{id}'
				.replace('{' + 'id' + '}', String(params.id));

			let queryParameters: any = assign({}, extraQueryParams);
			let headerParams: any = assign({}, this.defaultHeaders);
			// verify required parameter 'id' is set
			if (params.id == null) {
				throw new Error('Missing required parameter id when calling procurementCatalogIdDelete');
			}
			let fetchParams = {
				method: 'DELETE',
				headers: headerParams,

			};

			if (extraFetchParams) {
				fetchParams = assign(fetchParams, extraFetchParams);
			}

			let localVarPathWithQueryParameters = localVarPath + (localVarPath.indexOf('?') !== -1 ? '&' : '?') + querystring.stringify(queryParameters);

			return fetch(localVarPathWithQueryParameters, fetchParams).then((response) => {
				if (response.status >= 200 && response.status < 300) {
					return response.json();
				} else {
					let error = new Error(response.statusText);
					(error as any).response = response;
					throw error;
				}
			});
		}
		/**
		 *
		 * Get Catalog By Id
		 * @param id
		 */
		public procurementCatalogIdGet (params: {  id: number; }, extraQueryParams?: any, extraFetchParams?: any ) : Promise<CatalogItem> {
			const localVarPath = this.basePath + '/procurement/catalog/{id}'
				.replace('{' + 'id' + '}', String(params.id));

			let queryParameters: any = assign({}, extraQueryParams);
			let headerParams: any = assign({}, this.defaultHeaders);
			// verify required parameter 'id' is set
			if (params.id == null) {
				throw new Error('Missing required parameter id when calling procurementCatalogIdGet');
			}
			let fetchParams = {
				method: 'GET',
				headers: headerParams,

			};

			if (extraFetchParams) {
				fetchParams = assign(fetchParams, extraFetchParams);
			}

			let localVarPathWithQueryParameters = localVarPath + (localVarPath.indexOf('?') !== -1 ? '&' : '?') + querystring.stringify(queryParameters);

			return fetch(localVarPathWithQueryParameters, fetchParams).then((response) => {
				if (response.status >= 200 && response.status < 300) {
					return response.json();
				} else {
					let error = new Error(response.statusText);
					(error as any).response = response;
					throw error;
				}
			});
		}
		/**
		 *
		 * Update Catalog
		 * @param id
		 * @param operations
		 */
		public procurementCatalogIdPatch (params: {  id: number; operations: Array<PatchOperation>; }, extraQueryParams?: any, extraFetchParams?: any ) : Promise<CatalogItem> {
			const localVarPath = this.basePath + '/procurement/catalog/{id}'
				.replace('{' + 'id' + '}', String(params.id));

			let queryParameters: any = assign({}, extraQueryParams);
			let headerParams: any = assign({}, this.defaultHeaders);
			headerParams['Content-Type'] = 'application/json';

			// verify required parameter 'id' is set
			if (params.id == null) {
				throw new Error('Missing required parameter id when calling procurementCatalogIdPatch');
			}
			// verify required parameter 'operations' is set
			if (params.operations == null) {
				throw new Error('Missing required parameter operations when calling procurementCatalogIdPatch');
			}
			let fetchParams = {
				method: 'PATCH',
				headers: headerParams,
				body: JSON.stringify(params.operations),

			};

			if (extraFetchParams) {
				fetchParams = assign(fetchParams, extraFetchParams);
			}

			let localVarPathWithQueryParameters = localVarPath + (localVarPath.indexOf('?') !== -1 ? '&' : '?') + querystring.stringify(queryParameters);

			return fetch(localVarPathWithQueryParameters, fetchParams).then((response) => {
				if (response.status >= 200 && response.status < 300) {
					return response.json();
				} else {
					let error = new Error(response.statusText);
					(error as any).response = response;
					throw error;
				}
			});
		}
		/**
		 *
		 * Replace Catalog
		 * @param id
		 * @param catalogItem
		 */
		public procurementCatalogIdPut (params: {  id: number; catalogItem: CatalogItem; }, extraQueryParams?: any, extraFetchParams?: any ) : Promise<CatalogItem> {
			const localVarPath = this.basePath + '/procurement/catalog/{id}'
				.replace('{' + 'id' + '}', String(params.id));

			let queryParameters: any = assign({}, extraQueryParams);
			let headerParams: any = assign({}, this.defaultHeaders);
			headerParams['Content-Type'] = 'application/json';

			// verify required parameter 'id' is set
			if (params.id == null) {
				throw new Error('Missing required parameter id when calling procurementCatalogIdPut');
			}
			// verify required parameter 'catalogItem' is set
			if (params.catalogItem == null) {
				throw new Error('Missing required parameter catalogItem when calling procurementCatalogIdPut');
			}
			let fetchParams = {
				method: 'PUT',
				headers: headerParams,
				body: JSON.stringify(params.catalogItem),

			};

			if (extraFetchParams) {
				fetchParams = assign(fetchParams, extraFetchParams);
			}

			let localVarPathWithQueryParameters = localVarPath + (localVarPath.indexOf('?') !== -1 ? '&' : '?') + querystring.stringify(queryParameters);

			return fetch(localVarPathWithQueryParameters, fetchParams).then((response) => {
				if (response.status >= 200 && response.status < 300) {
					return response.json();
				} else {
					let error = new Error(response.statusText);
					(error as any).response = response;
					throw error;
				}
			});
		}
		/**
		 *
		 * Create Catalog
		 * @param catalogItem
		 */
		public procurementCatalogPost (params: {  catalogItem: CatalogItem; }, extraQueryParams?: any, extraFetchParams?: any ) : Promise<CatalogItem> {
			const localVarPath = this.basePath + '/procurement/catalog';

			let queryParameters: any = assign({}, extraQueryParams);
			let headerParams: any = assign({}, this.defaultHeaders);
			headerParams['Content-Type'] = 'application/json';

			// verify required parameter 'catalogItem' is set
			if (params.catalogItem == null) {
				throw new Error('Missing required parameter catalogItem when calling procurementCatalogPost');
			}
			let fetchParams = {
				method: 'POST',
				headers: headerParams,
				body: JSON.stringify(params.catalogItem),

			};

			if (extraFetchParams) {
				fetchParams = assign(fetchParams, extraFetchParams);
			}

			let localVarPathWithQueryParameters = localVarPath + (localVarPath.indexOf('?') !== -1 ? '&' : '?') + querystring.stringify(queryParameters);

			return fetch(localVarPathWithQueryParameters, fetchParams).then((response) => {
				if (response.status >= 200 && response.status < 300) {
					return response.json();
				} else {
					let error = new Error(response.statusText);
					(error as any).response = response;
					throw error;
				}
			});
		}
	}
//}
//export namespace  {
	'use strict';

	export class CategoriesApi {
		protected basePath = 'https://api-na.myconnectwise.net/v4_6_release/apis/3.0';
		public defaultHeaders : any = {};

		constructor(basePath?: string) {
			if (basePath) {
				this.basePath = basePath;
			}
		}

		/**
		 *
		 * Get Categories Count
		 * @param conditions
		 */
		public procurementCategoriesCountGet (params: {  conditions?: string; }, extraQueryParams?: any, extraFetchParams?: any ) : Promise<Count> {
			const localVarPath = this.basePath + '/procurement/categories/count';

			let queryParameters: any = assign({}, extraQueryParams);
			let headerParams: any = assign({}, this.defaultHeaders);
			if (params.conditions !== undefined) {
				queryParameters['conditions'] = params.conditions;
			}

			let fetchParams = {
				method: 'GET',
				headers: headerParams,

			};

			if (extraFetchParams) {
				fetchParams = assign(fetchParams, extraFetchParams);
			}

			let localVarPathWithQueryParameters = localVarPath + (localVarPath.indexOf('?') !== -1 ? '&' : '?') + querystring.stringify(queryParameters);

			return fetch(localVarPathWithQueryParameters, fetchParams).then((response) => {
				if (response.status >= 200 && response.status < 300) {
					return response.json();
				} else {
					let error = new Error(response.statusText);
					(error as any).response = response;
					throw error;
				}
			});
		}
		/**
		 *
		 * Get Categories
		 * @param conditions
		 * @param orderBy
		 * @param childconditions
		 * @param customfieldconditions
		 * @param page
		 * @param pageSize
		 */
		public procurementCategoriesGet (params: {  conditions?: string; orderBy?: string; childconditions?: string; customfieldconditions?: string; page?: number; pageSize?: number; }, extraQueryParams?: any, extraFetchParams?: any ) : Promise<Array<Category>> {
			const localVarPath = this.basePath + '/procurement/categories';

			let queryParameters: any = assign({}, extraQueryParams);
			let headerParams: any = assign({}, this.defaultHeaders);
			if (params.conditions !== undefined) {
				queryParameters['conditions'] = params.conditions;
			}

			if (params.orderBy !== undefined) {
				queryParameters['orderBy'] = params.orderBy;
			}

			if (params.childconditions !== undefined) {
				queryParameters['childconditions'] = params.childconditions;
			}

			if (params.customfieldconditions !== undefined) {
				queryParameters['customfieldconditions'] = params.customfieldconditions;
			}

			if (params.page !== undefined) {
				queryParameters['page'] = params.page;
			}

			if (params.pageSize !== undefined) {
				queryParameters['pageSize'] = params.pageSize;
			}

			let fetchParams = {
				method: 'GET',
				headers: headerParams,

			};

			if (extraFetchParams) {
				fetchParams = assign(fetchParams, extraFetchParams);
			}

			let localVarPathWithQueryParameters = localVarPath + (localVarPath.indexOf('?') !== -1 ? '&' : '?') + querystring.stringify(queryParameters);

			return fetch(localVarPathWithQueryParameters, fetchParams).then((response) => {
				if (response.status >= 200 && response.status < 300) {
					return response.json();
				} else {
					let error = new Error(response.statusText);
					(error as any).response = response;
					throw error;
				}
			});
		}
		/**
		 *
		 * Delete Category By Id
		 * @param id
		 */
		public procurementCategoriesIdDelete (params: {  id: number; }, extraQueryParams?: any, extraFetchParams?: any ) : Promise<{}> {
			const localVarPath = this.basePath + '/procurement/categories/{id}'
				.replace('{' + 'id' + '}', String(params.id));

			let queryParameters: any = assign({}, extraQueryParams);
			let headerParams: any = assign({}, this.defaultHeaders);
			// verify required parameter 'id' is set
			if (params.id == null) {
				throw new Error('Missing required parameter id when calling procurementCategoriesIdDelete');
			}
			let fetchParams = {
				method: 'DELETE',
				headers: headerParams,

			};

			if (extraFetchParams) {
				fetchParams = assign(fetchParams, extraFetchParams);
			}

			let localVarPathWithQueryParameters = localVarPath + (localVarPath.indexOf('?') !== -1 ? '&' : '?') + querystring.stringify(queryParameters);

			return fetch(localVarPathWithQueryParameters, fetchParams).then((response) => {
				if (response.status >= 200 && response.status < 300) {
					return response.json();
				} else {
					let error = new Error(response.statusText);
					(error as any).response = response;
					throw error;
				}
			});
		}
		/**
		 *
		 * Get Category By Id
		 * @param id
		 */
		public procurementCategoriesIdGet (params: {  id: number; }, extraQueryParams?: any, extraFetchParams?: any ) : Promise<Category> {
			const localVarPath = this.basePath + '/procurement/categories/{id}'
				.replace('{' + 'id' + '}', String(params.id));

			let queryParameters: any = assign({}, extraQueryParams);
			let headerParams: any = assign({}, this.defaultHeaders);
			// verify required parameter 'id' is set
			if (params.id == null) {
				throw new Error('Missing required parameter id when calling procurementCategoriesIdGet');
			}
			let fetchParams = {
				method: 'GET',
				headers: headerParams,

			};

			if (extraFetchParams) {
				fetchParams = assign(fetchParams, extraFetchParams);
			}

			let localVarPathWithQueryParameters = localVarPath + (localVarPath.indexOf('?') !== -1 ? '&' : '?') + querystring.stringify(queryParameters);

			return fetch(localVarPathWithQueryParameters, fetchParams).then((response) => {
				if (response.status >= 200 && response.status < 300) {
					return response.json();
				} else {
					let error = new Error(response.statusText);
					(error as any).response = response;
					throw error;
				}
			});
		}
		/**
		 *
		 * Update Category
		 * @param id
		 * @param operations
		 */
		public procurementCategoriesIdPatch (params: {  id: number; operations: Array<PatchOperation>; }, extraQueryParams?: any, extraFetchParams?: any ) : Promise<Category> {
			const localVarPath = this.basePath + '/procurement/categories/{id}'
				.replace('{' + 'id' + '}', String(params.id));

			let queryParameters: any = assign({}, extraQueryParams);
			let headerParams: any = assign({}, this.defaultHeaders);
			headerParams['Content-Type'] = 'application/json';

			// verify required parameter 'id' is set
			if (params.id == null) {
				throw new Error('Missing required parameter id when calling procurementCategoriesIdPatch');
			}
			// verify required parameter 'operations' is set
			if (params.operations == null) {
				throw new Error('Missing required parameter operations when calling procurementCategoriesIdPatch');
			}
			let fetchParams = {
				method: 'PATCH',
				headers: headerParams,
				body: JSON.stringify(params.operations),

			};

			if (extraFetchParams) {
				fetchParams = assign(fetchParams, extraFetchParams);
			}

			let localVarPathWithQueryParameters = localVarPath + (localVarPath.indexOf('?') !== -1 ? '&' : '?') + querystring.stringify(queryParameters);

			return fetch(localVarPathWithQueryParameters, fetchParams).then((response) => {
				if (response.status >= 200 && response.status < 300) {
					return response.json();
				} else {
					let error = new Error(response.statusText);
					(error as any).response = response;
					throw error;
				}
			});
		}
		/**
		 *
		 * Replace Category
		 * @param id
		 * @param category
		 */
		public procurementCategoriesIdPut (params: {  id: number; category: Category; }, extraQueryParams?: any, extraFetchParams?: any ) : Promise<Category> {
			const localVarPath = this.basePath + '/procurement/categories/{id}'
				.replace('{' + 'id' + '}', String(params.id));

			let queryParameters: any = assign({}, extraQueryParams);
			let headerParams: any = assign({}, this.defaultHeaders);
			headerParams['Content-Type'] = 'application/json';

			// verify required parameter 'id' is set
			if (params.id == null) {
				throw new Error('Missing required parameter id when calling procurementCategoriesIdPut');
			}
			// verify required parameter 'category' is set
			if (params.category == null) {
				throw new Error('Missing required parameter category when calling procurementCategoriesIdPut');
			}
			let fetchParams = {
				method: 'PUT',
				headers: headerParams,
				body: JSON.stringify(params.category),

			};

			if (extraFetchParams) {
				fetchParams = assign(fetchParams, extraFetchParams);
			}

			let localVarPathWithQueryParameters = localVarPath + (localVarPath.indexOf('?') !== -1 ? '&' : '?') + querystring.stringify(queryParameters);

			return fetch(localVarPathWithQueryParameters, fetchParams).then((response) => {
				if (response.status >= 200 && response.status < 300) {
					return response.json();
				} else {
					let error = new Error(response.statusText);
					(error as any).response = response;
					throw error;
				}
			});
		}
		/**
		 *
		 * Create Category
		 * @param category
		 */
		public procurementCategoriesPost (params: {  category: Category; }, extraQueryParams?: any, extraFetchParams?: any ) : Promise<Category> {
			const localVarPath = this.basePath + '/procurement/categories';

			let queryParameters: any = assign({}, extraQueryParams);
			let headerParams: any = assign({}, this.defaultHeaders);
			headerParams['Content-Type'] = 'application/json';

			// verify required parameter 'category' is set
			if (params.category == null) {
				throw new Error('Missing required parameter category when calling procurementCategoriesPost');
			}
			let fetchParams = {
				method: 'POST',
				headers: headerParams,
				body: JSON.stringify(params.category),

			};

			if (extraFetchParams) {
				fetchParams = assign(fetchParams, extraFetchParams);
			}

			let localVarPathWithQueryParameters = localVarPath + (localVarPath.indexOf('?') !== -1 ? '&' : '?') + querystring.stringify(queryParameters);

			return fetch(localVarPathWithQueryParameters, fetchParams).then((response) => {
				if (response.status >= 200 && response.status < 300) {
					return response.json();
				} else {
					let error = new Error(response.statusText);
					(error as any).response = response;
					throw error;
				}
			});
		}
	}
//}
//export namespace  {
	'use strict';

	export class CertificationsApi {
		protected basePath = 'https://api-na.myconnectwise.net/v4_6_release/apis/3.0';
		public defaultHeaders : any = {};

		constructor(basePath?: string) {
			if (basePath) {
				this.basePath = basePath;
			}
		}

		/**
		 *
		 * Get Certification Count
		 * @param conditions
		 */
		public systemCertificationsCountGet (params: {  conditions?: string; }, extraQueryParams?: any, extraFetchParams?: any ) : Promise<Count> {
			const localVarPath = this.basePath + '/system/certifications/count';

			let queryParameters: any = assign({}, extraQueryParams);
			let headerParams: any = assign({}, this.defaultHeaders);
			if (params.conditions !== undefined) {
				queryParameters['conditions'] = params.conditions;
			}

			let fetchParams = {
				method: 'GET',
				headers: headerParams,

			};

			if (extraFetchParams) {
				fetchParams = assign(fetchParams, extraFetchParams);
			}

			let localVarPathWithQueryParameters = localVarPath + (localVarPath.indexOf('?') !== -1 ? '&' : '?') + querystring.stringify(queryParameters);

			return fetch(localVarPathWithQueryParameters, fetchParams).then((response) => {
				if (response.status >= 200 && response.status < 300) {
					return response.json();
				} else {
					let error = new Error(response.statusText);
					(error as any).response = response;
					throw error;
				}
			});
		}
		/**
		 *
		 * Get Certification
		 * @param conditions
		 * @param orderBy
		 * @param childconditions
		 * @param customfieldconditions
		 * @param page
		 * @param pageSize
		 */
		public systemCertificationsGet (params: {  conditions?: string; orderBy?: string; childconditions?: string; customfieldconditions?: string; page?: number; pageSize?: number; }, extraQueryParams?: any, extraFetchParams?: any ) : Promise<Array<Certification>> {
			const localVarPath = this.basePath + '/system/certifications';

			let queryParameters: any = assign({}, extraQueryParams);
			let headerParams: any = assign({}, this.defaultHeaders);
			if (params.conditions !== undefined) {
				queryParameters['conditions'] = params.conditions;
			}

			if (params.orderBy !== undefined) {
				queryParameters['orderBy'] = params.orderBy;
			}

			if (params.childconditions !== undefined) {
				queryParameters['childconditions'] = params.childconditions;
			}

			if (params.customfieldconditions !== undefined) {
				queryParameters['customfieldconditions'] = params.customfieldconditions;
			}

			if (params.page !== undefined) {
				queryParameters['page'] = params.page;
			}

			if (params.pageSize !== undefined) {
				queryParameters['pageSize'] = params.pageSize;
			}

			let fetchParams = {
				method: 'GET',
				headers: headerParams,

			};

			if (extraFetchParams) {
				fetchParams = assign(fetchParams, extraFetchParams);
			}

			let localVarPathWithQueryParameters = localVarPath + (localVarPath.indexOf('?') !== -1 ? '&' : '?') + querystring.stringify(queryParameters);

			return fetch(localVarPathWithQueryParameters, fetchParams).then((response) => {
				if (response.status >= 200 && response.status < 300) {
					return response.json();
				} else {
					let error = new Error(response.statusText);
					(error as any).response = response;
					throw error;
				}
			});
		}
		/**
		 *
		 * Delete Certification By Id
		 * @param id
		 */
		public systemCertificationsIdDelete (params: {  id: number; }, extraQueryParams?: any, extraFetchParams?: any ) : Promise<{}> {
			const localVarPath = this.basePath + '/system/certifications/{id}'
				.replace('{' + 'id' + '}', String(params.id));

			let queryParameters: any = assign({}, extraQueryParams);
			let headerParams: any = assign({}, this.defaultHeaders);
			// verify required parameter 'id' is set
			if (params.id == null) {
				throw new Error('Missing required parameter id when calling systemCertificationsIdDelete');
			}
			let fetchParams = {
				method: 'DELETE',
				headers: headerParams,

			};

			if (extraFetchParams) {
				fetchParams = assign(fetchParams, extraFetchParams);
			}

			let localVarPathWithQueryParameters = localVarPath + (localVarPath.indexOf('?') !== -1 ? '&' : '?') + querystring.stringify(queryParameters);

			return fetch(localVarPathWithQueryParameters, fetchParams).then((response) => {
				if (response.status >= 200 && response.status < 300) {
					return response.json();
				} else {
					let error = new Error(response.statusText);
					(error as any).response = response;
					throw error;
				}
			});
		}
		/**
		 *
		 * Get Certification By Id
		 * @param id
		 */
		public systemCertificationsIdGet (params: {  id: number; }, extraQueryParams?: any, extraFetchParams?: any ) : Promise<Certification> {
			const localVarPath = this.basePath + '/system/certifications/{id}'
				.replace('{' + 'id' + '}', String(params.id));

			let queryParameters: any = assign({}, extraQueryParams);
			let headerParams: any = assign({}, this.defaultHeaders);
			// verify required parameter 'id' is set
			if (params.id == null) {
				throw new Error('Missing required parameter id when calling systemCertificationsIdGet');
			}
			let fetchParams = {
				method: 'GET',
				headers: headerParams,

			};

			if (extraFetchParams) {
				fetchParams = assign(fetchParams, extraFetchParams);
			}

			let localVarPathWithQueryParameters = localVarPath + (localVarPath.indexOf('?') !== -1 ? '&' : '?') + querystring.stringify(queryParameters);

			return fetch(localVarPathWithQueryParameters, fetchParams).then((response) => {
				if (response.status >= 200 && response.status < 300) {
					return response.json();
				} else {
					let error = new Error(response.statusText);
					(error as any).response = response;
					throw error;
				}
			});
		}
		/**
		 *
		 * Update Certification
		 * @param id
		 * @param operations
		 */
		public systemCertificationsIdPatch (params: {  id: number; operations: Array<PatchOperation>; }, extraQueryParams?: any, extraFetchParams?: any ) : Promise<Certification> {
			const localVarPath = this.basePath + '/system/certifications/{id}'
				.replace('{' + 'id' + '}', String(params.id));

			let queryParameters: any = assign({}, extraQueryParams);
			let headerParams: any = assign({}, this.defaultHeaders);
			headerParams['Content-Type'] = 'application/json';

			// verify required parameter 'id' is set
			if (params.id == null) {
				throw new Error('Missing required parameter id when calling systemCertificationsIdPatch');
			}
			// verify required parameter 'operations' is set
			if (params.operations == null) {
				throw new Error('Missing required parameter operations when calling systemCertificationsIdPatch');
			}
			let fetchParams = {
				method: 'PATCH',
				headers: headerParams,
				body: JSON.stringify(params.operations),

			};

			if (extraFetchParams) {
				fetchParams = assign(fetchParams, extraFetchParams);
			}

			let localVarPathWithQueryParameters = localVarPath + (localVarPath.indexOf('?') !== -1 ? '&' : '?') + querystring.stringify(queryParameters);

			return fetch(localVarPathWithQueryParameters, fetchParams).then((response) => {
				if (response.status >= 200 && response.status < 300) {
					return response.json();
				} else {
					let error = new Error(response.statusText);
					(error as any).response = response;
					throw error;
				}
			});
		}
		/**
		 *
		 * Replace Certification
		 * @param id
		 * @param certification
		 */
		public systemCertificationsIdPut (params: {  id: number; certification: Certification; }, extraQueryParams?: any, extraFetchParams?: any ) : Promise<Certification> {
			const localVarPath = this.basePath + '/system/certifications/{id}'
				.replace('{' + 'id' + '}', String(params.id));

			let queryParameters: any = assign({}, extraQueryParams);
			let headerParams: any = assign({}, this.defaultHeaders);
			headerParams['Content-Type'] = 'application/json';

			// verify required parameter 'id' is set
			if (params.id == null) {
				throw new Error('Missing required parameter id when calling systemCertificationsIdPut');
			}
			// verify required parameter 'certification' is set
			if (params.certification == null) {
				throw new Error('Missing required parameter certification when calling systemCertificationsIdPut');
			}
			let fetchParams = {
				method: 'PUT',
				headers: headerParams,
				body: JSON.stringify(params.certification),

			};

			if (extraFetchParams) {
				fetchParams = assign(fetchParams, extraFetchParams);
			}

			let localVarPathWithQueryParameters = localVarPath + (localVarPath.indexOf('?') !== -1 ? '&' : '?') + querystring.stringify(queryParameters);

			return fetch(localVarPathWithQueryParameters, fetchParams).then((response) => {
				if (response.status >= 200 && response.status < 300) {
					return response.json();
				} else {
					let error = new Error(response.statusText);
					(error as any).response = response;
					throw error;
				}
			});
		}
		/**
		 *
		 * Create Certification
		 * @param certification
		 */
		public systemCertificationsPost (params: {  certification: Certification; }, extraQueryParams?: any, extraFetchParams?: any ) : Promise<Certification> {
			const localVarPath = this.basePath + '/system/certifications';

			let queryParameters: any = assign({}, extraQueryParams);
			let headerParams: any = assign({}, this.defaultHeaders);
			headerParams['Content-Type'] = 'application/json';

			// verify required parameter 'certification' is set
			if (params.certification == null) {
				throw new Error('Missing required parameter certification when calling systemCertificationsPost');
			}
			let fetchParams = {
				method: 'POST',
				headers: headerParams,
				body: JSON.stringify(params.certification),

			};

			if (extraFetchParams) {
				fetchParams = assign(fetchParams, extraFetchParams);
			}

			let localVarPathWithQueryParameters = localVarPath + (localVarPath.indexOf('?') !== -1 ? '&' : '?') + querystring.stringify(queryParameters);

			return fetch(localVarPathWithQueryParameters, fetchParams).then((response) => {
				if (response.status >= 200 && response.status < 300) {
					return response.json();
				} else {
					let error = new Error(response.statusText);
					(error as any).response = response;
					throw error;
				}
			});
		}
	}
//}
//export namespace  {
	'use strict';

	export class CodesApi {
		protected basePath = 'https://api-na.myconnectwise.net/v4_6_release/apis/3.0';
		public defaultHeaders : any = {};

		constructor(basePath?: string) {
			if (basePath) {
				this.basePath = basePath;
			}
		}

		/**
		 *
		 * Create Codes Count
		 * @param conditions
		 */
		public serviceCodesCountGet (params: {  conditions?: string; }, extraQueryParams?: any, extraFetchParams?: any ) : Promise<Count> {
			const localVarPath = this.basePath + '/service/codes/count';

			let queryParameters: any = assign({}, extraQueryParams);
			let headerParams: any = assign({}, this.defaultHeaders);
			if (params.conditions !== undefined) {
				queryParameters['conditions'] = params.conditions;
			}

			let fetchParams = {
				method: 'GET',
				headers: headerParams,

			};

			if (extraFetchParams) {
				fetchParams = assign(fetchParams, extraFetchParams);
			}

			let localVarPathWithQueryParameters = localVarPath + (localVarPath.indexOf('?') !== -1 ? '&' : '?') + querystring.stringify(queryParameters);

			return fetch(localVarPathWithQueryParameters, fetchParams).then((response) => {
				if (response.status >= 200 && response.status < 300) {
					return response.json();
				} else {
					let error = new Error(response.statusText);
					(error as any).response = response;
					throw error;
				}
			});
		}
		/**
		 *
		 * Get Codes
		 * @param conditions
		 * @param orderBy
		 * @param childconditions
		 * @param customfieldconditions
		 * @param page
		 * @param pageSize
		 */
		public serviceCodesGet (params: {  conditions?: string; orderBy?: string; childconditions?: string; customfieldconditions?: string; page?: number; pageSize?: number; }, extraQueryParams?: any, extraFetchParams?: any ) : Promise<Array<Code>> {
			const localVarPath = this.basePath + '/service/codes';

			let queryParameters: any = assign({}, extraQueryParams);
			let headerParams: any = assign({}, this.defaultHeaders);
			if (params.conditions !== undefined) {
				queryParameters['conditions'] = params.conditions;
			}

			if (params.orderBy !== undefined) {
				queryParameters['orderBy'] = params.orderBy;
			}

			if (params.childconditions !== undefined) {
				queryParameters['childconditions'] = params.childconditions;
			}

			if (params.customfieldconditions !== undefined) {
				queryParameters['customfieldconditions'] = params.customfieldconditions;
			}

			if (params.page !== undefined) {
				queryParameters['page'] = params.page;
			}

			if (params.pageSize !== undefined) {
				queryParameters['pageSize'] = params.pageSize;
			}

			let fetchParams = {
				method: 'GET',
				headers: headerParams,

			};

			if (extraFetchParams) {
				fetchParams = assign(fetchParams, extraFetchParams);
			}

			let localVarPathWithQueryParameters = localVarPath + (localVarPath.indexOf('?') !== -1 ? '&' : '?') + querystring.stringify(queryParameters);

			return fetch(localVarPathWithQueryParameters, fetchParams).then((response) => {
				if (response.status >= 200 && response.status < 300) {
					return response.json();
				} else {
					let error = new Error(response.statusText);
					(error as any).response = response;
					throw error;
				}
			});
		}
		/**
		 *
		 * Delete Code By Id
		 * @param id
		 */
		public serviceCodesIdDelete (params: {  id: number; }, extraQueryParams?: any, extraFetchParams?: any ) : Promise<{}> {
			const localVarPath = this.basePath + '/service/codes/{id}'
				.replace('{' + 'id' + '}', String(params.id));

			let queryParameters: any = assign({}, extraQueryParams);
			let headerParams: any = assign({}, this.defaultHeaders);
			// verify required parameter 'id' is set
			if (params.id == null) {
				throw new Error('Missing required parameter id when calling serviceCodesIdDelete');
			}
			let fetchParams = {
				method: 'DELETE',
				headers: headerParams,

			};

			if (extraFetchParams) {
				fetchParams = assign(fetchParams, extraFetchParams);
			}

			let localVarPathWithQueryParameters = localVarPath + (localVarPath.indexOf('?') !== -1 ? '&' : '?') + querystring.stringify(queryParameters);

			return fetch(localVarPathWithQueryParameters, fetchParams).then((response) => {
				if (response.status >= 200 && response.status < 300) {
					return response.json();
				} else {
					let error = new Error(response.statusText);
					(error as any).response = response;
					throw error;
				}
			});
		}
		/**
		 *
		 * Get Code By Id
		 * @param id
		 */
		public serviceCodesIdGet (params: {  id: number; }, extraQueryParams?: any, extraFetchParams?: any ) : Promise<Code> {
			const localVarPath = this.basePath + '/service/codes/{id}'
				.replace('{' + 'id' + '}', String(params.id));

			let queryParameters: any = assign({}, extraQueryParams);
			let headerParams: any = assign({}, this.defaultHeaders);
			// verify required parameter 'id' is set
			if (params.id == null) {
				throw new Error('Missing required parameter id when calling serviceCodesIdGet');
			}
			let fetchParams = {
				method: 'GET',
				headers: headerParams,

			};

			if (extraFetchParams) {
				fetchParams = assign(fetchParams, extraFetchParams);
			}

			let localVarPathWithQueryParameters = localVarPath + (localVarPath.indexOf('?') !== -1 ? '&' : '?') + querystring.stringify(queryParameters);

			return fetch(localVarPathWithQueryParameters, fetchParams).then((response) => {
				if (response.status >= 200 && response.status < 300) {
					return response.json();
				} else {
					let error = new Error(response.statusText);
					(error as any).response = response;
					throw error;
				}
			});
		}
		/**
		 *
		 * Update Code
		 * @param id
		 * @param operations
		 */
		public serviceCodesIdPatch (params: {  id: number; operations: Array<PatchOperation>; }, extraQueryParams?: any, extraFetchParams?: any ) : Promise<Code> {
			const localVarPath = this.basePath + '/service/codes/{id}'
				.replace('{' + 'id' + '}', String(params.id));

			let queryParameters: any = assign({}, extraQueryParams);
			let headerParams: any = assign({}, this.defaultHeaders);
			headerParams['Content-Type'] = 'application/json';

			// verify required parameter 'id' is set
			if (params.id == null) {
				throw new Error('Missing required parameter id when calling serviceCodesIdPatch');
			}
			// verify required parameter 'operations' is set
			if (params.operations == null) {
				throw new Error('Missing required parameter operations when calling serviceCodesIdPatch');
			}
			let fetchParams = {
				method: 'PATCH',
				headers: headerParams,
				body: JSON.stringify(params.operations),

			};

			if (extraFetchParams) {
				fetchParams = assign(fetchParams, extraFetchParams);
			}

			let localVarPathWithQueryParameters = localVarPath + (localVarPath.indexOf('?') !== -1 ? '&' : '?') + querystring.stringify(queryParameters);

			return fetch(localVarPathWithQueryParameters, fetchParams).then((response) => {
				if (response.status >= 200 && response.status < 300) {
					return response.json();
				} else {
					let error = new Error(response.statusText);
					(error as any).response = response;
					throw error;
				}
			});
		}
		/**
		 *
		 * Replace Code
		 * @param id
		 * @param code
		 */
		public serviceCodesIdPut (params: {  id: number; code: Code; }, extraQueryParams?: any, extraFetchParams?: any ) : Promise<Code> {
			const localVarPath = this.basePath + '/service/codes/{id}'
				.replace('{' + 'id' + '}', String(params.id));

			let queryParameters: any = assign({}, extraQueryParams);
			let headerParams: any = assign({}, this.defaultHeaders);
			headerParams['Content-Type'] = 'application/json';

			// verify required parameter 'id' is set
			if (params.id == null) {
				throw new Error('Missing required parameter id when calling serviceCodesIdPut');
			}
			// verify required parameter 'code' is set
			if (params.code == null) {
				throw new Error('Missing required parameter code when calling serviceCodesIdPut');
			}
			let fetchParams = {
				method: 'PUT',
				headers: headerParams,
				body: JSON.stringify(params.code),

			};

			if (extraFetchParams) {
				fetchParams = assign(fetchParams, extraFetchParams);
			}

			let localVarPathWithQueryParameters = localVarPath + (localVarPath.indexOf('?') !== -1 ? '&' : '?') + querystring.stringify(queryParameters);

			return fetch(localVarPathWithQueryParameters, fetchParams).then((response) => {
				if (response.status >= 200 && response.status < 300) {
					return response.json();
				} else {
					let error = new Error(response.statusText);
					(error as any).response = response;
					throw error;
				}
			});
		}
		/**
		 *
		 * Create Codes
		 * @param code
		 */
		public serviceCodesPost (params: {  code: Code; }, extraQueryParams?: any, extraFetchParams?: any ) : Promise<Code> {
			const localVarPath = this.basePath + '/service/codes';

			let queryParameters: any = assign({}, extraQueryParams);
			let headerParams: any = assign({}, this.defaultHeaders);
			headerParams['Content-Type'] = 'application/json';

			// verify required parameter 'code' is set
			if (params.code == null) {
				throw new Error('Missing required parameter code when calling serviceCodesPost');
			}
			let fetchParams = {
				method: 'POST',
				headers: headerParams,
				body: JSON.stringify(params.code),

			};

			if (extraFetchParams) {
				fetchParams = assign(fetchParams, extraFetchParams);
			}

			let localVarPathWithQueryParameters = localVarPath + (localVarPath.indexOf('?') !== -1 ? '&' : '?') + querystring.stringify(queryParameters);

			return fetch(localVarPathWithQueryParameters, fetchParams).then((response) => {
				if (response.status >= 200 && response.status < 300) {
					return response.json();
				} else {
					let error = new Error(response.statusText);
					(error as any).response = response;
					throw error;
				}
			});
		}
	}
//}
//export namespace  {
	'use strict';

	export class CompaniesApi {
		protected basePath = 'https://api-na.myconnectwise.net/v4_6_release/apis/3.0';
		public defaultHeaders : any = {};

		constructor(basePath?: string) {
			if (basePath) {
				this.basePath = basePath;
			}
		}

		/**
		 *
		 * Get Companies Count
		 * @param conditions
		 * @param customFieldConditions
		 */
		public companyCompaniesCountGet (params: {  conditions?: string; customFieldConditions?: string; }, extraQueryParams?: any, extraFetchParams?: any ) : Promise<Count> {
			const localVarPath = this.basePath + '/company/companies/count';

			let queryParameters: any = assign({}, extraQueryParams);
			let headerParams: any = assign({}, this.defaultHeaders);
			if (params.conditions !== undefined) {
				queryParameters['conditions'] = params.conditions;
			}

			if (params.customFieldConditions !== undefined) {
				queryParameters['customFieldConditions'] = params.customFieldConditions;
			}

			let fetchParams = {
				method: 'GET',
				headers: headerParams,

			};

			if (extraFetchParams) {
				fetchParams = assign(fetchParams, extraFetchParams);
			}

			let localVarPathWithQueryParameters = localVarPath + (localVarPath.indexOf('?') !== -1 ? '&' : '?') + querystring.stringify(queryParameters);

			return fetch(localVarPathWithQueryParameters, fetchParams).then((response) => {
				if (response.status >= 200 && response.status < 300) {
					return response.json();
				} else {
					let error = new Error(response.statusText);
					(error as any).response = response;
					throw error;
				}
			});
		}
		/**
		 *
		 * Get Companies
		 * @param conditions
		 * @param orderBy
		 * @param childconditions
		 * @param customfieldconditions
		 * @param page
		 * @param pageSize
		 */
		public companyCompaniesGet (params: {  conditions?: string; orderBy?: string; childconditions?: string; customfieldconditions?: string; page?: number; pageSize?: number; }, extraQueryParams?: any, extraFetchParams?: any ) : Promise<Array<Company>> {
			const localVarPath = this.basePath + '/company/companies';

			let queryParameters: any = assign({}, extraQueryParams);
			let headerParams: any = assign({}, this.defaultHeaders);
			if (params.conditions !== undefined) {
				queryParameters['conditions'] = params.conditions;
			}

			if (params.orderBy !== undefined) {
				queryParameters['orderBy'] = params.orderBy;
			}

			if (params.childconditions !== undefined) {
				queryParameters['childconditions'] = params.childconditions;
			}

			if (params.customfieldconditions !== undefined) {
				queryParameters['customfieldconditions'] = params.customfieldconditions;
			}

			if (params.page !== undefined) {
				queryParameters['page'] = params.page;
			}

			if (params.pageSize !== undefined) {
				queryParameters['pageSize'] = params.pageSize;
			}

			let fetchParams = {
				method: 'GET',
				headers: headerParams,

			};

			if (extraFetchParams) {
				fetchParams = assign(fetchParams, extraFetchParams);
			}

			let localVarPathWithQueryParameters = localVarPath + (localVarPath.indexOf('?') !== -1 ? '&' : '?') + querystring.stringify(queryParameters);

			return fetch(localVarPathWithQueryParameters, fetchParams).then((response) => {
				if (response.status >= 200 && response.status < 300) {
					return response.json();
				} else {
					let error = new Error(response.statusText);
					(error as any).response = response;
					throw error;
				}
			});
		}
		/**
		 *
		 * Delete Company By Id
		 * @param id
		 */
		public companyCompaniesIdDelete (params: {  id: number; }, extraQueryParams?: any, extraFetchParams?: any ) : Promise<{}> {
			const localVarPath = this.basePath + '/company/companies/{id}'
				.replace('{' + 'id' + '}', String(params.id));

			let queryParameters: any = assign({}, extraQueryParams);
			let headerParams: any = assign({}, this.defaultHeaders);
			// verify required parameter 'id' is set
			if (params.id == null) {
				throw new Error('Missing required parameter id when calling companyCompaniesIdDelete');
			}
			let fetchParams = {
				method: 'DELETE',
				headers: headerParams,

			};

			if (extraFetchParams) {
				fetchParams = assign(fetchParams, extraFetchParams);
			}

			let localVarPathWithQueryParameters = localVarPath + (localVarPath.indexOf('?') !== -1 ? '&' : '?') + querystring.stringify(queryParameters);

			return fetch(localVarPathWithQueryParameters, fetchParams).then((response) => {
				if (response.status >= 200 && response.status < 300) {
					return response.json();
				} else {
					let error = new Error(response.statusText);
					(error as any).response = response;
					throw error;
				}
			});
		}
		/**
		 *
		 * Get Company By Id
		 * @param id
		 */
		public companyCompaniesIdGet (params: {  id: number; }, extraQueryParams?: any, extraFetchParams?: any ) : Promise<Company> {
			const localVarPath = this.basePath + '/company/companies/{id}'
				.replace('{' + 'id' + '}', String(params.id));

			let queryParameters: any = assign({}, extraQueryParams);
			let headerParams: any = assign({}, this.defaultHeaders);
			// verify required parameter 'id' is set
			if (params.id == null) {
				throw new Error('Missing required parameter id when calling companyCompaniesIdGet');
			}
			let fetchParams = {
				method: 'GET',
				headers: headerParams,

			};

			if (extraFetchParams) {
				fetchParams = assign(fetchParams, extraFetchParams);
			}

			let localVarPathWithQueryParameters = localVarPath + (localVarPath.indexOf('?') !== -1 ? '&' : '?') + querystring.stringify(queryParameters);

			return fetch(localVarPathWithQueryParameters, fetchParams).then((response) => {
				if (response.status >= 200 && response.status < 300) {
					return response.json();
				} else {
					let error = new Error(response.statusText);
					(error as any).response = response;
					throw error;
				}
			});
		}
		/**
		 *
		 * Merge Company
		 * @param id
		 * @param merge
		 */
		public companyCompaniesIdMergePost (params: {  id: number; merge: CompanyMerge; }, extraQueryParams?: any, extraFetchParams?: any ) : Promise<SuccessResponse> {
			const localVarPath = this.basePath + '/company/companies/{id}/merge'
				.replace('{' + 'id' + '}', String(params.id));

			let queryParameters: any = assign({}, extraQueryParams);
			let headerParams: any = assign({}, this.defaultHeaders);
			headerParams['Content-Type'] = 'application/json';

			// verify required parameter 'id' is set
			if (params.id == null) {
				throw new Error('Missing required parameter id when calling companyCompaniesIdMergePost');
			}
			// verify required parameter 'merge' is set
			if (params.merge == null) {
				throw new Error('Missing required parameter merge when calling companyCompaniesIdMergePost');
			}
			let fetchParams = {
				method: 'POST',
				headers: headerParams,
				body: JSON.stringify(params.merge),

			};

			if (extraFetchParams) {
				fetchParams = assign(fetchParams, extraFetchParams);
			}

			let localVarPathWithQueryParameters = localVarPath + (localVarPath.indexOf('?') !== -1 ? '&' : '?') + querystring.stringify(queryParameters);

			return fetch(localVarPathWithQueryParameters, fetchParams).then((response) => {
				if (response.status >= 200 && response.status < 300) {
					return response.json();
				} else {
					let error = new Error(response.statusText);
					(error as any).response = response;
					throw error;
				}
			});
		}
		/**
		 *
		 * Update Company
		 * @param id
		 * @param operations
		 */
		public companyCompaniesIdPatch (params: {  id: number; operations: Array<PatchOperation>; }, extraQueryParams?: any, extraFetchParams?: any ) : Promise<Company> {
			const localVarPath = this.basePath + '/company/companies/{id}'
				.replace('{' + 'id' + '}', String(params.id));

			let queryParameters: any = assign({}, extraQueryParams);
			let headerParams: any = assign({}, this.defaultHeaders);
			headerParams['Content-Type'] = 'application/json';

			// verify required parameter 'id' is set
			if (params.id == null) {
				throw new Error('Missing required parameter id when calling companyCompaniesIdPatch');
			}
			// verify required parameter 'operations' is set
			if (params.operations == null) {
				throw new Error('Missing required parameter operations when calling companyCompaniesIdPatch');
			}
			let fetchParams = {
				method: 'PATCH',
				headers: headerParams,
				body: JSON.stringify(params.operations),

			};

			if (extraFetchParams) {
				fetchParams = assign(fetchParams, extraFetchParams);
			}

			let localVarPathWithQueryParameters = localVarPath + (localVarPath.indexOf('?') !== -1 ? '&' : '?') + querystring.stringify(queryParameters);

			return fetch(localVarPathWithQueryParameters, fetchParams).then((response) => {
				if (response.status >= 200 && response.status < 300) {
					return response.json();
				} else {
					let error = new Error(response.statusText);
					(error as any).response = response;
					throw error;
				}
			});
		}
		/**
		 *
		 * Replace Company
		 * @param id
		 * @param company
		 */
		public companyCompaniesIdPut (params: {  id: number; company: Company; }, extraQueryParams?: any, extraFetchParams?: any ) : Promise<Company> {
			const localVarPath = this.basePath + '/company/companies/{id}'
				.replace('{' + 'id' + '}', String(params.id));

			let queryParameters: any = assign({}, extraQueryParams);
			let headerParams: any = assign({}, this.defaultHeaders);
			headerParams['Content-Type'] = 'application/json';

			// verify required parameter 'id' is set
			if (params.id == null) {
				throw new Error('Missing required parameter id when calling companyCompaniesIdPut');
			}
			// verify required parameter 'company' is set
			if (params.company == null) {
				throw new Error('Missing required parameter company when calling companyCompaniesIdPut');
			}
			let fetchParams = {
				method: 'PUT',
				headers: headerParams,
				body: JSON.stringify(params.company),

			};

			if (extraFetchParams) {
				fetchParams = assign(fetchParams, extraFetchParams);
			}

			let localVarPathWithQueryParameters = localVarPath + (localVarPath.indexOf('?') !== -1 ? '&' : '?') + querystring.stringify(queryParameters);

			return fetch(localVarPathWithQueryParameters, fetchParams).then((response) => {
				if (response.status >= 200 && response.status < 300) {
					return response.json();
				} else {
					let error = new Error(response.statusText);
					(error as any).response = response;
					throw error;
				}
			});
		}
		/**
		 *
		 * Create Company
		 * @param company
		 */
		public companyCompaniesPost (params: {  company: Company; }, extraQueryParams?: any, extraFetchParams?: any ) : Promise<Company> {
			const localVarPath = this.basePath + '/company/companies';

			let queryParameters: any = assign({}, extraQueryParams);
			let headerParams: any = assign({}, this.defaultHeaders);
			headerParams['Content-Type'] = 'application/json';

			// verify required parameter 'company' is set
			if (params.company == null) {
				throw new Error('Missing required parameter company when calling companyCompaniesPost');
			}
			let fetchParams = {
				method: 'POST',
				headers: headerParams,
				body: JSON.stringify(params.company),

			};

			if (extraFetchParams) {
				fetchParams = assign(fetchParams, extraFetchParams);
			}

			let localVarPathWithQueryParameters = localVarPath + (localVarPath.indexOf('?') !== -1 ? '&' : '?') + querystring.stringify(queryParameters);

			return fetch(localVarPathWithQueryParameters, fetchParams).then((response) => {
				if (response.status >= 200 && response.status < 300) {
					return response.json();
				} else {
					let error = new Error(response.statusText);
					(error as any).response = response;
					throw error;
				}
			});
		}
	}
//}
//export namespace  {
	'use strict';

	export class CompanyCustomNotesApi {
		protected basePath = 'https://api-na.myconnectwise.net/v4_6_release/apis/3.0';
		public defaultHeaders : any = {};

		constructor(basePath?: string) {
			if (basePath) {
				this.basePath = basePath;
			}
		}

		/**
		 *
		 * Get Custom Note Count
		 * @param id
		 * @param conditions
		 */
		public companyCompaniesIdCustomStatusNotesCountGet (params: {  id: number; conditions?: string; }, extraQueryParams?: any, extraFetchParams?: any ) : Promise<Count> {
			const localVarPath = this.basePath + '/company/companies/{id}/customStatusNotes/count'
				.replace('{' + 'id' + '}', String(params.id));

			let queryParameters: any = assign({}, extraQueryParams);
			let headerParams: any = assign({}, this.defaultHeaders);
			// verify required parameter 'id' is set
			if (params.id == null) {
				throw new Error('Missing required parameter id when calling companyCompaniesIdCustomStatusNotesCountGet');
			}
			if (params.conditions !== undefined) {
				queryParameters['conditions'] = params.conditions;
			}

			let fetchParams = {
				method: 'GET',
				headers: headerParams,

			};

			if (extraFetchParams) {
				fetchParams = assign(fetchParams, extraFetchParams);
			}

			let localVarPathWithQueryParameters = localVarPath + (localVarPath.indexOf('?') !== -1 ? '&' : '?') + querystring.stringify(queryParameters);

			return fetch(localVarPathWithQueryParameters, fetchParams).then((response) => {
				if (response.status >= 200 && response.status < 300) {
					return response.json();
				} else {
					let error = new Error(response.statusText);
					(error as any).response = response;
					throw error;
				}
			});
		}
		/**
		 *
		 * Delete Custom Note By Id
		 * @param id
		 * @param customNoteId
		 */
		public companyCompaniesIdCustomStatusNotesCustomNoteIdDelete (params: {  id: number; customNoteId: number; }, extraQueryParams?: any, extraFetchParams?: any ) : Promise<{}> {
			const localVarPath = this.basePath + '/company/companies/{id}/customStatusNotes/{customNoteId}'
				.replace('{' + 'id' + '}', String(params.id))
				.replace('{' + 'customNoteId' + '}', String(params.customNoteId));

			let queryParameters: any = assign({}, extraQueryParams);
			let headerParams: any = assign({}, this.defaultHeaders);
			// verify required parameter 'id' is set
			if (params.id == null) {
				throw new Error('Missing required parameter id when calling companyCompaniesIdCustomStatusNotesCustomNoteIdDelete');
			}
			// verify required parameter 'customNoteId' is set
			if (params.customNoteId == null) {
				throw new Error('Missing required parameter customNoteId when calling companyCompaniesIdCustomStatusNotesCustomNoteIdDelete');
			}
			let fetchParams = {
				method: 'DELETE',
				headers: headerParams,

			};

			if (extraFetchParams) {
				fetchParams = assign(fetchParams, extraFetchParams);
			}

			let localVarPathWithQueryParameters = localVarPath + (localVarPath.indexOf('?') !== -1 ? '&' : '?') + querystring.stringify(queryParameters);

			return fetch(localVarPathWithQueryParameters, fetchParams).then((response) => {
				if (response.status >= 200 && response.status < 300) {
					return response.json();
				} else {
					let error = new Error(response.statusText);
					(error as any).response = response;
					throw error;
				}
			});
		}
		/**
		 *
		 * Get Custom Note By Id
		 * @param id
		 * @param customNoteId
		 */
		public companyCompaniesIdCustomStatusNotesCustomNoteIdGet (params: {  id: number; customNoteId: number; }, extraQueryParams?: any, extraFetchParams?: any ) : Promise<CompanyCustomNote> {
			const localVarPath = this.basePath + '/company/companies/{id}/customStatusNotes/{customNoteId}'
				.replace('{' + 'id' + '}', String(params.id))
				.replace('{' + 'customNoteId' + '}', String(params.customNoteId));

			let queryParameters: any = assign({}, extraQueryParams);
			let headerParams: any = assign({}, this.defaultHeaders);
			// verify required parameter 'id' is set
			if (params.id == null) {
				throw new Error('Missing required parameter id when calling companyCompaniesIdCustomStatusNotesCustomNoteIdGet');
			}
			// verify required parameter 'customNoteId' is set
			if (params.customNoteId == null) {
				throw new Error('Missing required parameter customNoteId when calling companyCompaniesIdCustomStatusNotesCustomNoteIdGet');
			}
			let fetchParams = {
				method: 'GET',
				headers: headerParams,

			};

			if (extraFetchParams) {
				fetchParams = assign(fetchParams, extraFetchParams);
			}

			let localVarPathWithQueryParameters = localVarPath + (localVarPath.indexOf('?') !== -1 ? '&' : '?') + querystring.stringify(queryParameters);

			return fetch(localVarPathWithQueryParameters, fetchParams).then((response) => {
				if (response.status >= 200 && response.status < 300) {
					return response.json();
				} else {
					let error = new Error(response.statusText);
					(error as any).response = response;
					throw error;
				}
			});
		}
		/**
		 *
		 * Update Custom Note
		 * @param id
		 * @param customNoteId
		 * @param operations
		 */
		public companyCompaniesIdCustomStatusNotesCustomNoteIdPatch (params: {  id: number; customNoteId: number; operations: Array<PatchOperation>; }, extraQueryParams?: any, extraFetchParams?: any ) : Promise<CompanyCustomNote> {
			const localVarPath = this.basePath + '/company/companies/{id}/customStatusNotes/{customNoteId}'
				.replace('{' + 'id' + '}', String(params.id))
				.replace('{' + 'customNoteId' + '}', String(params.customNoteId));

			let queryParameters: any = assign({}, extraQueryParams);
			let headerParams: any = assign({}, this.defaultHeaders);
			headerParams['Content-Type'] = 'application/json';

			// verify required parameter 'id' is set
			if (params.id == null) {
				throw new Error('Missing required parameter id when calling companyCompaniesIdCustomStatusNotesCustomNoteIdPatch');
			}
			// verify required parameter 'customNoteId' is set
			if (params.customNoteId == null) {
				throw new Error('Missing required parameter customNoteId when calling companyCompaniesIdCustomStatusNotesCustomNoteIdPatch');
			}
			// verify required parameter 'operations' is set
			if (params.operations == null) {
				throw new Error('Missing required parameter operations when calling companyCompaniesIdCustomStatusNotesCustomNoteIdPatch');
			}
			let fetchParams = {
				method: 'PATCH',
				headers: headerParams,
				body: JSON.stringify(params.operations),

			};

			if (extraFetchParams) {
				fetchParams = assign(fetchParams, extraFetchParams);
			}

			let localVarPathWithQueryParameters = localVarPath + (localVarPath.indexOf('?') !== -1 ? '&' : '?') + querystring.stringify(queryParameters);

			return fetch(localVarPathWithQueryParameters, fetchParams).then((response) => {
				if (response.status >= 200 && response.status < 300) {
					return response.json();
				} else {
					let error = new Error(response.statusText);
					(error as any).response = response;
					throw error;
				}
			});
		}
		/**
		 *
		 * Replace Custom Note
		 * @param id
		 * @param customNoteId
		 * @param customNote
		 */
		public companyCompaniesIdCustomStatusNotesCustomNoteIdPut (params: {  id: number; customNoteId: number; customNote: CompanyCustomNote; }, extraQueryParams?: any, extraFetchParams?: any ) : Promise<CompanyCustomNote> {
			const localVarPath = this.basePath + '/company/companies/{id}/customStatusNotes/{customNoteId}'
				.replace('{' + 'id' + '}', String(params.id))
				.replace('{' + 'customNoteId' + '}', String(params.customNoteId));

			let queryParameters: any = assign({}, extraQueryParams);
			let headerParams: any = assign({}, this.defaultHeaders);
			headerParams['Content-Type'] = 'application/json';

			// verify required parameter 'id' is set
			if (params.id == null) {
				throw new Error('Missing required parameter id when calling companyCompaniesIdCustomStatusNotesCustomNoteIdPut');
			}
			// verify required parameter 'customNoteId' is set
			if (params.customNoteId == null) {
				throw new Error('Missing required parameter customNoteId when calling companyCompaniesIdCustomStatusNotesCustomNoteIdPut');
			}
			// verify required parameter 'customNote' is set
			if (params.customNote == null) {
				throw new Error('Missing required parameter customNote when calling companyCompaniesIdCustomStatusNotesCustomNoteIdPut');
			}
			let fetchParams = {
				method: 'PUT',
				headers: headerParams,
				body: JSON.stringify(params.customNote),

			};

			if (extraFetchParams) {
				fetchParams = assign(fetchParams, extraFetchParams);
			}

			let localVarPathWithQueryParameters = localVarPath + (localVarPath.indexOf('?') !== -1 ? '&' : '?') + querystring.stringify(queryParameters);

			return fetch(localVarPathWithQueryParameters, fetchParams).then((response) => {
				if (response.status >= 200 && response.status < 300) {
					return response.json();
				} else {
					let error = new Error(response.statusText);
					(error as any).response = response;
					throw error;
				}
			});
		}
		/**
		 *
		 * Get Custom Note
		 * @param id
		 * @param conditions
		 * @param orderBy
		 * @param childconditions
		 * @param customfieldconditions
		 * @param page
		 * @param pageSize
		 */
		public companyCompaniesIdCustomStatusNotesGet (params: {  id: number; conditions?: string; orderBy?: string; childconditions?: string; customfieldconditions?: string; page?: number; pageSize?: number; }, extraQueryParams?: any, extraFetchParams?: any ) : Promise<Array<CompanyCustomNote>> {
			const localVarPath = this.basePath + '/company/companies/{id}/customStatusNotes'
				.replace('{' + 'id' + '}', String(params.id));

			let queryParameters: any = assign({}, extraQueryParams);
			let headerParams: any = assign({}, this.defaultHeaders);
			// verify required parameter 'id' is set
			if (params.id == null) {
				throw new Error('Missing required parameter id when calling companyCompaniesIdCustomStatusNotesGet');
			}
			if (params.conditions !== undefined) {
				queryParameters['conditions'] = params.conditions;
			}

			if (params.orderBy !== undefined) {
				queryParameters['orderBy'] = params.orderBy;
			}

			if (params.childconditions !== undefined) {
				queryParameters['childconditions'] = params.childconditions;
			}

			if (params.customfieldconditions !== undefined) {
				queryParameters['customfieldconditions'] = params.customfieldconditions;
			}

			if (params.page !== undefined) {
				queryParameters['page'] = params.page;
			}

			if (params.pageSize !== undefined) {
				queryParameters['pageSize'] = params.pageSize;
			}

			let fetchParams = {
				method: 'GET',
				headers: headerParams,

			};

			if (extraFetchParams) {
				fetchParams = assign(fetchParams, extraFetchParams);
			}

			let localVarPathWithQueryParameters = localVarPath + (localVarPath.indexOf('?') !== -1 ? '&' : '?') + querystring.stringify(queryParameters);

			return fetch(localVarPathWithQueryParameters, fetchParams).then((response) => {
				if (response.status >= 200 && response.status < 300) {
					return response.json();
				} else {
					let error = new Error(response.statusText);
					(error as any).response = response;
					throw error;
				}
			});
		}
		/**
		 *
		 * Create Custom Note
		 * @param id
		 * @param customNote
		 */
		public companyCompaniesIdCustomStatusNotesPost (params: {  id: number; customNote: CompanyCustomNote; }, extraQueryParams?: any, extraFetchParams?: any ) : Promise<CompanyCustomNote> {
			const localVarPath = this.basePath + '/company/companies/{id}/customStatusNotes'
				.replace('{' + 'id' + '}', String(params.id));

			let queryParameters: any = assign({}, extraQueryParams);
			let headerParams: any = assign({}, this.defaultHeaders);
			headerParams['Content-Type'] = 'application/json';

			// verify required parameter 'id' is set
			if (params.id == null) {
				throw new Error('Missing required parameter id when calling companyCompaniesIdCustomStatusNotesPost');
			}
			// verify required parameter 'customNote' is set
			if (params.customNote == null) {
				throw new Error('Missing required parameter customNote when calling companyCompaniesIdCustomStatusNotesPost');
			}
			let fetchParams = {
				method: 'POST',
				headers: headerParams,
				body: JSON.stringify(params.customNote),

			};

			if (extraFetchParams) {
				fetchParams = assign(fetchParams, extraFetchParams);
			}

			let localVarPathWithQueryParameters = localVarPath + (localVarPath.indexOf('?') !== -1 ? '&' : '?') + querystring.stringify(queryParameters);

			return fetch(localVarPathWithQueryParameters, fetchParams).then((response) => {
				if (response.status >= 200 && response.status < 300) {
					return response.json();
				} else {
					let error = new Error(response.statusText);
					(error as any).response = response;
					throw error;
				}
			});
		}
	}
//}
//export namespace  {
	'use strict';

	export class CompanyManagementSummaryReportsApi {
		protected basePath = 'https://api-na.myconnectwise.net/v4_6_release/apis/3.0';
		public defaultHeaders : any = {};

		constructor(basePath?: string) {
			if (basePath) {
				this.basePath = basePath;
			}
		}

		/**
		 *
		 * Get Company Types Count
		 * @param id
		 * @param conditions
		 */
		public companyCompaniesIdManagementSummaryReportsCountGet (params: {  id: number; conditions?: string; }, extraQueryParams?: any, extraFetchParams?: any ) : Promise<Count> {
			const localVarPath = this.basePath + '/company/companies/{id}/managementSummaryReports/count'
				.replace('{' + 'id' + '}', String(params.id));

			let queryParameters: any = assign({}, extraQueryParams);
			let headerParams: any = assign({}, this.defaultHeaders);
			// verify required parameter 'id' is set
			if (params.id == null) {
				throw new Error('Missing required parameter id when calling companyCompaniesIdManagementSummaryReportsCountGet');
			}
			if (params.conditions !== undefined) {
				queryParameters['conditions'] = params.conditions;
			}

			let fetchParams = {
				method: 'GET',
				headers: headerParams,

			};

			if (extraFetchParams) {
				fetchParams = assign(fetchParams, extraFetchParams);
			}

			let localVarPathWithQueryParameters = localVarPath + (localVarPath.indexOf('?') !== -1 ? '&' : '?') + querystring.stringify(queryParameters);

			return fetch(localVarPathWithQueryParameters, fetchParams).then((response) => {
				if (response.status >= 200 && response.status < 300) {
					return response.json();
				} else {
					let error = new Error(response.statusText);
					(error as any).response = response;
					throw error;
				}
			});
		}
		/**
		 *
		 * Get Management Summarys
		 * @param id
		 * @param conditions
		 * @param orderBy
		 * @param childconditions
		 * @param customfieldconditions
		 * @param page
		 * @param pageSize
		 */
		public companyCompaniesIdManagementSummaryReportsGet (params: {  id: number; conditions?: string; orderBy?: string; childconditions?: string; customfieldconditions?: string; page?: number; pageSize?: number; }, extraQueryParams?: any, extraFetchParams?: any ) : Promise<Array<CompanyManagementSummary>> {
			const localVarPath = this.basePath + '/company/companies/{id}/managementSummaryReports'
				.replace('{' + 'id' + '}', String(params.id));

			let queryParameters: any = assign({}, extraQueryParams);
			let headerParams: any = assign({}, this.defaultHeaders);
			// verify required parameter 'id' is set
			if (params.id == null) {
				throw new Error('Missing required parameter id when calling companyCompaniesIdManagementSummaryReportsGet');
			}
			if (params.conditions !== undefined) {
				queryParameters['conditions'] = params.conditions;
			}

			if (params.orderBy !== undefined) {
				queryParameters['orderBy'] = params.orderBy;
			}

			if (params.childconditions !== undefined) {
				queryParameters['childconditions'] = params.childconditions;
			}

			if (params.customfieldconditions !== undefined) {
				queryParameters['customfieldconditions'] = params.customfieldconditions;
			}

			if (params.page !== undefined) {
				queryParameters['page'] = params.page;
			}

			if (params.pageSize !== undefined) {
				queryParameters['pageSize'] = params.pageSize;
			}

			let fetchParams = {
				method: 'GET',
				headers: headerParams,

			};

			if (extraFetchParams) {
				fetchParams = assign(fetchParams, extraFetchParams);
			}

			let localVarPathWithQueryParameters = localVarPath + (localVarPath.indexOf('?') !== -1 ? '&' : '?') + querystring.stringify(queryParameters);

			return fetch(localVarPathWithQueryParameters, fetchParams).then((response) => {
				if (response.status >= 200 && response.status < 300) {
					return response.json();
				} else {
					let error = new Error(response.statusText);
					(error as any).response = response;
					throw error;
				}
			});
		}
		/**
		 *
		 * Create Management Summary
		 * @param id
		 * @param managementSummary
		 */
		public companyCompaniesIdManagementSummaryReportsPost (params: {  id: number; managementSummary: CompanyManagementSummary; }, extraQueryParams?: any, extraFetchParams?: any ) : Promise<CompanyManagementSummary> {
			const localVarPath = this.basePath + '/company/companies/{id}/managementSummaryReports'
				.replace('{' + 'id' + '}', String(params.id));

			let queryParameters: any = assign({}, extraQueryParams);
			let headerParams: any = assign({}, this.defaultHeaders);
			headerParams['Content-Type'] = 'application/json';

			// verify required parameter 'id' is set
			if (params.id == null) {
				throw new Error('Missing required parameter id when calling companyCompaniesIdManagementSummaryReportsPost');
			}
			// verify required parameter 'managementSummary' is set
			if (params.managementSummary == null) {
				throw new Error('Missing required parameter managementSummary when calling companyCompaniesIdManagementSummaryReportsPost');
			}
			let fetchParams = {
				method: 'POST',
				headers: headerParams,
				body: JSON.stringify(params.managementSummary),

			};

			if (extraFetchParams) {
				fetchParams = assign(fetchParams, extraFetchParams);
			}

			let localVarPathWithQueryParameters = localVarPath + (localVarPath.indexOf('?') !== -1 ? '&' : '?') + querystring.stringify(queryParameters);

			return fetch(localVarPathWithQueryParameters, fetchParams).then((response) => {
				if (response.status >= 200 && response.status < 300) {
					return response.json();
				} else {
					let error = new Error(response.statusText);
					(error as any).response = response;
					throw error;
				}
			});
		}
		/**
		 *
		 * Delete Management Summary By Id
		 * @param id
		 * @param reportId
		 */
		public companyCompaniesIdManagementSummaryReportsReportIdDelete (params: {  id: number; reportId: number; }, extraQueryParams?: any, extraFetchParams?: any ) : Promise<{}> {
			const localVarPath = this.basePath + '/company/companies/{id}/managementSummaryReports/{reportId}'
				.replace('{' + 'id' + '}', String(params.id))
				.replace('{' + 'reportId' + '}', String(params.reportId));

			let queryParameters: any = assign({}, extraQueryParams);
			let headerParams: any = assign({}, this.defaultHeaders);
			// verify required parameter 'id' is set
			if (params.id == null) {
				throw new Error('Missing required parameter id when calling companyCompaniesIdManagementSummaryReportsReportIdDelete');
			}
			// verify required parameter 'reportId' is set
			if (params.reportId == null) {
				throw new Error('Missing required parameter reportId when calling companyCompaniesIdManagementSummaryReportsReportIdDelete');
			}
			let fetchParams = {
				method: 'DELETE',
				headers: headerParams,

			};

			if (extraFetchParams) {
				fetchParams = assign(fetchParams, extraFetchParams);
			}

			let localVarPathWithQueryParameters = localVarPath + (localVarPath.indexOf('?') !== -1 ? '&' : '?') + querystring.stringify(queryParameters);

			return fetch(localVarPathWithQueryParameters, fetchParams).then((response) => {
				if (response.status >= 200 && response.status < 300) {
					return response.json();
				} else {
					let error = new Error(response.statusText);
					(error as any).response = response;
					throw error;
				}
			});
		}
		/**
		 *
		 * Get Management Summary By Id
		 * @param id
		 * @param reportId
		 */
		public companyCompaniesIdManagementSummaryReportsReportIdGet (params: {  id: number; reportId: number; }, extraQueryParams?: any, extraFetchParams?: any ) : Promise<CompanyManagementSummary> {
			const localVarPath = this.basePath + '/company/companies/{id}/managementSummaryReports/{reportId}'
				.replace('{' + 'id' + '}', String(params.id))
				.replace('{' + 'reportId' + '}', String(params.reportId));

			let queryParameters: any = assign({}, extraQueryParams);
			let headerParams: any = assign({}, this.defaultHeaders);
			// verify required parameter 'id' is set
			if (params.id == null) {
				throw new Error('Missing required parameter id when calling companyCompaniesIdManagementSummaryReportsReportIdGet');
			}
			// verify required parameter 'reportId' is set
			if (params.reportId == null) {
				throw new Error('Missing required parameter reportId when calling companyCompaniesIdManagementSummaryReportsReportIdGet');
			}
			let fetchParams = {
				method: 'GET',
				headers: headerParams,

			};

			if (extraFetchParams) {
				fetchParams = assign(fetchParams, extraFetchParams);
			}

			let localVarPathWithQueryParameters = localVarPath + (localVarPath.indexOf('?') !== -1 ? '&' : '?') + querystring.stringify(queryParameters);

			return fetch(localVarPathWithQueryParameters, fetchParams).then((response) => {
				if (response.status >= 200 && response.status < 300) {
					return response.json();
				} else {
					let error = new Error(response.statusText);
					(error as any).response = response;
					throw error;
				}
			});
		}
		/**
		 *
		 * Update Management Summary
		 * @param id
		 * @param reportId
		 * @param operations
		 */
		public companyCompaniesIdManagementSummaryReportsReportIdPatch (params: {  id: number; reportId: number; operations: Array<PatchOperation>; }, extraQueryParams?: any, extraFetchParams?: any ) : Promise<CompanyManagementSummary> {
			const localVarPath = this.basePath + '/company/companies/{id}/managementSummaryReports/{reportId}'
				.replace('{' + 'id' + '}', String(params.id))
				.replace('{' + 'reportId' + '}', String(params.reportId));

			let queryParameters: any = assign({}, extraQueryParams);
			let headerParams: any = assign({}, this.defaultHeaders);
			headerParams['Content-Type'] = 'application/json';

			// verify required parameter 'id' is set
			if (params.id == null) {
				throw new Error('Missing required parameter id when calling companyCompaniesIdManagementSummaryReportsReportIdPatch');
			}
			// verify required parameter 'reportId' is set
			if (params.reportId == null) {
				throw new Error('Missing required parameter reportId when calling companyCompaniesIdManagementSummaryReportsReportIdPatch');
			}
			// verify required parameter 'operations' is set
			if (params.operations == null) {
				throw new Error('Missing required parameter operations when calling companyCompaniesIdManagementSummaryReportsReportIdPatch');
			}
			let fetchParams = {
				method: 'PATCH',
				headers: headerParams,
				body: JSON.stringify(params.operations),

			};

			if (extraFetchParams) {
				fetchParams = assign(fetchParams, extraFetchParams);
			}

			let localVarPathWithQueryParameters = localVarPath + (localVarPath.indexOf('?') !== -1 ? '&' : '?') + querystring.stringify(queryParameters);

			return fetch(localVarPathWithQueryParameters, fetchParams).then((response) => {
				if (response.status >= 200 && response.status < 300) {
					return response.json();
				} else {
					let error = new Error(response.statusText);
					(error as any).response = response;
					throw error;
				}
			});
		}
		/**
		 *
		 * Replace Management Summary
		 * @param id
		 * @param reportId
		 * @param managementSummary
		 */
		public companyCompaniesIdManagementSummaryReportsReportIdPut (params: {  id: number; reportId: number; managementSummary: CompanyManagementSummary; }, extraQueryParams?: any, extraFetchParams?: any ) : Promise<CompanyManagementSummary> {
			const localVarPath = this.basePath + '/company/companies/{id}/managementSummaryReports/{reportId}'
				.replace('{' + 'id' + '}', String(params.id))
				.replace('{' + 'reportId' + '}', String(params.reportId));

			let queryParameters: any = assign({}, extraQueryParams);
			let headerParams: any = assign({}, this.defaultHeaders);
			headerParams['Content-Type'] = 'application/json';

			// verify required parameter 'id' is set
			if (params.id == null) {
				throw new Error('Missing required parameter id when calling companyCompaniesIdManagementSummaryReportsReportIdPut');
			}
			// verify required parameter 'reportId' is set
			if (params.reportId == null) {
				throw new Error('Missing required parameter reportId when calling companyCompaniesIdManagementSummaryReportsReportIdPut');
			}
			// verify required parameter 'managementSummary' is set
			if (params.managementSummary == null) {
				throw new Error('Missing required parameter managementSummary when calling companyCompaniesIdManagementSummaryReportsReportIdPut');
			}
			let fetchParams = {
				method: 'PUT',
				headers: headerParams,
				body: JSON.stringify(params.managementSummary),

			};

			if (extraFetchParams) {
				fetchParams = assign(fetchParams, extraFetchParams);
			}

			let localVarPathWithQueryParameters = localVarPath + (localVarPath.indexOf('?') !== -1 ? '&' : '?') + querystring.stringify(queryParameters);

			return fetch(localVarPathWithQueryParameters, fetchParams).then((response) => {
				if (response.status >= 200 && response.status < 300) {
					return response.json();
				} else {
					let error = new Error(response.statusText);
					(error as any).response = response;
					throw error;
				}
			});
		}
	}
//}
//export namespace  {
	'use strict';

	export class CompanyNoteTypesApi {
		protected basePath = 'https://api-na.myconnectwise.net/v4_6_release/apis/3.0';
		public defaultHeaders : any = {};

		constructor(basePath?: string) {
			if (basePath) {
				this.basePath = basePath;
			}
		}

		/**
		 *
		 * Get Note Type Count
		 * @param conditions
		 */
		public companyNoteTypesCountGet (params: {  conditions?: string; }, extraQueryParams?: any, extraFetchParams?: any ) : Promise<Count> {
			const localVarPath = this.basePath + '/company/noteTypes/count';

			let queryParameters: any = assign({}, extraQueryParams);
			let headerParams: any = assign({}, this.defaultHeaders);
			if (params.conditions !== undefined) {
				queryParameters['conditions'] = params.conditions;
			}

			let fetchParams = {
				method: 'GET',
				headers: headerParams,

			};

			if (extraFetchParams) {
				fetchParams = assign(fetchParams, extraFetchParams);
			}

			let localVarPathWithQueryParameters = localVarPath + (localVarPath.indexOf('?') !== -1 ? '&' : '?') + querystring.stringify(queryParameters);

			return fetch(localVarPathWithQueryParameters, fetchParams).then((response) => {
				if (response.status >= 200 && response.status < 300) {
					return response.json();
				} else {
					let error = new Error(response.statusText);
					(error as any).response = response;
					throw error;
				}
			});
		}
		/**
		 *
		 * Get Note Type
		 * @param conditions
		 * @param orderBy
		 * @param childconditions
		 * @param customfieldconditions
		 * @param page
		 * @param pageSize
		 */
		public companyNoteTypesGet (params: {  conditions?: string; orderBy?: string; childconditions?: string; customfieldconditions?: string; page?: number; pageSize?: number; }, extraQueryParams?: any, extraFetchParams?: any ) : Promise<Array<NoteType>> {
			const localVarPath = this.basePath + '/company/noteTypes';

			let queryParameters: any = assign({}, extraQueryParams);
			let headerParams: any = assign({}, this.defaultHeaders);
			if (params.conditions !== undefined) {
				queryParameters['conditions'] = params.conditions;
			}

			if (params.orderBy !== undefined) {
				queryParameters['orderBy'] = params.orderBy;
			}

			if (params.childconditions !== undefined) {
				queryParameters['childconditions'] = params.childconditions;
			}

			if (params.customfieldconditions !== undefined) {
				queryParameters['customfieldconditions'] = params.customfieldconditions;
			}

			if (params.page !== undefined) {
				queryParameters['page'] = params.page;
			}

			if (params.pageSize !== undefined) {
				queryParameters['pageSize'] = params.pageSize;
			}

			let fetchParams = {
				method: 'GET',
				headers: headerParams,

			};

			if (extraFetchParams) {
				fetchParams = assign(fetchParams, extraFetchParams);
			}

			let localVarPathWithQueryParameters = localVarPath + (localVarPath.indexOf('?') !== -1 ? '&' : '?') + querystring.stringify(queryParameters);

			return fetch(localVarPathWithQueryParameters, fetchParams).then((response) => {
				if (response.status >= 200 && response.status < 300) {
					return response.json();
				} else {
					let error = new Error(response.statusText);
					(error as any).response = response;
					throw error;
				}
			});
		}
		/**
		 *
		 * Delete Note Type By Id
		 * @param id
		 */
		public companyNoteTypesIdDelete (params: {  id: number; }, extraQueryParams?: any, extraFetchParams?: any ) : Promise<{}> {
			const localVarPath = this.basePath + '/company/noteTypes/{id}'
				.replace('{' + 'id' + '}', String(params.id));

			let queryParameters: any = assign({}, extraQueryParams);
			let headerParams: any = assign({}, this.defaultHeaders);
			// verify required parameter 'id' is set
			if (params.id == null) {
				throw new Error('Missing required parameter id when calling companyNoteTypesIdDelete');
			}
			let fetchParams = {
				method: 'DELETE',
				headers: headerParams,

			};

			if (extraFetchParams) {
				fetchParams = assign(fetchParams, extraFetchParams);
			}

			let localVarPathWithQueryParameters = localVarPath + (localVarPath.indexOf('?') !== -1 ? '&' : '?') + querystring.stringify(queryParameters);

			return fetch(localVarPathWithQueryParameters, fetchParams).then((response) => {
				if (response.status >= 200 && response.status < 300) {
					return response.json();
				} else {
					let error = new Error(response.statusText);
					(error as any).response = response;
					throw error;
				}
			});
		}
		/**
		 *
		 * Get Note Type By Id
		 * @param id
		 */
		public companyNoteTypesIdGet (params: {  id: number; }, extraQueryParams?: any, extraFetchParams?: any ) : Promise<NoteType> {
			const localVarPath = this.basePath + '/company/noteTypes/{id}'
				.replace('{' + 'id' + '}', String(params.id));

			let queryParameters: any = assign({}, extraQueryParams);
			let headerParams: any = assign({}, this.defaultHeaders);
			// verify required parameter 'id' is set
			if (params.id == null) {
				throw new Error('Missing required parameter id when calling companyNoteTypesIdGet');
			}
			let fetchParams = {
				method: 'GET',
				headers: headerParams,

			};

			if (extraFetchParams) {
				fetchParams = assign(fetchParams, extraFetchParams);
			}

			let localVarPathWithQueryParameters = localVarPath + (localVarPath.indexOf('?') !== -1 ? '&' : '?') + querystring.stringify(queryParameters);

			return fetch(localVarPathWithQueryParameters, fetchParams).then((response) => {
				if (response.status >= 200 && response.status < 300) {
					return response.json();
				} else {
					let error = new Error(response.statusText);
					(error as any).response = response;
					throw error;
				}
			});
		}
		/**
		 *
		 * Update Note Type
		 * @param id
		 * @param operations
		 */
		public companyNoteTypesIdPatch (params: {  id: number; operations: Array<PatchOperation>; }, extraQueryParams?: any, extraFetchParams?: any ) : Promise<NoteType> {
			const localVarPath = this.basePath + '/company/noteTypes/{id}'
				.replace('{' + 'id' + '}', String(params.id));

			let queryParameters: any = assign({}, extraQueryParams);
			let headerParams: any = assign({}, this.defaultHeaders);
			headerParams['Content-Type'] = 'application/json';

			// verify required parameter 'id' is set
			if (params.id == null) {
				throw new Error('Missing required parameter id when calling companyNoteTypesIdPatch');
			}
			// verify required parameter 'operations' is set
			if (params.operations == null) {
				throw new Error('Missing required parameter operations when calling companyNoteTypesIdPatch');
			}
			let fetchParams = {
				method: 'PATCH',
				headers: headerParams,
				body: JSON.stringify(params.operations),

			};

			if (extraFetchParams) {
				fetchParams = assign(fetchParams, extraFetchParams);
			}

			let localVarPathWithQueryParameters = localVarPath + (localVarPath.indexOf('?') !== -1 ? '&' : '?') + querystring.stringify(queryParameters);

			return fetch(localVarPathWithQueryParameters, fetchParams).then((response) => {
				if (response.status >= 200 && response.status < 300) {
					return response.json();
				} else {
					let error = new Error(response.statusText);
					(error as any).response = response;
					throw error;
				}
			});
		}
		/**
		 *
		 * Replace Note Type
		 * @param id
		 * @param noteType
		 */
		public companyNoteTypesIdPut (params: {  id: number; noteType: NoteType; }, extraQueryParams?: any, extraFetchParams?: any ) : Promise<NoteType> {
			const localVarPath = this.basePath + '/company/noteTypes/{id}'
				.replace('{' + 'id' + '}', String(params.id));

			let queryParameters: any = assign({}, extraQueryParams);
			let headerParams: any = assign({}, this.defaultHeaders);
			headerParams['Content-Type'] = 'application/json';

			// verify required parameter 'id' is set
			if (params.id == null) {
				throw new Error('Missing required parameter id when calling companyNoteTypesIdPut');
			}
			// verify required parameter 'noteType' is set
			if (params.noteType == null) {
				throw new Error('Missing required parameter noteType when calling companyNoteTypesIdPut');
			}
			let fetchParams = {
				method: 'PUT',
				headers: headerParams,
				body: JSON.stringify(params.noteType),

			};

			if (extraFetchParams) {
				fetchParams = assign(fetchParams, extraFetchParams);
			}

			let localVarPathWithQueryParameters = localVarPath + (localVarPath.indexOf('?') !== -1 ? '&' : '?') + querystring.stringify(queryParameters);

			return fetch(localVarPathWithQueryParameters, fetchParams).then((response) => {
				if (response.status >= 200 && response.status < 300) {
					return response.json();
				} else {
					let error = new Error(response.statusText);
					(error as any).response = response;
					throw error;
				}
			});
		}
		/**
		 *
		 * Create Note Type
		 * @param noteType
		 */
		public companyNoteTypesPost (params: {  noteType: NoteType; }, extraQueryParams?: any, extraFetchParams?: any ) : Promise<NoteType> {
			const localVarPath = this.basePath + '/company/noteTypes';

			let queryParameters: any = assign({}, extraQueryParams);
			let headerParams: any = assign({}, this.defaultHeaders);
			headerParams['Content-Type'] = 'application/json';

			// verify required parameter 'noteType' is set
			if (params.noteType == null) {
				throw new Error('Missing required parameter noteType when calling companyNoteTypesPost');
			}
			let fetchParams = {
				method: 'POST',
				headers: headerParams,
				body: JSON.stringify(params.noteType),

			};

			if (extraFetchParams) {
				fetchParams = assign(fetchParams, extraFetchParams);
			}

			let localVarPathWithQueryParameters = localVarPath + (localVarPath.indexOf('?') !== -1 ? '&' : '?') + querystring.stringify(queryParameters);

			return fetch(localVarPathWithQueryParameters, fetchParams).then((response) => {
				if (response.status >= 200 && response.status < 300) {
					return response.json();
				} else {
					let error = new Error(response.statusText);
					(error as any).response = response;
					throw error;
				}
			});
		}
	}
//}
//export namespace  {
	'use strict';

	export class CompanyNotesApi {
		protected basePath = 'https://api-na.myconnectwise.net/v4_6_release/apis/3.0';
		public defaultHeaders : any = {};

		constructor(basePath?: string) {
			if (basePath) {
				this.basePath = basePath;
			}
		}

		/**
		 *
		 * Get Company Notes Count
		 * @param id
		 * @param conditions
		 */
		public companyCompaniesIdNotesCountGet (params: {  id: number; conditions?: string; }, extraQueryParams?: any, extraFetchParams?: any ) : Promise<Count> {
			const localVarPath = this.basePath + '/company/companies/{id}/notes/count'
				.replace('{' + 'id' + '}', String(params.id));

			let queryParameters: any = assign({}, extraQueryParams);
			let headerParams: any = assign({}, this.defaultHeaders);
			// verify required parameter 'id' is set
			if (params.id == null) {
				throw new Error('Missing required parameter id when calling companyCompaniesIdNotesCountGet');
			}
			if (params.conditions !== undefined) {
				queryParameters['conditions'] = params.conditions;
			}

			let fetchParams = {
				method: 'GET',
				headers: headerParams,

			};

			if (extraFetchParams) {
				fetchParams = assign(fetchParams, extraFetchParams);
			}

			let localVarPathWithQueryParameters = localVarPath + (localVarPath.indexOf('?') !== -1 ? '&' : '?') + querystring.stringify(queryParameters);

			return fetch(localVarPathWithQueryParameters, fetchParams).then((response) => {
				if (response.status >= 200 && response.status < 300) {
					return response.json();
				} else {
					let error = new Error(response.statusText);
					(error as any).response = response;
					throw error;
				}
			});
		}
		/**
		 *
		 * Get Company Notes
		 * @param id
		 * @param conditions
		 * @param orderBy
		 * @param childconditions
		 * @param customfieldconditions
		 * @param page
		 * @param pageSize
		 */
		public companyCompaniesIdNotesGet (params: {  id: number; conditions?: string; orderBy?: string; childconditions?: string; customfieldconditions?: string; page?: number; pageSize?: number; }, extraQueryParams?: any, extraFetchParams?: any ) : Promise<Array<CompanyNote>> {
			const localVarPath = this.basePath + '/company/companies/{id}/notes'
				.replace('{' + 'id' + '}', String(params.id));

			let queryParameters: any = assign({}, extraQueryParams);
			let headerParams: any = assign({}, this.defaultHeaders);
			// verify required parameter 'id' is set
			if (params.id == null) {
				throw new Error('Missing required parameter id when calling companyCompaniesIdNotesGet');
			}
			if (params.conditions !== undefined) {
				queryParameters['conditions'] = params.conditions;
			}

			if (params.orderBy !== undefined) {
				queryParameters['orderBy'] = params.orderBy;
			}

			if (params.childconditions !== undefined) {
				queryParameters['childconditions'] = params.childconditions;
			}

			if (params.customfieldconditions !== undefined) {
				queryParameters['customfieldconditions'] = params.customfieldconditions;
			}

			if (params.page !== undefined) {
				queryParameters['page'] = params.page;
			}

			if (params.pageSize !== undefined) {
				queryParameters['pageSize'] = params.pageSize;
			}

			let fetchParams = {
				method: 'GET',
				headers: headerParams,

			};

			if (extraFetchParams) {
				fetchParams = assign(fetchParams, extraFetchParams);
			}

			let localVarPathWithQueryParameters = localVarPath + (localVarPath.indexOf('?') !== -1 ? '&' : '?') + querystring.stringify(queryParameters);

			return fetch(localVarPathWithQueryParameters, fetchParams).then((response) => {
				if (response.status >= 200 && response.status < 300) {
					return response.json();
				} else {
					let error = new Error(response.statusText);
					(error as any).response = response;
					throw error;
				}
			});
		}
		/**
		 *
		 * Delete Company Note By Id
		 * @param id
		 * @param noteId
		 */
		public companyCompaniesIdNotesNoteIdDelete (params: {  id: number; noteId: number; }, extraQueryParams?: any, extraFetchParams?: any ) : Promise<{}> {
			const localVarPath = this.basePath + '/company/companies/{id}/notes/{noteId}'
				.replace('{' + 'id' + '}', String(params.id))
				.replace('{' + 'noteId' + '}', String(params.noteId));

			let queryParameters: any = assign({}, extraQueryParams);
			let headerParams: any = assign({}, this.defaultHeaders);
			// verify required parameter 'id' is set
			if (params.id == null) {
				throw new Error('Missing required parameter id when calling companyCompaniesIdNotesNoteIdDelete');
			}
			// verify required parameter 'noteId' is set
			if (params.noteId == null) {
				throw new Error('Missing required parameter noteId when calling companyCompaniesIdNotesNoteIdDelete');
			}
			let fetchParams = {
				method: 'DELETE',
				headers: headerParams,

			};

			if (extraFetchParams) {
				fetchParams = assign(fetchParams, extraFetchParams);
			}

			let localVarPathWithQueryParameters = localVarPath + (localVarPath.indexOf('?') !== -1 ? '&' : '?') + querystring.stringify(queryParameters);

			return fetch(localVarPathWithQueryParameters, fetchParams).then((response) => {
				if (response.status >= 200 && response.status < 300) {
					return response.json();
				} else {
					let error = new Error(response.statusText);
					(error as any).response = response;
					throw error;
				}
			});
		}
		/**
		 *
		 * Get Company Note By Id
		 * @param id
		 * @param noteId
		 */
		public companyCompaniesIdNotesNoteIdGet (params: {  id: number; noteId: number; }, extraQueryParams?: any, extraFetchParams?: any ) : Promise<CompanyNote> {
			const localVarPath = this.basePath + '/company/companies/{id}/notes/{noteId}'
				.replace('{' + 'id' + '}', String(params.id))
				.replace('{' + 'noteId' + '}', String(params.noteId));

			let queryParameters: any = assign({}, extraQueryParams);
			let headerParams: any = assign({}, this.defaultHeaders);
			// verify required parameter 'id' is set
			if (params.id == null) {
				throw new Error('Missing required parameter id when calling companyCompaniesIdNotesNoteIdGet');
			}
			// verify required parameter 'noteId' is set
			if (params.noteId == null) {
				throw new Error('Missing required parameter noteId when calling companyCompaniesIdNotesNoteIdGet');
			}
			let fetchParams = {
				method: 'GET',
				headers: headerParams,

			};

			if (extraFetchParams) {
				fetchParams = assign(fetchParams, extraFetchParams);
			}

			let localVarPathWithQueryParameters = localVarPath + (localVarPath.indexOf('?') !== -1 ? '&' : '?') + querystring.stringify(queryParameters);

			return fetch(localVarPathWithQueryParameters, fetchParams).then((response) => {
				if (response.status >= 200 && response.status < 300) {
					return response.json();
				} else {
					let error = new Error(response.statusText);
					(error as any).response = response;
					throw error;
				}
			});
		}
		/**
		 *
		 * Update Company Note
		 * @param id
		 * @param noteId
		 * @param operations
		 */
		public companyCompaniesIdNotesNoteIdPatch (params: {  id: number; noteId: number; operations: Array<PatchOperation>; }, extraQueryParams?: any, extraFetchParams?: any ) : Promise<CompanyNote> {
			const localVarPath = this.basePath + '/company/companies/{id}/notes/{noteId}'
				.replace('{' + 'id' + '}', String(params.id))
				.replace('{' + 'noteId' + '}', String(params.noteId));

			let queryParameters: any = assign({}, extraQueryParams);
			let headerParams: any = assign({}, this.defaultHeaders);
			headerParams['Content-Type'] = 'application/json';

			// verify required parameter 'id' is set
			if (params.id == null) {
				throw new Error('Missing required parameter id when calling companyCompaniesIdNotesNoteIdPatch');
			}
			// verify required parameter 'noteId' is set
			if (params.noteId == null) {
				throw new Error('Missing required parameter noteId when calling companyCompaniesIdNotesNoteIdPatch');
			}
			// verify required parameter 'operations' is set
			if (params.operations == null) {
				throw new Error('Missing required parameter operations when calling companyCompaniesIdNotesNoteIdPatch');
			}
			let fetchParams = {
				method: 'PATCH',
				headers: headerParams,
				body: JSON.stringify(params.operations),

			};

			if (extraFetchParams) {
				fetchParams = assign(fetchParams, extraFetchParams);
			}

			let localVarPathWithQueryParameters = localVarPath + (localVarPath.indexOf('?') !== -1 ? '&' : '?') + querystring.stringify(queryParameters);

			return fetch(localVarPathWithQueryParameters, fetchParams).then((response) => {
				if (response.status >= 200 && response.status < 300) {
					return response.json();
				} else {
					let error = new Error(response.statusText);
					(error as any).response = response;
					throw error;
				}
			});
		}
		/**
		 *
		 * Replace Company Note
		 * @param id
		 * @param noteId
		 * @param companyNote
		 */
		public companyCompaniesIdNotesNoteIdPut (params: {  id: number; noteId: number; companyNote: CompanyNote; }, extraQueryParams?: any, extraFetchParams?: any ) : Promise<CompanyNote> {
			const localVarPath = this.basePath + '/company/companies/{id}/notes/{noteId}'
				.replace('{' + 'id' + '}', String(params.id))
				.replace('{' + 'noteId' + '}', String(params.noteId));

			let queryParameters: any = assign({}, extraQueryParams);
			let headerParams: any = assign({}, this.defaultHeaders);
			headerParams['Content-Type'] = 'application/json';

			// verify required parameter 'id' is set
			if (params.id == null) {
				throw new Error('Missing required parameter id when calling companyCompaniesIdNotesNoteIdPut');
			}
			// verify required parameter 'noteId' is set
			if (params.noteId == null) {
				throw new Error('Missing required parameter noteId when calling companyCompaniesIdNotesNoteIdPut');
			}
			// verify required parameter 'companyNote' is set
			if (params.companyNote == null) {
				throw new Error('Missing required parameter companyNote when calling companyCompaniesIdNotesNoteIdPut');
			}
			let fetchParams = {
				method: 'PUT',
				headers: headerParams,
				body: JSON.stringify(params.companyNote),

			};

			if (extraFetchParams) {
				fetchParams = assign(fetchParams, extraFetchParams);
			}

			let localVarPathWithQueryParameters = localVarPath + (localVarPath.indexOf('?') !== -1 ? '&' : '?') + querystring.stringify(queryParameters);

			return fetch(localVarPathWithQueryParameters, fetchParams).then((response) => {
				if (response.status >= 200 && response.status < 300) {
					return response.json();
				} else {
					let error = new Error(response.statusText);
					(error as any).response = response;
					throw error;
				}
			});
		}
		/**
		 *
		 * Create Company Note
		 * @param id
		 * @param companyNote
		 */
		public companyCompaniesIdNotesPost (params: {  id: number; companyNote: CompanyNote; }, extraQueryParams?: any, extraFetchParams?: any ) : Promise<CompanyNote> {
			const localVarPath = this.basePath + '/company/companies/{id}/notes'
				.replace('{' + 'id' + '}', String(params.id));

			let queryParameters: any = assign({}, extraQueryParams);
			let headerParams: any = assign({}, this.defaultHeaders);
			headerParams['Content-Type'] = 'application/json';

			// verify required parameter 'id' is set
			if (params.id == null) {
				throw new Error('Missing required parameter id when calling companyCompaniesIdNotesPost');
			}
			// verify required parameter 'companyNote' is set
			if (params.companyNote == null) {
				throw new Error('Missing required parameter companyNote when calling companyCompaniesIdNotesPost');
			}
			let fetchParams = {
				method: 'POST',
				headers: headerParams,
				body: JSON.stringify(params.companyNote),

			};

			if (extraFetchParams) {
				fetchParams = assign(fetchParams, extraFetchParams);
			}

			let localVarPathWithQueryParameters = localVarPath + (localVarPath.indexOf('?') !== -1 ? '&' : '?') + querystring.stringify(queryParameters);

			return fetch(localVarPathWithQueryParameters, fetchParams).then((response) => {
				if (response.status >= 200 && response.status < 300) {
					return response.json();
				} else {
					let error = new Error(response.statusText);
					(error as any).response = response;
					throw error;
				}
			});
		}
	}
//}
//export namespace  {
	'use strict';

	export class CompanySitesApi {
		protected basePath = 'https://api-na.myconnectwise.net/v4_6_release/apis/3.0';
		public defaultHeaders : any = {};

		constructor(basePath?: string) {
			if (basePath) {
				this.basePath = basePath;
			}
		}

		/**
		 *
		 * Get Sites Count
		 * @param id
		 * @param conditions
		 */
		public companyCompaniesIdSitesCountGet (params: {  id: number; conditions?: string; }, extraQueryParams?: any, extraFetchParams?: any ) : Promise<Count> {
			const localVarPath = this.basePath + '/company/companies/{id}/sites/count'
				.replace('{' + 'id' + '}', String(params.id));

			let queryParameters: any = assign({}, extraQueryParams);
			let headerParams: any = assign({}, this.defaultHeaders);
			// verify required parameter 'id' is set
			if (params.id == null) {
				throw new Error('Missing required parameter id when calling companyCompaniesIdSitesCountGet');
			}
			if (params.conditions !== undefined) {
				queryParameters['conditions'] = params.conditions;
			}

			let fetchParams = {
				method: 'GET',
				headers: headerParams,

			};

			if (extraFetchParams) {
				fetchParams = assign(fetchParams, extraFetchParams);
			}

			let localVarPathWithQueryParameters = localVarPath + (localVarPath.indexOf('?') !== -1 ? '&' : '?') + querystring.stringify(queryParameters);

			return fetch(localVarPathWithQueryParameters, fetchParams).then((response) => {
				if (response.status >= 200 && response.status < 300) {
					return response.json();
				} else {
					let error = new Error(response.statusText);
					(error as any).response = response;
					throw error;
				}
			});
		}
		/**
		 *
		 * Get Sites
		 * @param id
		 * @param conditions
		 * @param orderBy
		 * @param childconditions
		 * @param customfieldconditions
		 * @param page
		 * @param pageSize
		 */
		public companyCompaniesIdSitesGet (params: {  id: number; conditions?: string; orderBy?: string; childconditions?: string; customfieldconditions?: string; page?: number; pageSize?: number; }, extraQueryParams?: any, extraFetchParams?: any ) : Promise<Array<CompanySite>> {
			const localVarPath = this.basePath + '/company/companies/{id}/sites'
				.replace('{' + 'id' + '}', String(params.id));

			let queryParameters: any = assign({}, extraQueryParams);
			let headerParams: any = assign({}, this.defaultHeaders);
			// verify required parameter 'id' is set
			if (params.id == null) {
				throw new Error('Missing required parameter id when calling companyCompaniesIdSitesGet');
			}
			if (params.conditions !== undefined) {
				queryParameters['conditions'] = params.conditions;
			}

			if (params.orderBy !== undefined) {
				queryParameters['orderBy'] = params.orderBy;
			}

			if (params.childconditions !== undefined) {
				queryParameters['childconditions'] = params.childconditions;
			}

			if (params.customfieldconditions !== undefined) {
				queryParameters['customfieldconditions'] = params.customfieldconditions;
			}

			if (params.page !== undefined) {
				queryParameters['page'] = params.page;
			}

			if (params.pageSize !== undefined) {
				queryParameters['pageSize'] = params.pageSize;
			}

			let fetchParams = {
				method: 'GET',
				headers: headerParams,

			};

			if (extraFetchParams) {
				fetchParams = assign(fetchParams, extraFetchParams);
			}

			let localVarPathWithQueryParameters = localVarPath + (localVarPath.indexOf('?') !== -1 ? '&' : '?') + querystring.stringify(queryParameters);

			return fetch(localVarPathWithQueryParameters, fetchParams).then((response) => {
				if (response.status >= 200 && response.status < 300) {
					return response.json();
				} else {
					let error = new Error(response.statusText);
					(error as any).response = response;
					throw error;
				}
			});
		}
		/**
		 *
		 * Create Site
		 * @param id
		 * @param site
		 */
		public companyCompaniesIdSitesPost (params: {  id: number; site: CompanySite; }, extraQueryParams?: any, extraFetchParams?: any ) : Promise<CompanySite> {
			const localVarPath = this.basePath + '/company/companies/{id}/sites'
				.replace('{' + 'id' + '}', String(params.id));

			let queryParameters: any = assign({}, extraQueryParams);
			let headerParams: any = assign({}, this.defaultHeaders);
			headerParams['Content-Type'] = 'application/json';

			// verify required parameter 'id' is set
			if (params.id == null) {
				throw new Error('Missing required parameter id when calling companyCompaniesIdSitesPost');
			}
			// verify required parameter 'site' is set
			if (params.site == null) {
				throw new Error('Missing required parameter site when calling companyCompaniesIdSitesPost');
			}
			let fetchParams = {
				method: 'POST',
				headers: headerParams,
				body: JSON.stringify(params.site),

			};

			if (extraFetchParams) {
				fetchParams = assign(fetchParams, extraFetchParams);
			}

			let localVarPathWithQueryParameters = localVarPath + (localVarPath.indexOf('?') !== -1 ? '&' : '?') + querystring.stringify(queryParameters);

			return fetch(localVarPathWithQueryParameters, fetchParams).then((response) => {
				if (response.status >= 200 && response.status < 300) {
					return response.json();
				} else {
					let error = new Error(response.statusText);
					(error as any).response = response;
					throw error;
				}
			});
		}
		/**
		 *
		 * Delete Site By Id
		 * @param id
		 * @param siteId
		 */
		public companyCompaniesIdSitesSiteIdDelete (params: {  id: number; siteId: number; }, extraQueryParams?: any, extraFetchParams?: any ) : Promise<{}> {
			const localVarPath = this.basePath + '/company/companies/{id}/sites/{siteId}'
				.replace('{' + 'id' + '}', String(params.id))
				.replace('{' + 'siteId' + '}', String(params.siteId));

			let queryParameters: any = assign({}, extraQueryParams);
			let headerParams: any = assign({}, this.defaultHeaders);
			// verify required parameter 'id' is set
			if (params.id == null) {
				throw new Error('Missing required parameter id when calling companyCompaniesIdSitesSiteIdDelete');
			}
			// verify required parameter 'siteId' is set
			if (params.siteId == null) {
				throw new Error('Missing required parameter siteId when calling companyCompaniesIdSitesSiteIdDelete');
			}
			let fetchParams = {
				method: 'DELETE',
				headers: headerParams,

			};

			if (extraFetchParams) {
				fetchParams = assign(fetchParams, extraFetchParams);
			}

			let localVarPathWithQueryParameters = localVarPath + (localVarPath.indexOf('?') !== -1 ? '&' : '?') + querystring.stringify(queryParameters);

			return fetch(localVarPathWithQueryParameters, fetchParams).then((response) => {
				if (response.status >= 200 && response.status < 300) {
					return response.json();
				} else {
					let error = new Error(response.statusText);
					(error as any).response = response;
					throw error;
				}
			});
		}
		/**
		 *
		 * Get Site By Id
		 * @param id
		 * @param siteId
		 */
		public companyCompaniesIdSitesSiteIdGet (params: {  id: number; siteId: number; }, extraQueryParams?: any, extraFetchParams?: any ) : Promise<CompanySite> {
			const localVarPath = this.basePath + '/company/companies/{id}/sites/{siteId}'
				.replace('{' + 'id' + '}', String(params.id))
				.replace('{' + 'siteId' + '}', String(params.siteId));

			let queryParameters: any = assign({}, extraQueryParams);
			let headerParams: any = assign({}, this.defaultHeaders);
			// verify required parameter 'id' is set
			if (params.id == null) {
				throw new Error('Missing required parameter id when calling companyCompaniesIdSitesSiteIdGet');
			}
			// verify required parameter 'siteId' is set
			if (params.siteId == null) {
				throw new Error('Missing required parameter siteId when calling companyCompaniesIdSitesSiteIdGet');
			}
			let fetchParams = {
				method: 'GET',
				headers: headerParams,

			};

			if (extraFetchParams) {
				fetchParams = assign(fetchParams, extraFetchParams);
			}

			let localVarPathWithQueryParameters = localVarPath + (localVarPath.indexOf('?') !== -1 ? '&' : '?') + querystring.stringify(queryParameters);

			return fetch(localVarPathWithQueryParameters, fetchParams).then((response) => {
				if (response.status >= 200 && response.status < 300) {
					return response.json();
				} else {
					let error = new Error(response.statusText);
					(error as any).response = response;
					throw error;
				}
			});
		}
		/**
		 *
		 * Update Site
		 * @param id
		 * @param siteId
		 * @param operations
		 */
		public companyCompaniesIdSitesSiteIdPatch (params: {  id: number; siteId: number; operations: Array<PatchOperation>; }, extraQueryParams?: any, extraFetchParams?: any ) : Promise<CompanySite> {
			const localVarPath = this.basePath + '/company/companies/{id}/sites/{siteId}'
				.replace('{' + 'id' + '}', String(params.id))
				.replace('{' + 'siteId' + '}', String(params.siteId));

			let queryParameters: any = assign({}, extraQueryParams);
			let headerParams: any = assign({}, this.defaultHeaders);
			headerParams['Content-Type'] = 'application/json';

			// verify required parameter 'id' is set
			if (params.id == null) {
				throw new Error('Missing required parameter id when calling companyCompaniesIdSitesSiteIdPatch');
			}
			// verify required parameter 'siteId' is set
			if (params.siteId == null) {
				throw new Error('Missing required parameter siteId when calling companyCompaniesIdSitesSiteIdPatch');
			}
			// verify required parameter 'operations' is set
			if (params.operations == null) {
				throw new Error('Missing required parameter operations when calling companyCompaniesIdSitesSiteIdPatch');
			}
			let fetchParams = {
				method: 'PATCH',
				headers: headerParams,
				body: JSON.stringify(params.operations),

			};

			if (extraFetchParams) {
				fetchParams = assign(fetchParams, extraFetchParams);
			}

			let localVarPathWithQueryParameters = localVarPath + (localVarPath.indexOf('?') !== -1 ? '&' : '?') + querystring.stringify(queryParameters);

			return fetch(localVarPathWithQueryParameters, fetchParams).then((response) => {
				if (response.status >= 200 && response.status < 300) {
					return response.json();
				} else {
					let error = new Error(response.statusText);
					(error as any).response = response;
					throw error;
				}
			});
		}
		/**
		 *
		 * Replace Site
		 * @param id
		 * @param siteId
		 * @param site
		 */
		public companyCompaniesIdSitesSiteIdPut (params: {  id: number; siteId: number; site: CompanySite; }, extraQueryParams?: any, extraFetchParams?: any ) : Promise<CompanySite> {
			const localVarPath = this.basePath + '/company/companies/{id}/sites/{siteId}'
				.replace('{' + 'id' + '}', String(params.id))
				.replace('{' + 'siteId' + '}', String(params.siteId));

			let queryParameters: any = assign({}, extraQueryParams);
			let headerParams: any = assign({}, this.defaultHeaders);
			headerParams['Content-Type'] = 'application/json';

			// verify required parameter 'id' is set
			if (params.id == null) {
				throw new Error('Missing required parameter id when calling companyCompaniesIdSitesSiteIdPut');
			}
			// verify required parameter 'siteId' is set
			if (params.siteId == null) {
				throw new Error('Missing required parameter siteId when calling companyCompaniesIdSitesSiteIdPut');
			}
			// verify required parameter 'site' is set
			if (params.site == null) {
				throw new Error('Missing required parameter site when calling companyCompaniesIdSitesSiteIdPut');
			}
			let fetchParams = {
				method: 'PUT',
				headers: headerParams,
				body: JSON.stringify(params.site),

			};

			if (extraFetchParams) {
				fetchParams = assign(fetchParams, extraFetchParams);
			}

			let localVarPathWithQueryParameters = localVarPath + (localVarPath.indexOf('?') !== -1 ? '&' : '?') + querystring.stringify(queryParameters);

			return fetch(localVarPathWithQueryParameters, fetchParams).then((response) => {
				if (response.status >= 200 && response.status < 300) {
					return response.json();
				} else {
					let error = new Error(response.statusText);
					(error as any).response = response;
					throw error;
				}
			});
		}
	}
//}
//export namespace  {
	'use strict';

	export class CompanyStatusesApi {
		protected basePath = 'https://api-na.myconnectwise.net/v4_6_release/apis/3.0';
		public defaultHeaders : any = {};

		constructor(basePath?: string) {
			if (basePath) {
				this.basePath = basePath;
			}
		}

		/**
		 *
		 * Get Company Statuses Count
		 * @param conditions
		 */
		public companyCompaniesStatusesCountGet (params: {  conditions?: string; }, extraQueryParams?: any, extraFetchParams?: any ) : Promise<Count> {
			const localVarPath = this.basePath + '/company/companies/statuses/count';

			let queryParameters: any = assign({}, extraQueryParams);
			let headerParams: any = assign({}, this.defaultHeaders);
			if (params.conditions !== undefined) {
				queryParameters['conditions'] = params.conditions;
			}

			let fetchParams = {
				method: 'GET',
				headers: headerParams,

			};

			if (extraFetchParams) {
				fetchParams = assign(fetchParams, extraFetchParams);
			}

			let localVarPathWithQueryParameters = localVarPath + (localVarPath.indexOf('?') !== -1 ? '&' : '?') + querystring.stringify(queryParameters);

			return fetch(localVarPathWithQueryParameters, fetchParams).then((response) => {
				if (response.status >= 200 && response.status < 300) {
					return response.json();
				} else {
					let error = new Error(response.statusText);
					(error as any).response = response;
					throw error;
				}
			});
		}
		/**
		 *
		 * Get Company Statuses
		 * @param conditions
		 * @param orderBy
		 * @param childconditions
		 * @param customfieldconditions
		 * @param page
		 * @param pageSize
		 */
		public companyCompaniesStatusesGet (params: {  conditions?: string; orderBy?: string; childconditions?: string; customfieldconditions?: string; page?: number; pageSize?: number; }, extraQueryParams?: any, extraFetchParams?: any ) : Promise<Array<CompanyStatus>> {
			const localVarPath = this.basePath + '/company/companies/statuses';

			let queryParameters: any = assign({}, extraQueryParams);
			let headerParams: any = assign({}, this.defaultHeaders);
			if (params.conditions !== undefined) {
				queryParameters['conditions'] = params.conditions;
			}

			if (params.orderBy !== undefined) {
				queryParameters['orderBy'] = params.orderBy;
			}

			if (params.childconditions !== undefined) {
				queryParameters['childconditions'] = params.childconditions;
			}

			if (params.customfieldconditions !== undefined) {
				queryParameters['customfieldconditions'] = params.customfieldconditions;
			}

			if (params.page !== undefined) {
				queryParameters['page'] = params.page;
			}

			if (params.pageSize !== undefined) {
				queryParameters['pageSize'] = params.pageSize;
			}

			let fetchParams = {
				method: 'GET',
				headers: headerParams,

			};

			if (extraFetchParams) {
				fetchParams = assign(fetchParams, extraFetchParams);
			}

			let localVarPathWithQueryParameters = localVarPath + (localVarPath.indexOf('?') !== -1 ? '&' : '?') + querystring.stringify(queryParameters);

			return fetch(localVarPathWithQueryParameters, fetchParams).then((response) => {
				if (response.status >= 200 && response.status < 300) {
					return response.json();
				} else {
					let error = new Error(response.statusText);
					(error as any).response = response;
					throw error;
				}
			});
		}
		/**
		 *
		 * Delete Company Status By Id
		 * @param id
		 */
		public companyCompaniesStatusesIdDelete (params: {  id: number; }, extraQueryParams?: any, extraFetchParams?: any ) : Promise<{}> {
			const localVarPath = this.basePath + '/company/companies/statuses/{id}'
				.replace('{' + 'id' + '}', String(params.id));

			let queryParameters: any = assign({}, extraQueryParams);
			let headerParams: any = assign({}, this.defaultHeaders);
			// verify required parameter 'id' is set
			if (params.id == null) {
				throw new Error('Missing required parameter id when calling companyCompaniesStatusesIdDelete');
			}
			let fetchParams = {
				method: 'DELETE',
				headers: headerParams,

			};

			if (extraFetchParams) {
				fetchParams = assign(fetchParams, extraFetchParams);
			}

			let localVarPathWithQueryParameters = localVarPath + (localVarPath.indexOf('?') !== -1 ? '&' : '?') + querystring.stringify(queryParameters);

			return fetch(localVarPathWithQueryParameters, fetchParams).then((response) => {
				if (response.status >= 200 && response.status < 300) {
					return response.json();
				} else {
					let error = new Error(response.statusText);
					(error as any).response = response;
					throw error;
				}
			});
		}
		/**
		 *
		 * Get Company Status By Id
		 * @param id
		 */
		public companyCompaniesStatusesIdGet (params: {  id: number; }, extraQueryParams?: any, extraFetchParams?: any ) : Promise<CompanyStatus> {
			const localVarPath = this.basePath + '/company/companies/statuses/{id}'
				.replace('{' + 'id' + '}', String(params.id));

			let queryParameters: any = assign({}, extraQueryParams);
			let headerParams: any = assign({}, this.defaultHeaders);
			// verify required parameter 'id' is set
			if (params.id == null) {
				throw new Error('Missing required parameter id when calling companyCompaniesStatusesIdGet');
			}
			let fetchParams = {
				method: 'GET',
				headers: headerParams,

			};

			if (extraFetchParams) {
				fetchParams = assign(fetchParams, extraFetchParams);
			}

			let localVarPathWithQueryParameters = localVarPath + (localVarPath.indexOf('?') !== -1 ? '&' : '?') + querystring.stringify(queryParameters);

			return fetch(localVarPathWithQueryParameters, fetchParams).then((response) => {
				if (response.status >= 200 && response.status < 300) {
					return response.json();
				} else {
					let error = new Error(response.statusText);
					(error as any).response = response;
					throw error;
				}
			});
		}
		/**
		 *
		 * Update Company Status
		 * @param id
		 * @param operations
		 */
		public companyCompaniesStatusesIdPatch (params: {  id: number; operations: Array<PatchOperation>; }, extraQueryParams?: any, extraFetchParams?: any ) : Promise<CompanyStatus> {
			const localVarPath = this.basePath + '/company/companies/statuses/{id}'
				.replace('{' + 'id' + '}', String(params.id));

			let queryParameters: any = assign({}, extraQueryParams);
			let headerParams: any = assign({}, this.defaultHeaders);
			headerParams['Content-Type'] = 'application/json';

			// verify required parameter 'id' is set
			if (params.id == null) {
				throw new Error('Missing required parameter id when calling companyCompaniesStatusesIdPatch');
			}
			// verify required parameter 'operations' is set
			if (params.operations == null) {
				throw new Error('Missing required parameter operations when calling companyCompaniesStatusesIdPatch');
			}
			let fetchParams = {
				method: 'PATCH',
				headers: headerParams,
				body: JSON.stringify(params.operations),

			};

			if (extraFetchParams) {
				fetchParams = assign(fetchParams, extraFetchParams);
			}

			let localVarPathWithQueryParameters = localVarPath + (localVarPath.indexOf('?') !== -1 ? '&' : '?') + querystring.stringify(queryParameters);

			return fetch(localVarPathWithQueryParameters, fetchParams).then((response) => {
				if (response.status >= 200 && response.status < 300) {
					return response.json();
				} else {
					let error = new Error(response.statusText);
					(error as any).response = response;
					throw error;
				}
			});
		}
		/**
		 *
		 * Replace Company Status
		 * @param id
		 * @param companyStatus
		 */
		public companyCompaniesStatusesIdPut (params: {  id: number; companyStatus: CompanyStatus; }, extraQueryParams?: any, extraFetchParams?: any ) : Promise<CompanyStatus> {
			const localVarPath = this.basePath + '/company/companies/statuses/{id}'
				.replace('{' + 'id' + '}', String(params.id));

			let queryParameters: any = assign({}, extraQueryParams);
			let headerParams: any = assign({}, this.defaultHeaders);
			headerParams['Content-Type'] = 'application/json';

			// verify required parameter 'id' is set
			if (params.id == null) {
				throw new Error('Missing required parameter id when calling companyCompaniesStatusesIdPut');
			}
			// verify required parameter 'companyStatus' is set
			if (params.companyStatus == null) {
				throw new Error('Missing required parameter companyStatus when calling companyCompaniesStatusesIdPut');
			}
			let fetchParams = {
				method: 'PUT',
				headers: headerParams,
				body: JSON.stringify(params.companyStatus),

			};

			if (extraFetchParams) {
				fetchParams = assign(fetchParams, extraFetchParams);
			}

			let localVarPathWithQueryParameters = localVarPath + (localVarPath.indexOf('?') !== -1 ? '&' : '?') + querystring.stringify(queryParameters);

			return fetch(localVarPathWithQueryParameters, fetchParams).then((response) => {
				if (response.status >= 200 && response.status < 300) {
					return response.json();
				} else {
					let error = new Error(response.statusText);
					(error as any).response = response;
					throw error;
				}
			});
		}
		/**
		 *
		 * Create Company Status
		 * @param companyStatus
		 */
		public companyCompaniesStatusesPost (params: {  companyStatus: CompanyStatus; }, extraQueryParams?: any, extraFetchParams?: any ) : Promise<CompanyStatus> {
			const localVarPath = this.basePath + '/company/companies/statuses';

			let queryParameters: any = assign({}, extraQueryParams);
			let headerParams: any = assign({}, this.defaultHeaders);
			headerParams['Content-Type'] = 'application/json';

			// verify required parameter 'companyStatus' is set
			if (params.companyStatus == null) {
				throw new Error('Missing required parameter companyStatus when calling companyCompaniesStatusesPost');
			}
			let fetchParams = {
				method: 'POST',
				headers: headerParams,
				body: JSON.stringify(params.companyStatus),

			};

			if (extraFetchParams) {
				fetchParams = assign(fetchParams, extraFetchParams);
			}

			let localVarPathWithQueryParameters = localVarPath + (localVarPath.indexOf('?') !== -1 ? '&' : '?') + querystring.stringify(queryParameters);

			return fetch(localVarPathWithQueryParameters, fetchParams).then((response) => {
				if (response.status >= 200 && response.status < 300) {
					return response.json();
				} else {
					let error = new Error(response.statusText);
					(error as any).response = response;
					throw error;
				}
			});
		}
	}
//}
//export namespace  {
	'use strict';

	export class CompanyTeamsApi {
		protected basePath = 'https://api-na.myconnectwise.net/v4_6_release/apis/3.0';
		public defaultHeaders : any = {};

		constructor(basePath?: string) {
			if (basePath) {
				this.basePath = basePath;
			}
		}

		/**
		 *
		 * Get Company Teams Count
		 * @param id
		 * @param conditions
		 */
		public companyCompaniesIdTeamsCountGet (params: {  id: number; conditions?: string; }, extraQueryParams?: any, extraFetchParams?: any ) : Promise<Count> {
			const localVarPath = this.basePath + '/company/companies/{id}/teams/count'
				.replace('{' + 'id' + '}', String(params.id));

			let queryParameters: any = assign({}, extraQueryParams);
			let headerParams: any = assign({}, this.defaultHeaders);
			// verify required parameter 'id' is set
			if (params.id == null) {
				throw new Error('Missing required parameter id when calling companyCompaniesIdTeamsCountGet');
			}
			if (params.conditions !== undefined) {
				queryParameters['conditions'] = params.conditions;
			}

			let fetchParams = {
				method: 'GET',
				headers: headerParams,

			};

			if (extraFetchParams) {
				fetchParams = assign(fetchParams, extraFetchParams);
			}

			let localVarPathWithQueryParameters = localVarPath + (localVarPath.indexOf('?') !== -1 ? '&' : '?') + querystring.stringify(queryParameters);

			return fetch(localVarPathWithQueryParameters, fetchParams).then((response) => {
				if (response.status >= 200 && response.status < 300) {
					return response.json();
				} else {
					let error = new Error(response.statusText);
					(error as any).response = response;
					throw error;
				}
			});
		}
		/**
		 *
		 * Get Company Teams
		 * @param id
		 * @param conditions
		 * @param orderBy
		 * @param childconditions
		 * @param customfieldconditions
		 * @param page
		 * @param pageSize
		 */
		public companyCompaniesIdTeamsGet (params: {  id: number; conditions?: string; orderBy?: string; childconditions?: string; customfieldconditions?: string; page?: number; pageSize?: number; }, extraQueryParams?: any, extraFetchParams?: any ) : Promise<Array<CompanyTeam>> {
			const localVarPath = this.basePath + '/company/companies/{id}/teams'
				.replace('{' + 'id' + '}', String(params.id));

			let queryParameters: any = assign({}, extraQueryParams);
			let headerParams: any = assign({}, this.defaultHeaders);
			// verify required parameter 'id' is set
			if (params.id == null) {
				throw new Error('Missing required parameter id when calling companyCompaniesIdTeamsGet');
			}
			if (params.conditions !== undefined) {
				queryParameters['conditions'] = params.conditions;
			}

			if (params.orderBy !== undefined) {
				queryParameters['orderBy'] = params.orderBy;
			}

			if (params.childconditions !== undefined) {
				queryParameters['childconditions'] = params.childconditions;
			}

			if (params.customfieldconditions !== undefined) {
				queryParameters['customfieldconditions'] = params.customfieldconditions;
			}

			if (params.page !== undefined) {
				queryParameters['page'] = params.page;
			}

			if (params.pageSize !== undefined) {
				queryParameters['pageSize'] = params.pageSize;
			}

			let fetchParams = {
				method: 'GET',
				headers: headerParams,

			};

			if (extraFetchParams) {
				fetchParams = assign(fetchParams, extraFetchParams);
			}

			let localVarPathWithQueryParameters = localVarPath + (localVarPath.indexOf('?') !== -1 ? '&' : '?') + querystring.stringify(queryParameters);

			return fetch(localVarPathWithQueryParameters, fetchParams).then((response) => {
				if (response.status >= 200 && response.status < 300) {
					return response.json();
				} else {
					let error = new Error(response.statusText);
					(error as any).response = response;
					throw error;
				}
			});
		}
		/**
		 *
		 * Create Company Team
		 * @param id
		 * @param companyTeam
		 */
		public companyCompaniesIdTeamsPost (params: {  id: number; companyTeam: CompanyTeam; }, extraQueryParams?: any, extraFetchParams?: any ) : Promise<CompanyTeam> {
			const localVarPath = this.basePath + '/company/companies/{id}/teams'
				.replace('{' + 'id' + '}', String(params.id));

			let queryParameters: any = assign({}, extraQueryParams);
			let headerParams: any = assign({}, this.defaultHeaders);
			headerParams['Content-Type'] = 'application/json';

			// verify required parameter 'id' is set
			if (params.id == null) {
				throw new Error('Missing required parameter id when calling companyCompaniesIdTeamsPost');
			}
			// verify required parameter 'companyTeam' is set
			if (params.companyTeam == null) {
				throw new Error('Missing required parameter companyTeam when calling companyCompaniesIdTeamsPost');
			}
			let fetchParams = {
				method: 'POST',
				headers: headerParams,
				body: JSON.stringify(params.companyTeam),

			};

			if (extraFetchParams) {
				fetchParams = assign(fetchParams, extraFetchParams);
			}

			let localVarPathWithQueryParameters = localVarPath + (localVarPath.indexOf('?') !== -1 ? '&' : '?') + querystring.stringify(queryParameters);

			return fetch(localVarPathWithQueryParameters, fetchParams).then((response) => {
				if (response.status >= 200 && response.status < 300) {
					return response.json();
				} else {
					let error = new Error(response.statusText);
					(error as any).response = response;
					throw error;
				}
			});
		}
		/**
		 *
		 * Delete Company Team By Id
		 * @param id
		 * @param teamId
		 */
		public companyCompaniesIdTeamsTeamIdDelete (params: {  id: number; teamId: number; }, extraQueryParams?: any, extraFetchParams?: any ) : Promise<{}> {
			const localVarPath = this.basePath + '/company/companies/{id}/teams/{teamId}'
				.replace('{' + 'id' + '}', String(params.id))
				.replace('{' + 'teamId' + '}', String(params.teamId));

			let queryParameters: any = assign({}, extraQueryParams);
			let headerParams: any = assign({}, this.defaultHeaders);
			// verify required parameter 'id' is set
			if (params.id == null) {
				throw new Error('Missing required parameter id when calling companyCompaniesIdTeamsTeamIdDelete');
			}
			// verify required parameter 'teamId' is set
			if (params.teamId == null) {
				throw new Error('Missing required parameter teamId when calling companyCompaniesIdTeamsTeamIdDelete');
			}
			let fetchParams = {
				method: 'DELETE',
				headers: headerParams,

			};

			if (extraFetchParams) {
				fetchParams = assign(fetchParams, extraFetchParams);
			}

			let localVarPathWithQueryParameters = localVarPath + (localVarPath.indexOf('?') !== -1 ? '&' : '?') + querystring.stringify(queryParameters);

			return fetch(localVarPathWithQueryParameters, fetchParams).then((response) => {
				if (response.status >= 200 && response.status < 300) {
					return response.json();
				} else {
					let error = new Error(response.statusText);
					(error as any).response = response;
					throw error;
				}
			});
		}
		/**
		 *
		 * Get Company Team By Id
		 * @param id
		 * @param teamId
		 */
		public companyCompaniesIdTeamsTeamIdGet (params: {  id: number; teamId: number; }, extraQueryParams?: any, extraFetchParams?: any ) : Promise<CompanyTeam> {
			const localVarPath = this.basePath + '/company/companies/{id}/teams/{teamId}'
				.replace('{' + 'id' + '}', String(params.id))
				.replace('{' + 'teamId' + '}', String(params.teamId));

			let queryParameters: any = assign({}, extraQueryParams);
			let headerParams: any = assign({}, this.defaultHeaders);
			// verify required parameter 'id' is set
			if (params.id == null) {
				throw new Error('Missing required parameter id when calling companyCompaniesIdTeamsTeamIdGet');
			}
			// verify required parameter 'teamId' is set
			if (params.teamId == null) {
				throw new Error('Missing required parameter teamId when calling companyCompaniesIdTeamsTeamIdGet');
			}
			let fetchParams = {
				method: 'GET',
				headers: headerParams,

			};

			if (extraFetchParams) {
				fetchParams = assign(fetchParams, extraFetchParams);
			}

			let localVarPathWithQueryParameters = localVarPath + (localVarPath.indexOf('?') !== -1 ? '&' : '?') + querystring.stringify(queryParameters);

			return fetch(localVarPathWithQueryParameters, fetchParams).then((response) => {
				if (response.status >= 200 && response.status < 300) {
					return response.json();
				} else {
					let error = new Error(response.statusText);
					(error as any).response = response;
					throw error;
				}
			});
		}
		/**
		 *
		 * Update Company Team
		 * @param id
		 * @param teamId
		 * @param operations
		 */
		public companyCompaniesIdTeamsTeamIdPatch (params: {  id: number; teamId: number; operations: Array<PatchOperation>; }, extraQueryParams?: any, extraFetchParams?: any ) : Promise<CompanyTeam> {
			const localVarPath = this.basePath + '/company/companies/{id}/teams/{teamId}'
				.replace('{' + 'id' + '}', String(params.id))
				.replace('{' + 'teamId' + '}', String(params.teamId));

			let queryParameters: any = assign({}, extraQueryParams);
			let headerParams: any = assign({}, this.defaultHeaders);
			headerParams['Content-Type'] = 'application/json';

			// verify required parameter 'id' is set
			if (params.id == null) {
				throw new Error('Missing required parameter id when calling companyCompaniesIdTeamsTeamIdPatch');
			}
			// verify required parameter 'teamId' is set
			if (params.teamId == null) {
				throw new Error('Missing required parameter teamId when calling companyCompaniesIdTeamsTeamIdPatch');
			}
			// verify required parameter 'operations' is set
			if (params.operations == null) {
				throw new Error('Missing required parameter operations when calling companyCompaniesIdTeamsTeamIdPatch');
			}
			let fetchParams = {
				method: 'PATCH',
				headers: headerParams,
				body: JSON.stringify(params.operations),

			};

			if (extraFetchParams) {
				fetchParams = assign(fetchParams, extraFetchParams);
			}

			let localVarPathWithQueryParameters = localVarPath + (localVarPath.indexOf('?') !== -1 ? '&' : '?') + querystring.stringify(queryParameters);

			return fetch(localVarPathWithQueryParameters, fetchParams).then((response) => {
				if (response.status >= 200 && response.status < 300) {
					return response.json();
				} else {
					let error = new Error(response.statusText);
					(error as any).response = response;
					throw error;
				}
			});
		}
		/**
		 *
		 * Replace Company Team
		 * @param id
		 * @param teamId
		 * @param companyTeam
		 */
		public companyCompaniesIdTeamsTeamIdPut (params: {  id: number; teamId: number; companyTeam: CompanyTeam; }, extraQueryParams?: any, extraFetchParams?: any ) : Promise<CompanyTeam> {
			const localVarPath = this.basePath + '/company/companies/{id}/teams/{teamId}'
				.replace('{' + 'id' + '}', String(params.id))
				.replace('{' + 'teamId' + '}', String(params.teamId));

			let queryParameters: any = assign({}, extraQueryParams);
			let headerParams: any = assign({}, this.defaultHeaders);
			headerParams['Content-Type'] = 'application/json';

			// verify required parameter 'id' is set
			if (params.id == null) {
				throw new Error('Missing required parameter id when calling companyCompaniesIdTeamsTeamIdPut');
			}
			// verify required parameter 'teamId' is set
			if (params.teamId == null) {
				throw new Error('Missing required parameter teamId when calling companyCompaniesIdTeamsTeamIdPut');
			}
			// verify required parameter 'companyTeam' is set
			if (params.companyTeam == null) {
				throw new Error('Missing required parameter companyTeam when calling companyCompaniesIdTeamsTeamIdPut');
			}
			let fetchParams = {
				method: 'PUT',
				headers: headerParams,
				body: JSON.stringify(params.companyTeam),

			};

			if (extraFetchParams) {
				fetchParams = assign(fetchParams, extraFetchParams);
			}

			let localVarPathWithQueryParameters = localVarPath + (localVarPath.indexOf('?') !== -1 ? '&' : '?') + querystring.stringify(queryParameters);

			return fetch(localVarPathWithQueryParameters, fetchParams).then((response) => {
				if (response.status >= 200 && response.status < 300) {
					return response.json();
				} else {
					let error = new Error(response.statusText);
					(error as any).response = response;
					throw error;
				}
			});
		}
	}
//}
//export namespace  {
	'use strict';

	export class CompanyTypesApi {
		protected basePath = 'https://api-na.myconnectwise.net/v4_6_release/apis/3.0';
		public defaultHeaders : any = {};

		constructor(basePath?: string) {
			if (basePath) {
				this.basePath = basePath;
			}
		}

		/**
		 *
		 * Get Company Types Count
		 * @param conditions
		 */
		public companyCompaniesTypesCountGet (params: {  conditions?: string; }, extraQueryParams?: any, extraFetchParams?: any ) : Promise<Count> {
			const localVarPath = this.basePath + '/company/companies/types/count';

			let queryParameters: any = assign({}, extraQueryParams);
			let headerParams: any = assign({}, this.defaultHeaders);
			if (params.conditions !== undefined) {
				queryParameters['conditions'] = params.conditions;
			}

			let fetchParams = {
				method: 'GET',
				headers: headerParams,

			};

			if (extraFetchParams) {
				fetchParams = assign(fetchParams, extraFetchParams);
			}

			let localVarPathWithQueryParameters = localVarPath + (localVarPath.indexOf('?') !== -1 ? '&' : '?') + querystring.stringify(queryParameters);

			return fetch(localVarPathWithQueryParameters, fetchParams).then((response) => {
				if (response.status >= 200 && response.status < 300) {
					return response.json();
				} else {
					let error = new Error(response.statusText);
					(error as any).response = response;
					throw error;
				}
			});
		}
		/**
		 *
		 * Get Company Types
		 * @param conditions
		 * @param orderBy
		 * @param childconditions
		 * @param customfieldconditions
		 * @param page
		 * @param pageSize
		 */
		public companyCompaniesTypesGet (params: {  conditions?: string; orderBy?: string; childconditions?: string; customfieldconditions?: string; page?: number; pageSize?: number; }, extraQueryParams?: any, extraFetchParams?: any ) : Promise<Array<CompanyType>> {
			const localVarPath = this.basePath + '/company/companies/types';

			let queryParameters: any = assign({}, extraQueryParams);
			let headerParams: any = assign({}, this.defaultHeaders);
			if (params.conditions !== undefined) {
				queryParameters['conditions'] = params.conditions;
			}

			if (params.orderBy !== undefined) {
				queryParameters['orderBy'] = params.orderBy;
			}

			if (params.childconditions !== undefined) {
				queryParameters['childconditions'] = params.childconditions;
			}

			if (params.customfieldconditions !== undefined) {
				queryParameters['customfieldconditions'] = params.customfieldconditions;
			}

			if (params.page !== undefined) {
				queryParameters['page'] = params.page;
			}

			if (params.pageSize !== undefined) {
				queryParameters['pageSize'] = params.pageSize;
			}

			let fetchParams = {
				method: 'GET',
				headers: headerParams,

			};

			if (extraFetchParams) {
				fetchParams = assign(fetchParams, extraFetchParams);
			}

			let localVarPathWithQueryParameters = localVarPath + (localVarPath.indexOf('?') !== -1 ? '&' : '?') + querystring.stringify(queryParameters);

			return fetch(localVarPathWithQueryParameters, fetchParams).then((response) => {
				if (response.status >= 200 && response.status < 300) {
					return response.json();
				} else {
					let error = new Error(response.statusText);
					(error as any).response = response;
					throw error;
				}
			});
		}
		/**
		 *
		 * Delete Company Type By Id
		 * @param id
		 */
		public companyCompaniesTypesIdDelete (params: {  id: number; }, extraQueryParams?: any, extraFetchParams?: any ) : Promise<{}> {
			const localVarPath = this.basePath + '/company/companies/types/{id}'
				.replace('{' + 'id' + '}', String(params.id));

			let queryParameters: any = assign({}, extraQueryParams);
			let headerParams: any = assign({}, this.defaultHeaders);
			// verify required parameter 'id' is set
			if (params.id == null) {
				throw new Error('Missing required parameter id when calling companyCompaniesTypesIdDelete');
			}
			let fetchParams = {
				method: 'DELETE',
				headers: headerParams,

			};

			if (extraFetchParams) {
				fetchParams = assign(fetchParams, extraFetchParams);
			}

			let localVarPathWithQueryParameters = localVarPath + (localVarPath.indexOf('?') !== -1 ? '&' : '?') + querystring.stringify(queryParameters);

			return fetch(localVarPathWithQueryParameters, fetchParams).then((response) => {
				if (response.status >= 200 && response.status < 300) {
					return response.json();
				} else {
					let error = new Error(response.statusText);
					(error as any).response = response;
					throw error;
				}
			});
		}
		/**
		 *
		 * Get Company Type By Id
		 * @param id
		 */
		public companyCompaniesTypesIdGet (params: {  id: number; }, extraQueryParams?: any, extraFetchParams?: any ) : Promise<CompanyType> {
			const localVarPath = this.basePath + '/company/companies/types/{id}'
				.replace('{' + 'id' + '}', String(params.id));

			let queryParameters: any = assign({}, extraQueryParams);
			let headerParams: any = assign({}, this.defaultHeaders);
			// verify required parameter 'id' is set
			if (params.id == null) {
				throw new Error('Missing required parameter id when calling companyCompaniesTypesIdGet');
			}
			let fetchParams = {
				method: 'GET',
				headers: headerParams,

			};

			if (extraFetchParams) {
				fetchParams = assign(fetchParams, extraFetchParams);
			}

			let localVarPathWithQueryParameters = localVarPath + (localVarPath.indexOf('?') !== -1 ? '&' : '?') + querystring.stringify(queryParameters);

			return fetch(localVarPathWithQueryParameters, fetchParams).then((response) => {
				if (response.status >= 200 && response.status < 300) {
					return response.json();
				} else {
					let error = new Error(response.statusText);
					(error as any).response = response;
					throw error;
				}
			});
		}
		/**
		 *
		 * Update Company Type
		 * @param id
		 * @param operations
		 */
		public companyCompaniesTypesIdPatch (params: {  id: number; operations: Array<PatchOperation>; }, extraQueryParams?: any, extraFetchParams?: any ) : Promise<CompanyType> {
			const localVarPath = this.basePath + '/company/companies/types/{id}'
				.replace('{' + 'id' + '}', String(params.id));

			let queryParameters: any = assign({}, extraQueryParams);
			let headerParams: any = assign({}, this.defaultHeaders);
			headerParams['Content-Type'] = 'application/json';

			// verify required parameter 'id' is set
			if (params.id == null) {
				throw new Error('Missing required parameter id when calling companyCompaniesTypesIdPatch');
			}
			// verify required parameter 'operations' is set
			if (params.operations == null) {
				throw new Error('Missing required parameter operations when calling companyCompaniesTypesIdPatch');
			}
			let fetchParams = {
				method: 'PATCH',
				headers: headerParams,
				body: JSON.stringify(params.operations),

			};

			if (extraFetchParams) {
				fetchParams = assign(fetchParams, extraFetchParams);
			}

			let localVarPathWithQueryParameters = localVarPath + (localVarPath.indexOf('?') !== -1 ? '&' : '?') + querystring.stringify(queryParameters);

			return fetch(localVarPathWithQueryParameters, fetchParams).then((response) => {
				if (response.status >= 200 && response.status < 300) {
					return response.json();
				} else {
					let error = new Error(response.statusText);
					(error as any).response = response;
					throw error;
				}
			});
		}
		/**
		 *
		 * Replace Company Type
		 * @param id
		 * @param companyType
		 */
		public companyCompaniesTypesIdPut (params: {  id: number; companyType: CompanyType; }, extraQueryParams?: any, extraFetchParams?: any ) : Promise<CompanyType> {
			const localVarPath = this.basePath + '/company/companies/types/{id}'
				.replace('{' + 'id' + '}', String(params.id));

			let queryParameters: any = assign({}, extraQueryParams);
			let headerParams: any = assign({}, this.defaultHeaders);
			headerParams['Content-Type'] = 'application/json';

			// verify required parameter 'id' is set
			if (params.id == null) {
				throw new Error('Missing required parameter id when calling companyCompaniesTypesIdPut');
			}
			// verify required parameter 'companyType' is set
			if (params.companyType == null) {
				throw new Error('Missing required parameter companyType when calling companyCompaniesTypesIdPut');
			}
			let fetchParams = {
				method: 'PUT',
				headers: headerParams,
				body: JSON.stringify(params.companyType),

			};

			if (extraFetchParams) {
				fetchParams = assign(fetchParams, extraFetchParams);
			}

			let localVarPathWithQueryParameters = localVarPath + (localVarPath.indexOf('?') !== -1 ? '&' : '?') + querystring.stringify(queryParameters);

			return fetch(localVarPathWithQueryParameters, fetchParams).then((response) => {
				if (response.status >= 200 && response.status < 300) {
					return response.json();
				} else {
					let error = new Error(response.statusText);
					(error as any).response = response;
					throw error;
				}
			});
		}
		/**
		 *
		 * Create Company Type
		 * @param companyType
		 */
		public companyCompaniesTypesPost (params: {  companyType: CompanyType; }, extraQueryParams?: any, extraFetchParams?: any ) : Promise<CompanyType> {
			const localVarPath = this.basePath + '/company/companies/types';

			let queryParameters: any = assign({}, extraQueryParams);
			let headerParams: any = assign({}, this.defaultHeaders);
			headerParams['Content-Type'] = 'application/json';

			// verify required parameter 'companyType' is set
			if (params.companyType == null) {
				throw new Error('Missing required parameter companyType when calling companyCompaniesTypesPost');
			}
			let fetchParams = {
				method: 'POST',
				headers: headerParams,
				body: JSON.stringify(params.companyType),

			};

			if (extraFetchParams) {
				fetchParams = assign(fetchParams, extraFetchParams);
			}

			let localVarPathWithQueryParameters = localVarPath + (localVarPath.indexOf('?') !== -1 ? '&' : '?') + querystring.stringify(queryParameters);

			return fetch(localVarPathWithQueryParameters, fetchParams).then((response) => {
				if (response.status >= 200 && response.status < 300) {
					return response.json();
				} else {
					let error = new Error(response.statusText);
					(error as any).response = response;
					throw error;
				}
			});
		}
	}
//}
//export namespace  {
	'use strict';

	export class ConfigurationStatusesApi {
		protected basePath = 'https://api-na.myconnectwise.net/v4_6_release/apis/3.0';
		public defaultHeaders : any = {};

		constructor(basePath?: string) {
			if (basePath) {
				this.basePath = basePath;
			}
		}

		/**
		 *
		 * Get Configuration Statuses Count
		 * @param conditions
		 */
		public companyConfigurationsStatusesCountGet (params: {  conditions?: string; }, extraQueryParams?: any, extraFetchParams?: any ) : Promise<Count> {
			const localVarPath = this.basePath + '/company/configurations/statuses/count';

			let queryParameters: any = assign({}, extraQueryParams);
			let headerParams: any = assign({}, this.defaultHeaders);
			if (params.conditions !== undefined) {
				queryParameters['conditions'] = params.conditions;
			}

			let fetchParams = {
				method: 'GET',
				headers: headerParams,

			};

			if (extraFetchParams) {
				fetchParams = assign(fetchParams, extraFetchParams);
			}

			let localVarPathWithQueryParameters = localVarPath + (localVarPath.indexOf('?') !== -1 ? '&' : '?') + querystring.stringify(queryParameters);

			return fetch(localVarPathWithQueryParameters, fetchParams).then((response) => {
				if (response.status >= 200 && response.status < 300) {
					return response.json();
				} else {
					let error = new Error(response.statusText);
					(error as any).response = response;
					throw error;
				}
			});
		}
		/**
		 *
		 * Get Configuration Statuses
		 * @param conditions
		 * @param orderBy
		 * @param childconditions
		 * @param customfieldconditions
		 * @param page
		 * @param pageSize
		 */
		public companyConfigurationsStatusesGet (params: {  conditions?: string; orderBy?: string; childconditions?: string; customfieldconditions?: string; page?: number; pageSize?: number; }, extraQueryParams?: any, extraFetchParams?: any ) : Promise<Array<ConfigurationStatus>> {
			const localVarPath = this.basePath + '/company/configurations/statuses';

			let queryParameters: any = assign({}, extraQueryParams);
			let headerParams: any = assign({}, this.defaultHeaders);
			if (params.conditions !== undefined) {
				queryParameters['conditions'] = params.conditions;
			}

			if (params.orderBy !== undefined) {
				queryParameters['orderBy'] = params.orderBy;
			}

			if (params.childconditions !== undefined) {
				queryParameters['childconditions'] = params.childconditions;
			}

			if (params.customfieldconditions !== undefined) {
				queryParameters['customfieldconditions'] = params.customfieldconditions;
			}

			if (params.page !== undefined) {
				queryParameters['page'] = params.page;
			}

			if (params.pageSize !== undefined) {
				queryParameters['pageSize'] = params.pageSize;
			}

			let fetchParams = {
				method: 'GET',
				headers: headerParams,

			};

			if (extraFetchParams) {
				fetchParams = assign(fetchParams, extraFetchParams);
			}

			let localVarPathWithQueryParameters = localVarPath + (localVarPath.indexOf('?') !== -1 ? '&' : '?') + querystring.stringify(queryParameters);

			return fetch(localVarPathWithQueryParameters, fetchParams).then((response) => {
				if (response.status >= 200 && response.status < 300) {
					return response.json();
				} else {
					let error = new Error(response.statusText);
					(error as any).response = response;
					throw error;
				}
			});
		}
		/**
		 *
		 * Delete Configuration Status By Id
		 * @param id
		 */
		public companyConfigurationsStatusesIdDelete (params: {  id: number; }, extraQueryParams?: any, extraFetchParams?: any ) : Promise<{}> {
			const localVarPath = this.basePath + '/company/configurations/statuses/{id}'
				.replace('{' + 'id' + '}', String(params.id));

			let queryParameters: any = assign({}, extraQueryParams);
			let headerParams: any = assign({}, this.defaultHeaders);
			// verify required parameter 'id' is set
			if (params.id == null) {
				throw new Error('Missing required parameter id when calling companyConfigurationsStatusesIdDelete');
			}
			let fetchParams = {
				method: 'DELETE',
				headers: headerParams,

			};

			if (extraFetchParams) {
				fetchParams = assign(fetchParams, extraFetchParams);
			}

			let localVarPathWithQueryParameters = localVarPath + (localVarPath.indexOf('?') !== -1 ? '&' : '?') + querystring.stringify(queryParameters);

			return fetch(localVarPathWithQueryParameters, fetchParams).then((response) => {
				if (response.status >= 200 && response.status < 300) {
					return response.json();
				} else {
					let error = new Error(response.statusText);
					(error as any).response = response;
					throw error;
				}
			});
		}
		/**
		 *
		 * Get Configuration Status By Id
		 * @param id
		 */
		public companyConfigurationsStatusesIdGet (params: {  id: number; }, extraQueryParams?: any, extraFetchParams?: any ) : Promise<ConfigurationStatus> {
			const localVarPath = this.basePath + '/company/configurations/statuses/{id}'
				.replace('{' + 'id' + '}', String(params.id));

			let queryParameters: any = assign({}, extraQueryParams);
			let headerParams: any = assign({}, this.defaultHeaders);
			// verify required parameter 'id' is set
			if (params.id == null) {
				throw new Error('Missing required parameter id when calling companyConfigurationsStatusesIdGet');
			}
			let fetchParams = {
				method: 'GET',
				headers: headerParams,

			};

			if (extraFetchParams) {
				fetchParams = assign(fetchParams, extraFetchParams);
			}

			let localVarPathWithQueryParameters = localVarPath + (localVarPath.indexOf('?') !== -1 ? '&' : '?') + querystring.stringify(queryParameters);

			return fetch(localVarPathWithQueryParameters, fetchParams).then((response) => {
				if (response.status >= 200 && response.status < 300) {
					return response.json();
				} else {
					let error = new Error(response.statusText);
					(error as any).response = response;
					throw error;
				}
			});
		}
		/**
		 *
		 * Update Configuration Status
		 * @param id
		 * @param operations
		 */
		public companyConfigurationsStatusesIdPatch (params: {  id: number; operations: Array<PatchOperation>; }, extraQueryParams?: any, extraFetchParams?: any ) : Promise<ConfigurationStatus> {
			const localVarPath = this.basePath + '/company/configurations/statuses/{id}'
				.replace('{' + 'id' + '}', String(params.id));

			let queryParameters: any = assign({}, extraQueryParams);
			let headerParams: any = assign({}, this.defaultHeaders);
			headerParams['Content-Type'] = 'application/json';

			// verify required parameter 'id' is set
			if (params.id == null) {
				throw new Error('Missing required parameter id when calling companyConfigurationsStatusesIdPatch');
			}
			// verify required parameter 'operations' is set
			if (params.operations == null) {
				throw new Error('Missing required parameter operations when calling companyConfigurationsStatusesIdPatch');
			}
			let fetchParams = {
				method: 'PATCH',
				headers: headerParams,
				body: JSON.stringify(params.operations),

			};

			if (extraFetchParams) {
				fetchParams = assign(fetchParams, extraFetchParams);
			}

			let localVarPathWithQueryParameters = localVarPath + (localVarPath.indexOf('?') !== -1 ? '&' : '?') + querystring.stringify(queryParameters);

			return fetch(localVarPathWithQueryParameters, fetchParams).then((response) => {
				if (response.status >= 200 && response.status < 300) {
					return response.json();
				} else {
					let error = new Error(response.statusText);
					(error as any).response = response;
					throw error;
				}
			});
		}
		/**
		 *
		 * Replace Configuration Status
		 * @param id
		 * @param configurationStatus
		 */
		public companyConfigurationsStatusesIdPut (params: {  id: number; configurationStatus: ConfigurationStatus; }, extraQueryParams?: any, extraFetchParams?: any ) : Promise<ConfigurationStatus> {
			const localVarPath = this.basePath + '/company/configurations/statuses/{id}'
				.replace('{' + 'id' + '}', String(params.id));

			let queryParameters: any = assign({}, extraQueryParams);
			let headerParams: any = assign({}, this.defaultHeaders);
			headerParams['Content-Type'] = 'application/json';

			// verify required parameter 'id' is set
			if (params.id == null) {
				throw new Error('Missing required parameter id when calling companyConfigurationsStatusesIdPut');
			}
			// verify required parameter 'configurationStatus' is set
			if (params.configurationStatus == null) {
				throw new Error('Missing required parameter configurationStatus when calling companyConfigurationsStatusesIdPut');
			}
			let fetchParams = {
				method: 'PUT',
				headers: headerParams,
				body: JSON.stringify(params.configurationStatus),

			};

			if (extraFetchParams) {
				fetchParams = assign(fetchParams, extraFetchParams);
			}

			let localVarPathWithQueryParameters = localVarPath + (localVarPath.indexOf('?') !== -1 ? '&' : '?') + querystring.stringify(queryParameters);

			return fetch(localVarPathWithQueryParameters, fetchParams).then((response) => {
				if (response.status >= 200 && response.status < 300) {
					return response.json();
				} else {
					let error = new Error(response.statusText);
					(error as any).response = response;
					throw error;
				}
			});
		}
		/**
		 *
		 * Create Configuration Status
		 * @param configurationStatus
		 */
		public companyConfigurationsStatusesPost (params: {  configurationStatus: ConfigurationStatus; }, extraQueryParams?: any, extraFetchParams?: any ) : Promise<ConfigurationStatus> {
			const localVarPath = this.basePath + '/company/configurations/statuses';

			let queryParameters: any = assign({}, extraQueryParams);
			let headerParams: any = assign({}, this.defaultHeaders);
			headerParams['Content-Type'] = 'application/json';

			// verify required parameter 'configurationStatus' is set
			if (params.configurationStatus == null) {
				throw new Error('Missing required parameter configurationStatus when calling companyConfigurationsStatusesPost');
			}
			let fetchParams = {
				method: 'POST',
				headers: headerParams,
				body: JSON.stringify(params.configurationStatus),

			};

			if (extraFetchParams) {
				fetchParams = assign(fetchParams, extraFetchParams);
			}

			let localVarPathWithQueryParameters = localVarPath + (localVarPath.indexOf('?') !== -1 ? '&' : '?') + querystring.stringify(queryParameters);

			return fetch(localVarPathWithQueryParameters, fetchParams).then((response) => {
				if (response.status >= 200 && response.status < 300) {
					return response.json();
				} else {
					let error = new Error(response.statusText);
					(error as any).response = response;
					throw error;
				}
			});
		}
	}
//}
//export namespace  {
	'use strict';

	export class ConfigurationTypeQuestionsApi {
		protected basePath = 'https://api-na.myconnectwise.net/v4_6_release/apis/3.0';
		public defaultHeaders : any = {};

		constructor(basePath?: string) {
			if (basePath) {
				this.basePath = basePath;
			}
		}

		/**
		 *
		 * Get Configuration Type Questions Count
		 * @param id
		 * @param conditions
		 */
		public companyConfigurationsTypesIdQuestionsCountGet (params: {  id: number; conditions?: string; }, extraQueryParams?: any, extraFetchParams?: any ) : Promise<Count> {
			const localVarPath = this.basePath + '/company/configurations/types/{id}/questions/count'
				.replace('{' + 'id' + '}', String(params.id));

			let queryParameters: any = assign({}, extraQueryParams);
			let headerParams: any = assign({}, this.defaultHeaders);
			// verify required parameter 'id' is set
			if (params.id == null) {
				throw new Error('Missing required parameter id when calling companyConfigurationsTypesIdQuestionsCountGet');
			}
			if (params.conditions !== undefined) {
				queryParameters['conditions'] = params.conditions;
			}

			let fetchParams = {
				method: 'GET',
				headers: headerParams,

			};

			if (extraFetchParams) {
				fetchParams = assign(fetchParams, extraFetchParams);
			}

			let localVarPathWithQueryParameters = localVarPath + (localVarPath.indexOf('?') !== -1 ? '&' : '?') + querystring.stringify(queryParameters);

			return fetch(localVarPathWithQueryParameters, fetchParams).then((response) => {
				if (response.status >= 200 && response.status < 300) {
					return response.json();
				} else {
					let error = new Error(response.statusText);
					(error as any).response = response;
					throw error;
				}
			});
		}
		/**
		 *
		 * Get Configuration Type Questions
		 * @param id
		 * @param conditions
		 * @param orderBy
		 * @param childconditions
		 * @param customfieldconditions
		 * @param page
		 * @param pageSize
		 */
		public companyConfigurationsTypesIdQuestionsGet (params: {  id: number; conditions?: string; orderBy?: string; childconditions?: string; customfieldconditions?: string; page?: number; pageSize?: number; }, extraQueryParams?: any, extraFetchParams?: any ) : Promise<Array<ConfigurationTypeQuestion>> {
			const localVarPath = this.basePath + '/company/configurations/types/{id}/questions'
				.replace('{' + 'id' + '}', String(params.id));

			let queryParameters: any = assign({}, extraQueryParams);
			let headerParams: any = assign({}, this.defaultHeaders);
			// verify required parameter 'id' is set
			if (params.id == null) {
				throw new Error('Missing required parameter id when calling companyConfigurationsTypesIdQuestionsGet');
			}
			if (params.conditions !== undefined) {
				queryParameters['conditions'] = params.conditions;
			}

			if (params.orderBy !== undefined) {
				queryParameters['orderBy'] = params.orderBy;
			}

			if (params.childconditions !== undefined) {
				queryParameters['childconditions'] = params.childconditions;
			}

			if (params.customfieldconditions !== undefined) {
				queryParameters['customfieldconditions'] = params.customfieldconditions;
			}

			if (params.page !== undefined) {
				queryParameters['page'] = params.page;
			}

			if (params.pageSize !== undefined) {
				queryParameters['pageSize'] = params.pageSize;
			}

			let fetchParams = {
				method: 'GET',
				headers: headerParams,

			};

			if (extraFetchParams) {
				fetchParams = assign(fetchParams, extraFetchParams);
			}

			let localVarPathWithQueryParameters = localVarPath + (localVarPath.indexOf('?') !== -1 ? '&' : '?') + querystring.stringify(queryParameters);

			return fetch(localVarPathWithQueryParameters, fetchParams).then((response) => {
				if (response.status >= 200 && response.status < 300) {
					return response.json();
				} else {
					let error = new Error(response.statusText);
					(error as any).response = response;
					throw error;
				}
			});
		}
		/**
		 *
		 * Create Configuration Type Question
		 * @param id
		 * @param configurationTypeQuestion
		 */
		public companyConfigurationsTypesIdQuestionsPost (params: {  id: number; configurationTypeQuestion: ConfigurationTypeQuestion; }, extraQueryParams?: any, extraFetchParams?: any ) : Promise<ConfigurationTypeQuestion> {
			const localVarPath = this.basePath + '/company/configurations/types/{id}/questions'
				.replace('{' + 'id' + '}', String(params.id));

			let queryParameters: any = assign({}, extraQueryParams);
			let headerParams: any = assign({}, this.defaultHeaders);
			headerParams['Content-Type'] = 'application/json';

			// verify required parameter 'id' is set
			if (params.id == null) {
				throw new Error('Missing required parameter id when calling companyConfigurationsTypesIdQuestionsPost');
			}
			// verify required parameter 'configurationTypeQuestion' is set
			if (params.configurationTypeQuestion == null) {
				throw new Error('Missing required parameter configurationTypeQuestion when calling companyConfigurationsTypesIdQuestionsPost');
			}
			let fetchParams = {
				method: 'POST',
				headers: headerParams,
				body: JSON.stringify(params.configurationTypeQuestion),

			};

			if (extraFetchParams) {
				fetchParams = assign(fetchParams, extraFetchParams);
			}

			let localVarPathWithQueryParameters = localVarPath + (localVarPath.indexOf('?') !== -1 ? '&' : '?') + querystring.stringify(queryParameters);

			return fetch(localVarPathWithQueryParameters, fetchParams).then((response) => {
				if (response.status >= 200 && response.status < 300) {
					return response.json();
				} else {
					let error = new Error(response.statusText);
					(error as any).response = response;
					throw error;
				}
			});
		}
		/**
		 *
		 * Delete Configuration Type Question By Id
		 * @param id
		 * @param questionId
		 */
		public companyConfigurationsTypesIdQuestionsQuestionIdDelete (params: {  id: number; questionId: number; }, extraQueryParams?: any, extraFetchParams?: any ) : Promise<{}> {
			const localVarPath = this.basePath + '/company/configurations/types/{id}/questions/{questionId}'
				.replace('{' + 'id' + '}', String(params.id))
				.replace('{' + 'questionId' + '}', String(params.questionId));

			let queryParameters: any = assign({}, extraQueryParams);
			let headerParams: any = assign({}, this.defaultHeaders);
			// verify required parameter 'id' is set
			if (params.id == null) {
				throw new Error('Missing required parameter id when calling companyConfigurationsTypesIdQuestionsQuestionIdDelete');
			}
			// verify required parameter 'questionId' is set
			if (params.questionId == null) {
				throw new Error('Missing required parameter questionId when calling companyConfigurationsTypesIdQuestionsQuestionIdDelete');
			}
			let fetchParams = {
				method: 'DELETE',
				headers: headerParams,

			};

			if (extraFetchParams) {
				fetchParams = assign(fetchParams, extraFetchParams);
			}

			let localVarPathWithQueryParameters = localVarPath + (localVarPath.indexOf('?') !== -1 ? '&' : '?') + querystring.stringify(queryParameters);

			return fetch(localVarPathWithQueryParameters, fetchParams).then((response) => {
				if (response.status >= 200 && response.status < 300) {
					return response.json();
				} else {
					let error = new Error(response.statusText);
					(error as any).response = response;
					throw error;
				}
			});
		}
		/**
		 *
		 * Get Configuration Type Question By Id
		 * @param id
		 * @param questionId
		 */
		public companyConfigurationsTypesIdQuestionsQuestionIdGet (params: {  id: number; questionId: number; }, extraQueryParams?: any, extraFetchParams?: any ) : Promise<ConfigurationTypeQuestion> {
			const localVarPath = this.basePath + '/company/configurations/types/{id}/questions/{questionId}'
				.replace('{' + 'id' + '}', String(params.id))
				.replace('{' + 'questionId' + '}', String(params.questionId));

			let queryParameters: any = assign({}, extraQueryParams);
			let headerParams: any = assign({}, this.defaultHeaders);
			// verify required parameter 'id' is set
			if (params.id == null) {
				throw new Error('Missing required parameter id when calling companyConfigurationsTypesIdQuestionsQuestionIdGet');
			}
			// verify required parameter 'questionId' is set
			if (params.questionId == null) {
				throw new Error('Missing required parameter questionId when calling companyConfigurationsTypesIdQuestionsQuestionIdGet');
			}
			let fetchParams = {
				method: 'GET',
				headers: headerParams,

			};

			if (extraFetchParams) {
				fetchParams = assign(fetchParams, extraFetchParams);
			}

			let localVarPathWithQueryParameters = localVarPath + (localVarPath.indexOf('?') !== -1 ? '&' : '?') + querystring.stringify(queryParameters);

			return fetch(localVarPathWithQueryParameters, fetchParams).then((response) => {
				if (response.status >= 200 && response.status < 300) {
					return response.json();
				} else {
					let error = new Error(response.statusText);
					(error as any).response = response;
					throw error;
				}
			});
		}
		/**
		 *
		 * Update Configuration Type Question
		 * @param id
		 * @param questionId
		 * @param operations
		 */
		public companyConfigurationsTypesIdQuestionsQuestionIdPatch (params: {  id: number; questionId: number; operations: Array<PatchOperation>; }, extraQueryParams?: any, extraFetchParams?: any ) : Promise<ConfigurationTypeQuestion> {
			const localVarPath = this.basePath + '/company/configurations/types/{id}/questions/{questionId}'
				.replace('{' + 'id' + '}', String(params.id))
				.replace('{' + 'questionId' + '}', String(params.questionId));

			let queryParameters: any = assign({}, extraQueryParams);
			let headerParams: any = assign({}, this.defaultHeaders);
			headerParams['Content-Type'] = 'application/json';

			// verify required parameter 'id' is set
			if (params.id == null) {
				throw new Error('Missing required parameter id when calling companyConfigurationsTypesIdQuestionsQuestionIdPatch');
			}
			// verify required parameter 'questionId' is set
			if (params.questionId == null) {
				throw new Error('Missing required parameter questionId when calling companyConfigurationsTypesIdQuestionsQuestionIdPatch');
			}
			// verify required parameter 'operations' is set
			if (params.operations == null) {
				throw new Error('Missing required parameter operations when calling companyConfigurationsTypesIdQuestionsQuestionIdPatch');
			}
			let fetchParams = {
				method: 'PATCH',
				headers: headerParams,
				body: JSON.stringify(params.operations),

			};

			if (extraFetchParams) {
				fetchParams = assign(fetchParams, extraFetchParams);
			}

			let localVarPathWithQueryParameters = localVarPath + (localVarPath.indexOf('?') !== -1 ? '&' : '?') + querystring.stringify(queryParameters);

			return fetch(localVarPathWithQueryParameters, fetchParams).then((response) => {
				if (response.status >= 200 && response.status < 300) {
					return response.json();
				} else {
					let error = new Error(response.statusText);
					(error as any).response = response;
					throw error;
				}
			});
		}
		/**
		 *
		 * Replace Configuration Type Question
		 * @param id
		 * @param questionId
		 * @param configurationTypeQuestion
		 */
		public companyConfigurationsTypesIdQuestionsQuestionIdPut (params: {  id: number; questionId: number; configurationTypeQuestion: ConfigurationTypeQuestion; }, extraQueryParams?: any, extraFetchParams?: any ) : Promise<ConfigurationTypeQuestion> {
			const localVarPath = this.basePath + '/company/configurations/types/{id}/questions/{questionId}'
				.replace('{' + 'id' + '}', String(params.id))
				.replace('{' + 'questionId' + '}', String(params.questionId));

			let queryParameters: any = assign({}, extraQueryParams);
			let headerParams: any = assign({}, this.defaultHeaders);
			headerParams['Content-Type'] = 'application/json';

			// verify required parameter 'id' is set
			if (params.id == null) {
				throw new Error('Missing required parameter id when calling companyConfigurationsTypesIdQuestionsQuestionIdPut');
			}
			// verify required parameter 'questionId' is set
			if (params.questionId == null) {
				throw new Error('Missing required parameter questionId when calling companyConfigurationsTypesIdQuestionsQuestionIdPut');
			}
			// verify required parameter 'configurationTypeQuestion' is set
			if (params.configurationTypeQuestion == null) {
				throw new Error('Missing required parameter configurationTypeQuestion when calling companyConfigurationsTypesIdQuestionsQuestionIdPut');
			}
			let fetchParams = {
				method: 'PUT',
				headers: headerParams,
				body: JSON.stringify(params.configurationTypeQuestion),

			};

			if (extraFetchParams) {
				fetchParams = assign(fetchParams, extraFetchParams);
			}

			let localVarPathWithQueryParameters = localVarPath + (localVarPath.indexOf('?') !== -1 ? '&' : '?') + querystring.stringify(queryParameters);

			return fetch(localVarPathWithQueryParameters, fetchParams).then((response) => {
				if (response.status >= 200 && response.status < 300) {
					return response.json();
				} else {
					let error = new Error(response.statusText);
					(error as any).response = response;
					throw error;
				}
			});
		}
	}
//}
//export namespace  {
	'use strict';

	export class ConfigurationTypesApi {
		protected basePath = 'https://api-na.myconnectwise.net/v4_6_release/apis/3.0';
		public defaultHeaders : any = {};

		constructor(basePath?: string) {
			if (basePath) {
				this.basePath = basePath;
			}
		}

		/**
		 *
		 * Get Configuration Types Count
		 * @param conditions
		 */
		public companyConfigurationsTypesCountGet (params: {  conditions?: string; }, extraQueryParams?: any, extraFetchParams?: any ) : Promise<Count> {
			const localVarPath = this.basePath + '/company/configurations/types/count';

			let queryParameters: any = assign({}, extraQueryParams);
			let headerParams: any = assign({}, this.defaultHeaders);
			if (params.conditions !== undefined) {
				queryParameters['conditions'] = params.conditions;
			}

			let fetchParams = {
				method: 'GET',
				headers: headerParams,

			};

			if (extraFetchParams) {
				fetchParams = assign(fetchParams, extraFetchParams);
			}

			let localVarPathWithQueryParameters = localVarPath + (localVarPath.indexOf('?') !== -1 ? '&' : '?') + querystring.stringify(queryParameters);

			return fetch(localVarPathWithQueryParameters, fetchParams).then((response) => {
				if (response.status >= 200 && response.status < 300) {
					return response.json();
				} else {
					let error = new Error(response.statusText);
					(error as any).response = response;
					throw error;
				}
			});
		}
		/**
		 *
		 * Get Configuration Types
		 * @param conditions
		 * @param orderBy
		 * @param childconditions
		 * @param customfieldconditions
		 * @param page
		 * @param pageSize
		 */
		public companyConfigurationsTypesGet (params: {  conditions?: string; orderBy?: string; childconditions?: string; customfieldconditions?: string; page?: number; pageSize?: number; }, extraQueryParams?: any, extraFetchParams?: any ) : Promise<Array<ConfigurationType>> {
			const localVarPath = this.basePath + '/company/configurations/types';

			let queryParameters: any = assign({}, extraQueryParams);
			let headerParams: any = assign({}, this.defaultHeaders);
			if (params.conditions !== undefined) {
				queryParameters['conditions'] = params.conditions;
			}

			if (params.orderBy !== undefined) {
				queryParameters['orderBy'] = params.orderBy;
			}

			if (params.childconditions !== undefined) {
				queryParameters['childconditions'] = params.childconditions;
			}

			if (params.customfieldconditions !== undefined) {
				queryParameters['customfieldconditions'] = params.customfieldconditions;
			}

			if (params.page !== undefined) {
				queryParameters['page'] = params.page;
			}

			if (params.pageSize !== undefined) {
				queryParameters['pageSize'] = params.pageSize;
			}

			let fetchParams = {
				method: 'GET',
				headers: headerParams,

			};

			if (extraFetchParams) {
				fetchParams = assign(fetchParams, extraFetchParams);
			}

			let localVarPathWithQueryParameters = localVarPath + (localVarPath.indexOf('?') !== -1 ? '&' : '?') + querystring.stringify(queryParameters);

			return fetch(localVarPathWithQueryParameters, fetchParams).then((response) => {
				if (response.status >= 200 && response.status < 300) {
					return response.json();
				} else {
					let error = new Error(response.statusText);
					(error as any).response = response;
					throw error;
				}
			});
		}
		/**
		 *
		 * Delete Configuration Type By Id
		 * @param id
		 */
		public companyConfigurationsTypesIdDelete (params: {  id: number; }, extraQueryParams?: any, extraFetchParams?: any ) : Promise<{}> {
			const localVarPath = this.basePath + '/company/configurations/types/{id}'
				.replace('{' + 'id' + '}', String(params.id));

			let queryParameters: any = assign({}, extraQueryParams);
			let headerParams: any = assign({}, this.defaultHeaders);
			// verify required parameter 'id' is set
			if (params.id == null) {
				throw new Error('Missing required parameter id when calling companyConfigurationsTypesIdDelete');
			}
			let fetchParams = {
				method: 'DELETE',
				headers: headerParams,

			};

			if (extraFetchParams) {
				fetchParams = assign(fetchParams, extraFetchParams);
			}

			let localVarPathWithQueryParameters = localVarPath + (localVarPath.indexOf('?') !== -1 ? '&' : '?') + querystring.stringify(queryParameters);

			return fetch(localVarPathWithQueryParameters, fetchParams).then((response) => {
				if (response.status >= 200 && response.status < 300) {
					return response.json();
				} else {
					let error = new Error(response.statusText);
					(error as any).response = response;
					throw error;
				}
			});
		}
		/**
		 *
		 * Get Configuration Type By Id
		 * @param id
		 */
		public companyConfigurationsTypesIdGet (params: {  id: number; }, extraQueryParams?: any, extraFetchParams?: any ) : Promise<ConfigurationType> {
			const localVarPath = this.basePath + '/company/configurations/types/{id}'
				.replace('{' + 'id' + '}', String(params.id));

			let queryParameters: any = assign({}, extraQueryParams);
			let headerParams: any = assign({}, this.defaultHeaders);
			// verify required parameter 'id' is set
			if (params.id == null) {
				throw new Error('Missing required parameter id when calling companyConfigurationsTypesIdGet');
			}
			let fetchParams = {
				method: 'GET',
				headers: headerParams,

			};

			if (extraFetchParams) {
				fetchParams = assign(fetchParams, extraFetchParams);
			}

			let localVarPathWithQueryParameters = localVarPath + (localVarPath.indexOf('?') !== -1 ? '&' : '?') + querystring.stringify(queryParameters);

			return fetch(localVarPathWithQueryParameters, fetchParams).then((response) => {
				if (response.status >= 200 && response.status < 300) {
					return response.json();
				} else {
					let error = new Error(response.statusText);
					(error as any).response = response;
					throw error;
				}
			});
		}
		/**
		 *
		 * Update Configuration Type
		 * @param id
		 * @param operations
		 */
		public companyConfigurationsTypesIdPatch (params: {  id: number; operations: Array<PatchOperation>; }, extraQueryParams?: any, extraFetchParams?: any ) : Promise<ConfigurationType> {
			const localVarPath = this.basePath + '/company/configurations/types/{id}'
				.replace('{' + 'id' + '}', String(params.id));

			let queryParameters: any = assign({}, extraQueryParams);
			let headerParams: any = assign({}, this.defaultHeaders);
			headerParams['Content-Type'] = 'application/json';

			// verify required parameter 'id' is set
			if (params.id == null) {
				throw new Error('Missing required parameter id when calling companyConfigurationsTypesIdPatch');
			}
			// verify required parameter 'operations' is set
			if (params.operations == null) {
				throw new Error('Missing required parameter operations when calling companyConfigurationsTypesIdPatch');
			}
			let fetchParams = {
				method: 'PATCH',
				headers: headerParams,
				body: JSON.stringify(params.operations),

			};

			if (extraFetchParams) {
				fetchParams = assign(fetchParams, extraFetchParams);
			}

			let localVarPathWithQueryParameters = localVarPath + (localVarPath.indexOf('?') !== -1 ? '&' : '?') + querystring.stringify(queryParameters);

			return fetch(localVarPathWithQueryParameters, fetchParams).then((response) => {
				if (response.status >= 200 && response.status < 300) {
					return response.json();
				} else {
					let error = new Error(response.statusText);
					(error as any).response = response;
					throw error;
				}
			});
		}
		/**
		 *
		 * Replace Configuration Type
		 * @param id
		 * @param configurationType
		 */
		public companyConfigurationsTypesIdPut (params: {  id: number; configurationType: ConfigurationType; }, extraQueryParams?: any, extraFetchParams?: any ) : Promise<ConfigurationType> {
			const localVarPath = this.basePath + '/company/configurations/types/{id}'
				.replace('{' + 'id' + '}', String(params.id));

			let queryParameters: any = assign({}, extraQueryParams);
			let headerParams: any = assign({}, this.defaultHeaders);
			headerParams['Content-Type'] = 'application/json';

			// verify required parameter 'id' is set
			if (params.id == null) {
				throw new Error('Missing required parameter id when calling companyConfigurationsTypesIdPut');
			}
			// verify required parameter 'configurationType' is set
			if (params.configurationType == null) {
				throw new Error('Missing required parameter configurationType when calling companyConfigurationsTypesIdPut');
			}
			let fetchParams = {
				method: 'PUT',
				headers: headerParams,
				body: JSON.stringify(params.configurationType),

			};

			if (extraFetchParams) {
				fetchParams = assign(fetchParams, extraFetchParams);
			}

			let localVarPathWithQueryParameters = localVarPath + (localVarPath.indexOf('?') !== -1 ? '&' : '?') + querystring.stringify(queryParameters);

			return fetch(localVarPathWithQueryParameters, fetchParams).then((response) => {
				if (response.status >= 200 && response.status < 300) {
					return response.json();
				} else {
					let error = new Error(response.statusText);
					(error as any).response = response;
					throw error;
				}
			});
		}
		/**
		 *
		 * Create Configuration Type
		 * @param configurationType
		 */
		public companyConfigurationsTypesPost (params: {  configurationType: ConfigurationType; }, extraQueryParams?: any, extraFetchParams?: any ) : Promise<ConfigurationType> {
			const localVarPath = this.basePath + '/company/configurations/types';

			let queryParameters: any = assign({}, extraQueryParams);
			let headerParams: any = assign({}, this.defaultHeaders);
			headerParams['Content-Type'] = 'application/json';

			// verify required parameter 'configurationType' is set
			if (params.configurationType == null) {
				throw new Error('Missing required parameter configurationType when calling companyConfigurationsTypesPost');
			}
			let fetchParams = {
				method: 'POST',
				headers: headerParams,
				body: JSON.stringify(params.configurationType),

			};

			if (extraFetchParams) {
				fetchParams = assign(fetchParams, extraFetchParams);
			}

			let localVarPathWithQueryParameters = localVarPath + (localVarPath.indexOf('?') !== -1 ? '&' : '?') + querystring.stringify(queryParameters);

			return fetch(localVarPathWithQueryParameters, fetchParams).then((response) => {
				if (response.status >= 200 && response.status < 300) {
					return response.json();
				} else {
					let error = new Error(response.statusText);
					(error as any).response = response;
					throw error;
				}
			});
		}
	}
//}
//export namespace  {
	'use strict';

	export class ConfigurationsApi {
		protected basePath = 'https://api-na.myconnectwise.net/v4_6_release/apis/3.0';
		public defaultHeaders : any = {};

		constructor(basePath?: string) {
			if (basePath) {
				this.basePath = basePath;
			}
		}

		/**
		 *
		 * Get Configurations Count
		 * @param conditions
		 * @param managedIdentifier
		 */
		public companyConfigurationsCountGet (params: {  conditions?: string; managedIdentifier?: string; }, extraQueryParams?: any, extraFetchParams?: any ) : Promise<Count> {
			const localVarPath = this.basePath + '/company/configurations/count';

			let queryParameters: any = assign({}, extraQueryParams);
			let headerParams: any = assign({}, this.defaultHeaders);
			if (params.conditions !== undefined) {
				queryParameters['conditions'] = params.conditions;
			}

			if (params.managedIdentifier !== undefined) {
				queryParameters['managedIdentifier'] = params.managedIdentifier;
			}

			let fetchParams = {
				method: 'GET',
				headers: headerParams,

			};

			if (extraFetchParams) {
				fetchParams = assign(fetchParams, extraFetchParams);
			}

			let localVarPathWithQueryParameters = localVarPath + (localVarPath.indexOf('?') !== -1 ? '&' : '?') + querystring.stringify(queryParameters);

			return fetch(localVarPathWithQueryParameters, fetchParams).then((response) => {
				if (response.status >= 200 && response.status < 300) {
					return response.json();
				} else {
					let error = new Error(response.statusText);
					(error as any).response = response;
					throw error;
				}
			});
		}
		/**
		 *
		 * Get Configurations
		 * @param conditions
		 * @param orderBy
		 * @param childconditions
		 * @param customfieldconditions
		 * @param page
		 * @param pageSize
		 * @param managedIdentifier
		 */
		public companyConfigurationsGet (params: {  conditions?: string; orderBy?: string; childconditions?: string; customfieldconditions?: string; page?: number; pageSize?: number; managedIdentifier?: string; }, extraQueryParams?: any, extraFetchParams?: any ) : Promise<Array<Configuration>> {
			const localVarPath = this.basePath + '/company/configurations';

			let queryParameters: any = assign({}, extraQueryParams);
			let headerParams: any = assign({}, this.defaultHeaders);
			if (params.conditions !== undefined) {
				queryParameters['conditions'] = params.conditions;
			}

			if (params.orderBy !== undefined) {
				queryParameters['orderBy'] = params.orderBy;
			}

			if (params.childconditions !== undefined) {
				queryParameters['childconditions'] = params.childconditions;
			}

			if (params.customfieldconditions !== undefined) {
				queryParameters['customfieldconditions'] = params.customfieldconditions;
			}

			if (params.page !== undefined) {
				queryParameters['page'] = params.page;
			}

			if (params.pageSize !== undefined) {
				queryParameters['pageSize'] = params.pageSize;
			}

			if (params.managedIdentifier !== undefined) {
				queryParameters['managedIdentifier'] = params.managedIdentifier;
			}

			let fetchParams = {
				method: 'GET',
				headers: headerParams,

			};

			if (extraFetchParams) {
				fetchParams = assign(fetchParams, extraFetchParams);
			}

			let localVarPathWithQueryParameters = localVarPath + (localVarPath.indexOf('?') !== -1 ? '&' : '?') + querystring.stringify(queryParameters);

			return fetch(localVarPathWithQueryParameters, fetchParams).then((response) => {
				if (response.status >= 200 && response.status < 300) {
					return response.json();
				} else {
					let error = new Error(response.statusText);
					(error as any).response = response;
					throw error;
				}
			});
		}
		/**
		 *
		 * Delete Configuration By Id
		 * @param id
		 */
		public companyConfigurationsIdDelete (params: {  id: number; }, extraQueryParams?: any, extraFetchParams?: any ) : Promise<{}> {
			const localVarPath = this.basePath + '/company/configurations/{id}'
				.replace('{' + 'id' + '}', String(params.id));

			let queryParameters: any = assign({}, extraQueryParams);
			let headerParams: any = assign({}, this.defaultHeaders);
			// verify required parameter 'id' is set
			if (params.id == null) {
				throw new Error('Missing required parameter id when calling companyConfigurationsIdDelete');
			}
			let fetchParams = {
				method: 'DELETE',
				headers: headerParams,

			};

			if (extraFetchParams) {
				fetchParams = assign(fetchParams, extraFetchParams);
			}

			let localVarPathWithQueryParameters = localVarPath + (localVarPath.indexOf('?') !== -1 ? '&' : '?') + querystring.stringify(queryParameters);

			return fetch(localVarPathWithQueryParameters, fetchParams).then((response) => {
				if (response.status >= 200 && response.status < 300) {
					return response.json();
				} else {
					let error = new Error(response.statusText);
					(error as any).response = response;
					throw error;
				}
			});
		}
		/**
		 *
		 * Get Configuration By Id
		 * @param id
		 */
		public companyConfigurationsIdGet (params: {  id: number; }, extraQueryParams?: any, extraFetchParams?: any ) : Promise<Configuration> {
			const localVarPath = this.basePath + '/company/configurations/{id}'
				.replace('{' + 'id' + '}', String(params.id));

			let queryParameters: any = assign({}, extraQueryParams);
			let headerParams: any = assign({}, this.defaultHeaders);
			// verify required parameter 'id' is set
			if (params.id == null) {
				throw new Error('Missing required parameter id when calling companyConfigurationsIdGet');
			}
			let fetchParams = {
				method: 'GET',
				headers: headerParams,

			};

			if (extraFetchParams) {
				fetchParams = assign(fetchParams, extraFetchParams);
			}

			let localVarPathWithQueryParameters = localVarPath + (localVarPath.indexOf('?') !== -1 ? '&' : '?') + querystring.stringify(queryParameters);

			return fetch(localVarPathWithQueryParameters, fetchParams).then((response) => {
				if (response.status >= 200 && response.status < 300) {
					return response.json();
				} else {
					let error = new Error(response.statusText);
					(error as any).response = response;
					throw error;
				}
			});
		}
		/**
		 *
		 * Update Configuration
		 * @param id
		 * @param operations
		 * @param managementSolutionName
		 * @param managedIdentifier
		 * @param type
		 * @param level
		 * @param childConfigurationsMatchingOn
		 * @param inactivateConfigurationsMatchingOn
		 * @param inactiveConfigurationStatusId
		 */
		public companyConfigurationsIdPatch (params: {  id: number; operations: Array<PatchOperation>; managementSolutionName?: string; managedIdentifier?: string; type?: string; level?: string; childConfigurationsMatchingOn?: string; inactivateConfigurationsMatchingOn?: string; inactiveConfigurationStatusId?: number; }, extraQueryParams?: any, extraFetchParams?: any ) : Promise<Configuration> {
			const localVarPath = this.basePath + '/company/configurations/{id}'
				.replace('{' + 'id' + '}', String(params.id));

			let queryParameters: any = assign({}, extraQueryParams);
			let headerParams: any = assign({}, this.defaultHeaders);
			headerParams['Content-Type'] = 'application/json';

			// verify required parameter 'id' is set
			if (params.id == null) {
				throw new Error('Missing required parameter id when calling companyConfigurationsIdPatch');
			}
			// verify required parameter 'operations' is set
			if (params.operations == null) {
				throw new Error('Missing required parameter operations when calling companyConfigurationsIdPatch');
			}
			if (params.managementSolutionName !== undefined) {
				queryParameters['managementSolutionName'] = params.managementSolutionName;
			}

			if (params.managedIdentifier !== undefined) {
				queryParameters['managedIdentifier'] = params.managedIdentifier;
			}

			if (params.type !== undefined) {
				queryParameters['type'] = params.type;
			}

			if (params.level !== undefined) {
				queryParameters['level'] = params.level;
			}

			if (params.childConfigurationsMatchingOn !== undefined) {
				queryParameters['childConfigurationsMatchingOn'] = params.childConfigurationsMatchingOn;
			}

			if (params.inactivateConfigurationsMatchingOn !== undefined) {
				queryParameters['inactivateConfigurationsMatchingOn'] = params.inactivateConfigurationsMatchingOn;
			}

			if (params.inactiveConfigurationStatusId !== undefined) {
				queryParameters['inactiveConfigurationStatusId'] = params.inactiveConfigurationStatusId;
			}

			let fetchParams = {
				method: 'PATCH',
				headers: headerParams,
				body: JSON.stringify(params.operations),

			};

			if (extraFetchParams) {
				fetchParams = assign(fetchParams, extraFetchParams);
			}

			let localVarPathWithQueryParameters = localVarPath + (localVarPath.indexOf('?') !== -1 ? '&' : '?') + querystring.stringify(queryParameters);

			return fetch(localVarPathWithQueryParameters, fetchParams).then((response) => {
				if (response.status >= 200 && response.status < 300) {
					return response.json();
				} else {
					let error = new Error(response.statusText);
					(error as any).response = response;
					throw error;
				}
			});
		}
		/**
		 *
		 * Replace Configuration
		 * @param id
		 * @param configuration
		 * @param managementSolutionName
		 * @param managedIdentifier
		 * @param type
		 * @param level
		 * @param childConfigurationsMatchingOn
		 * @param inactivateConfigurationsMatchingOn
		 * @param inactiveConfigurationStatusId
		 */
		public companyConfigurationsIdPut (params: {  id: number; configuration: Configuration; managementSolutionName?: string; managedIdentifier?: string; type?: string; level?: string; childConfigurationsMatchingOn?: string; inactivateConfigurationsMatchingOn?: string; inactiveConfigurationStatusId?: number; }, extraQueryParams?: any, extraFetchParams?: any ) : Promise<Configuration> {
			const localVarPath = this.basePath + '/company/configurations/{id}'
				.replace('{' + 'id' + '}', String(params.id));

			let queryParameters: any = assign({}, extraQueryParams);
			let headerParams: any = assign({}, this.defaultHeaders);
			headerParams['Content-Type'] = 'application/json';

			// verify required parameter 'id' is set
			if (params.id == null) {
				throw new Error('Missing required parameter id when calling companyConfigurationsIdPut');
			}
			// verify required parameter 'configuration' is set
			if (params.configuration == null) {
				throw new Error('Missing required parameter configuration when calling companyConfigurationsIdPut');
			}
			if (params.managementSolutionName !== undefined) {
				queryParameters['managementSolutionName'] = params.managementSolutionName;
			}

			if (params.managedIdentifier !== undefined) {
				queryParameters['managedIdentifier'] = params.managedIdentifier;
			}

			if (params.type !== undefined) {
				queryParameters['type'] = params.type;
			}

			if (params.level !== undefined) {
				queryParameters['level'] = params.level;
			}

			if (params.childConfigurationsMatchingOn !== undefined) {
				queryParameters['childConfigurationsMatchingOn'] = params.childConfigurationsMatchingOn;
			}

			if (params.inactivateConfigurationsMatchingOn !== undefined) {
				queryParameters['inactivateConfigurationsMatchingOn'] = params.inactivateConfigurationsMatchingOn;
			}

			if (params.inactiveConfigurationStatusId !== undefined) {
				queryParameters['inactiveConfigurationStatusId'] = params.inactiveConfigurationStatusId;
			}

			let fetchParams = {
				method: 'PUT',
				headers: headerParams,
				body: JSON.stringify(params.configuration),

			};

			if (extraFetchParams) {
				fetchParams = assign(fetchParams, extraFetchParams);
			}

			let localVarPathWithQueryParameters = localVarPath + (localVarPath.indexOf('?') !== -1 ? '&' : '?') + querystring.stringify(queryParameters);

			return fetch(localVarPathWithQueryParameters, fetchParams).then((response) => {
				if (response.status >= 200 && response.status < 300) {
					return response.json();
				} else {
					let error = new Error(response.statusText);
					(error as any).response = response;
					throw error;
				}
			});
		}
		/**
		 *
		 * Create Configuration
		 * @param configuration
		 * @param managementSolutionName
		 * @param managedIdentifier
		 * @param type
		 * @param level
		 * @param childConfigurationsMatchingOn
		 * @param inactivateConfigurationsMatchingOn
		 * @param inactiveConfigurationStatusId
		 */
		public companyConfigurationsPost (params: {  configuration: Configuration; managementSolutionName?: string; managedIdentifier?: string; type?: string; level?: string; childConfigurationsMatchingOn?: string; inactivateConfigurationsMatchingOn?: string; inactiveConfigurationStatusId?: number; }, extraQueryParams?: any, extraFetchParams?: any ) : Promise<Configuration> {
			const localVarPath = this.basePath + '/company/configurations';

			let queryParameters: any = assign({}, extraQueryParams);
			let headerParams: any = assign({}, this.defaultHeaders);
			headerParams['Content-Type'] = 'application/json';

			// verify required parameter 'configuration' is set
			if (params.configuration == null) {
				throw new Error('Missing required parameter configuration when calling companyConfigurationsPost');
			}
			if (params.managementSolutionName !== undefined) {
				queryParameters['managementSolutionName'] = params.managementSolutionName;
			}

			if (params.managedIdentifier !== undefined) {
				queryParameters['managedIdentifier'] = params.managedIdentifier;
			}

			if (params.type !== undefined) {
				queryParameters['type'] = params.type;
			}

			if (params.level !== undefined) {
				queryParameters['level'] = params.level;
			}

			if (params.childConfigurationsMatchingOn !== undefined) {
				queryParameters['childConfigurationsMatchingOn'] = params.childConfigurationsMatchingOn;
			}

			if (params.inactivateConfigurationsMatchingOn !== undefined) {
				queryParameters['inactivateConfigurationsMatchingOn'] = params.inactivateConfigurationsMatchingOn;
			}

			if (params.inactiveConfigurationStatusId !== undefined) {
				queryParameters['inactiveConfigurationStatusId'] = params.inactiveConfigurationStatusId;
			}

			let fetchParams = {
				method: 'POST',
				headers: headerParams,
				body: JSON.stringify(params.configuration),

			};

			if (extraFetchParams) {
				fetchParams = assign(fetchParams, extraFetchParams);
			}

			let localVarPathWithQueryParameters = localVarPath + (localVarPath.indexOf('?') !== -1 ? '&' : '?') + querystring.stringify(queryParameters);

			return fetch(localVarPathWithQueryParameters, fetchParams).then((response) => {
				if (response.status >= 200 && response.status < 300) {
					return response.json();
				} else {
					let error = new Error(response.statusText);
					(error as any).response = response;
					throw error;
				}
			});
		}
	}
//}
//export namespace  {
	'use strict';

	export class ConnectWiseHostedSetupsApi {
		protected basePath = 'https://api-na.myconnectwise.net/v4_6_release/apis/3.0';
		public defaultHeaders : any = {};

		constructor(basePath?: string) {
			if (basePath) {
				this.basePath = basePath;
			}
		}

		/**
		 *
		 * Get Connect Wise Hosted Setups Count
		 * @param conditions
		 */
		public systemConnectwisehostedsetupsCountGet (params: {  conditions?: string; }, extraQueryParams?: any, extraFetchParams?: any ) : Promise<Count> {
			const localVarPath = this.basePath + '/system/connectwisehostedsetups/count';

			let queryParameters: any = assign({}, extraQueryParams);
			let headerParams: any = assign({}, this.defaultHeaders);
			if (params.conditions !== undefined) {
				queryParameters['conditions'] = params.conditions;
			}

			let fetchParams = {
				method: 'GET',
				headers: headerParams,

			};

			if (extraFetchParams) {
				fetchParams = assign(fetchParams, extraFetchParams);
			}

			let localVarPathWithQueryParameters = localVarPath + (localVarPath.indexOf('?') !== -1 ? '&' : '?') + querystring.stringify(queryParameters);

			return fetch(localVarPathWithQueryParameters, fetchParams).then((response) => {
				if (response.status >= 200 && response.status < 300) {
					return response.json();
				} else {
					let error = new Error(response.statusText);
					(error as any).response = response;
					throw error;
				}
			});
		}
		/**
		 *
		 * Get Connect Wise Hosted Setups
		 * @param conditions
		 * @param orderBy
		 * @param childconditions
		 * @param customfieldconditions
		 * @param page
		 * @param pageSize
		 */
		public systemConnectwisehostedsetupsGet (params: {  conditions?: string; orderBy?: string; childconditions?: string; customfieldconditions?: string; page?: number; pageSize?: number; }, extraQueryParams?: any, extraFetchParams?: any ) : Promise<Array<ConnectWiseHostedSetup>> {
			const localVarPath = this.basePath + '/system/connectwisehostedsetups';

			let queryParameters: any = assign({}, extraQueryParams);
			let headerParams: any = assign({}, this.defaultHeaders);
			if (params.conditions !== undefined) {
				queryParameters['conditions'] = params.conditions;
			}

			if (params.orderBy !== undefined) {
				queryParameters['orderBy'] = params.orderBy;
			}

			if (params.childconditions !== undefined) {
				queryParameters['childconditions'] = params.childconditions;
			}

			if (params.customfieldconditions !== undefined) {
				queryParameters['customfieldconditions'] = params.customfieldconditions;
			}

			if (params.page !== undefined) {
				queryParameters['page'] = params.page;
			}

			if (params.pageSize !== undefined) {
				queryParameters['pageSize'] = params.pageSize;
			}

			let fetchParams = {
				method: 'GET',
				headers: headerParams,

			};

			if (extraFetchParams) {
				fetchParams = assign(fetchParams, extraFetchParams);
			}

			let localVarPathWithQueryParameters = localVarPath + (localVarPath.indexOf('?') !== -1 ? '&' : '?') + querystring.stringify(queryParameters);

			return fetch(localVarPathWithQueryParameters, fetchParams).then((response) => {
				if (response.status >= 200 && response.status < 300) {
					return response.json();
				} else {
					let error = new Error(response.statusText);
					(error as any).response = response;
					throw error;
				}
			});
		}
		/**
		 *
		 * Delete Connect Wise Hosted Setup By Id
		 * @param id
		 */
		public systemConnectwisehostedsetupsIdDelete (params: {  id: number; }, extraQueryParams?: any, extraFetchParams?: any ) : Promise<{}> {
			const localVarPath = this.basePath + '/system/connectwisehostedsetups/{id}'
				.replace('{' + 'id' + '}', String(params.id));

			let queryParameters: any = assign({}, extraQueryParams);
			let headerParams: any = assign({}, this.defaultHeaders);
			// verify required parameter 'id' is set
			if (params.id == null) {
				throw new Error('Missing required parameter id when calling systemConnectwisehostedsetupsIdDelete');
			}
			let fetchParams = {
				method: 'DELETE',
				headers: headerParams,

			};

			if (extraFetchParams) {
				fetchParams = assign(fetchParams, extraFetchParams);
			}

			let localVarPathWithQueryParameters = localVarPath + (localVarPath.indexOf('?') !== -1 ? '&' : '?') + querystring.stringify(queryParameters);

			return fetch(localVarPathWithQueryParameters, fetchParams).then((response) => {
				if (response.status >= 200 && response.status < 300) {
					return response.json();
				} else {
					let error = new Error(response.statusText);
					(error as any).response = response;
					throw error;
				}
			});
		}
		/**
		 *
		 * Get Connect Wise Hosted Setup By Id
		 * @param id
		 */
		public systemConnectwisehostedsetupsIdGet (params: {  id: number; }, extraQueryParams?: any, extraFetchParams?: any ) : Promise<ConnectWiseHostedSetup> {
			const localVarPath = this.basePath + '/system/connectwisehostedsetups/{id}'
				.replace('{' + 'id' + '}', String(params.id));

			let queryParameters: any = assign({}, extraQueryParams);
			let headerParams: any = assign({}, this.defaultHeaders);
			// verify required parameter 'id' is set
			if (params.id == null) {
				throw new Error('Missing required parameter id when calling systemConnectwisehostedsetupsIdGet');
			}
			let fetchParams = {
				method: 'GET',
				headers: headerParams,

			};

			if (extraFetchParams) {
				fetchParams = assign(fetchParams, extraFetchParams);
			}

			let localVarPathWithQueryParameters = localVarPath + (localVarPath.indexOf('?') !== -1 ? '&' : '?') + querystring.stringify(queryParameters);

			return fetch(localVarPathWithQueryParameters, fetchParams).then((response) => {
				if (response.status >= 200 && response.status < 300) {
					return response.json();
				} else {
					let error = new Error(response.statusText);
					(error as any).response = response;
					throw error;
				}
			});
		}
		/**
		 *
		 * Update Connect Wise Hosted Setup
		 * @param id
		 * @param operations
		 */
		public systemConnectwisehostedsetupsIdPatch (params: {  id: number; operations: Array<PatchOperation>; }, extraQueryParams?: any, extraFetchParams?: any ) : Promise<ConnectWiseHostedSetup> {
			const localVarPath = this.basePath + '/system/connectwisehostedsetups/{id}'
				.replace('{' + 'id' + '}', String(params.id));

			let queryParameters: any = assign({}, extraQueryParams);
			let headerParams: any = assign({}, this.defaultHeaders);
			headerParams['Content-Type'] = 'application/json';

			// verify required parameter 'id' is set
			if (params.id == null) {
				throw new Error('Missing required parameter id when calling systemConnectwisehostedsetupsIdPatch');
			}
			// verify required parameter 'operations' is set
			if (params.operations == null) {
				throw new Error('Missing required parameter operations when calling systemConnectwisehostedsetupsIdPatch');
			}
			let fetchParams = {
				method: 'PATCH',
				headers: headerParams,
				body: JSON.stringify(params.operations),

			};

			if (extraFetchParams) {
				fetchParams = assign(fetchParams, extraFetchParams);
			}

			let localVarPathWithQueryParameters = localVarPath + (localVarPath.indexOf('?') !== -1 ? '&' : '?') + querystring.stringify(queryParameters);

			return fetch(localVarPathWithQueryParameters, fetchParams).then((response) => {
				if (response.status >= 200 && response.status < 300) {
					return response.json();
				} else {
					let error = new Error(response.statusText);
					(error as any).response = response;
					throw error;
				}
			});
		}
		/**
		 *
		 * Replace Connect Wise Hosted Setup
		 * @param id
		 * @param connectWiseHostedSetup
		 */
		public systemConnectwisehostedsetupsIdPut (params: {  id: number; connectWiseHostedSetup: ConnectWiseHostedSetup; }, extraQueryParams?: any, extraFetchParams?: any ) : Promise<ConnectWiseHostedSetup> {
			const localVarPath = this.basePath + '/system/connectwisehostedsetups/{id}'
				.replace('{' + 'id' + '}', String(params.id));

			let queryParameters: any = assign({}, extraQueryParams);
			let headerParams: any = assign({}, this.defaultHeaders);
			headerParams['Content-Type'] = 'application/json';

			// verify required parameter 'id' is set
			if (params.id == null) {
				throw new Error('Missing required parameter id when calling systemConnectwisehostedsetupsIdPut');
			}
			// verify required parameter 'connectWiseHostedSetup' is set
			if (params.connectWiseHostedSetup == null) {
				throw new Error('Missing required parameter connectWiseHostedSetup when calling systemConnectwisehostedsetupsIdPut');
			}
			let fetchParams = {
				method: 'PUT',
				headers: headerParams,
				body: JSON.stringify(params.connectWiseHostedSetup),

			};

			if (extraFetchParams) {
				fetchParams = assign(fetchParams, extraFetchParams);
			}

			let localVarPathWithQueryParameters = localVarPath + (localVarPath.indexOf('?') !== -1 ? '&' : '?') + querystring.stringify(queryParameters);

			return fetch(localVarPathWithQueryParameters, fetchParams).then((response) => {
				if (response.status >= 200 && response.status < 300) {
					return response.json();
				} else {
					let error = new Error(response.statusText);
					(error as any).response = response;
					throw error;
				}
			});
		}
		/**
		 *
		 * Create Connect Wise Hosted Setup
		 * @param connectWiseHostedSetup
		 */
		public systemConnectwisehostedsetupsPost (params: {  connectWiseHostedSetup: ConnectWiseHostedSetup; }, extraQueryParams?: any, extraFetchParams?: any ) : Promise<ConnectWiseHostedSetup> {
			const localVarPath = this.basePath + '/system/connectwisehostedsetups';

			let queryParameters: any = assign({}, extraQueryParams);
			let headerParams: any = assign({}, this.defaultHeaders);
			headerParams['Content-Type'] = 'application/json';

			// verify required parameter 'connectWiseHostedSetup' is set
			if (params.connectWiseHostedSetup == null) {
				throw new Error('Missing required parameter connectWiseHostedSetup when calling systemConnectwisehostedsetupsPost');
			}
			let fetchParams = {
				method: 'POST',
				headers: headerParams,
				body: JSON.stringify(params.connectWiseHostedSetup),

			};

			if (extraFetchParams) {
				fetchParams = assign(fetchParams, extraFetchParams);
			}

			let localVarPathWithQueryParameters = localVarPath + (localVarPath.indexOf('?') !== -1 ? '&' : '?') + querystring.stringify(queryParameters);

			return fetch(localVarPathWithQueryParameters, fetchParams).then((response) => {
				if (response.status >= 200 && response.status < 300) {
					return response.json();
				} else {
					let error = new Error(response.statusText);
					(error as any).response = response;
					throw error;
				}
			});
		}
	}
//}
//export namespace  {
	'use strict';

	export class ContactCommunicationsApi {
		protected basePath = 'https://api-na.myconnectwise.net/v4_6_release/apis/3.0';
		public defaultHeaders : any = {};

		constructor(basePath?: string) {
			if (basePath) {
				this.basePath = basePath;
			}
		}

		/**
		 *
		 * Delete Contact Communication By Id
		 * @param id
		 * @param communicationId
		 */
		public companyContactsIdCommunicationsCommunicationIdDelete (params: {  id: number; communicationId: number; }, extraQueryParams?: any, extraFetchParams?: any ) : Promise<{}> {
			const localVarPath = this.basePath + '/company/contacts/{id}/communications/{communicationId}'
				.replace('{' + 'id' + '}', String(params.id))
				.replace('{' + 'communicationId' + '}', String(params.communicationId));

			let queryParameters: any = assign({}, extraQueryParams);
			let headerParams: any = assign({}, this.defaultHeaders);
			// verify required parameter 'id' is set
			if (params.id == null) {
				throw new Error('Missing required parameter id when calling companyContactsIdCommunicationsCommunicationIdDelete');
			}
			// verify required parameter 'communicationId' is set
			if (params.communicationId == null) {
				throw new Error('Missing required parameter communicationId when calling companyContactsIdCommunicationsCommunicationIdDelete');
			}
			let fetchParams = {
				method: 'DELETE',
				headers: headerParams,

			};

			if (extraFetchParams) {
				fetchParams = assign(fetchParams, extraFetchParams);
			}

			let localVarPathWithQueryParameters = localVarPath + (localVarPath.indexOf('?') !== -1 ? '&' : '?') + querystring.stringify(queryParameters);

			return fetch(localVarPathWithQueryParameters, fetchParams).then((response) => {
				if (response.status >= 200 && response.status < 300) {
					return response.json();
				} else {
					let error = new Error(response.statusText);
					(error as any).response = response;
					throw error;
				}
			});
		}
		/**
		 *
		 * Get Contact Communication By Id
		 * @param id
		 * @param communicationId
		 */
		public companyContactsIdCommunicationsCommunicationIdGet (params: {  id: number; communicationId: number; }, extraQueryParams?: any, extraFetchParams?: any ) : Promise<ContactCommunication> {
			const localVarPath = this.basePath + '/company/contacts/{id}/communications/{communicationId}'
				.replace('{' + 'id' + '}', String(params.id))
				.replace('{' + 'communicationId' + '}', String(params.communicationId));

			let queryParameters: any = assign({}, extraQueryParams);
			let headerParams: any = assign({}, this.defaultHeaders);
			// verify required parameter 'id' is set
			if (params.id == null) {
				throw new Error('Missing required parameter id when calling companyContactsIdCommunicationsCommunicationIdGet');
			}
			// verify required parameter 'communicationId' is set
			if (params.communicationId == null) {
				throw new Error('Missing required parameter communicationId when calling companyContactsIdCommunicationsCommunicationIdGet');
			}
			let fetchParams = {
				method: 'GET',
				headers: headerParams,

			};

			if (extraFetchParams) {
				fetchParams = assign(fetchParams, extraFetchParams);
			}

			let localVarPathWithQueryParameters = localVarPath + (localVarPath.indexOf('?') !== -1 ? '&' : '?') + querystring.stringify(queryParameters);

			return fetch(localVarPathWithQueryParameters, fetchParams).then((response) => {
				if (response.status >= 200 && response.status < 300) {
					return response.json();
				} else {
					let error = new Error(response.statusText);
					(error as any).response = response;
					throw error;
				}
			});
		}
		/**
		 *
		 * Update Contact Communication
		 * @param id
		 * @param communicationId
		 * @param operations
		 */
		public companyContactsIdCommunicationsCommunicationIdPatch (params: {  id: number; communicationId: number; operations: Array<PatchOperation>; }, extraQueryParams?: any, extraFetchParams?: any ) : Promise<ContactCommunication> {
			const localVarPath = this.basePath + '/company/contacts/{id}/communications/{communicationId}'
				.replace('{' + 'id' + '}', String(params.id))
				.replace('{' + 'communicationId' + '}', String(params.communicationId));

			let queryParameters: any = assign({}, extraQueryParams);
			let headerParams: any = assign({}, this.defaultHeaders);
			headerParams['Content-Type'] = 'application/json';

			// verify required parameter 'id' is set
			if (params.id == null) {
				throw new Error('Missing required parameter id when calling companyContactsIdCommunicationsCommunicationIdPatch');
			}
			// verify required parameter 'communicationId' is set
			if (params.communicationId == null) {
				throw new Error('Missing required parameter communicationId when calling companyContactsIdCommunicationsCommunicationIdPatch');
			}
			// verify required parameter 'operations' is set
			if (params.operations == null) {
				throw new Error('Missing required parameter operations when calling companyContactsIdCommunicationsCommunicationIdPatch');
			}
			let fetchParams = {
				method: 'PATCH',
				headers: headerParams,
				body: JSON.stringify(params.operations),

			};

			if (extraFetchParams) {
				fetchParams = assign(fetchParams, extraFetchParams);
			}

			let localVarPathWithQueryParameters = localVarPath + (localVarPath.indexOf('?') !== -1 ? '&' : '?') + querystring.stringify(queryParameters);

			return fetch(localVarPathWithQueryParameters, fetchParams).then((response) => {
				if (response.status >= 200 && response.status < 300) {
					return response.json();
				} else {
					let error = new Error(response.statusText);
					(error as any).response = response;
					throw error;
				}
			});
		}
		/**
		 *
		 * Replace Contact Communication
		 * @param id
		 * @param communicationId
		 * @param contactCommunication
		 */
		public companyContactsIdCommunicationsCommunicationIdPut (params: {  id: number; communicationId: number; contactCommunication: ContactCommunication; }, extraQueryParams?: any, extraFetchParams?: any ) : Promise<ContactCommunication> {
			const localVarPath = this.basePath + '/company/contacts/{id}/communications/{communicationId}'
				.replace('{' + 'id' + '}', String(params.id))
				.replace('{' + 'communicationId' + '}', String(params.communicationId));

			let queryParameters: any = assign({}, extraQueryParams);
			let headerParams: any = assign({}, this.defaultHeaders);
			headerParams['Content-Type'] = 'application/json';

			// verify required parameter 'id' is set
			if (params.id == null) {
				throw new Error('Missing required parameter id when calling companyContactsIdCommunicationsCommunicationIdPut');
			}
			// verify required parameter 'communicationId' is set
			if (params.communicationId == null) {
				throw new Error('Missing required parameter communicationId when calling companyContactsIdCommunicationsCommunicationIdPut');
			}
			// verify required parameter 'contactCommunication' is set
			if (params.contactCommunication == null) {
				throw new Error('Missing required parameter contactCommunication when calling companyContactsIdCommunicationsCommunicationIdPut');
			}
			let fetchParams = {
				method: 'PUT',
				headers: headerParams,
				body: JSON.stringify(params.contactCommunication),

			};

			if (extraFetchParams) {
				fetchParams = assign(fetchParams, extraFetchParams);
			}

			let localVarPathWithQueryParameters = localVarPath + (localVarPath.indexOf('?') !== -1 ? '&' : '?') + querystring.stringify(queryParameters);

			return fetch(localVarPathWithQueryParameters, fetchParams).then((response) => {
				if (response.status >= 200 && response.status < 300) {
					return response.json();
				} else {
					let error = new Error(response.statusText);
					(error as any).response = response;
					throw error;
				}
			});
		}
		/**
		 *
		 * Get Contact Communications Count
		 * @param id
		 * @param conditions
		 */
		public companyContactsIdCommunicationsCountGet (params: {  id: number; conditions?: string; }, extraQueryParams?: any, extraFetchParams?: any ) : Promise<Count> {
			const localVarPath = this.basePath + '/company/contacts/{id}/communications/count'
				.replace('{' + 'id' + '}', String(params.id));

			let queryParameters: any = assign({}, extraQueryParams);
			let headerParams: any = assign({}, this.defaultHeaders);
			// verify required parameter 'id' is set
			if (params.id == null) {
				throw new Error('Missing required parameter id when calling companyContactsIdCommunicationsCountGet');
			}
			if (params.conditions !== undefined) {
				queryParameters['conditions'] = params.conditions;
			}

			let fetchParams = {
				method: 'GET',
				headers: headerParams,

			};

			if (extraFetchParams) {
				fetchParams = assign(fetchParams, extraFetchParams);
			}

			let localVarPathWithQueryParameters = localVarPath + (localVarPath.indexOf('?') !== -1 ? '&' : '?') + querystring.stringify(queryParameters);

			return fetch(localVarPathWithQueryParameters, fetchParams).then((response) => {
				if (response.status >= 200 && response.status < 300) {
					return response.json();
				} else {
					let error = new Error(response.statusText);
					(error as any).response = response;
					throw error;
				}
			});
		}
		/**
		 *
		 * Get Contact Communications
		 * @param id
		 * @param conditions
		 * @param orderBy
		 * @param childconditions
		 * @param customfieldconditions
		 * @param page
		 * @param pageSize
		 */
		public companyContactsIdCommunicationsGet (params: {  id: number; conditions?: string; orderBy?: string; childconditions?: string; customfieldconditions?: string; page?: number; pageSize?: number; }, extraQueryParams?: any, extraFetchParams?: any ) : Promise<Array<ContactCommunication>> {
			const localVarPath = this.basePath + '/company/contacts/{id}/communications'
				.replace('{' + 'id' + '}', String(params.id));

			let queryParameters: any = assign({}, extraQueryParams);
			let headerParams: any = assign({}, this.defaultHeaders);
			// verify required parameter 'id' is set
			if (params.id == null) {
				throw new Error('Missing required parameter id when calling companyContactsIdCommunicationsGet');
			}
			if (params.conditions !== undefined) {
				queryParameters['conditions'] = params.conditions;
			}

			if (params.orderBy !== undefined) {
				queryParameters['orderBy'] = params.orderBy;
			}

			if (params.childconditions !== undefined) {
				queryParameters['childconditions'] = params.childconditions;
			}

			if (params.customfieldconditions !== undefined) {
				queryParameters['customfieldconditions'] = params.customfieldconditions;
			}

			if (params.page !== undefined) {
				queryParameters['page'] = params.page;
			}

			if (params.pageSize !== undefined) {
				queryParameters['pageSize'] = params.pageSize;
			}

			let fetchParams = {
				method: 'GET',
				headers: headerParams,

			};

			if (extraFetchParams) {
				fetchParams = assign(fetchParams, extraFetchParams);
			}

			let localVarPathWithQueryParameters = localVarPath + (localVarPath.indexOf('?') !== -1 ? '&' : '?') + querystring.stringify(queryParameters);

			return fetch(localVarPathWithQueryParameters, fetchParams).then((response) => {
				if (response.status >= 200 && response.status < 300) {
					return response.json();
				} else {
					let error = new Error(response.statusText);
					(error as any).response = response;
					throw error;
				}
			});
		}
		/**
		 *
		 * Create Contact Communication
		 * @param id
		 * @param contactCommunication
		 */
		public companyContactsIdCommunicationsPost (params: {  id: number; contactCommunication: ContactCommunication; }, extraQueryParams?: any, extraFetchParams?: any ) : Promise<ContactCommunication> {
			const localVarPath = this.basePath + '/company/contacts/{id}/communications'
				.replace('{' + 'id' + '}', String(params.id));

			let queryParameters: any = assign({}, extraQueryParams);
			let headerParams: any = assign({}, this.defaultHeaders);
			headerParams['Content-Type'] = 'application/json';

			// verify required parameter 'id' is set
			if (params.id == null) {
				throw new Error('Missing required parameter id when calling companyContactsIdCommunicationsPost');
			}
			// verify required parameter 'contactCommunication' is set
			if (params.contactCommunication == null) {
				throw new Error('Missing required parameter contactCommunication when calling companyContactsIdCommunicationsPost');
			}
			let fetchParams = {
				method: 'POST',
				headers: headerParams,
				body: JSON.stringify(params.contactCommunication),

			};

			if (extraFetchParams) {
				fetchParams = assign(fetchParams, extraFetchParams);
			}

			let localVarPathWithQueryParameters = localVarPath + (localVarPath.indexOf('?') !== -1 ? '&' : '?') + querystring.stringify(queryParameters);

			return fetch(localVarPathWithQueryParameters, fetchParams).then((response) => {
				if (response.status >= 200 && response.status < 300) {
					return response.json();
				} else {
					let error = new Error(response.statusText);
					(error as any).response = response;
					throw error;
				}
			});
		}
	}
//}
//export namespace  {
	'use strict';

	export class ContactDepartmentsApi {
		protected basePath = 'https://api-na.myconnectwise.net/v4_6_release/apis/3.0';
		public defaultHeaders : any = {};

		constructor(basePath?: string) {
			if (basePath) {
				this.basePath = basePath;
			}
		}

		/**
		 *
		 * Get Contact Departments Count
		 * @param conditions
		 */
		public companyContactsDepartmentsCountGet (params: {  conditions?: string; }, extraQueryParams?: any, extraFetchParams?: any ) : Promise<Count> {
			const localVarPath = this.basePath + '/company/contacts/departments/count';

			let queryParameters: any = assign({}, extraQueryParams);
			let headerParams: any = assign({}, this.defaultHeaders);
			if (params.conditions !== undefined) {
				queryParameters['conditions'] = params.conditions;
			}

			let fetchParams = {
				method: 'GET',
				headers: headerParams,

			};

			if (extraFetchParams) {
				fetchParams = assign(fetchParams, extraFetchParams);
			}

			let localVarPathWithQueryParameters = localVarPath + (localVarPath.indexOf('?') !== -1 ? '&' : '?') + querystring.stringify(queryParameters);

			return fetch(localVarPathWithQueryParameters, fetchParams).then((response) => {
				if (response.status >= 200 && response.status < 300) {
					return response.json();
				} else {
					let error = new Error(response.statusText);
					(error as any).response = response;
					throw error;
				}
			});
		}
		/**
		 *
		 * Get Contact Departments
		 * @param conditions
		 * @param orderBy
		 * @param childconditions
		 * @param customfieldconditions
		 * @param page
		 * @param pageSize
		 */
		public companyContactsDepartmentsGet (params: {  conditions?: string; orderBy?: string; childconditions?: string; customfieldconditions?: string; page?: number; pageSize?: number; }, extraQueryParams?: any, extraFetchParams?: any ) : Promise<Array<ContactDepartment>> {
			const localVarPath = this.basePath + '/company/contacts/departments';

			let queryParameters: any = assign({}, extraQueryParams);
			let headerParams: any = assign({}, this.defaultHeaders);
			if (params.conditions !== undefined) {
				queryParameters['conditions'] = params.conditions;
			}

			if (params.orderBy !== undefined) {
				queryParameters['orderBy'] = params.orderBy;
			}

			if (params.childconditions !== undefined) {
				queryParameters['childconditions'] = params.childconditions;
			}

			if (params.customfieldconditions !== undefined) {
				queryParameters['customfieldconditions'] = params.customfieldconditions;
			}

			if (params.page !== undefined) {
				queryParameters['page'] = params.page;
			}

			if (params.pageSize !== undefined) {
				queryParameters['pageSize'] = params.pageSize;
			}

			let fetchParams = {
				method: 'GET',
				headers: headerParams,

			};

			if (extraFetchParams) {
				fetchParams = assign(fetchParams, extraFetchParams);
			}

			let localVarPathWithQueryParameters = localVarPath + (localVarPath.indexOf('?') !== -1 ? '&' : '?') + querystring.stringify(queryParameters);

			return fetch(localVarPathWithQueryParameters, fetchParams).then((response) => {
				if (response.status >= 200 && response.status < 300) {
					return response.json();
				} else {
					let error = new Error(response.statusText);
					(error as any).response = response;
					throw error;
				}
			});
		}
		/**
		 *
		 * Delete Contact Department By Id
		 * @param id
		 */
		public companyContactsDepartmentsIdDelete (params: {  id: number; }, extraQueryParams?: any, extraFetchParams?: any ) : Promise<{}> {
			const localVarPath = this.basePath + '/company/contacts/departments/{id}'
				.replace('{' + 'id' + '}', String(params.id));

			let queryParameters: any = assign({}, extraQueryParams);
			let headerParams: any = assign({}, this.defaultHeaders);
			// verify required parameter 'id' is set
			if (params.id == null) {
				throw new Error('Missing required parameter id when calling companyContactsDepartmentsIdDelete');
			}
			let fetchParams = {
				method: 'DELETE',
				headers: headerParams,

			};

			if (extraFetchParams) {
				fetchParams = assign(fetchParams, extraFetchParams);
			}

			let localVarPathWithQueryParameters = localVarPath + (localVarPath.indexOf('?') !== -1 ? '&' : '?') + querystring.stringify(queryParameters);

			return fetch(localVarPathWithQueryParameters, fetchParams).then((response) => {
				if (response.status >= 200 && response.status < 300) {
					return response.json();
				} else {
					let error = new Error(response.statusText);
					(error as any).response = response;
					throw error;
				}
			});
		}
		/**
		 *
		 * Get Contact Department By Id
		 * @param id
		 */
		public companyContactsDepartmentsIdGet (params: {  id: number; }, extraQueryParams?: any, extraFetchParams?: any ) : Promise<ContactDepartment> {
			const localVarPath = this.basePath + '/company/contacts/departments/{id}'
				.replace('{' + 'id' + '}', String(params.id));

			let queryParameters: any = assign({}, extraQueryParams);
			let headerParams: any = assign({}, this.defaultHeaders);
			// verify required parameter 'id' is set
			if (params.id == null) {
				throw new Error('Missing required parameter id when calling companyContactsDepartmentsIdGet');
			}
			let fetchParams = {
				method: 'GET',
				headers: headerParams,

			};

			if (extraFetchParams) {
				fetchParams = assign(fetchParams, extraFetchParams);
			}

			let localVarPathWithQueryParameters = localVarPath + (localVarPath.indexOf('?') !== -1 ? '&' : '?') + querystring.stringify(queryParameters);

			return fetch(localVarPathWithQueryParameters, fetchParams).then((response) => {
				if (response.status >= 200 && response.status < 300) {
					return response.json();
				} else {
					let error = new Error(response.statusText);
					(error as any).response = response;
					throw error;
				}
			});
		}
		/**
		 *
		 * Update Contact Department
		 * @param id
		 * @param operations
		 */
		public companyContactsDepartmentsIdPatch (params: {  id: number; operations: Array<PatchOperation>; }, extraQueryParams?: any, extraFetchParams?: any ) : Promise<ContactDepartment> {
			const localVarPath = this.basePath + '/company/contacts/departments/{id}'
				.replace('{' + 'id' + '}', String(params.id));

			let queryParameters: any = assign({}, extraQueryParams);
			let headerParams: any = assign({}, this.defaultHeaders);
			headerParams['Content-Type'] = 'application/json';

			// verify required parameter 'id' is set
			if (params.id == null) {
				throw new Error('Missing required parameter id when calling companyContactsDepartmentsIdPatch');
			}
			// verify required parameter 'operations' is set
			if (params.operations == null) {
				throw new Error('Missing required parameter operations when calling companyContactsDepartmentsIdPatch');
			}
			let fetchParams = {
				method: 'PATCH',
				headers: headerParams,
				body: JSON.stringify(params.operations),

			};

			if (extraFetchParams) {
				fetchParams = assign(fetchParams, extraFetchParams);
			}

			let localVarPathWithQueryParameters = localVarPath + (localVarPath.indexOf('?') !== -1 ? '&' : '?') + querystring.stringify(queryParameters);

			return fetch(localVarPathWithQueryParameters, fetchParams).then((response) => {
				if (response.status >= 200 && response.status < 300) {
					return response.json();
				} else {
					let error = new Error(response.statusText);
					(error as any).response = response;
					throw error;
				}
			});
		}
		/**
		 *
		 * Replace Contact Department
		 * @param id
		 * @param contactDepartment
		 */
		public companyContactsDepartmentsIdPut (params: {  id: number; contactDepartment: ContactDepartment; }, extraQueryParams?: any, extraFetchParams?: any ) : Promise<ContactDepartment> {
			const localVarPath = this.basePath + '/company/contacts/departments/{id}'
				.replace('{' + 'id' + '}', String(params.id));

			let queryParameters: any = assign({}, extraQueryParams);
			let headerParams: any = assign({}, this.defaultHeaders);
			headerParams['Content-Type'] = 'application/json';

			// verify required parameter 'id' is set
			if (params.id == null) {
				throw new Error('Missing required parameter id when calling companyContactsDepartmentsIdPut');
			}
			// verify required parameter 'contactDepartment' is set
			if (params.contactDepartment == null) {
				throw new Error('Missing required parameter contactDepartment when calling companyContactsDepartmentsIdPut');
			}
			let fetchParams = {
				method: 'PUT',
				headers: headerParams,
				body: JSON.stringify(params.contactDepartment),

			};

			if (extraFetchParams) {
				fetchParams = assign(fetchParams, extraFetchParams);
			}

			let localVarPathWithQueryParameters = localVarPath + (localVarPath.indexOf('?') !== -1 ? '&' : '?') + querystring.stringify(queryParameters);

			return fetch(localVarPathWithQueryParameters, fetchParams).then((response) => {
				if (response.status >= 200 && response.status < 300) {
					return response.json();
				} else {
					let error = new Error(response.statusText);
					(error as any).response = response;
					throw error;
				}
			});
		}
		/**
		 *
		 * Create Contact Department
		 * @param contactDepartment
		 */
		public companyContactsDepartmentsPost (params: {  contactDepartment: ContactDepartment; }, extraQueryParams?: any, extraFetchParams?: any ) : Promise<ContactDepartment> {
			const localVarPath = this.basePath + '/company/contacts/departments';

			let queryParameters: any = assign({}, extraQueryParams);
			let headerParams: any = assign({}, this.defaultHeaders);
			headerParams['Content-Type'] = 'application/json';

			// verify required parameter 'contactDepartment' is set
			if (params.contactDepartment == null) {
				throw new Error('Missing required parameter contactDepartment when calling companyContactsDepartmentsPost');
			}
			let fetchParams = {
				method: 'POST',
				headers: headerParams,
				body: JSON.stringify(params.contactDepartment),

			};

			if (extraFetchParams) {
				fetchParams = assign(fetchParams, extraFetchParams);
			}

			let localVarPathWithQueryParameters = localVarPath + (localVarPath.indexOf('?') !== -1 ? '&' : '?') + querystring.stringify(queryParameters);

			return fetch(localVarPathWithQueryParameters, fetchParams).then((response) => {
				if (response.status >= 200 && response.status < 300) {
					return response.json();
				} else {
					let error = new Error(response.statusText);
					(error as any).response = response;
					throw error;
				}
			});
		}
	}
//}
//export namespace  {
	'use strict';

	export class ContactNotesApi {
		protected basePath = 'https://api-na.myconnectwise.net/v4_6_release/apis/3.0';
		public defaultHeaders : any = {};

		constructor(basePath?: string) {
			if (basePath) {
				this.basePath = basePath;
			}
		}

		/**
		 *
		 * Get Contact Notes Count
		 * @param id
		 * @param conditions
		 */
		public companyContactsIdNotesCountGet (params: {  id: number; conditions?: string; }, extraQueryParams?: any, extraFetchParams?: any ) : Promise<Count> {
			const localVarPath = this.basePath + '/company/contacts/{id}/notes/count'
				.replace('{' + 'id' + '}', String(params.id));

			let queryParameters: any = assign({}, extraQueryParams);
			let headerParams: any = assign({}, this.defaultHeaders);
			// verify required parameter 'id' is set
			if (params.id == null) {
				throw new Error('Missing required parameter id when calling companyContactsIdNotesCountGet');
			}
			if (params.conditions !== undefined) {
				queryParameters['conditions'] = params.conditions;
			}

			let fetchParams = {
				method: 'GET',
				headers: headerParams,

			};

			if (extraFetchParams) {
				fetchParams = assign(fetchParams, extraFetchParams);
			}

			let localVarPathWithQueryParameters = localVarPath + (localVarPath.indexOf('?') !== -1 ? '&' : '?') + querystring.stringify(queryParameters);

			return fetch(localVarPathWithQueryParameters, fetchParams).then((response) => {
				if (response.status >= 200 && response.status < 300) {
					return response.json();
				} else {
					let error = new Error(response.statusText);
					(error as any).response = response;
					throw error;
				}
			});
		}
		/**
		 *
		 * Get Contact Notes
		 * @param id
		 * @param conditions
		 * @param orderBy
		 * @param childconditions
		 * @param customfieldconditions
		 * @param page
		 * @param pageSize
		 */
		public companyContactsIdNotesGet (params: {  id: number; conditions?: string; orderBy?: string; childconditions?: string; customfieldconditions?: string; page?: number; pageSize?: number; }, extraQueryParams?: any, extraFetchParams?: any ) : Promise<Array<ContactNote>> {
			const localVarPath = this.basePath + '/company/contacts/{id}/notes'
				.replace('{' + 'id' + '}', String(params.id));

			let queryParameters: any = assign({}, extraQueryParams);
			let headerParams: any = assign({}, this.defaultHeaders);
			// verify required parameter 'id' is set
			if (params.id == null) {
				throw new Error('Missing required parameter id when calling companyContactsIdNotesGet');
			}
			if (params.conditions !== undefined) {
				queryParameters['conditions'] = params.conditions;
			}

			if (params.orderBy !== undefined) {
				queryParameters['orderBy'] = params.orderBy;
			}

			if (params.childconditions !== undefined) {
				queryParameters['childconditions'] = params.childconditions;
			}

			if (params.customfieldconditions !== undefined) {
				queryParameters['customfieldconditions'] = params.customfieldconditions;
			}

			if (params.page !== undefined) {
				queryParameters['page'] = params.page;
			}

			if (params.pageSize !== undefined) {
				queryParameters['pageSize'] = params.pageSize;
			}

			let fetchParams = {
				method: 'GET',
				headers: headerParams,

			};

			if (extraFetchParams) {
				fetchParams = assign(fetchParams, extraFetchParams);
			}

			let localVarPathWithQueryParameters = localVarPath + (localVarPath.indexOf('?') !== -1 ? '&' : '?') + querystring.stringify(queryParameters);

			return fetch(localVarPathWithQueryParameters, fetchParams).then((response) => {
				if (response.status >= 200 && response.status < 300) {
					return response.json();
				} else {
					let error = new Error(response.statusText);
					(error as any).response = response;
					throw error;
				}
			});
		}
		/**
		 *
		 * Delete Contact Note By Id
		 * @param id
		 * @param noteId
		 */
		public companyContactsIdNotesNoteIdDelete (params: {  id: number; noteId: number; }, extraQueryParams?: any, extraFetchParams?: any ) : Promise<{}> {
			const localVarPath = this.basePath + '/company/contacts/{id}/notes/{noteId}'
				.replace('{' + 'id' + '}', String(params.id))
				.replace('{' + 'noteId' + '}', String(params.noteId));

			let queryParameters: any = assign({}, extraQueryParams);
			let headerParams: any = assign({}, this.defaultHeaders);
			// verify required parameter 'id' is set
			if (params.id == null) {
				throw new Error('Missing required parameter id when calling companyContactsIdNotesNoteIdDelete');
			}
			// verify required parameter 'noteId' is set
			if (params.noteId == null) {
				throw new Error('Missing required parameter noteId when calling companyContactsIdNotesNoteIdDelete');
			}
			let fetchParams = {
				method: 'DELETE',
				headers: headerParams,

			};

			if (extraFetchParams) {
				fetchParams = assign(fetchParams, extraFetchParams);
			}

			let localVarPathWithQueryParameters = localVarPath + (localVarPath.indexOf('?') !== -1 ? '&' : '?') + querystring.stringify(queryParameters);

			return fetch(localVarPathWithQueryParameters, fetchParams).then((response) => {
				if (response.status >= 200 && response.status < 300) {
					return response.json();
				} else {
					let error = new Error(response.statusText);
					(error as any).response = response;
					throw error;
				}
			});
		}
		/**
		 *
		 * Get Contact Note By Id
		 * @param id
		 * @param noteId
		 */
		public companyContactsIdNotesNoteIdGet (params: {  id: number; noteId: number; }, extraQueryParams?: any, extraFetchParams?: any ) : Promise<ContactNote> {
			const localVarPath = this.basePath + '/company/contacts/{id}/notes/{noteId}'
				.replace('{' + 'id' + '}', String(params.id))
				.replace('{' + 'noteId' + '}', String(params.noteId));

			let queryParameters: any = assign({}, extraQueryParams);
			let headerParams: any = assign({}, this.defaultHeaders);
			// verify required parameter 'id' is set
			if (params.id == null) {
				throw new Error('Missing required parameter id when calling companyContactsIdNotesNoteIdGet');
			}
			// verify required parameter 'noteId' is set
			if (params.noteId == null) {
				throw new Error('Missing required parameter noteId when calling companyContactsIdNotesNoteIdGet');
			}
			let fetchParams = {
				method: 'GET',
				headers: headerParams,

			};

			if (extraFetchParams) {
				fetchParams = assign(fetchParams, extraFetchParams);
			}

			let localVarPathWithQueryParameters = localVarPath + (localVarPath.indexOf('?') !== -1 ? '&' : '?') + querystring.stringify(queryParameters);

			return fetch(localVarPathWithQueryParameters, fetchParams).then((response) => {
				if (response.status >= 200 && response.status < 300) {
					return response.json();
				} else {
					let error = new Error(response.statusText);
					(error as any).response = response;
					throw error;
				}
			});
		}
		/**
		 *
		 * Update Contact Note
		 * @param id
		 * @param noteId
		 * @param operations
		 */
		public companyContactsIdNotesNoteIdPatch (params: {  id: number; noteId: number; operations: Array<PatchOperation>; }, extraQueryParams?: any, extraFetchParams?: any ) : Promise<ContactNote> {
			const localVarPath = this.basePath + '/company/contacts/{id}/notes/{noteId}'
				.replace('{' + 'id' + '}', String(params.id))
				.replace('{' + 'noteId' + '}', String(params.noteId));

			let queryParameters: any = assign({}, extraQueryParams);
			let headerParams: any = assign({}, this.defaultHeaders);
			headerParams['Content-Type'] = 'application/json';

			// verify required parameter 'id' is set
			if (params.id == null) {
				throw new Error('Missing required parameter id when calling companyContactsIdNotesNoteIdPatch');
			}
			// verify required parameter 'noteId' is set
			if (params.noteId == null) {
				throw new Error('Missing required parameter noteId when calling companyContactsIdNotesNoteIdPatch');
			}
			// verify required parameter 'operations' is set
			if (params.operations == null) {
				throw new Error('Missing required parameter operations when calling companyContactsIdNotesNoteIdPatch');
			}
			let fetchParams = {
				method: 'PATCH',
				headers: headerParams,
				body: JSON.stringify(params.operations),

			};

			if (extraFetchParams) {
				fetchParams = assign(fetchParams, extraFetchParams);
			}

			let localVarPathWithQueryParameters = localVarPath + (localVarPath.indexOf('?') !== -1 ? '&' : '?') + querystring.stringify(queryParameters);

			return fetch(localVarPathWithQueryParameters, fetchParams).then((response) => {
				if (response.status >= 200 && response.status < 300) {
					return response.json();
				} else {
					let error = new Error(response.statusText);
					(error as any).response = response;
					throw error;
				}
			});
		}
		/**
		 *
		 * Replace Contact Note
		 * @param id
		 * @param noteId
		 * @param contactNote
		 */
		public companyContactsIdNotesNoteIdPut (params: {  id: number; noteId: number; contactNote: ContactNote; }, extraQueryParams?: any, extraFetchParams?: any ) : Promise<ContactNote> {
			const localVarPath = this.basePath + '/company/contacts/{id}/notes/{noteId}'
				.replace('{' + 'id' + '}', String(params.id))
				.replace('{' + 'noteId' + '}', String(params.noteId));

			let queryParameters: any = assign({}, extraQueryParams);
			let headerParams: any = assign({}, this.defaultHeaders);
			headerParams['Content-Type'] = 'application/json';

			// verify required parameter 'id' is set
			if (params.id == null) {
				throw new Error('Missing required parameter id when calling companyContactsIdNotesNoteIdPut');
			}
			// verify required parameter 'noteId' is set
			if (params.noteId == null) {
				throw new Error('Missing required parameter noteId when calling companyContactsIdNotesNoteIdPut');
			}
			// verify required parameter 'contactNote' is set
			if (params.contactNote == null) {
				throw new Error('Missing required parameter contactNote when calling companyContactsIdNotesNoteIdPut');
			}
			let fetchParams = {
				method: 'PUT',
				headers: headerParams,
				body: JSON.stringify(params.contactNote),

			};

			if (extraFetchParams) {
				fetchParams = assign(fetchParams, extraFetchParams);
			}

			let localVarPathWithQueryParameters = localVarPath + (localVarPath.indexOf('?') !== -1 ? '&' : '?') + querystring.stringify(queryParameters);

			return fetch(localVarPathWithQueryParameters, fetchParams).then((response) => {
				if (response.status >= 200 && response.status < 300) {
					return response.json();
				} else {
					let error = new Error(response.statusText);
					(error as any).response = response;
					throw error;
				}
			});
		}
		/**
		 *
		 * Create Contact Note
		 * @param id
		 * @param contactNote
		 */
		public companyContactsIdNotesPost (params: {  id: number; contactNote: ContactNote; }, extraQueryParams?: any, extraFetchParams?: any ) : Promise<ContactNote> {
			const localVarPath = this.basePath + '/company/contacts/{id}/notes'
				.replace('{' + 'id' + '}', String(params.id));

			let queryParameters: any = assign({}, extraQueryParams);
			let headerParams: any = assign({}, this.defaultHeaders);
			headerParams['Content-Type'] = 'application/json';

			// verify required parameter 'id' is set
			if (params.id == null) {
				throw new Error('Missing required parameter id when calling companyContactsIdNotesPost');
			}
			// verify required parameter 'contactNote' is set
			if (params.contactNote == null) {
				throw new Error('Missing required parameter contactNote when calling companyContactsIdNotesPost');
			}
			let fetchParams = {
				method: 'POST',
				headers: headerParams,
				body: JSON.stringify(params.contactNote),

			};

			if (extraFetchParams) {
				fetchParams = assign(fetchParams, extraFetchParams);
			}

			let localVarPathWithQueryParameters = localVarPath + (localVarPath.indexOf('?') !== -1 ? '&' : '?') + querystring.stringify(queryParameters);

			return fetch(localVarPathWithQueryParameters, fetchParams).then((response) => {
				if (response.status >= 200 && response.status < 300) {
					return response.json();
				} else {
					let error = new Error(response.statusText);
					(error as any).response = response;
					throw error;
				}
			});
		}
	}
//}
//export namespace  {
	'use strict';

	export class ContactRelationshipsApi {
		protected basePath = 'https://api-na.myconnectwise.net/v4_6_release/apis/3.0';
		public defaultHeaders : any = {};

		constructor(basePath?: string) {
			if (basePath) {
				this.basePath = basePath;
			}
		}

		/**
		 *
		 * Get Contact Relationships Count
		 * @param conditions
		 */
		public companyContactsRelationshipsCountGet (params: {  conditions?: string; }, extraQueryParams?: any, extraFetchParams?: any ) : Promise<Count> {
			const localVarPath = this.basePath + '/company/contacts/relationships/count';

			let queryParameters: any = assign({}, extraQueryParams);
			let headerParams: any = assign({}, this.defaultHeaders);
			if (params.conditions !== undefined) {
				queryParameters['conditions'] = params.conditions;
			}

			let fetchParams = {
				method: 'GET',
				headers: headerParams,

			};

			if (extraFetchParams) {
				fetchParams = assign(fetchParams, extraFetchParams);
			}

			let localVarPathWithQueryParameters = localVarPath + (localVarPath.indexOf('?') !== -1 ? '&' : '?') + querystring.stringify(queryParameters);

			return fetch(localVarPathWithQueryParameters, fetchParams).then((response) => {
				if (response.status >= 200 && response.status < 300) {
					return response.json();
				} else {
					let error = new Error(response.statusText);
					(error as any).response = response;
					throw error;
				}
			});
		}
		/**
		 *
		 * Get Contact Relationships
		 * @param conditions
		 * @param orderBy
		 * @param childconditions
		 * @param customfieldconditions
		 * @param page
		 * @param pageSize
		 */
		public companyContactsRelationshipsGet (params: {  conditions?: string; orderBy?: string; childconditions?: string; customfieldconditions?: string; page?: number; pageSize?: number; }, extraQueryParams?: any, extraFetchParams?: any ) : Promise<Array<ContactRelationship>> {
			const localVarPath = this.basePath + '/company/contacts/relationships';

			let queryParameters: any = assign({}, extraQueryParams);
			let headerParams: any = assign({}, this.defaultHeaders);
			if (params.conditions !== undefined) {
				queryParameters['conditions'] = params.conditions;
			}

			if (params.orderBy !== undefined) {
				queryParameters['orderBy'] = params.orderBy;
			}

			if (params.childconditions !== undefined) {
				queryParameters['childconditions'] = params.childconditions;
			}

			if (params.customfieldconditions !== undefined) {
				queryParameters['customfieldconditions'] = params.customfieldconditions;
			}

			if (params.page !== undefined) {
				queryParameters['page'] = params.page;
			}

			if (params.pageSize !== undefined) {
				queryParameters['pageSize'] = params.pageSize;
			}

			let fetchParams = {
				method: 'GET',
				headers: headerParams,

			};

			if (extraFetchParams) {
				fetchParams = assign(fetchParams, extraFetchParams);
			}

			let localVarPathWithQueryParameters = localVarPath + (localVarPath.indexOf('?') !== -1 ? '&' : '?') + querystring.stringify(queryParameters);

			return fetch(localVarPathWithQueryParameters, fetchParams).then((response) => {
				if (response.status >= 200 && response.status < 300) {
					return response.json();
				} else {
					let error = new Error(response.statusText);
					(error as any).response = response;
					throw error;
				}
			});
		}
		/**
		 *
		 * Delete Contact Relationship By Id
		 * @param id
		 */
		public companyContactsRelationshipsIdDelete (params: {  id: number; }, extraQueryParams?: any, extraFetchParams?: any ) : Promise<{}> {
			const localVarPath = this.basePath + '/company/contacts/relationships/{id}'
				.replace('{' + 'id' + '}', String(params.id));

			let queryParameters: any = assign({}, extraQueryParams);
			let headerParams: any = assign({}, this.defaultHeaders);
			// verify required parameter 'id' is set
			if (params.id == null) {
				throw new Error('Missing required parameter id when calling companyContactsRelationshipsIdDelete');
			}
			let fetchParams = {
				method: 'DELETE',
				headers: headerParams,

			};

			if (extraFetchParams) {
				fetchParams = assign(fetchParams, extraFetchParams);
			}

			let localVarPathWithQueryParameters = localVarPath + (localVarPath.indexOf('?') !== -1 ? '&' : '?') + querystring.stringify(queryParameters);

			return fetch(localVarPathWithQueryParameters, fetchParams).then((response) => {
				if (response.status >= 200 && response.status < 300) {
					return response.json();
				} else {
					let error = new Error(response.statusText);
					(error as any).response = response;
					throw error;
				}
			});
		}
		/**
		 *
		 * Get Contact Relationship By Id
		 * @param id
		 */
		public companyContactsRelationshipsIdGet (params: {  id: number; }, extraQueryParams?: any, extraFetchParams?: any ) : Promise<ContactRelationship> {
			const localVarPath = this.basePath + '/company/contacts/relationships/{id}'
				.replace('{' + 'id' + '}', String(params.id));

			let queryParameters: any = assign({}, extraQueryParams);
			let headerParams: any = assign({}, this.defaultHeaders);
			// verify required parameter 'id' is set
			if (params.id == null) {
				throw new Error('Missing required parameter id when calling companyContactsRelationshipsIdGet');
			}
			let fetchParams = {
				method: 'GET',
				headers: headerParams,

			};

			if (extraFetchParams) {
				fetchParams = assign(fetchParams, extraFetchParams);
			}

			let localVarPathWithQueryParameters = localVarPath + (localVarPath.indexOf('?') !== -1 ? '&' : '?') + querystring.stringify(queryParameters);

			return fetch(localVarPathWithQueryParameters, fetchParams).then((response) => {
				if (response.status >= 200 && response.status < 300) {
					return response.json();
				} else {
					let error = new Error(response.statusText);
					(error as any).response = response;
					throw error;
				}
			});
		}
		/**
		 *
		 * Update Contact Relationship
		 * @param id
		 * @param operations
		 */
		public companyContactsRelationshipsIdPatch (params: {  id: number; operations: Array<PatchOperation>; }, extraQueryParams?: any, extraFetchParams?: any ) : Promise<ContactRelationship> {
			const localVarPath = this.basePath + '/company/contacts/relationships/{id}'
				.replace('{' + 'id' + '}', String(params.id));

			let queryParameters: any = assign({}, extraQueryParams);
			let headerParams: any = assign({}, this.defaultHeaders);
			headerParams['Content-Type'] = 'application/json';

			// verify required parameter 'id' is set
			if (params.id == null) {
				throw new Error('Missing required parameter id when calling companyContactsRelationshipsIdPatch');
			}
			// verify required parameter 'operations' is set
			if (params.operations == null) {
				throw new Error('Missing required parameter operations when calling companyContactsRelationshipsIdPatch');
			}
			let fetchParams = {
				method: 'PATCH',
				headers: headerParams,
				body: JSON.stringify(params.operations),

			};

			if (extraFetchParams) {
				fetchParams = assign(fetchParams, extraFetchParams);
			}

			let localVarPathWithQueryParameters = localVarPath + (localVarPath.indexOf('?') !== -1 ? '&' : '?') + querystring.stringify(queryParameters);

			return fetch(localVarPathWithQueryParameters, fetchParams).then((response) => {
				if (response.status >= 200 && response.status < 300) {
					return response.json();
				} else {
					let error = new Error(response.statusText);
					(error as any).response = response;
					throw error;
				}
			});
		}
		/**
		 *
		 * Replace Contact Relationship
		 * @param id
		 * @param contactRelationship
		 */
		public companyContactsRelationshipsIdPut (params: {  id: number; contactRelationship: ContactRelationship; }, extraQueryParams?: any, extraFetchParams?: any ) : Promise<ContactRelationship> {
			const localVarPath = this.basePath + '/company/contacts/relationships/{id}'
				.replace('{' + 'id' + '}', String(params.id));

			let queryParameters: any = assign({}, extraQueryParams);
			let headerParams: any = assign({}, this.defaultHeaders);
			headerParams['Content-Type'] = 'application/json';

			// verify required parameter 'id' is set
			if (params.id == null) {
				throw new Error('Missing required parameter id when calling companyContactsRelationshipsIdPut');
			}
			// verify required parameter 'contactRelationship' is set
			if (params.contactRelationship == null) {
				throw new Error('Missing required parameter contactRelationship when calling companyContactsRelationshipsIdPut');
			}
			let fetchParams = {
				method: 'PUT',
				headers: headerParams,
				body: JSON.stringify(params.contactRelationship),

			};

			if (extraFetchParams) {
				fetchParams = assign(fetchParams, extraFetchParams);
			}

			let localVarPathWithQueryParameters = localVarPath + (localVarPath.indexOf('?') !== -1 ? '&' : '?') + querystring.stringify(queryParameters);

			return fetch(localVarPathWithQueryParameters, fetchParams).then((response) => {
				if (response.status >= 200 && response.status < 300) {
					return response.json();
				} else {
					let error = new Error(response.statusText);
					(error as any).response = response;
					throw error;
				}
			});
		}
		/**
		 *
		 * Create Contact Relationship
		 * @param contactRelationship
		 */
		public companyContactsRelationshipsPost (params: {  contactRelationship: ContactRelationship; }, extraQueryParams?: any, extraFetchParams?: any ) : Promise<ContactRelationship> {
			const localVarPath = this.basePath + '/company/contacts/relationships';

			let queryParameters: any = assign({}, extraQueryParams);
			let headerParams: any = assign({}, this.defaultHeaders);
			headerParams['Content-Type'] = 'application/json';

			// verify required parameter 'contactRelationship' is set
			if (params.contactRelationship == null) {
				throw new Error('Missing required parameter contactRelationship when calling companyContactsRelationshipsPost');
			}
			let fetchParams = {
				method: 'POST',
				headers: headerParams,
				body: JSON.stringify(params.contactRelationship),

			};

			if (extraFetchParams) {
				fetchParams = assign(fetchParams, extraFetchParams);
			}

			let localVarPathWithQueryParameters = localVarPath + (localVarPath.indexOf('?') !== -1 ? '&' : '?') + querystring.stringify(queryParameters);

			return fetch(localVarPathWithQueryParameters, fetchParams).then((response) => {
				if (response.status >= 200 && response.status < 300) {
					return response.json();
				} else {
					let error = new Error(response.statusText);
					(error as any).response = response;
					throw error;
				}
			});
		}
	}
//}
//export namespace  {
	'use strict';

	export class ContactTracksApi {
		protected basePath = 'https://api-na.myconnectwise.net/v4_6_release/apis/3.0';
		public defaultHeaders : any = {};

		constructor(basePath?: string) {
			if (basePath) {
				this.basePath = basePath;
			}
		}

		/**
		 *
		 * Get Tracks Count
		 * @param id
		 * @param conditions
		 */
		public companyContactsIdTracksCountGet (params: {  id: number; conditions?: string; }, extraQueryParams?: any, extraFetchParams?: any ) : Promise<Count> {
			const localVarPath = this.basePath + '/company/contacts/{id}/tracks/count'
				.replace('{' + 'id' + '}', String(params.id));

			let queryParameters: any = assign({}, extraQueryParams);
			let headerParams: any = assign({}, this.defaultHeaders);
			// verify required parameter 'id' is set
			if (params.id == null) {
				throw new Error('Missing required parameter id when calling companyContactsIdTracksCountGet');
			}
			if (params.conditions !== undefined) {
				queryParameters['conditions'] = params.conditions;
			}

			let fetchParams = {
				method: 'GET',
				headers: headerParams,

			};

			if (extraFetchParams) {
				fetchParams = assign(fetchParams, extraFetchParams);
			}

			let localVarPathWithQueryParameters = localVarPath + (localVarPath.indexOf('?') !== -1 ? '&' : '?') + querystring.stringify(queryParameters);

			return fetch(localVarPathWithQueryParameters, fetchParams).then((response) => {
				if (response.status >= 200 && response.status < 300) {
					return response.json();
				} else {
					let error = new Error(response.statusText);
					(error as any).response = response;
					throw error;
				}
			});
		}
		/**
		 *
		 * Get Tracks
		 * @param id
		 * @param conditions
		 * @param orderBy
		 * @param childconditions
		 * @param customfieldconditions
		 * @param page
		 * @param pageSize
		 */
		public companyContactsIdTracksGet (params: {  id: number; conditions?: string; orderBy?: string; childconditions?: string; customfieldconditions?: string; page?: number; pageSize?: number; }, extraQueryParams?: any, extraFetchParams?: any ) : Promise<Array<Track>> {
			const localVarPath = this.basePath + '/company/contacts/{id}/tracks'
				.replace('{' + 'id' + '}', String(params.id));

			let queryParameters: any = assign({}, extraQueryParams);
			let headerParams: any = assign({}, this.defaultHeaders);
			// verify required parameter 'id' is set
			if (params.id == null) {
				throw new Error('Missing required parameter id when calling companyContactsIdTracksGet');
			}
			if (params.conditions !== undefined) {
				queryParameters['conditions'] = params.conditions;
			}

			if (params.orderBy !== undefined) {
				queryParameters['orderBy'] = params.orderBy;
			}

			if (params.childconditions !== undefined) {
				queryParameters['childconditions'] = params.childconditions;
			}

			if (params.customfieldconditions !== undefined) {
				queryParameters['customfieldconditions'] = params.customfieldconditions;
			}

			if (params.page !== undefined) {
				queryParameters['page'] = params.page;
			}

			if (params.pageSize !== undefined) {
				queryParameters['pageSize'] = params.pageSize;
			}

			let fetchParams = {
				method: 'GET',
				headers: headerParams,

			};

			if (extraFetchParams) {
				fetchParams = assign(fetchParams, extraFetchParams);
			}

			let localVarPathWithQueryParameters = localVarPath + (localVarPath.indexOf('?') !== -1 ? '&' : '?') + querystring.stringify(queryParameters);

			return fetch(localVarPathWithQueryParameters, fetchParams).then((response) => {
				if (response.status >= 200 && response.status < 300) {
					return response.json();
				} else {
					let error = new Error(response.statusText);
					(error as any).response = response;
					throw error;
				}
			});
		}
		/**
		 *
		 * Create Track
		 * @param id
		 * @param track
		 */
		public companyContactsIdTracksPost (params: {  id: number; track: Track; }, extraQueryParams?: any, extraFetchParams?: any ) : Promise<Track> {
			const localVarPath = this.basePath + '/company/contacts/{id}/tracks'
				.replace('{' + 'id' + '}', String(params.id));

			let queryParameters: any = assign({}, extraQueryParams);
			let headerParams: any = assign({}, this.defaultHeaders);
			headerParams['Content-Type'] = 'application/json';

			// verify required parameter 'id' is set
			if (params.id == null) {
				throw new Error('Missing required parameter id when calling companyContactsIdTracksPost');
			}
			// verify required parameter 'track' is set
			if (params.track == null) {
				throw new Error('Missing required parameter track when calling companyContactsIdTracksPost');
			}
			let fetchParams = {
				method: 'POST',
				headers: headerParams,
				body: JSON.stringify(params.track),

			};

			if (extraFetchParams) {
				fetchParams = assign(fetchParams, extraFetchParams);
			}

			let localVarPathWithQueryParameters = localVarPath + (localVarPath.indexOf('?') !== -1 ? '&' : '?') + querystring.stringify(queryParameters);

			return fetch(localVarPathWithQueryParameters, fetchParams).then((response) => {
				if (response.status >= 200 && response.status < 300) {
					return response.json();
				} else {
					let error = new Error(response.statusText);
					(error as any).response = response;
					throw error;
				}
			});
		}
		/**
		 *
		 * Delete Track By Id
		 * @param id
		 * @param trackId
		 */
		public companyContactsIdTracksTrackIdDelete (params: {  id: number; trackId: number; }, extraQueryParams?: any, extraFetchParams?: any ) : Promise<{}> {
			const localVarPath = this.basePath + '/company/contacts/{id}/tracks/{trackId}'
				.replace('{' + 'id' + '}', String(params.id))
				.replace('{' + 'trackId' + '}', String(params.trackId));

			let queryParameters: any = assign({}, extraQueryParams);
			let headerParams: any = assign({}, this.defaultHeaders);
			// verify required parameter 'id' is set
			if (params.id == null) {
				throw new Error('Missing required parameter id when calling companyContactsIdTracksTrackIdDelete');
			}
			// verify required parameter 'trackId' is set
			if (params.trackId == null) {
				throw new Error('Missing required parameter trackId when calling companyContactsIdTracksTrackIdDelete');
			}
			let fetchParams = {
				method: 'DELETE',
				headers: headerParams,

			};

			if (extraFetchParams) {
				fetchParams = assign(fetchParams, extraFetchParams);
			}

			let localVarPathWithQueryParameters = localVarPath + (localVarPath.indexOf('?') !== -1 ? '&' : '?') + querystring.stringify(queryParameters);

			return fetch(localVarPathWithQueryParameters, fetchParams).then((response) => {
				if (response.status >= 200 && response.status < 300) {
					return response.json();
				} else {
					let error = new Error(response.statusText);
					(error as any).response = response;
					throw error;
				}
			});
		}
		/**
		 *
		 * Get Track By Id
		 * @param id
		 * @param trackId
		 */
		public companyContactsIdTracksTrackIdGet (params: {  id: number; trackId: number; }, extraQueryParams?: any, extraFetchParams?: any ) : Promise<Track> {
			const localVarPath = this.basePath + '/company/contacts/{id}/tracks/{trackId}'
				.replace('{' + 'id' + '}', String(params.id))
				.replace('{' + 'trackId' + '}', String(params.trackId));

			let queryParameters: any = assign({}, extraQueryParams);
			let headerParams: any = assign({}, this.defaultHeaders);
			// verify required parameter 'id' is set
			if (params.id == null) {
				throw new Error('Missing required parameter id when calling companyContactsIdTracksTrackIdGet');
			}
			// verify required parameter 'trackId' is set
			if (params.trackId == null) {
				throw new Error('Missing required parameter trackId when calling companyContactsIdTracksTrackIdGet');
			}
			let fetchParams = {
				method: 'GET',
				headers: headerParams,

			};

			if (extraFetchParams) {
				fetchParams = assign(fetchParams, extraFetchParams);
			}

			let localVarPathWithQueryParameters = localVarPath + (localVarPath.indexOf('?') !== -1 ? '&' : '?') + querystring.stringify(queryParameters);

			return fetch(localVarPathWithQueryParameters, fetchParams).then((response) => {
				if (response.status >= 200 && response.status < 300) {
					return response.json();
				} else {
					let error = new Error(response.statusText);
					(error as any).response = response;
					throw error;
				}
			});
		}
	}
//}
//export namespace  {
	'use strict';

	export class ContactTypesApi {
		protected basePath = 'https://api-na.myconnectwise.net/v4_6_release/apis/3.0';
		public defaultHeaders : any = {};

		constructor(basePath?: string) {
			if (basePath) {
				this.basePath = basePath;
			}
		}

		/**
		 *
		 * Get Contact Types Count
		 * @param conditions
		 */
		public companyContactsTypesCountGet (params: {  conditions?: string; }, extraQueryParams?: any, extraFetchParams?: any ) : Promise<Count> {
			const localVarPath = this.basePath + '/company/contacts/types/count';

			let queryParameters: any = assign({}, extraQueryParams);
			let headerParams: any = assign({}, this.defaultHeaders);
			if (params.conditions !== undefined) {
				queryParameters['conditions'] = params.conditions;
			}

			let fetchParams = {
				method: 'GET',
				headers: headerParams,

			};

			if (extraFetchParams) {
				fetchParams = assign(fetchParams, extraFetchParams);
			}

			let localVarPathWithQueryParameters = localVarPath + (localVarPath.indexOf('?') !== -1 ? '&' : '?') + querystring.stringify(queryParameters);

			return fetch(localVarPathWithQueryParameters, fetchParams).then((response) => {
				if (response.status >= 200 && response.status < 300) {
					return response.json();
				} else {
					let error = new Error(response.statusText);
					(error as any).response = response;
					throw error;
				}
			});
		}
		/**
		 *
		 * Get Contact Types
		 * @param conditions
		 * @param orderBy
		 * @param childconditions
		 * @param customfieldconditions
		 * @param page
		 * @param pageSize
		 */
		public companyContactsTypesGet (params: {  conditions?: string; orderBy?: string; childconditions?: string; customfieldconditions?: string; page?: number; pageSize?: number; }, extraQueryParams?: any, extraFetchParams?: any ) : Promise<Array<ContactType>> {
			const localVarPath = this.basePath + '/company/contacts/types';

			let queryParameters: any = assign({}, extraQueryParams);
			let headerParams: any = assign({}, this.defaultHeaders);
			if (params.conditions !== undefined) {
				queryParameters['conditions'] = params.conditions;
			}

			if (params.orderBy !== undefined) {
				queryParameters['orderBy'] = params.orderBy;
			}

			if (params.childconditions !== undefined) {
				queryParameters['childconditions'] = params.childconditions;
			}

			if (params.customfieldconditions !== undefined) {
				queryParameters['customfieldconditions'] = params.customfieldconditions;
			}

			if (params.page !== undefined) {
				queryParameters['page'] = params.page;
			}

			if (params.pageSize !== undefined) {
				queryParameters['pageSize'] = params.pageSize;
			}

			let fetchParams = {
				method: 'GET',
				headers: headerParams,

			};

			if (extraFetchParams) {
				fetchParams = assign(fetchParams, extraFetchParams);
			}

			let localVarPathWithQueryParameters = localVarPath + (localVarPath.indexOf('?') !== -1 ? '&' : '?') + querystring.stringify(queryParameters);

			return fetch(localVarPathWithQueryParameters, fetchParams).then((response) => {
				if (response.status >= 200 && response.status < 300) {
					return response.json();
				} else {
					let error = new Error(response.statusText);
					(error as any).response = response;
					throw error;
				}
			});
		}
		/**
		 *
		 * Delete Contact Type By Id
		 * @param id
		 */
		public companyContactsTypesIdDelete (params: {  id: number; }, extraQueryParams?: any, extraFetchParams?: any ) : Promise<{}> {
			const localVarPath = this.basePath + '/company/contacts/types/{id}'
				.replace('{' + 'id' + '}', String(params.id));

			let queryParameters: any = assign({}, extraQueryParams);
			let headerParams: any = assign({}, this.defaultHeaders);
			// verify required parameter 'id' is set
			if (params.id == null) {
				throw new Error('Missing required parameter id when calling companyContactsTypesIdDelete');
			}
			let fetchParams = {
				method: 'DELETE',
				headers: headerParams,

			};

			if (extraFetchParams) {
				fetchParams = assign(fetchParams, extraFetchParams);
			}

			let localVarPathWithQueryParameters = localVarPath + (localVarPath.indexOf('?') !== -1 ? '&' : '?') + querystring.stringify(queryParameters);

			return fetch(localVarPathWithQueryParameters, fetchParams).then((response) => {
				if (response.status >= 200 && response.status < 300) {
					return response.json();
				} else {
					let error = new Error(response.statusText);
					(error as any).response = response;
					throw error;
				}
			});
		}
		/**
		 *
		 * Get Contact Type By Id
		 * @param id
		 */
		public companyContactsTypesIdGet (params: {  id: number; }, extraQueryParams?: any, extraFetchParams?: any ) : Promise<ContactType> {
			const localVarPath = this.basePath + '/company/contacts/types/{id}'
				.replace('{' + 'id' + '}', String(params.id));

			let queryParameters: any = assign({}, extraQueryParams);
			let headerParams: any = assign({}, this.defaultHeaders);
			// verify required parameter 'id' is set
			if (params.id == null) {
				throw new Error('Missing required parameter id when calling companyContactsTypesIdGet');
			}
			let fetchParams = {
				method: 'GET',
				headers: headerParams,

			};

			if (extraFetchParams) {
				fetchParams = assign(fetchParams, extraFetchParams);
			}

			let localVarPathWithQueryParameters = localVarPath + (localVarPath.indexOf('?') !== -1 ? '&' : '?') + querystring.stringify(queryParameters);

			return fetch(localVarPathWithQueryParameters, fetchParams).then((response) => {
				if (response.status >= 200 && response.status < 300) {
					return response.json();
				} else {
					let error = new Error(response.statusText);
					(error as any).response = response;
					throw error;
				}
			});
		}
		/**
		 *
		 * Update Contact Type
		 * @param id
		 * @param operations
		 */
		public companyContactsTypesIdPatch (params: {  id: number; operations: Array<PatchOperation>; }, extraQueryParams?: any, extraFetchParams?: any ) : Promise<ContactType> {
			const localVarPath = this.basePath + '/company/contacts/types/{id}'
				.replace('{' + 'id' + '}', String(params.id));

			let queryParameters: any = assign({}, extraQueryParams);
			let headerParams: any = assign({}, this.defaultHeaders);
			headerParams['Content-Type'] = 'application/json';

			// verify required parameter 'id' is set
			if (params.id == null) {
				throw new Error('Missing required parameter id when calling companyContactsTypesIdPatch');
			}
			// verify required parameter 'operations' is set
			if (params.operations == null) {
				throw new Error('Missing required parameter operations when calling companyContactsTypesIdPatch');
			}
			let fetchParams = {
				method: 'PATCH',
				headers: headerParams,
				body: JSON.stringify(params.operations),

			};

			if (extraFetchParams) {
				fetchParams = assign(fetchParams, extraFetchParams);
			}

			let localVarPathWithQueryParameters = localVarPath + (localVarPath.indexOf('?') !== -1 ? '&' : '?') + querystring.stringify(queryParameters);

			return fetch(localVarPathWithQueryParameters, fetchParams).then((response) => {
				if (response.status >= 200 && response.status < 300) {
					return response.json();
				} else {
					let error = new Error(response.statusText);
					(error as any).response = response;
					throw error;
				}
			});
		}
		/**
		 *
		 * Replace Contact Type
		 * @param id
		 * @param contactType
		 */
		public companyContactsTypesIdPut (params: {  id: number; contactType: ContactType; }, extraQueryParams?: any, extraFetchParams?: any ) : Promise<ContactType> {
			const localVarPath = this.basePath + '/company/contacts/types/{id}'
				.replace('{' + 'id' + '}', String(params.id));

			let queryParameters: any = assign({}, extraQueryParams);
			let headerParams: any = assign({}, this.defaultHeaders);
			headerParams['Content-Type'] = 'application/json';

			// verify required parameter 'id' is set
			if (params.id == null) {
				throw new Error('Missing required parameter id when calling companyContactsTypesIdPut');
			}
			// verify required parameter 'contactType' is set
			if (params.contactType == null) {
				throw new Error('Missing required parameter contactType when calling companyContactsTypesIdPut');
			}
			let fetchParams = {
				method: 'PUT',
				headers: headerParams,
				body: JSON.stringify(params.contactType),

			};

			if (extraFetchParams) {
				fetchParams = assign(fetchParams, extraFetchParams);
			}

			let localVarPathWithQueryParameters = localVarPath + (localVarPath.indexOf('?') !== -1 ? '&' : '?') + querystring.stringify(queryParameters);

			return fetch(localVarPathWithQueryParameters, fetchParams).then((response) => {
				if (response.status >= 200 && response.status < 300) {
					return response.json();
				} else {
					let error = new Error(response.statusText);
					(error as any).response = response;
					throw error;
				}
			});
		}
		/**
		 *
		 * Create Contact Type
		 * @param contactType
		 */
		public companyContactsTypesPost (params: {  contactType: ContactType; }, extraQueryParams?: any, extraFetchParams?: any ) : Promise<ContactType> {
			const localVarPath = this.basePath + '/company/contacts/types';

			let queryParameters: any = assign({}, extraQueryParams);
			let headerParams: any = assign({}, this.defaultHeaders);
			headerParams['Content-Type'] = 'application/json';

			// verify required parameter 'contactType' is set
			if (params.contactType == null) {
				throw new Error('Missing required parameter contactType when calling companyContactsTypesPost');
			}
			let fetchParams = {
				method: 'POST',
				headers: headerParams,
				body: JSON.stringify(params.contactType),

			};

			if (extraFetchParams) {
				fetchParams = assign(fetchParams, extraFetchParams);
			}

			let localVarPathWithQueryParameters = localVarPath + (localVarPath.indexOf('?') !== -1 ? '&' : '?') + querystring.stringify(queryParameters);

			return fetch(localVarPathWithQueryParameters, fetchParams).then((response) => {
				if (response.status >= 200 && response.status < 300) {
					return response.json();
				} else {
					let error = new Error(response.statusText);
					(error as any).response = response;
					throw error;
				}
			});
		}
	}
//}
//export namespace  {
	'use strict';

	export class ContactsApi {
		protected basePath = 'https://api-na.myconnectwise.net/v4_6_release/apis/3.0';
		public defaultHeaders : any = {};

		constructor(basePath?: string) {
			if (basePath) {
				this.basePath = basePath;
			}
		}

		/**
		 *
		 * Get Contacts Count
		 * @param conditions
		 * @param customFieldConditions
		 * @param childConditions
		 */
		public companyContactsCountGet (params: {  conditions?: string; customFieldConditions?: string; childConditions?: string; }, extraQueryParams?: any, extraFetchParams?: any ) : Promise<Count> {
			const localVarPath = this.basePath + '/company/contacts/count';

			let queryParameters: any = assign({}, extraQueryParams);
			let headerParams: any = assign({}, this.defaultHeaders);
			if (params.conditions !== undefined) {
				queryParameters['conditions'] = params.conditions;
			}

			if (params.customFieldConditions !== undefined) {
				queryParameters['customFieldConditions'] = params.customFieldConditions;
			}

			if (params.childConditions !== undefined) {
				queryParameters['childConditions'] = params.childConditions;
			}

			let fetchParams = {
				method: 'GET',
				headers: headerParams,

			};

			if (extraFetchParams) {
				fetchParams = assign(fetchParams, extraFetchParams);
			}

			let localVarPathWithQueryParameters = localVarPath + (localVarPath.indexOf('?') !== -1 ? '&' : '?') + querystring.stringify(queryParameters);

			return fetch(localVarPathWithQueryParameters, fetchParams).then((response) => {
				if (response.status >= 200 && response.status < 300) {
					return response.json();
				} else {
					let error = new Error(response.statusText);
					(error as any).response = response;
					throw error;
				}
			});
		}
		/**
		 *
		 * Get Contacts
		 * @param conditions
		 * @param orderBy
		 * @param childconditions
		 * @param customfieldconditions
		 * @param page
		 * @param pageSize
		 */
		public companyContactsGet (params: {  conditions?: string; orderBy?: string; childconditions?: string; customfieldconditions?: string; page?: number; pageSize?: number; }, extraQueryParams?: any, extraFetchParams?: any ) : Promise<Array<Contact>> {
			const localVarPath = this.basePath + '/company/contacts';

			let queryParameters: any = assign({}, extraQueryParams);
			let headerParams: any = assign({}, this.defaultHeaders);
			if (params.conditions !== undefined) {
				queryParameters['conditions'] = params.conditions;
			}

			if (params.orderBy !== undefined) {
				queryParameters['orderBy'] = params.orderBy;
			}

			if (params.childconditions !== undefined) {
				queryParameters['childconditions'] = params.childconditions;
			}

			if (params.customfieldconditions !== undefined) {
				queryParameters['customfieldconditions'] = params.customfieldconditions;
			}

			if (params.page !== undefined) {
				queryParameters['page'] = params.page;
			}

			if (params.pageSize !== undefined) {
				queryParameters['pageSize'] = params.pageSize;
			}

			let fetchParams = {
				method: 'GET',
				headers: headerParams,

			};

			if (extraFetchParams) {
				fetchParams = assign(fetchParams, extraFetchParams);
			}

			let localVarPathWithQueryParameters = localVarPath + (localVarPath.indexOf('?') !== -1 ? '&' : '?') + querystring.stringify(queryParameters);

			return fetch(localVarPathWithQueryParameters, fetchParams).then((response) => {
				if (response.status >= 200 && response.status < 300) {
					return response.json();
				} else {
					let error = new Error(response.statusText);
					(error as any).response = response;
					throw error;
				}
			});
		}
		/**
		 *
		 * Delete Contact By Id
		 * @param id
		 * @param transferContactId
		 */
		public companyContactsIdDelete (params: {  id: number; transferContactId?: number; }, extraQueryParams?: any, extraFetchParams?: any ) : Promise<{}> {
			const localVarPath = this.basePath + '/company/contacts/{id}'
				.replace('{' + 'id' + '}', String(params.id));

			let queryParameters: any = assign({}, extraQueryParams);
			let headerParams: any = assign({}, this.defaultHeaders);
			// verify required parameter 'id' is set
			if (params.id == null) {
				throw new Error('Missing required parameter id when calling companyContactsIdDelete');
			}
			if (params.transferContactId !== undefined) {
				queryParameters['transferContactId'] = params.transferContactId;
			}

			let fetchParams = {
				method: 'DELETE',
				headers: headerParams,

			};

			if (extraFetchParams) {
				fetchParams = assign(fetchParams, extraFetchParams);
			}

			let localVarPathWithQueryParameters = localVarPath + (localVarPath.indexOf('?') !== -1 ? '&' : '?') + querystring.stringify(queryParameters);

			return fetch(localVarPathWithQueryParameters, fetchParams).then((response) => {
				if (response.status >= 200 && response.status < 300) {
					return response.json();
				} else {
					let error = new Error(response.statusText);
					(error as any).response = response;
					throw error;
				}
			});
		}
		/**
		 *
		 * Get Contact By Id
		 * @param id
		 */
		public companyContactsIdGet (params: {  id: number; }, extraQueryParams?: any, extraFetchParams?: any ) : Promise<Contact> {
			const localVarPath = this.basePath + '/company/contacts/{id}'
				.replace('{' + 'id' + '}', String(params.id));

			let queryParameters: any = assign({}, extraQueryParams);
			let headerParams: any = assign({}, this.defaultHeaders);
			// verify required parameter 'id' is set
			if (params.id == null) {
				throw new Error('Missing required parameter id when calling companyContactsIdGet');
			}
			let fetchParams = {
				method: 'GET',
				headers: headerParams,

			};

			if (extraFetchParams) {
				fetchParams = assign(fetchParams, extraFetchParams);
			}

			let localVarPathWithQueryParameters = localVarPath + (localVarPath.indexOf('?') !== -1 ? '&' : '?') + querystring.stringify(queryParameters);

			return fetch(localVarPathWithQueryParameters, fetchParams).then((response) => {
				if (response.status >= 200 && response.status < 300) {
					return response.json();
				} else {
					let error = new Error(response.statusText);
					(error as any).response = response;
					throw error;
				}
			});
		}
		/**
		 *
		 * Get Contact Image
		 * @param id
		 * @param useDefaultFlag
		 * @param lastModified
		 */
		public companyContactsIdImageGet (params: {  id: number; useDefaultFlag?: boolean; lastModified?: string; }, extraQueryParams?: any, extraFetchParams?: any ) : Promise<{}> {
			const localVarPath = this.basePath + '/company/contacts/{id}/image'
				.replace('{' + 'id' + '}', String(params.id));

			let queryParameters: any = assign({}, extraQueryParams);
			let headerParams: any = assign({}, this.defaultHeaders);
			// verify required parameter 'id' is set
			if (params.id == null) {
				throw new Error('Missing required parameter id when calling companyContactsIdImageGet');
			}
			if (params.useDefaultFlag !== undefined) {
				queryParameters['useDefaultFlag'] = params.useDefaultFlag;
			}

			if (params.lastModified !== undefined) {
				queryParameters['lastModified'] = params.lastModified;
			}

			let fetchParams = {
				method: 'GET',
				headers: headerParams,

			};

			if (extraFetchParams) {
				fetchParams = assign(fetchParams, extraFetchParams);
			}

			let localVarPathWithQueryParameters = localVarPath + (localVarPath.indexOf('?') !== -1 ? '&' : '?') + querystring.stringify(queryParameters);

			return fetch(localVarPathWithQueryParameters, fetchParams).then((response) => {
				if (response.status >= 200 && response.status < 300) {
					return response.json();
				} else {
					let error = new Error(response.statusText);
					(error as any).response = response;
					throw error;
				}
			});
		}
		/**
		 *
		 * Update Contact
		 * @param id
		 * @param operations
		 */
		public companyContactsIdPatch (params: {  id: number; operations: Array<PatchOperation>; }, extraQueryParams?: any, extraFetchParams?: any ) : Promise<Contact> {
			const localVarPath = this.basePath + '/company/contacts/{id}'
				.replace('{' + 'id' + '}', String(params.id));

			let queryParameters: any = assign({}, extraQueryParams);
			let headerParams: any = assign({}, this.defaultHeaders);
			headerParams['Content-Type'] = 'application/json';

			// verify required parameter 'id' is set
			if (params.id == null) {
				throw new Error('Missing required parameter id when calling companyContactsIdPatch');
			}
			// verify required parameter 'operations' is set
			if (params.operations == null) {
				throw new Error('Missing required parameter operations when calling companyContactsIdPatch');
			}
			let fetchParams = {
				method: 'PATCH',
				headers: headerParams,
				body: JSON.stringify(params.operations),

			};

			if (extraFetchParams) {
				fetchParams = assign(fetchParams, extraFetchParams);
			}

			let localVarPathWithQueryParameters = localVarPath + (localVarPath.indexOf('?') !== -1 ? '&' : '?') + querystring.stringify(queryParameters);

			return fetch(localVarPathWithQueryParameters, fetchParams).then((response) => {
				if (response.status >= 200 && response.status < 300) {
					return response.json();
				} else {
					let error = new Error(response.statusText);
					(error as any).response = response;
					throw error;
				}
			});
		}
		/**
		 *
		 * Get Portal Security
		 * @param id
		 */
		public companyContactsIdPortalSecurityGet (params: {  id: number; }, extraQueryParams?: any, extraFetchParams?: any ) : Promise<Array<PortalSecurity>> {
			const localVarPath = this.basePath + '/company/contacts/{id}/portalSecurity'
				.replace('{' + 'id' + '}', String(params.id));

			let queryParameters: any = assign({}, extraQueryParams);
			let headerParams: any = assign({}, this.defaultHeaders);
			// verify required parameter 'id' is set
			if (params.id == null) {
				throw new Error('Missing required parameter id when calling companyContactsIdPortalSecurityGet');
			}
			let fetchParams = {
				method: 'GET',
				headers: headerParams,

			};

			if (extraFetchParams) {
				fetchParams = assign(fetchParams, extraFetchParams);
			}

			let localVarPathWithQueryParameters = localVarPath + (localVarPath.indexOf('?') !== -1 ? '&' : '?') + querystring.stringify(queryParameters);

			return fetch(localVarPathWithQueryParameters, fetchParams).then((response) => {
				if (response.status >= 200 && response.status < 300) {
					return response.json();
				} else {
					let error = new Error(response.statusText);
					(error as any).response = response;
					throw error;
				}
			});
		}
		/**
		 *
		 * Replace Contact
		 * @param id
		 * @param contact
		 */
		public companyContactsIdPut (params: {  id: number; contact: Contact; }, extraQueryParams?: any, extraFetchParams?: any ) : Promise<Contact> {
			const localVarPath = this.basePath + '/company/contacts/{id}'
				.replace('{' + 'id' + '}', String(params.id));

			let queryParameters: any = assign({}, extraQueryParams);
			let headerParams: any = assign({}, this.defaultHeaders);
			headerParams['Content-Type'] = 'application/json';

			// verify required parameter 'id' is set
			if (params.id == null) {
				throw new Error('Missing required parameter id when calling companyContactsIdPut');
			}
			// verify required parameter 'contact' is set
			if (params.contact == null) {
				throw new Error('Missing required parameter contact when calling companyContactsIdPut');
			}
			let fetchParams = {
				method: 'PUT',
				headers: headerParams,
				body: JSON.stringify(params.contact),

			};

			if (extraFetchParams) {
				fetchParams = assign(fetchParams, extraFetchParams);
			}

			let localVarPathWithQueryParameters = localVarPath + (localVarPath.indexOf('?') !== -1 ? '&' : '?') + querystring.stringify(queryParameters);

			return fetch(localVarPathWithQueryParameters, fetchParams).then((response) => {
				if (response.status >= 200 && response.status < 300) {
					return response.json();
				} else {
					let error = new Error(response.statusText);
					(error as any).response = response;
					throw error;
				}
			});
		}
		/**
		 *
		 * Create Contact
		 * @param contact
		 */
		public companyContactsPost (params: {  contact: Contact; }, extraQueryParams?: any, extraFetchParams?: any ) : Promise<Contact> {
			const localVarPath = this.basePath + '/company/contacts';

			let queryParameters: any = assign({}, extraQueryParams);
			let headerParams: any = assign({}, this.defaultHeaders);
			headerParams['Content-Type'] = 'application/json';

			// verify required parameter 'contact' is set
			if (params.contact == null) {
				throw new Error('Missing required parameter contact when calling companyContactsPost');
			}
			let fetchParams = {
				method: 'POST',
				headers: headerParams,
				body: JSON.stringify(params.contact),

			};

			if (extraFetchParams) {
				fetchParams = assign(fetchParams, extraFetchParams);
			}

			let localVarPathWithQueryParameters = localVarPath + (localVarPath.indexOf('?') !== -1 ? '&' : '?') + querystring.stringify(queryParameters);

			return fetch(localVarPathWithQueryParameters, fetchParams).then((response) => {
				if (response.status >= 200 && response.status < 300) {
					return response.json();
				} else {
					let error = new Error(response.statusText);
					(error as any).response = response;
					throw error;
				}
			});
		}
		/**
		 *
		 * Request Password
		 * @param request
		 */
		public companyContactsRequestPasswordPost (params: {  request: RequestPasswordRequest; }, extraQueryParams?: any, extraFetchParams?: any ) : Promise<{}> {
			const localVarPath = this.basePath + '/company/contacts/requestPassword';

			let queryParameters: any = assign({}, extraQueryParams);
			let headerParams: any = assign({}, this.defaultHeaders);
			headerParams['Content-Type'] = 'application/json';

			// verify required parameter 'request' is set
			if (params.request == null) {
				throw new Error('Missing required parameter request when calling companyContactsRequestPasswordPost');
			}
			let fetchParams = {
				method: 'POST',
				headers: headerParams,
				body: JSON.stringify(params.request),

			};

			if (extraFetchParams) {
				fetchParams = assign(fetchParams, extraFetchParams);
			}

			let localVarPathWithQueryParameters = localVarPath + (localVarPath.indexOf('?') !== -1 ? '&' : '?') + querystring.stringify(queryParameters);

			return fetch(localVarPathWithQueryParameters, fetchParams).then((response) => {
				if (response.status >= 200 && response.status < 300) {
					return response.json();
				} else {
					let error = new Error(response.statusText);
					(error as any).response = response;
					throw error;
				}
			});
		}
		/**
		 *
		 * Validate Portal Credentials
		 * @param request
		 */
		public companyContactsValidatePortalCredentialsPost (params: {  request: ValidatePortalRequest; }, extraQueryParams?: any, extraFetchParams?: any ) : Promise<ValidatePortalResponse> {
			const localVarPath = this.basePath + '/company/contacts/validatePortalCredentials';

			let queryParameters: any = assign({}, extraQueryParams);
			let headerParams: any = assign({}, this.defaultHeaders);
			headerParams['Content-Type'] = 'application/json';

			// verify required parameter 'request' is set
			if (params.request == null) {
				throw new Error('Missing required parameter request when calling companyContactsValidatePortalCredentialsPost');
			}
			let fetchParams = {
				method: 'POST',
				headers: headerParams,
				body: JSON.stringify(params.request),

			};

			if (extraFetchParams) {
				fetchParams = assign(fetchParams, extraFetchParams);
			}

			let localVarPathWithQueryParameters = localVarPath + (localVarPath.indexOf('?') !== -1 ? '&' : '?') + querystring.stringify(queryParameters);

			return fetch(localVarPathWithQueryParameters, fetchParams).then((response) => {
				if (response.status >= 200 && response.status < 300) {
					return response.json();
				} else {
					let error = new Error(response.statusText);
					(error as any).response = response;
					throw error;
				}
			});
		}
	}
//}
//export namespace  {
	'use strict';

	export class CurrenciesApi {
		protected basePath = 'https://api-na.myconnectwise.net/v4_6_release/apis/3.0';
		public defaultHeaders : any = {};

		constructor(basePath?: string) {
			if (basePath) {
				this.basePath = basePath;
			}
		}

		/**
		 *
		 * Get Currencies Count
		 * @param conditions
		 */
		public financeCurrenciesCountGet (params: {  conditions?: string; }, extraQueryParams?: any, extraFetchParams?: any ) : Promise<Count> {
			const localVarPath = this.basePath + '/finance/currencies/count';

			let queryParameters: any = assign({}, extraQueryParams);
			let headerParams: any = assign({}, this.defaultHeaders);
			if (params.conditions !== undefined) {
				queryParameters['conditions'] = params.conditions;
			}

			let fetchParams = {
				method: 'GET',
				headers: headerParams,

			};

			if (extraFetchParams) {
				fetchParams = assign(fetchParams, extraFetchParams);
			}

			let localVarPathWithQueryParameters = localVarPath + (localVarPath.indexOf('?') !== -1 ? '&' : '?') + querystring.stringify(queryParameters);

			return fetch(localVarPathWithQueryParameters, fetchParams).then((response) => {
				if (response.status >= 200 && response.status < 300) {
					return response.json();
				} else {
					let error = new Error(response.statusText);
					(error as any).response = response;
					throw error;
				}
			});
		}
		/**
		 *
		 * Get Currencies
		 * @param conditions
		 * @param orderBy
		 * @param childconditions
		 * @param customfieldconditions
		 * @param page
		 * @param pageSize
		 */
		public financeCurrenciesGet (params: {  conditions?: string; orderBy?: string; childconditions?: string; customfieldconditions?: string; page?: number; pageSize?: number; }, extraQueryParams?: any, extraFetchParams?: any ) : Promise<Array<Currency>> {
			const localVarPath = this.basePath + '/finance/currencies';

			let queryParameters: any = assign({}, extraQueryParams);
			let headerParams: any = assign({}, this.defaultHeaders);
			if (params.conditions !== undefined) {
				queryParameters['conditions'] = params.conditions;
			}

			if (params.orderBy !== undefined) {
				queryParameters['orderBy'] = params.orderBy;
			}

			if (params.childconditions !== undefined) {
				queryParameters['childconditions'] = params.childconditions;
			}

			if (params.customfieldconditions !== undefined) {
				queryParameters['customfieldconditions'] = params.customfieldconditions;
			}

			if (params.page !== undefined) {
				queryParameters['page'] = params.page;
			}

			if (params.pageSize !== undefined) {
				queryParameters['pageSize'] = params.pageSize;
			}

			let fetchParams = {
				method: 'GET',
				headers: headerParams,

			};

			if (extraFetchParams) {
				fetchParams = assign(fetchParams, extraFetchParams);
			}

			let localVarPathWithQueryParameters = localVarPath + (localVarPath.indexOf('?') !== -1 ? '&' : '?') + querystring.stringify(queryParameters);

			return fetch(localVarPathWithQueryParameters, fetchParams).then((response) => {
				if (response.status >= 200 && response.status < 300) {
					return response.json();
				} else {
					let error = new Error(response.statusText);
					(error as any).response = response;
					throw error;
				}
			});
		}
		/**
		 *
		 * Delete Currency By Id
		 * @param id
		 */
		public financeCurrenciesIdDelete (params: {  id: number; }, extraQueryParams?: any, extraFetchParams?: any ) : Promise<{}> {
			const localVarPath = this.basePath + '/finance/currencies/{id}'
				.replace('{' + 'id' + '}', String(params.id));

			let queryParameters: any = assign({}, extraQueryParams);
			let headerParams: any = assign({}, this.defaultHeaders);
			// verify required parameter 'id' is set
			if (params.id == null) {
				throw new Error('Missing required parameter id when calling financeCurrenciesIdDelete');
			}
			let fetchParams = {
				method: 'DELETE',
				headers: headerParams,

			};

			if (extraFetchParams) {
				fetchParams = assign(fetchParams, extraFetchParams);
			}

			let localVarPathWithQueryParameters = localVarPath + (localVarPath.indexOf('?') !== -1 ? '&' : '?') + querystring.stringify(queryParameters);

			return fetch(localVarPathWithQueryParameters, fetchParams).then((response) => {
				if (response.status >= 200 && response.status < 300) {
					return response.json();
				} else {
					let error = new Error(response.statusText);
					(error as any).response = response;
					throw error;
				}
			});
		}
		/**
		 *
		 * Get Currency By Id
		 * @param id
		 */
		public financeCurrenciesIdGet (params: {  id: number; }, extraQueryParams?: any, extraFetchParams?: any ) : Promise<Currency> {
			const localVarPath = this.basePath + '/finance/currencies/{id}'
				.replace('{' + 'id' + '}', String(params.id));

			let queryParameters: any = assign({}, extraQueryParams);
			let headerParams: any = assign({}, this.defaultHeaders);
			// verify required parameter 'id' is set
			if (params.id == null) {
				throw new Error('Missing required parameter id when calling financeCurrenciesIdGet');
			}
			let fetchParams = {
				method: 'GET',
				headers: headerParams,

			};

			if (extraFetchParams) {
				fetchParams = assign(fetchParams, extraFetchParams);
			}

			let localVarPathWithQueryParameters = localVarPath + (localVarPath.indexOf('?') !== -1 ? '&' : '?') + querystring.stringify(queryParameters);

			return fetch(localVarPathWithQueryParameters, fetchParams).then((response) => {
				if (response.status >= 200 && response.status < 300) {
					return response.json();
				} else {
					let error = new Error(response.statusText);
					(error as any).response = response;
					throw error;
				}
			});
		}
		/**
		 *
		 * Update Currency
		 * @param id
		 * @param operations
		 */
		public financeCurrenciesIdPatch (params: {  id: number; operations: Array<PatchOperation>; }, extraQueryParams?: any, extraFetchParams?: any ) : Promise<Currency> {
			const localVarPath = this.basePath + '/finance/currencies/{id}'
				.replace('{' + 'id' + '}', String(params.id));

			let queryParameters: any = assign({}, extraQueryParams);
			let headerParams: any = assign({}, this.defaultHeaders);
			headerParams['Content-Type'] = 'application/json';

			// verify required parameter 'id' is set
			if (params.id == null) {
				throw new Error('Missing required parameter id when calling financeCurrenciesIdPatch');
			}
			// verify required parameter 'operations' is set
			if (params.operations == null) {
				throw new Error('Missing required parameter operations when calling financeCurrenciesIdPatch');
			}
			let fetchParams = {
				method: 'PATCH',
				headers: headerParams,
				body: JSON.stringify(params.operations),

			};

			if (extraFetchParams) {
				fetchParams = assign(fetchParams, extraFetchParams);
			}

			let localVarPathWithQueryParameters = localVarPath + (localVarPath.indexOf('?') !== -1 ? '&' : '?') + querystring.stringify(queryParameters);

			return fetch(localVarPathWithQueryParameters, fetchParams).then((response) => {
				if (response.status >= 200 && response.status < 300) {
					return response.json();
				} else {
					let error = new Error(response.statusText);
					(error as any).response = response;
					throw error;
				}
			});
		}
		/**
		 *
		 * Replace Currency
		 * @param id
		 * @param currency
		 */
		public financeCurrenciesIdPut (params: {  id: number; currency: Currency; }, extraQueryParams?: any, extraFetchParams?: any ) : Promise<Currency> {
			const localVarPath = this.basePath + '/finance/currencies/{id}'
				.replace('{' + 'id' + '}', String(params.id));

			let queryParameters: any = assign({}, extraQueryParams);
			let headerParams: any = assign({}, this.defaultHeaders);
			headerParams['Content-Type'] = 'application/json';

			// verify required parameter 'id' is set
			if (params.id == null) {
				throw new Error('Missing required parameter id when calling financeCurrenciesIdPut');
			}
			// verify required parameter 'currency' is set
			if (params.currency == null) {
				throw new Error('Missing required parameter currency when calling financeCurrenciesIdPut');
			}
			let fetchParams = {
				method: 'PUT',
				headers: headerParams,
				body: JSON.stringify(params.currency),

			};

			if (extraFetchParams) {
				fetchParams = assign(fetchParams, extraFetchParams);
			}

			let localVarPathWithQueryParameters = localVarPath + (localVarPath.indexOf('?') !== -1 ? '&' : '?') + querystring.stringify(queryParameters);

			return fetch(localVarPathWithQueryParameters, fetchParams).then((response) => {
				if (response.status >= 200 && response.status < 300) {
					return response.json();
				} else {
					let error = new Error(response.statusText);
					(error as any).response = response;
					throw error;
				}
			});
		}
		/**
		 *
		 * Create Currency
		 * @param currency
		 */
		public financeCurrenciesPost (params: {  currency: Currency; }, extraQueryParams?: any, extraFetchParams?: any ) : Promise<Currency> {
			const localVarPath = this.basePath + '/finance/currencies';

			let queryParameters: any = assign({}, extraQueryParams);
			let headerParams: any = assign({}, this.defaultHeaders);
			headerParams['Content-Type'] = 'application/json';

			// verify required parameter 'currency' is set
			if (params.currency == null) {
				throw new Error('Missing required parameter currency when calling financeCurrenciesPost');
			}
			let fetchParams = {
				method: 'POST',
				headers: headerParams,
				body: JSON.stringify(params.currency),

			};

			if (extraFetchParams) {
				fetchParams = assign(fetchParams, extraFetchParams);
			}

			let localVarPathWithQueryParameters = localVarPath + (localVarPath.indexOf('?') !== -1 ? '&' : '?') + querystring.stringify(queryParameters);

			return fetch(localVarPathWithQueryParameters, fetchParams).then((response) => {
				if (response.status >= 200 && response.status < 300) {
					return response.json();
				} else {
					let error = new Error(response.statusText);
					(error as any).response = response;
					throw error;
				}
			});
		}
	}
//}
//export namespace  {
	'use strict';

	export class DocumentsApi {
		protected basePath = 'https://api-na.myconnectwise.net/v4_6_release/apis/3.0';
		public defaultHeaders : any = {};

		constructor(basePath?: string) {
			if (basePath) {
				this.basePath = basePath;
			}
		}

		/**
		 *
		 * Get Documents Info Count
		 * @param recordType
		 * @param recordId
		 */
		public systemDocumentsCountGet (params: {  recordType?: string; recordId?: number; }, extraQueryParams?: any, extraFetchParams?: any ) : Promise<Count> {
			const localVarPath = this.basePath + '/system/documents/count';

			let queryParameters: any = assign({}, extraQueryParams);
			let headerParams: any = assign({}, this.defaultHeaders);
			if (params.recordType !== undefined) {
				queryParameters['recordType'] = params.recordType;
			}

			if (params.recordId !== undefined) {
				queryParameters['recordId'] = params.recordId;
			}

			let fetchParams = {
				method: 'GET',
				headers: headerParams,

			};

			if (extraFetchParams) {
				fetchParams = assign(fetchParams, extraFetchParams);
			}

			let localVarPathWithQueryParameters = localVarPath + (localVarPath.indexOf('?') !== -1 ? '&' : '?') + querystring.stringify(queryParameters);

			return fetch(localVarPathWithQueryParameters, fetchParams).then((response) => {
				if (response.status >= 200 && response.status < 300) {
					return response.json();
				} else {
					let error = new Error(response.statusText);
					(error as any).response = response;
					throw error;
				}
			});
		}
		/**
		 *
		 * Get Documents Info
		 * @param recordType
		 * @param recordId
		 * @param page
		 * @param pageSize
		 */
		public systemDocumentsGet (params: {  recordType?: string; recordId?: number; page?: number; pageSize?: number; }, extraQueryParams?: any, extraFetchParams?: any ) : Promise<Array<DocumentInfo>> {
			const localVarPath = this.basePath + '/system/documents';

			let queryParameters: any = assign({}, extraQueryParams);
			let headerParams: any = assign({}, this.defaultHeaders);
			if (params.recordType !== undefined) {
				queryParameters['recordType'] = params.recordType;
			}

			if (params.recordId !== undefined) {
				queryParameters['recordId'] = params.recordId;
			}

			if (params.page !== undefined) {
				queryParameters['page'] = params.page;
			}

			if (params.pageSize !== undefined) {
				queryParameters['pageSize'] = params.pageSize;
			}

			let fetchParams = {
				method: 'GET',
				headers: headerParams,

			};

			if (extraFetchParams) {
				fetchParams = assign(fetchParams, extraFetchParams);
			}

			let localVarPathWithQueryParameters = localVarPath + (localVarPath.indexOf('?') !== -1 ? '&' : '?') + querystring.stringify(queryParameters);

			return fetch(localVarPathWithQueryParameters, fetchParams).then((response) => {
				if (response.status >= 200 && response.status < 300) {
					return response.json();
				} else {
					let error = new Error(response.statusText);
					(error as any).response = response;
					throw error;
				}
			});
		}
		/**
		 *
		 * Delete Document Info By Id
		 * @param id
		 */
		public systemDocumentsIdDelete (params: {  id: number; }, extraQueryParams?: any, extraFetchParams?: any ) : Promise<{}> {
			const localVarPath = this.basePath + '/system/documents/{id}'
				.replace('{' + 'id' + '}', String(params.id));

			let queryParameters: any = assign({}, extraQueryParams);
			let headerParams: any = assign({}, this.defaultHeaders);
			// verify required parameter 'id' is set
			if (params.id == null) {
				throw new Error('Missing required parameter id when calling systemDocumentsIdDelete');
			}
			let fetchParams = {
				method: 'DELETE',
				headers: headerParams,

			};

			if (extraFetchParams) {
				fetchParams = assign(fetchParams, extraFetchParams);
			}

			let localVarPathWithQueryParameters = localVarPath + (localVarPath.indexOf('?') !== -1 ? '&' : '?') + querystring.stringify(queryParameters);

			return fetch(localVarPathWithQueryParameters, fetchParams).then((response) => {
				if (response.status >= 200 && response.status < 300) {
					return response.json();
				} else {
					let error = new Error(response.statusText);
					(error as any).response = response;
					throw error;
				}
			});
		}
		/**
		 *
		 * Download Document
		 * @param id
		 * @param lastModified
		 */
		public systemDocumentsIdDownloadGet (params: {  id: number; lastModified?: string; }, extraQueryParams?: any, extraFetchParams?: any ) : Promise<{}> {
			const localVarPath = this.basePath + '/system/documents/{id}/download'
				.replace('{' + 'id' + '}', String(params.id));

			let queryParameters: any = assign({}, extraQueryParams);
			let headerParams: any = assign({}, this.defaultHeaders);
			// verify required parameter 'id' is set
			if (params.id == null) {
				throw new Error('Missing required parameter id when calling systemDocumentsIdDownloadGet');
			}
			if (params.lastModified !== undefined) {
				queryParameters['lastModified'] = params.lastModified;
			}

			let fetchParams = {
				method: 'GET',
				headers: headerParams,

			};

			if (extraFetchParams) {
				fetchParams = assign(fetchParams, extraFetchParams);
			}

			let localVarPathWithQueryParameters = localVarPath + (localVarPath.indexOf('?') !== -1 ? '&' : '?') + querystring.stringify(queryParameters);

			return fetch(localVarPathWithQueryParameters, fetchParams).then((response) => {
				if (response.status >= 200 && response.status < 300) {
					return response.json();
				} else {
					let error = new Error(response.statusText);
					(error as any).response = response;
					throw error;
				}
			});
		}
		/**
		 *
		 * Get Document Info By Id
		 * @param id
		 */
		public systemDocumentsIdGet (params: {  id: number; }, extraQueryParams?: any, extraFetchParams?: any ) : Promise<DocumentInfo> {
			const localVarPath = this.basePath + '/system/documents/{id}'
				.replace('{' + 'id' + '}', String(params.id));

			let queryParameters: any = assign({}, extraQueryParams);
			let headerParams: any = assign({}, this.defaultHeaders);
			// verify required parameter 'id' is set
			if (params.id == null) {
				throw new Error('Missing required parameter id when calling systemDocumentsIdGet');
			}
			let fetchParams = {
				method: 'GET',
				headers: headerParams,

			};

			if (extraFetchParams) {
				fetchParams = assign(fetchParams, extraFetchParams);
			}

			let localVarPathWithQueryParameters = localVarPath + (localVarPath.indexOf('?') !== -1 ? '&' : '?') + querystring.stringify(queryParameters);

			return fetch(localVarPathWithQueryParameters, fetchParams).then((response) => {
				if (response.status >= 200 && response.status < 300) {
					return response.json();
				} else {
					let error = new Error(response.statusText);
					(error as any).response = response;
					throw error;
				}
			});
		}
		/**
		 *
		 * Update Document By Id
		 * @param id
		 * @param recordId Entity id
		 * @param recordType Entity type
		 * @param title Document title
		 * @param url Document url
		 * @param file File to upload
		 * @param privateFlag Indicates if document is private
		 * @param readOnlyFlag Indicates if document is readonly
		 */
		public systemDocumentsIdPost (params: {  id: number; recordId: number; recordType: string; title: string; url: string; file?: any; privateFlag?: boolean; readOnlyFlag?: boolean; }, extraQueryParams?: any, extraFetchParams?: any ) : Promise<DocumentInfo> {
			const localVarPath = this.basePath + '/system/documents/{id}'
				.replace('{' + 'id' + '}', String(params.id));

			let queryParameters: any = assign({}, extraQueryParams);
			let headerParams: any = assign({}, this.defaultHeaders);
			let formParams: any = {};
			headerParams['Content-Type'] = 'application/x-www-form-urlencoded';

			// verify required parameter 'id' is set
			if (params.id == null) {
				throw new Error('Missing required parameter id when calling systemDocumentsIdPost');
			}
			// verify required parameter 'recordId' is set
			if (params.recordId == null) {
				throw new Error('Missing required parameter recordId when calling systemDocumentsIdPost');
			}
			// verify required parameter 'recordType' is set
			if (params.recordType == null) {
				throw new Error('Missing required parameter recordType when calling systemDocumentsIdPost');
			}
			// verify required parameter 'title' is set
			if (params.title == null) {
				throw new Error('Missing required parameter title when calling systemDocumentsIdPost');
			}
			// verify required parameter 'url' is set
			if (params.url == null) {
				throw new Error('Missing required parameter url when calling systemDocumentsIdPost');
			}
			formParams['file'] = params.file;

			formParams['recordId'] = params.recordId;

			formParams['recordType'] = params.recordType;

			formParams['title'] = params.title;

			formParams['url'] = params.url;

			formParams['privateFlag'] = params.privateFlag;

			formParams['readOnlyFlag'] = params.readOnlyFlag;

			let fetchParams = {
				method: 'POST',
				headers: headerParams,
								body: querystring.stringify(formParams),

			};

			if (extraFetchParams) {
				fetchParams = assign(fetchParams, extraFetchParams);
			}

			let localVarPathWithQueryParameters = localVarPath + (localVarPath.indexOf('?') !== -1 ? '&' : '?') + querystring.stringify(queryParameters);

			return fetch(localVarPathWithQueryParameters, fetchParams).then((response) => {
				if (response.status >= 200 && response.status < 300) {
					return response.json();
				} else {
					let error = new Error(response.statusText);
					(error as any).response = response;
					throw error;
				}
			});
		}
		/**
		 *
		 * Insert Document
		 * @param recordType Entity type
		 * @param title Document title
		 * @param url Document url
		 * @param file File to upload
		 * @param recordId Entity id
		 * @param privateFlag Indicates if document is private
		 * @param readOnlyFlag Indicates if document is readonly
		 */
		public systemDocumentsPost (params: {  recordType: string; title: string; url: string; file?: any; recordId?: number; privateFlag?: boolean; readOnlyFlag?: boolean; }, extraQueryParams?: any, extraFetchParams?: any ) : Promise<DocumentInfo> {
			const localVarPath = this.basePath + '/system/documents';

			let queryParameters: any = assign({}, extraQueryParams);
			let headerParams: any = assign({}, this.defaultHeaders);
			let formParams: any = {};
			headerParams['Content-Type'] = 'application/x-www-form-urlencoded';

			// verify required parameter 'recordType' is set
			if (params.recordType == null) {
				throw new Error('Missing required parameter recordType when calling systemDocumentsPost');
			}
			// verify required parameter 'title' is set
			if (params.title == null) {
				throw new Error('Missing required parameter title when calling systemDocumentsPost');
			}
			// verify required parameter 'url' is set
			if (params.url == null) {
				throw new Error('Missing required parameter url when calling systemDocumentsPost');
			}
			formParams['file'] = params.file;

			formParams['recordId'] = params.recordId;

			formParams['recordType'] = params.recordType;

			formParams['title'] = params.title;

			formParams['url'] = params.url;

			formParams['privateFlag'] = params.privateFlag;

			formParams['readOnlyFlag'] = params.readOnlyFlag;

			let fetchParams = {
				method: 'POST',
				headers: headerParams,
								body: querystring.stringify(formParams),

			};

			if (extraFetchParams) {
				fetchParams = assign(fetchParams, extraFetchParams);
			}

			let localVarPathWithQueryParameters = localVarPath + (localVarPath.indexOf('?') !== -1 ? '&' : '?') + querystring.stringify(queryParameters);

			return fetch(localVarPathWithQueryParameters, fetchParams).then((response) => {
				if (response.status >= 200 && response.status < 300) {
					return response.json();
				} else {
					let error = new Error(response.statusText);
					(error as any).response = response;
					throw error;
				}
			});
		}
		/**
		 *
		 * Get Upload Sample Page
		 */
		public systemDocumentsUploadsampleGet (params: {  }, extraQueryParams?: any, extraFetchParams?: any ) : Promise<{}> {
			const localVarPath = this.basePath + '/system/documents/uploadsample';

			let queryParameters: any = assign({}, extraQueryParams);
			let headerParams: any = assign({}, this.defaultHeaders);
			let fetchParams = {
				method: 'GET',
				headers: headerParams,

			};

			if (extraFetchParams) {
				fetchParams = assign(fetchParams, extraFetchParams);
			}

			let localVarPathWithQueryParameters = localVarPath + (localVarPath.indexOf('?') !== -1 ? '&' : '?') + querystring.stringify(queryParameters);

			return fetch(localVarPathWithQueryParameters, fetchParams).then((response) => {
				if (response.status >= 200 && response.status < 300) {
					return response.json();
				} else {
					let error = new Error(response.statusText);
					(error as any).response = response;
					throw error;
				}
			});
		}
	}
//}
//export namespace  {
	'use strict';

	export class ExpenseEntriesApi {
		protected basePath = 'https://api-na.myconnectwise.net/v4_6_release/apis/3.0';
		public defaultHeaders : any = {};

		constructor(basePath?: string) {
			if (basePath) {
				this.basePath = basePath;
			}
		}

		/**
		 *
		 * Get Expense Entries Count
		 * @param conditions
		 * @param customFieldConditions
		 * @param childConditions
		 */
		public expenseEntriesCountGet (params: {  conditions?: string; customFieldConditions?: string; childConditions?: string; }, extraQueryParams?: any, extraFetchParams?: any ) : Promise<Count> {
			const localVarPath = this.basePath + '/expense/entries/count';

			let queryParameters: any = assign({}, extraQueryParams);
			let headerParams: any = assign({}, this.defaultHeaders);
			if (params.conditions !== undefined) {
				queryParameters['conditions'] = params.conditions;
			}

			if (params.customFieldConditions !== undefined) {
				queryParameters['customFieldConditions'] = params.customFieldConditions;
			}

			if (params.childConditions !== undefined) {
				queryParameters['childConditions'] = params.childConditions;
			}

			let fetchParams = {
				method: 'GET',
				headers: headerParams,

			};

			if (extraFetchParams) {
				fetchParams = assign(fetchParams, extraFetchParams);
			}

			let localVarPathWithQueryParameters = localVarPath + (localVarPath.indexOf('?') !== -1 ? '&' : '?') + querystring.stringify(queryParameters);

			return fetch(localVarPathWithQueryParameters, fetchParams).then((response) => {
				if (response.status >= 200 && response.status < 300) {
					return response.json();
				} else {
					let error = new Error(response.statusText);
					(error as any).response = response;
					throw error;
				}
			});
		}
		/**
		 *
		 * Get Expense Entries
		 * @param conditions
		 * @param orderBy
		 * @param childconditions
		 * @param customfieldconditions
		 * @param page
		 * @param pageSize
		 */
		public expenseEntriesGet (params: {  conditions?: string; orderBy?: string; childconditions?: string; customfieldconditions?: string; page?: number; pageSize?: number; }, extraQueryParams?: any, extraFetchParams?: any ) : Promise<Array<ExpenseEntry>> {
			const localVarPath = this.basePath + '/expense/entries';

			let queryParameters: any = assign({}, extraQueryParams);
			let headerParams: any = assign({}, this.defaultHeaders);
			if (params.conditions !== undefined) {
				queryParameters['conditions'] = params.conditions;
			}

			if (params.orderBy !== undefined) {
				queryParameters['orderBy'] = params.orderBy;
			}

			if (params.childconditions !== undefined) {
				queryParameters['childconditions'] = params.childconditions;
			}

			if (params.customfieldconditions !== undefined) {
				queryParameters['customfieldconditions'] = params.customfieldconditions;
			}

			if (params.page !== undefined) {
				queryParameters['page'] = params.page;
			}

			if (params.pageSize !== undefined) {
				queryParameters['pageSize'] = params.pageSize;
			}

			let fetchParams = {
				method: 'GET',
				headers: headerParams,

			};

			if (extraFetchParams) {
				fetchParams = assign(fetchParams, extraFetchParams);
			}

			let localVarPathWithQueryParameters = localVarPath + (localVarPath.indexOf('?') !== -1 ? '&' : '?') + querystring.stringify(queryParameters);

			return fetch(localVarPathWithQueryParameters, fetchParams).then((response) => {
				if (response.status >= 200 && response.status < 300) {
					return response.json();
				} else {
					let error = new Error(response.statusText);
					(error as any).response = response;
					throw error;
				}
			});
		}
		/**
		 *
		 * Delete Expense Entry By Id
		 * @param id
		 */
		public expenseEntriesIdDelete (params: {  id: number; }, extraQueryParams?: any, extraFetchParams?: any ) : Promise<{}> {
			const localVarPath = this.basePath + '/expense/entries/{id}'
				.replace('{' + 'id' + '}', String(params.id));

			let queryParameters: any = assign({}, extraQueryParams);
			let headerParams: any = assign({}, this.defaultHeaders);
			// verify required parameter 'id' is set
			if (params.id == null) {
				throw new Error('Missing required parameter id when calling expenseEntriesIdDelete');
			}
			let fetchParams = {
				method: 'DELETE',
				headers: headerParams,

			};

			if (extraFetchParams) {
				fetchParams = assign(fetchParams, extraFetchParams);
			}

			let localVarPathWithQueryParameters = localVarPath + (localVarPath.indexOf('?') !== -1 ? '&' : '?') + querystring.stringify(queryParameters);

			return fetch(localVarPathWithQueryParameters, fetchParams).then((response) => {
				if (response.status >= 200 && response.status < 300) {
					return response.json();
				} else {
					let error = new Error(response.statusText);
					(error as any).response = response;
					throw error;
				}
			});
		}
		/**
		 *
		 * Get Expense Entry By Id
		 * @param id
		 */
		public expenseEntriesIdGet (params: {  id: number; }, extraQueryParams?: any, extraFetchParams?: any ) : Promise<ExpenseEntry> {
			const localVarPath = this.basePath + '/expense/entries/{id}'
				.replace('{' + 'id' + '}', String(params.id));

			let queryParameters: any = assign({}, extraQueryParams);
			let headerParams: any = assign({}, this.defaultHeaders);
			// verify required parameter 'id' is set
			if (params.id == null) {
				throw new Error('Missing required parameter id when calling expenseEntriesIdGet');
			}
			let fetchParams = {
				method: 'GET',
				headers: headerParams,

			};

			if (extraFetchParams) {
				fetchParams = assign(fetchParams, extraFetchParams);
			}

			let localVarPathWithQueryParameters = localVarPath + (localVarPath.indexOf('?') !== -1 ? '&' : '?') + querystring.stringify(queryParameters);

			return fetch(localVarPathWithQueryParameters, fetchParams).then((response) => {
				if (response.status >= 200 && response.status < 300) {
					return response.json();
				} else {
					let error = new Error(response.statusText);
					(error as any).response = response;
					throw error;
				}
			});
		}
		/**
		 *
		 * Update Expense Entry
		 * @param id
		 * @param operations
		 */
		public expenseEntriesIdPatch (params: {  id: number; operations: Array<PatchOperation>; }, extraQueryParams?: any, extraFetchParams?: any ) : Promise<ExpenseEntry> {
			const localVarPath = this.basePath + '/expense/entries/{id}'
				.replace('{' + 'id' + '}', String(params.id));

			let queryParameters: any = assign({}, extraQueryParams);
			let headerParams: any = assign({}, this.defaultHeaders);
			headerParams['Content-Type'] = 'application/json';

			// verify required parameter 'id' is set
			if (params.id == null) {
				throw new Error('Missing required parameter id when calling expenseEntriesIdPatch');
			}
			// verify required parameter 'operations' is set
			if (params.operations == null) {
				throw new Error('Missing required parameter operations when calling expenseEntriesIdPatch');
			}
			let fetchParams = {
				method: 'PATCH',
				headers: headerParams,
				body: JSON.stringify(params.operations),

			};

			if (extraFetchParams) {
				fetchParams = assign(fetchParams, extraFetchParams);
			}

			let localVarPathWithQueryParameters = localVarPath + (localVarPath.indexOf('?') !== -1 ? '&' : '?') + querystring.stringify(queryParameters);

			return fetch(localVarPathWithQueryParameters, fetchParams).then((response) => {
				if (response.status >= 200 && response.status < 300) {
					return response.json();
				} else {
					let error = new Error(response.statusText);
					(error as any).response = response;
					throw error;
				}
			});
		}
		/**
		 *
		 * Replace Expense Entry
		 * @param id
		 * @param expenseEntry
		 */
		public expenseEntriesIdPut (params: {  id: number; expenseEntry: ExpenseEntry; }, extraQueryParams?: any, extraFetchParams?: any ) : Promise<ExpenseEntry> {
			const localVarPath = this.basePath + '/expense/entries/{id}'
				.replace('{' + 'id' + '}', String(params.id));

			let queryParameters: any = assign({}, extraQueryParams);
			let headerParams: any = assign({}, this.defaultHeaders);
			headerParams['Content-Type'] = 'application/json';

			// verify required parameter 'id' is set
			if (params.id == null) {
				throw new Error('Missing required parameter id when calling expenseEntriesIdPut');
			}
			// verify required parameter 'expenseEntry' is set
			if (params.expenseEntry == null) {
				throw new Error('Missing required parameter expenseEntry when calling expenseEntriesIdPut');
			}
			let fetchParams = {
				method: 'PUT',
				headers: headerParams,
				body: JSON.stringify(params.expenseEntry),

			};

			if (extraFetchParams) {
				fetchParams = assign(fetchParams, extraFetchParams);
			}

			let localVarPathWithQueryParameters = localVarPath + (localVarPath.indexOf('?') !== -1 ? '&' : '?') + querystring.stringify(queryParameters);

			return fetch(localVarPathWithQueryParameters, fetchParams).then((response) => {
				if (response.status >= 200 && response.status < 300) {
					return response.json();
				} else {
					let error = new Error(response.statusText);
					(error as any).response = response;
					throw error;
				}
			});
		}
		/**
		 *
		 * Create Expense Entry
		 * @param expenseEntry
		 */
		public expenseEntriesPost (params: {  expenseEntry: ExpenseEntry; }, extraQueryParams?: any, extraFetchParams?: any ) : Promise<ExpenseEntry> {
			const localVarPath = this.basePath + '/expense/entries';

			let queryParameters: any = assign({}, extraQueryParams);
			let headerParams: any = assign({}, this.defaultHeaders);
			headerParams['Content-Type'] = 'application/json';

			// verify required parameter 'expenseEntry' is set
			if (params.expenseEntry == null) {
				throw new Error('Missing required parameter expenseEntry when calling expenseEntriesPost');
			}
			let fetchParams = {
				method: 'POST',
				headers: headerParams,
				body: JSON.stringify(params.expenseEntry),

			};

			if (extraFetchParams) {
				fetchParams = assign(fetchParams, extraFetchParams);
			}

			let localVarPathWithQueryParameters = localVarPath + (localVarPath.indexOf('?') !== -1 ? '&' : '?') + querystring.stringify(queryParameters);

			return fetch(localVarPathWithQueryParameters, fetchParams).then((response) => {
				if (response.status >= 200 && response.status < 300) {
					return response.json();
				} else {
					let error = new Error(response.statusText);
					(error as any).response = response;
					throw error;
				}
			});
		}
	}
//}
//export namespace  {
	'use strict';

	export class ExpenseTypesApi {
		protected basePath = 'https://api-na.myconnectwise.net/v4_6_release/apis/3.0';
		public defaultHeaders : any = {};

		constructor(basePath?: string) {
			if (basePath) {
				this.basePath = basePath;
			}
		}

		/**
		 *
		 * Get Expense Types Count
		 * @param conditions
		 */
		public expenseTypesCountGet (params: {  conditions?: string; }, extraQueryParams?: any, extraFetchParams?: any ) : Promise<Count> {
			const localVarPath = this.basePath + '/expense/types/count';

			let queryParameters: any = assign({}, extraQueryParams);
			let headerParams: any = assign({}, this.defaultHeaders);
			if (params.conditions !== undefined) {
				queryParameters['conditions'] = params.conditions;
			}

			let fetchParams = {
				method: 'GET',
				headers: headerParams,

			};

			if (extraFetchParams) {
				fetchParams = assign(fetchParams, extraFetchParams);
			}

			let localVarPathWithQueryParameters = localVarPath + (localVarPath.indexOf('?') !== -1 ? '&' : '?') + querystring.stringify(queryParameters);

			return fetch(localVarPathWithQueryParameters, fetchParams).then((response) => {
				if (response.status >= 200 && response.status < 300) {
					return response.json();
				} else {
					let error = new Error(response.statusText);
					(error as any).response = response;
					throw error;
				}
			});
		}
		/**
		 *
		 * Get Expense Types
		 * @param conditions
		 * @param orderBy
		 * @param childconditions
		 * @param customfieldconditions
		 * @param page
		 * @param pageSize
		 */
		public expenseTypesGet (params: {  conditions?: string; orderBy?: string; childconditions?: string; customfieldconditions?: string; page?: number; pageSize?: number; }, extraQueryParams?: any, extraFetchParams?: any ) : Promise<Array<ExpenseType>> {
			const localVarPath = this.basePath + '/expense/types';

			let queryParameters: any = assign({}, extraQueryParams);
			let headerParams: any = assign({}, this.defaultHeaders);
			if (params.conditions !== undefined) {
				queryParameters['conditions'] = params.conditions;
			}

			if (params.orderBy !== undefined) {
				queryParameters['orderBy'] = params.orderBy;
			}

			if (params.childconditions !== undefined) {
				queryParameters['childconditions'] = params.childconditions;
			}

			if (params.customfieldconditions !== undefined) {
				queryParameters['customfieldconditions'] = params.customfieldconditions;
			}

			if (params.page !== undefined) {
				queryParameters['page'] = params.page;
			}

			if (params.pageSize !== undefined) {
				queryParameters['pageSize'] = params.pageSize;
			}

			let fetchParams = {
				method: 'GET',
				headers: headerParams,

			};

			if (extraFetchParams) {
				fetchParams = assign(fetchParams, extraFetchParams);
			}

			let localVarPathWithQueryParameters = localVarPath + (localVarPath.indexOf('?') !== -1 ? '&' : '?') + querystring.stringify(queryParameters);

			return fetch(localVarPathWithQueryParameters, fetchParams).then((response) => {
				if (response.status >= 200 && response.status < 300) {
					return response.json();
				} else {
					let error = new Error(response.statusText);
					(error as any).response = response;
					throw error;
				}
			});
		}
		/**
		 *
		 * Delete Expense Type By Id
		 * @param id
		 */
		public expenseTypesIdDelete (params: {  id: number; }, extraQueryParams?: any, extraFetchParams?: any ) : Promise<{}> {
			const localVarPath = this.basePath + '/expense/types/{id}'
				.replace('{' + 'id' + '}', String(params.id));

			let queryParameters: any = assign({}, extraQueryParams);
			let headerParams: any = assign({}, this.defaultHeaders);
			// verify required parameter 'id' is set
			if (params.id == null) {
				throw new Error('Missing required parameter id when calling expenseTypesIdDelete');
			}
			let fetchParams = {
				method: 'DELETE',
				headers: headerParams,

			};

			if (extraFetchParams) {
				fetchParams = assign(fetchParams, extraFetchParams);
			}

			let localVarPathWithQueryParameters = localVarPath + (localVarPath.indexOf('?') !== -1 ? '&' : '?') + querystring.stringify(queryParameters);

			return fetch(localVarPathWithQueryParameters, fetchParams).then((response) => {
				if (response.status >= 200 && response.status < 300) {
					return response.json();
				} else {
					let error = new Error(response.statusText);
					(error as any).response = response;
					throw error;
				}
			});
		}
		/**
		 *
		 * Get Expense Type By Id
		 * @param id
		 */
		public expenseTypesIdGet (params: {  id: number; }, extraQueryParams?: any, extraFetchParams?: any ) : Promise<ExpenseType> {
			const localVarPath = this.basePath + '/expense/types/{id}'
				.replace('{' + 'id' + '}', String(params.id));

			let queryParameters: any = assign({}, extraQueryParams);
			let headerParams: any = assign({}, this.defaultHeaders);
			// verify required parameter 'id' is set
			if (params.id == null) {
				throw new Error('Missing required parameter id when calling expenseTypesIdGet');
			}
			let fetchParams = {
				method: 'GET',
				headers: headerParams,

			};

			if (extraFetchParams) {
				fetchParams = assign(fetchParams, extraFetchParams);
			}

			let localVarPathWithQueryParameters = localVarPath + (localVarPath.indexOf('?') !== -1 ? '&' : '?') + querystring.stringify(queryParameters);

			return fetch(localVarPathWithQueryParameters, fetchParams).then((response) => {
				if (response.status >= 200 && response.status < 300) {
					return response.json();
				} else {
					let error = new Error(response.statusText);
					(error as any).response = response;
					throw error;
				}
			});
		}
		/**
		 *
		 * Update Expense Type
		 * @param id
		 * @param operations
		 */
		public expenseTypesIdPatch (params: {  id: number; operations: Array<PatchOperation>; }, extraQueryParams?: any, extraFetchParams?: any ) : Promise<ExpenseType> {
			const localVarPath = this.basePath + '/expense/types/{id}'
				.replace('{' + 'id' + '}', String(params.id));

			let queryParameters: any = assign({}, extraQueryParams);
			let headerParams: any = assign({}, this.defaultHeaders);
			headerParams['Content-Type'] = 'application/json';

			// verify required parameter 'id' is set
			if (params.id == null) {
				throw new Error('Missing required parameter id when calling expenseTypesIdPatch');
			}
			// verify required parameter 'operations' is set
			if (params.operations == null) {
				throw new Error('Missing required parameter operations when calling expenseTypesIdPatch');
			}
			let fetchParams = {
				method: 'PATCH',
				headers: headerParams,
				body: JSON.stringify(params.operations),

			};

			if (extraFetchParams) {
				fetchParams = assign(fetchParams, extraFetchParams);
			}

			let localVarPathWithQueryParameters = localVarPath + (localVarPath.indexOf('?') !== -1 ? '&' : '?') + querystring.stringify(queryParameters);

			return fetch(localVarPathWithQueryParameters, fetchParams).then((response) => {
				if (response.status >= 200 && response.status < 300) {
					return response.json();
				} else {
					let error = new Error(response.statusText);
					(error as any).response = response;
					throw error;
				}
			});
		}
		/**
		 *
		 * Replace Expense Type
		 * @param id
		 * @param expenseType
		 */
		public expenseTypesIdPut (params: {  id: number; expenseType: ExpenseType; }, extraQueryParams?: any, extraFetchParams?: any ) : Promise<ExpenseType> {
			const localVarPath = this.basePath + '/expense/types/{id}'
				.replace('{' + 'id' + '}', String(params.id));

			let queryParameters: any = assign({}, extraQueryParams);
			let headerParams: any = assign({}, this.defaultHeaders);
			headerParams['Content-Type'] = 'application/json';

			// verify required parameter 'id' is set
			if (params.id == null) {
				throw new Error('Missing required parameter id when calling expenseTypesIdPut');
			}
			// verify required parameter 'expenseType' is set
			if (params.expenseType == null) {
				throw new Error('Missing required parameter expenseType when calling expenseTypesIdPut');
			}
			let fetchParams = {
				method: 'PUT',
				headers: headerParams,
				body: JSON.stringify(params.expenseType),

			};

			if (extraFetchParams) {
				fetchParams = assign(fetchParams, extraFetchParams);
			}

			let localVarPathWithQueryParameters = localVarPath + (localVarPath.indexOf('?') !== -1 ? '&' : '?') + querystring.stringify(queryParameters);

			return fetch(localVarPathWithQueryParameters, fetchParams).then((response) => {
				if (response.status >= 200 && response.status < 300) {
					return response.json();
				} else {
					let error = new Error(response.statusText);
					(error as any).response = response;
					throw error;
				}
			});
		}
		/**
		 *
		 * Create Expense Type
		 * @param expenseType
		 */
		public expenseTypesPost (params: {  expenseType: ExpenseType; }, extraQueryParams?: any, extraFetchParams?: any ) : Promise<ExpenseType> {
			const localVarPath = this.basePath + '/expense/types';

			let queryParameters: any = assign({}, extraQueryParams);
			let headerParams: any = assign({}, this.defaultHeaders);
			headerParams['Content-Type'] = 'application/json';

			// verify required parameter 'expenseType' is set
			if (params.expenseType == null) {
				throw new Error('Missing required parameter expenseType when calling expenseTypesPost');
			}
			let fetchParams = {
				method: 'POST',
				headers: headerParams,
				body: JSON.stringify(params.expenseType),

			};

			if (extraFetchParams) {
				fetchParams = assign(fetchParams, extraFetchParams);
			}

			let localVarPathWithQueryParameters = localVarPath + (localVarPath.indexOf('?') !== -1 ? '&' : '?') + querystring.stringify(queryParameters);

			return fetch(localVarPathWithQueryParameters, fetchParams).then((response) => {
				if (response.status >= 200 && response.status < 300) {
					return response.json();
				} else {
					let error = new Error(response.statusText);
					(error as any).response = response;
					throw error;
				}
			});
		}
	}
//}
//export namespace  {
	'use strict';

	export class GroupCompaniesApi {
		protected basePath = 'https://api-na.myconnectwise.net/v4_6_release/apis/3.0';
		public defaultHeaders : any = {};

		constructor(basePath?: string) {
			if (basePath) {
				this.basePath = basePath;
			}
		}

		/**
		 *
		 * Delete Marketing Company By Id
		 * @param id
		 * @param companyId
		 */
		public marketingGroupsIdCompaniesCompanyIdDelete (params: {  id: number; companyId: number; }, extraQueryParams?: any, extraFetchParams?: any ) : Promise<{}> {
			const localVarPath = this.basePath + '/marketing/groups/{id}/companies/{companyId}'
				.replace('{' + 'id' + '}', String(params.id))
				.replace('{' + 'companyId' + '}', String(params.companyId));

			let queryParameters: any = assign({}, extraQueryParams);
			let headerParams: any = assign({}, this.defaultHeaders);
			// verify required parameter 'id' is set
			if (params.id == null) {
				throw new Error('Missing required parameter id when calling marketingGroupsIdCompaniesCompanyIdDelete');
			}
			// verify required parameter 'companyId' is set
			if (params.companyId == null) {
				throw new Error('Missing required parameter companyId when calling marketingGroupsIdCompaniesCompanyIdDelete');
			}
			let fetchParams = {
				method: 'DELETE',
				headers: headerParams,

			};

			if (extraFetchParams) {
				fetchParams = assign(fetchParams, extraFetchParams);
			}

			let localVarPathWithQueryParameters = localVarPath + (localVarPath.indexOf('?') !== -1 ? '&' : '?') + querystring.stringify(queryParameters);

			return fetch(localVarPathWithQueryParameters, fetchParams).then((response) => {
				if (response.status >= 200 && response.status < 300) {
					return response.json();
				} else {
					let error = new Error(response.statusText);
					(error as any).response = response;
					throw error;
				}
			});
		}
		/**
		 *
		 * Get Marketing Company By Id
		 * @param id
		 * @param companyId
		 */
		public marketingGroupsIdCompaniesCompanyIdGet (params: {  id: number; companyId: number; }, extraQueryParams?: any, extraFetchParams?: any ) : Promise<MarketingCompany> {
			const localVarPath = this.basePath + '/marketing/groups/{id}/companies/{companyId}'
				.replace('{' + 'id' + '}', String(params.id))
				.replace('{' + 'companyId' + '}', String(params.companyId));

			let queryParameters: any = assign({}, extraQueryParams);
			let headerParams: any = assign({}, this.defaultHeaders);
			// verify required parameter 'id' is set
			if (params.id == null) {
				throw new Error('Missing required parameter id when calling marketingGroupsIdCompaniesCompanyIdGet');
			}
			// verify required parameter 'companyId' is set
			if (params.companyId == null) {
				throw new Error('Missing required parameter companyId when calling marketingGroupsIdCompaniesCompanyIdGet');
			}
			let fetchParams = {
				method: 'GET',
				headers: headerParams,

			};

			if (extraFetchParams) {
				fetchParams = assign(fetchParams, extraFetchParams);
			}

			let localVarPathWithQueryParameters = localVarPath + (localVarPath.indexOf('?') !== -1 ? '&' : '?') + querystring.stringify(queryParameters);

			return fetch(localVarPathWithQueryParameters, fetchParams).then((response) => {
				if (response.status >= 200 && response.status < 300) {
					return response.json();
				} else {
					let error = new Error(response.statusText);
					(error as any).response = response;
					throw error;
				}
			});
		}
		/**
		 *
		 * Update Marketing Company
		 * @param id
		 * @param companyId
		 * @param operations
		 */
		public marketingGroupsIdCompaniesCompanyIdPatch (params: {  id: number; companyId: number; operations: Array<PatchOperation>; }, extraQueryParams?: any, extraFetchParams?: any ) : Promise<MarketingCompany> {
			const localVarPath = this.basePath + '/marketing/groups/{id}/companies/{companyId}'
				.replace('{' + 'id' + '}', String(params.id))
				.replace('{' + 'companyId' + '}', String(params.companyId));

			let queryParameters: any = assign({}, extraQueryParams);
			let headerParams: any = assign({}, this.defaultHeaders);
			headerParams['Content-Type'] = 'application/json';

			// verify required parameter 'id' is set
			if (params.id == null) {
				throw new Error('Missing required parameter id when calling marketingGroupsIdCompaniesCompanyIdPatch');
			}
			// verify required parameter 'companyId' is set
			if (params.companyId == null) {
				throw new Error('Missing required parameter companyId when calling marketingGroupsIdCompaniesCompanyIdPatch');
			}
			// verify required parameter 'operations' is set
			if (params.operations == null) {
				throw new Error('Missing required parameter operations when calling marketingGroupsIdCompaniesCompanyIdPatch');
			}
			let fetchParams = {
				method: 'PATCH',
				headers: headerParams,
				body: JSON.stringify(params.operations),

			};

			if (extraFetchParams) {
				fetchParams = assign(fetchParams, extraFetchParams);
			}

			let localVarPathWithQueryParameters = localVarPath + (localVarPath.indexOf('?') !== -1 ? '&' : '?') + querystring.stringify(queryParameters);

			return fetch(localVarPathWithQueryParameters, fetchParams).then((response) => {
				if (response.status >= 200 && response.status < 300) {
					return response.json();
				} else {
					let error = new Error(response.statusText);
					(error as any).response = response;
					throw error;
				}
			});
		}
		/**
		 *
		 * Replace Marketing Company
		 * @param id
		 * @param companyId
		 * @param marketingCompany
		 */
		public marketingGroupsIdCompaniesCompanyIdPut (params: {  id: number; companyId: number; marketingCompany: MarketingCompany; }, extraQueryParams?: any, extraFetchParams?: any ) : Promise<MarketingCompany> {
			const localVarPath = this.basePath + '/marketing/groups/{id}/companies/{companyId}'
				.replace('{' + 'id' + '}', String(params.id))
				.replace('{' + 'companyId' + '}', String(params.companyId));

			let queryParameters: any = assign({}, extraQueryParams);
			let headerParams: any = assign({}, this.defaultHeaders);
			headerParams['Content-Type'] = 'application/json';

			// verify required parameter 'id' is set
			if (params.id == null) {
				throw new Error('Missing required parameter id when calling marketingGroupsIdCompaniesCompanyIdPut');
			}
			// verify required parameter 'companyId' is set
			if (params.companyId == null) {
				throw new Error('Missing required parameter companyId when calling marketingGroupsIdCompaniesCompanyIdPut');
			}
			// verify required parameter 'marketingCompany' is set
			if (params.marketingCompany == null) {
				throw new Error('Missing required parameter marketingCompany when calling marketingGroupsIdCompaniesCompanyIdPut');
			}
			let fetchParams = {
				method: 'PUT',
				headers: headerParams,
				body: JSON.stringify(params.marketingCompany),

			};

			if (extraFetchParams) {
				fetchParams = assign(fetchParams, extraFetchParams);
			}

			let localVarPathWithQueryParameters = localVarPath + (localVarPath.indexOf('?') !== -1 ? '&' : '?') + querystring.stringify(queryParameters);

			return fetch(localVarPathWithQueryParameters, fetchParams).then((response) => {
				if (response.status >= 200 && response.status < 300) {
					return response.json();
				} else {
					let error = new Error(response.statusText);
					(error as any).response = response;
					throw error;
				}
			});
		}
		/**
		 *
		 * Get Marketing Companys Count
		 * @param id
		 * @param conditions
		 */
		public marketingGroupsIdCompaniesCountGet (params: {  id: number; conditions?: string; }, extraQueryParams?: any, extraFetchParams?: any ) : Promise<Count> {
			const localVarPath = this.basePath + '/marketing/groups/{id}/companies/count'
				.replace('{' + 'id' + '}', String(params.id));

			let queryParameters: any = assign({}, extraQueryParams);
			let headerParams: any = assign({}, this.defaultHeaders);
			// verify required parameter 'id' is set
			if (params.id == null) {
				throw new Error('Missing required parameter id when calling marketingGroupsIdCompaniesCountGet');
			}
			if (params.conditions !== undefined) {
				queryParameters['conditions'] = params.conditions;
			}

			let fetchParams = {
				method: 'GET',
				headers: headerParams,

			};

			if (extraFetchParams) {
				fetchParams = assign(fetchParams, extraFetchParams);
			}

			let localVarPathWithQueryParameters = localVarPath + (localVarPath.indexOf('?') !== -1 ? '&' : '?') + querystring.stringify(queryParameters);

			return fetch(localVarPathWithQueryParameters, fetchParams).then((response) => {
				if (response.status >= 200 && response.status < 300) {
					return response.json();
				} else {
					let error = new Error(response.statusText);
					(error as any).response = response;
					throw error;
				}
			});
		}
		/**
		 *
		 * Get Marketing Companys
		 * @param id
		 * @param conditions
		 * @param orderBy
		 * @param childconditions
		 * @param customfieldconditions
		 * @param page
		 * @param pageSize
		 */
		public marketingGroupsIdCompaniesGet (params: {  id: number; conditions?: string; orderBy?: string; childconditions?: string; customfieldconditions?: string; page?: number; pageSize?: number; }, extraQueryParams?: any, extraFetchParams?: any ) : Promise<Array<MarketingCompany>> {
			const localVarPath = this.basePath + '/marketing/groups/{id}/companies'
				.replace('{' + 'id' + '}', String(params.id));

			let queryParameters: any = assign({}, extraQueryParams);
			let headerParams: any = assign({}, this.defaultHeaders);
			// verify required parameter 'id' is set
			if (params.id == null) {
				throw new Error('Missing required parameter id when calling marketingGroupsIdCompaniesGet');
			}
			if (params.conditions !== undefined) {
				queryParameters['conditions'] = params.conditions;
			}

			if (params.orderBy !== undefined) {
				queryParameters['orderBy'] = params.orderBy;
			}

			if (params.childconditions !== undefined) {
				queryParameters['childconditions'] = params.childconditions;
			}

			if (params.customfieldconditions !== undefined) {
				queryParameters['customfieldconditions'] = params.customfieldconditions;
			}

			if (params.page !== undefined) {
				queryParameters['page'] = params.page;
			}

			if (params.pageSize !== undefined) {
				queryParameters['pageSize'] = params.pageSize;
			}

			let fetchParams = {
				method: 'GET',
				headers: headerParams,

			};

			if (extraFetchParams) {
				fetchParams = assign(fetchParams, extraFetchParams);
			}

			let localVarPathWithQueryParameters = localVarPath + (localVarPath.indexOf('?') !== -1 ? '&' : '?') + querystring.stringify(queryParameters);

			return fetch(localVarPathWithQueryParameters, fetchParams).then((response) => {
				if (response.status >= 200 && response.status < 300) {
					return response.json();
				} else {
					let error = new Error(response.statusText);
					(error as any).response = response;
					throw error;
				}
			});
		}
		/**
		 *
		 * Create Marketing Company
		 * @param id
		 * @param marketingCompany
		 */
		public marketingGroupsIdCompaniesPost (params: {  id: number; marketingCompany: MarketingCompany; }, extraQueryParams?: any, extraFetchParams?: any ) : Promise<MarketingCompany> {
			const localVarPath = this.basePath + '/marketing/groups/{id}/companies'
				.replace('{' + 'id' + '}', String(params.id));

			let queryParameters: any = assign({}, extraQueryParams);
			let headerParams: any = assign({}, this.defaultHeaders);
			headerParams['Content-Type'] = 'application/json';

			// verify required parameter 'id' is set
			if (params.id == null) {
				throw new Error('Missing required parameter id when calling marketingGroupsIdCompaniesPost');
			}
			// verify required parameter 'marketingCompany' is set
			if (params.marketingCompany == null) {
				throw new Error('Missing required parameter marketingCompany when calling marketingGroupsIdCompaniesPost');
			}
			let fetchParams = {
				method: 'POST',
				headers: headerParams,
				body: JSON.stringify(params.marketingCompany),

			};

			if (extraFetchParams) {
				fetchParams = assign(fetchParams, extraFetchParams);
			}

			let localVarPathWithQueryParameters = localVarPath + (localVarPath.indexOf('?') !== -1 ? '&' : '?') + querystring.stringify(queryParameters);

			return fetch(localVarPathWithQueryParameters, fetchParams).then((response) => {
				if (response.status >= 200 && response.status < 300) {
					return response.json();
				} else {
					let error = new Error(response.statusText);
					(error as any).response = response;
					throw error;
				}
			});
		}
	}
//}
//export namespace  {
	'use strict';

	export class GroupContactsApi {
		protected basePath = 'https://api-na.myconnectwise.net/v4_6_release/apis/3.0';
		public defaultHeaders : any = {};

		constructor(basePath?: string) {
			if (basePath) {
				this.basePath = basePath;
			}
		}

		/**
		 *
		 * Delete Marketing Contact By Id
		 * @param id
		 * @param contactId
		 */
		public marketingGroupsIdContactsContactIdDelete (params: {  id: number; contactId: number; }, extraQueryParams?: any, extraFetchParams?: any ) : Promise<{}> {
			const localVarPath = this.basePath + '/marketing/groups/{id}/contacts/{contactId}'
				.replace('{' + 'id' + '}', String(params.id))
				.replace('{' + 'contactId' + '}', String(params.contactId));

			let queryParameters: any = assign({}, extraQueryParams);
			let headerParams: any = assign({}, this.defaultHeaders);
			// verify required parameter 'id' is set
			if (params.id == null) {
				throw new Error('Missing required parameter id when calling marketingGroupsIdContactsContactIdDelete');
			}
			// verify required parameter 'contactId' is set
			if (params.contactId == null) {
				throw new Error('Missing required parameter contactId when calling marketingGroupsIdContactsContactIdDelete');
			}
			let fetchParams = {
				method: 'DELETE',
				headers: headerParams,

			};

			if (extraFetchParams) {
				fetchParams = assign(fetchParams, extraFetchParams);
			}

			let localVarPathWithQueryParameters = localVarPath + (localVarPath.indexOf('?') !== -1 ? '&' : '?') + querystring.stringify(queryParameters);

			return fetch(localVarPathWithQueryParameters, fetchParams).then((response) => {
				if (response.status >= 200 && response.status < 300) {
					return response.json();
				} else {
					let error = new Error(response.statusText);
					(error as any).response = response;
					throw error;
				}
			});
		}
		/**
		 *
		 * Get Marketing Contact By Id
		 * @param id
		 * @param contactId
		 */
		public marketingGroupsIdContactsContactIdGet (params: {  id: number; contactId: number; }, extraQueryParams?: any, extraFetchParams?: any ) : Promise<MarketingContact> {
			const localVarPath = this.basePath + '/marketing/groups/{id}/contacts/{contactId}'
				.replace('{' + 'id' + '}', String(params.id))
				.replace('{' + 'contactId' + '}', String(params.contactId));

			let queryParameters: any = assign({}, extraQueryParams);
			let headerParams: any = assign({}, this.defaultHeaders);
			// verify required parameter 'id' is set
			if (params.id == null) {
				throw new Error('Missing required parameter id when calling marketingGroupsIdContactsContactIdGet');
			}
			// verify required parameter 'contactId' is set
			if (params.contactId == null) {
				throw new Error('Missing required parameter contactId when calling marketingGroupsIdContactsContactIdGet');
			}
			let fetchParams = {
				method: 'GET',
				headers: headerParams,

			};

			if (extraFetchParams) {
				fetchParams = assign(fetchParams, extraFetchParams);
			}

			let localVarPathWithQueryParameters = localVarPath + (localVarPath.indexOf('?') !== -1 ? '&' : '?') + querystring.stringify(queryParameters);

			return fetch(localVarPathWithQueryParameters, fetchParams).then((response) => {
				if (response.status >= 200 && response.status < 300) {
					return response.json();
				} else {
					let error = new Error(response.statusText);
					(error as any).response = response;
					throw error;
				}
			});
		}
		/**
		 *
		 * Update Marketing Contact
		 * @param id
		 * @param contactId
		 * @param operations
		 */
		public marketingGroupsIdContactsContactIdPatch (params: {  id: number; contactId: number; operations: Array<PatchOperation>; }, extraQueryParams?: any, extraFetchParams?: any ) : Promise<MarketingContact> {
			const localVarPath = this.basePath + '/marketing/groups/{id}/contacts/{contactId}'
				.replace('{' + 'id' + '}', String(params.id))
				.replace('{' + 'contactId' + '}', String(params.contactId));

			let queryParameters: any = assign({}, extraQueryParams);
			let headerParams: any = assign({}, this.defaultHeaders);
			headerParams['Content-Type'] = 'application/json';

			// verify required parameter 'id' is set
			if (params.id == null) {
				throw new Error('Missing required parameter id when calling marketingGroupsIdContactsContactIdPatch');
			}
			// verify required parameter 'contactId' is set
			if (params.contactId == null) {
				throw new Error('Missing required parameter contactId when calling marketingGroupsIdContactsContactIdPatch');
			}
			// verify required parameter 'operations' is set
			if (params.operations == null) {
				throw new Error('Missing required parameter operations when calling marketingGroupsIdContactsContactIdPatch');
			}
			let fetchParams = {
				method: 'PATCH',
				headers: headerParams,
				body: JSON.stringify(params.operations),

			};

			if (extraFetchParams) {
				fetchParams = assign(fetchParams, extraFetchParams);
			}

			let localVarPathWithQueryParameters = localVarPath + (localVarPath.indexOf('?') !== -1 ? '&' : '?') + querystring.stringify(queryParameters);

			return fetch(localVarPathWithQueryParameters, fetchParams).then((response) => {
				if (response.status >= 200 && response.status < 300) {
					return response.json();
				} else {
					let error = new Error(response.statusText);
					(error as any).response = response;
					throw error;
				}
			});
		}
		/**
		 *
		 * Replace Marketing Contact
		 * @param id
		 * @param contactId
		 * @param marketingContact
		 */
		public marketingGroupsIdContactsContactIdPut (params: {  id: number; contactId: number; marketingContact: MarketingContact; }, extraQueryParams?: any, extraFetchParams?: any ) : Promise<MarketingContact> {
			const localVarPath = this.basePath + '/marketing/groups/{id}/contacts/{contactId}'
				.replace('{' + 'id' + '}', String(params.id))
				.replace('{' + 'contactId' + '}', String(params.contactId));

			let queryParameters: any = assign({}, extraQueryParams);
			let headerParams: any = assign({}, this.defaultHeaders);
			headerParams['Content-Type'] = 'application/json';

			// verify required parameter 'id' is set
			if (params.id == null) {
				throw new Error('Missing required parameter id when calling marketingGroupsIdContactsContactIdPut');
			}
			// verify required parameter 'contactId' is set
			if (params.contactId == null) {
				throw new Error('Missing required parameter contactId when calling marketingGroupsIdContactsContactIdPut');
			}
			// verify required parameter 'marketingContact' is set
			if (params.marketingContact == null) {
				throw new Error('Missing required parameter marketingContact when calling marketingGroupsIdContactsContactIdPut');
			}
			let fetchParams = {
				method: 'PUT',
				headers: headerParams,
				body: JSON.stringify(params.marketingContact),

			};

			if (extraFetchParams) {
				fetchParams = assign(fetchParams, extraFetchParams);
			}

			let localVarPathWithQueryParameters = localVarPath + (localVarPath.indexOf('?') !== -1 ? '&' : '?') + querystring.stringify(queryParameters);

			return fetch(localVarPathWithQueryParameters, fetchParams).then((response) => {
				if (response.status >= 200 && response.status < 300) {
					return response.json();
				} else {
					let error = new Error(response.statusText);
					(error as any).response = response;
					throw error;
				}
			});
		}
		/**
		 *
		 * Get Marketing Contacts Count
		 * @param id
		 * @param conditions
		 */
		public marketingGroupsIdContactsCountGet (params: {  id: number; conditions?: string; }, extraQueryParams?: any, extraFetchParams?: any ) : Promise<Count> {
			const localVarPath = this.basePath + '/marketing/groups/{id}/contacts/count'
				.replace('{' + 'id' + '}', String(params.id));

			let queryParameters: any = assign({}, extraQueryParams);
			let headerParams: any = assign({}, this.defaultHeaders);
			// verify required parameter 'id' is set
			if (params.id == null) {
				throw new Error('Missing required parameter id when calling marketingGroupsIdContactsCountGet');
			}
			if (params.conditions !== undefined) {
				queryParameters['conditions'] = params.conditions;
			}

			let fetchParams = {
				method: 'GET',
				headers: headerParams,

			};

			if (extraFetchParams) {
				fetchParams = assign(fetchParams, extraFetchParams);
			}

			let localVarPathWithQueryParameters = localVarPath + (localVarPath.indexOf('?') !== -1 ? '&' : '?') + querystring.stringify(queryParameters);

			return fetch(localVarPathWithQueryParameters, fetchParams).then((response) => {
				if (response.status >= 200 && response.status < 300) {
					return response.json();
				} else {
					let error = new Error(response.statusText);
					(error as any).response = response;
					throw error;
				}
			});
		}
		/**
		 *
		 * Get Marketing Contacts
		 * @param id
		 * @param conditions
		 * @param orderBy
		 * @param childconditions
		 * @param customfieldconditions
		 * @param page
		 * @param pageSize
		 */
		public marketingGroupsIdContactsGet (params: {  id: number; conditions?: string; orderBy?: string; childconditions?: string; customfieldconditions?: string; page?: number; pageSize?: number; }, extraQueryParams?: any, extraFetchParams?: any ) : Promise<Array<MarketingContact>> {
			const localVarPath = this.basePath + '/marketing/groups/{id}/contacts'
				.replace('{' + 'id' + '}', String(params.id));

			let queryParameters: any = assign({}, extraQueryParams);
			let headerParams: any = assign({}, this.defaultHeaders);
			// verify required parameter 'id' is set
			if (params.id == null) {
				throw new Error('Missing required parameter id when calling marketingGroupsIdContactsGet');
			}
			if (params.conditions !== undefined) {
				queryParameters['conditions'] = params.conditions;
			}

			if (params.orderBy !== undefined) {
				queryParameters['orderBy'] = params.orderBy;
			}

			if (params.childconditions !== undefined) {
				queryParameters['childconditions'] = params.childconditions;
			}

			if (params.customfieldconditions !== undefined) {
				queryParameters['customfieldconditions'] = params.customfieldconditions;
			}

			if (params.page !== undefined) {
				queryParameters['page'] = params.page;
			}

			if (params.pageSize !== undefined) {
				queryParameters['pageSize'] = params.pageSize;
			}

			let fetchParams = {
				method: 'GET',
				headers: headerParams,

			};

			if (extraFetchParams) {
				fetchParams = assign(fetchParams, extraFetchParams);
			}

			let localVarPathWithQueryParameters = localVarPath + (localVarPath.indexOf('?') !== -1 ? '&' : '?') + querystring.stringify(queryParameters);

			return fetch(localVarPathWithQueryParameters, fetchParams).then((response) => {
				if (response.status >= 200 && response.status < 300) {
					return response.json();
				} else {
					let error = new Error(response.statusText);
					(error as any).response = response;
					throw error;
				}
			});
		}
		/**
		 *
		 * Create Marketing Contact
		 * @param id
		 * @param marketingContact
		 */
		public marketingGroupsIdContactsPost (params: {  id: number; marketingContact: MarketingContact; }, extraQueryParams?: any, extraFetchParams?: any ) : Promise<MarketingContact> {
			const localVarPath = this.basePath + '/marketing/groups/{id}/contacts'
				.replace('{' + 'id' + '}', String(params.id));

			let queryParameters: any = assign({}, extraQueryParams);
			let headerParams: any = assign({}, this.defaultHeaders);
			headerParams['Content-Type'] = 'application/json';

			// verify required parameter 'id' is set
			if (params.id == null) {
				throw new Error('Missing required parameter id when calling marketingGroupsIdContactsPost');
			}
			// verify required parameter 'marketingContact' is set
			if (params.marketingContact == null) {
				throw new Error('Missing required parameter marketingContact when calling marketingGroupsIdContactsPost');
			}
			let fetchParams = {
				method: 'POST',
				headers: headerParams,
				body: JSON.stringify(params.marketingContact),

			};

			if (extraFetchParams) {
				fetchParams = assign(fetchParams, extraFetchParams);
			}

			let localVarPathWithQueryParameters = localVarPath + (localVarPath.indexOf('?') !== -1 ? '&' : '?') + querystring.stringify(queryParameters);

			return fetch(localVarPathWithQueryParameters, fetchParams).then((response) => {
				if (response.status >= 200 && response.status < 300) {
					return response.json();
				} else {
					let error = new Error(response.statusText);
					(error as any).response = response;
					throw error;
				}
			});
		}
	}
//}
//export namespace  {
	'use strict';

	export class GroupsApi {
		protected basePath = 'https://api-na.myconnectwise.net/v4_6_release/apis/3.0';
		public defaultHeaders : any = {};

		constructor(basePath?: string) {
			if (basePath) {
				this.basePath = basePath;
			}
		}

		/**
		 *
		 * Get Groups Count
		 * @param conditions
		 */
		public marketingGroupsCountGet (params: {  conditions?: string; }, extraQueryParams?: any, extraFetchParams?: any ) : Promise<Count> {
			const localVarPath = this.basePath + '/marketing/groups/count';

			let queryParameters: any = assign({}, extraQueryParams);
			let headerParams: any = assign({}, this.defaultHeaders);
			if (params.conditions !== undefined) {
				queryParameters['conditions'] = params.conditions;
			}

			let fetchParams = {
				method: 'GET',
				headers: headerParams,

			};

			if (extraFetchParams) {
				fetchParams = assign(fetchParams, extraFetchParams);
			}

			let localVarPathWithQueryParameters = localVarPath + (localVarPath.indexOf('?') !== -1 ? '&' : '?') + querystring.stringify(queryParameters);

			return fetch(localVarPathWithQueryParameters, fetchParams).then((response) => {
				if (response.status >= 200 && response.status < 300) {
					return response.json();
				} else {
					let error = new Error(response.statusText);
					(error as any).response = response;
					throw error;
				}
			});
		}
		/**
		 *
		 * Get Groups
		 * @param conditions
		 * @param orderBy
		 * @param childconditions
		 * @param customfieldconditions
		 * @param page
		 * @param pageSize
		 */
		public marketingGroupsGet (params: {  conditions?: string; orderBy?: string; childconditions?: string; customfieldconditions?: string; page?: number; pageSize?: number; }, extraQueryParams?: any, extraFetchParams?: any ) : Promise<Array<Group>> {
			const localVarPath = this.basePath + '/marketing/groups';

			let queryParameters: any = assign({}, extraQueryParams);
			let headerParams: any = assign({}, this.defaultHeaders);
			if (params.conditions !== undefined) {
				queryParameters['conditions'] = params.conditions;
			}

			if (params.orderBy !== undefined) {
				queryParameters['orderBy'] = params.orderBy;
			}

			if (params.childconditions !== undefined) {
				queryParameters['childconditions'] = params.childconditions;
			}

			if (params.customfieldconditions !== undefined) {
				queryParameters['customfieldconditions'] = params.customfieldconditions;
			}

			if (params.page !== undefined) {
				queryParameters['page'] = params.page;
			}

			if (params.pageSize !== undefined) {
				queryParameters['pageSize'] = params.pageSize;
			}

			let fetchParams = {
				method: 'GET',
				headers: headerParams,

			};

			if (extraFetchParams) {
				fetchParams = assign(fetchParams, extraFetchParams);
			}

			let localVarPathWithQueryParameters = localVarPath + (localVarPath.indexOf('?') !== -1 ? '&' : '?') + querystring.stringify(queryParameters);

			return fetch(localVarPathWithQueryParameters, fetchParams).then((response) => {
				if (response.status >= 200 && response.status < 300) {
					return response.json();
				} else {
					let error = new Error(response.statusText);
					(error as any).response = response;
					throw error;
				}
			});
		}
		/**
		 *
		 * Delete Group By Id
		 * @param id
		 */
		public marketingGroupsIdDelete (params: {  id: number; }, extraQueryParams?: any, extraFetchParams?: any ) : Promise<{}> {
			const localVarPath = this.basePath + '/marketing/groups/{id}'
				.replace('{' + 'id' + '}', String(params.id));

			let queryParameters: any = assign({}, extraQueryParams);
			let headerParams: any = assign({}, this.defaultHeaders);
			// verify required parameter 'id' is set
			if (params.id == null) {
				throw new Error('Missing required parameter id when calling marketingGroupsIdDelete');
			}
			let fetchParams = {
				method: 'DELETE',
				headers: headerParams,

			};

			if (extraFetchParams) {
				fetchParams = assign(fetchParams, extraFetchParams);
			}

			let localVarPathWithQueryParameters = localVarPath + (localVarPath.indexOf('?') !== -1 ? '&' : '?') + querystring.stringify(queryParameters);

			return fetch(localVarPathWithQueryParameters, fetchParams).then((response) => {
				if (response.status >= 200 && response.status < 300) {
					return response.json();
				} else {
					let error = new Error(response.statusText);
					(error as any).response = response;
					throw error;
				}
			});
		}
		/**
		 *
		 * Get Group By Id
		 * @param id
		 */
		public marketingGroupsIdGet (params: {  id: number; }, extraQueryParams?: any, extraFetchParams?: any ) : Promise<Group> {
			const localVarPath = this.basePath + '/marketing/groups/{id}'
				.replace('{' + 'id' + '}', String(params.id));

			let queryParameters: any = assign({}, extraQueryParams);
			let headerParams: any = assign({}, this.defaultHeaders);
			// verify required parameter 'id' is set
			if (params.id == null) {
				throw new Error('Missing required parameter id when calling marketingGroupsIdGet');
			}
			let fetchParams = {
				method: 'GET',
				headers: headerParams,

			};

			if (extraFetchParams) {
				fetchParams = assign(fetchParams, extraFetchParams);
			}

			let localVarPathWithQueryParameters = localVarPath + (localVarPath.indexOf('?') !== -1 ? '&' : '?') + querystring.stringify(queryParameters);

			return fetch(localVarPathWithQueryParameters, fetchParams).then((response) => {
				if (response.status >= 200 && response.status < 300) {
					return response.json();
				} else {
					let error = new Error(response.statusText);
					(error as any).response = response;
					throw error;
				}
			});
		}
		/**
		 *
		 * Update Group
		 * @param id
		 * @param operations
		 */
		public marketingGroupsIdPatch (params: {  id: number; operations: Array<PatchOperation>; }, extraQueryParams?: any, extraFetchParams?: any ) : Promise<Group> {
			const localVarPath = this.basePath + '/marketing/groups/{id}'
				.replace('{' + 'id' + '}', String(params.id));

			let queryParameters: any = assign({}, extraQueryParams);
			let headerParams: any = assign({}, this.defaultHeaders);
			headerParams['Content-Type'] = 'application/json';

			// verify required parameter 'id' is set
			if (params.id == null) {
				throw new Error('Missing required parameter id when calling marketingGroupsIdPatch');
			}
			// verify required parameter 'operations' is set
			if (params.operations == null) {
				throw new Error('Missing required parameter operations when calling marketingGroupsIdPatch');
			}
			let fetchParams = {
				method: 'PATCH',
				headers: headerParams,
				body: JSON.stringify(params.operations),

			};

			if (extraFetchParams) {
				fetchParams = assign(fetchParams, extraFetchParams);
			}

			let localVarPathWithQueryParameters = localVarPath + (localVarPath.indexOf('?') !== -1 ? '&' : '?') + querystring.stringify(queryParameters);

			return fetch(localVarPathWithQueryParameters, fetchParams).then((response) => {
				if (response.status >= 200 && response.status < 300) {
					return response.json();
				} else {
					let error = new Error(response.statusText);
					(error as any).response = response;
					throw error;
				}
			});
		}
		/**
		 *
		 * Replace Group
		 * @param id
		 * @param group
		 */
		public marketingGroupsIdPut (params: {  id: number; group: Group; }, extraQueryParams?: any, extraFetchParams?: any ) : Promise<Group> {
			const localVarPath = this.basePath + '/marketing/groups/{id}'
				.replace('{' + 'id' + '}', String(params.id));

			let queryParameters: any = assign({}, extraQueryParams);
			let headerParams: any = assign({}, this.defaultHeaders);
			headerParams['Content-Type'] = 'application/json';

			// verify required parameter 'id' is set
			if (params.id == null) {
				throw new Error('Missing required parameter id when calling marketingGroupsIdPut');
			}
			// verify required parameter 'group' is set
			if (params.group == null) {
				throw new Error('Missing required parameter group when calling marketingGroupsIdPut');
			}
			let fetchParams = {
				method: 'PUT',
				headers: headerParams,
				body: JSON.stringify(params.group),

			};

			if (extraFetchParams) {
				fetchParams = assign(fetchParams, extraFetchParams);
			}

			let localVarPathWithQueryParameters = localVarPath + (localVarPath.indexOf('?') !== -1 ? '&' : '?') + querystring.stringify(queryParameters);

			return fetch(localVarPathWithQueryParameters, fetchParams).then((response) => {
				if (response.status >= 200 && response.status < 300) {
					return response.json();
				} else {
					let error = new Error(response.statusText);
					(error as any).response = response;
					throw error;
				}
			});
		}
		/**
		 *
		 * Create Group
		 * @param group
		 */
		public marketingGroupsPost (params: {  group: Group; }, extraQueryParams?: any, extraFetchParams?: any ) : Promise<Group> {
			const localVarPath = this.basePath + '/marketing/groups';

			let queryParameters: any = assign({}, extraQueryParams);
			let headerParams: any = assign({}, this.defaultHeaders);
			headerParams['Content-Type'] = 'application/json';

			// verify required parameter 'group' is set
			if (params.group == null) {
				throw new Error('Missing required parameter group when calling marketingGroupsPost');
			}
			let fetchParams = {
				method: 'POST',
				headers: headerParams,
				body: JSON.stringify(params.group),

			};

			if (extraFetchParams) {
				fetchParams = assign(fetchParams, extraFetchParams);
			}

			let localVarPathWithQueryParameters = localVarPath + (localVarPath.indexOf('?') !== -1 ? '&' : '?') + querystring.stringify(queryParameters);

			return fetch(localVarPathWithQueryParameters, fetchParams).then((response) => {
				if (response.status >= 200 && response.status < 300) {
					return response.json();
				} else {
					let error = new Error(response.statusText);
					(error as any).response = response;
					throw error;
				}
			});
		}
	}
//}
//export namespace  {
	'use strict';

	export class InOutBoardsApi {
		protected basePath = 'https://api-na.myconnectwise.net/v4_6_release/apis/3.0';
		public defaultHeaders : any = {};

		constructor(basePath?: string) {
			if (basePath) {
				this.basePath = basePath;
			}
		}

		/**
		 *
		 * Get In Out Board Count
		 * @param conditions
		 */
		public systemInOutBoardsCountGet (params: {  conditions?: string; }, extraQueryParams?: any, extraFetchParams?: any ) : Promise<Count> {
			const localVarPath = this.basePath + '/system/inOutBoards/count';

			let queryParameters: any = assign({}, extraQueryParams);
			let headerParams: any = assign({}, this.defaultHeaders);
			if (params.conditions !== undefined) {
				queryParameters['conditions'] = params.conditions;
			}

			let fetchParams = {
				method: 'GET',
				headers: headerParams,

			};

			if (extraFetchParams) {
				fetchParams = assign(fetchParams, extraFetchParams);
			}

			let localVarPathWithQueryParameters = localVarPath + (localVarPath.indexOf('?') !== -1 ? '&' : '?') + querystring.stringify(queryParameters);

			return fetch(localVarPathWithQueryParameters, fetchParams).then((response) => {
				if (response.status >= 200 && response.status < 300) {
					return response.json();
				} else {
					let error = new Error(response.statusText);
					(error as any).response = response;
					throw error;
				}
			});
		}
		/**
		 *
		 * Get In Out Board
		 * @param conditions
		 * @param orderBy
		 * @param childconditions
		 * @param customfieldconditions
		 * @param page
		 * @param pageSize
		 */
		public systemInOutBoardsGet (params: {  conditions?: string; orderBy?: string; childconditions?: string; customfieldconditions?: string; page?: number; pageSize?: number; }, extraQueryParams?: any, extraFetchParams?: any ) : Promise<Array<InOutBoard>> {
			const localVarPath = this.basePath + '/system/inOutBoards';

			let queryParameters: any = assign({}, extraQueryParams);
			let headerParams: any = assign({}, this.defaultHeaders);
			if (params.conditions !== undefined) {
				queryParameters['conditions'] = params.conditions;
			}

			if (params.orderBy !== undefined) {
				queryParameters['orderBy'] = params.orderBy;
			}

			if (params.childconditions !== undefined) {
				queryParameters['childconditions'] = params.childconditions;
			}

			if (params.customfieldconditions !== undefined) {
				queryParameters['customfieldconditions'] = params.customfieldconditions;
			}

			if (params.page !== undefined) {
				queryParameters['page'] = params.page;
			}

			if (params.pageSize !== undefined) {
				queryParameters['pageSize'] = params.pageSize;
			}

			let fetchParams = {
				method: 'GET',
				headers: headerParams,

			};

			if (extraFetchParams) {
				fetchParams = assign(fetchParams, extraFetchParams);
			}

			let localVarPathWithQueryParameters = localVarPath + (localVarPath.indexOf('?') !== -1 ? '&' : '?') + querystring.stringify(queryParameters);

			return fetch(localVarPathWithQueryParameters, fetchParams).then((response) => {
				if (response.status >= 200 && response.status < 300) {
					return response.json();
				} else {
					let error = new Error(response.statusText);
					(error as any).response = response;
					throw error;
				}
			});
		}
		/**
		 *
		 * Delete In Out Board By Id
		 * @param id
		 */
		public systemInOutBoardsIdDelete (params: {  id: number; }, extraQueryParams?: any, extraFetchParams?: any ) : Promise<{}> {
			const localVarPath = this.basePath + '/system/inOutBoards/{id}'
				.replace('{' + 'id' + '}', String(params.id));

			let queryParameters: any = assign({}, extraQueryParams);
			let headerParams: any = assign({}, this.defaultHeaders);
			// verify required parameter 'id' is set
			if (params.id == null) {
				throw new Error('Missing required parameter id when calling systemInOutBoardsIdDelete');
			}
			let fetchParams = {
				method: 'DELETE',
				headers: headerParams,

			};

			if (extraFetchParams) {
				fetchParams = assign(fetchParams, extraFetchParams);
			}

			let localVarPathWithQueryParameters = localVarPath + (localVarPath.indexOf('?') !== -1 ? '&' : '?') + querystring.stringify(queryParameters);

			return fetch(localVarPathWithQueryParameters, fetchParams).then((response) => {
				if (response.status >= 200 && response.status < 300) {
					return response.json();
				} else {
					let error = new Error(response.statusText);
					(error as any).response = response;
					throw error;
				}
			});
		}
		/**
		 *
		 * Get In Out Board By Id
		 * @param id
		 */
		public systemInOutBoardsIdGet (params: {  id: number; }, extraQueryParams?: any, extraFetchParams?: any ) : Promise<InOutBoard> {
			const localVarPath = this.basePath + '/system/inOutBoards/{id}'
				.replace('{' + 'id' + '}', String(params.id));

			let queryParameters: any = assign({}, extraQueryParams);
			let headerParams: any = assign({}, this.defaultHeaders);
			// verify required parameter 'id' is set
			if (params.id == null) {
				throw new Error('Missing required parameter id when calling systemInOutBoardsIdGet');
			}
			let fetchParams = {
				method: 'GET',
				headers: headerParams,

			};

			if (extraFetchParams) {
				fetchParams = assign(fetchParams, extraFetchParams);
			}

			let localVarPathWithQueryParameters = localVarPath + (localVarPath.indexOf('?') !== -1 ? '&' : '?') + querystring.stringify(queryParameters);

			return fetch(localVarPathWithQueryParameters, fetchParams).then((response) => {
				if (response.status >= 200 && response.status < 300) {
					return response.json();
				} else {
					let error = new Error(response.statusText);
					(error as any).response = response;
					throw error;
				}
			});
		}
		/**
		 *
		 * Update In Out Board
		 * @param id
		 * @param operations
		 */
		public systemInOutBoardsIdPatch (params: {  id: number; operations: Array<PatchOperation>; }, extraQueryParams?: any, extraFetchParams?: any ) : Promise<InOutBoard> {
			const localVarPath = this.basePath + '/system/inOutBoards/{id}'
				.replace('{' + 'id' + '}', String(params.id));

			let queryParameters: any = assign({}, extraQueryParams);
			let headerParams: any = assign({}, this.defaultHeaders);
			headerParams['Content-Type'] = 'application/json';

			// verify required parameter 'id' is set
			if (params.id == null) {
				throw new Error('Missing required parameter id when calling systemInOutBoardsIdPatch');
			}
			// verify required parameter 'operations' is set
			if (params.operations == null) {
				throw new Error('Missing required parameter operations when calling systemInOutBoardsIdPatch');
			}
			let fetchParams = {
				method: 'PATCH',
				headers: headerParams,
				body: JSON.stringify(params.operations),

			};

			if (extraFetchParams) {
				fetchParams = assign(fetchParams, extraFetchParams);
			}

			let localVarPathWithQueryParameters = localVarPath + (localVarPath.indexOf('?') !== -1 ? '&' : '?') + querystring.stringify(queryParameters);

			return fetch(localVarPathWithQueryParameters, fetchParams).then((response) => {
				if (response.status >= 200 && response.status < 300) {
					return response.json();
				} else {
					let error = new Error(response.statusText);
					(error as any).response = response;
					throw error;
				}
			});
		}
		/**
		 *
		 * Replace In Out Board
		 * @param id
		 * @param inOutBoard
		 */
		public systemInOutBoardsIdPut (params: {  id: number; inOutBoard: InOutBoard; }, extraQueryParams?: any, extraFetchParams?: any ) : Promise<InOutBoard> {
			const localVarPath = this.basePath + '/system/inOutBoards/{id}'
				.replace('{' + 'id' + '}', String(params.id));

			let queryParameters: any = assign({}, extraQueryParams);
			let headerParams: any = assign({}, this.defaultHeaders);
			headerParams['Content-Type'] = 'application/json';

			// verify required parameter 'id' is set
			if (params.id == null) {
				throw new Error('Missing required parameter id when calling systemInOutBoardsIdPut');
			}
			// verify required parameter 'inOutBoard' is set
			if (params.inOutBoard == null) {
				throw new Error('Missing required parameter inOutBoard when calling systemInOutBoardsIdPut');
			}
			let fetchParams = {
				method: 'PUT',
				headers: headerParams,
				body: JSON.stringify(params.inOutBoard),

			};

			if (extraFetchParams) {
				fetchParams = assign(fetchParams, extraFetchParams);
			}

			let localVarPathWithQueryParameters = localVarPath + (localVarPath.indexOf('?') !== -1 ? '&' : '?') + querystring.stringify(queryParameters);

			return fetch(localVarPathWithQueryParameters, fetchParams).then((response) => {
				if (response.status >= 200 && response.status < 300) {
					return response.json();
				} else {
					let error = new Error(response.statusText);
					(error as any).response = response;
					throw error;
				}
			});
		}
		/**
		 *
		 * Create In Out Board
		 * @param inOutBoard
		 */
		public systemInOutBoardsPost (params: {  inOutBoard: InOutBoard; }, extraQueryParams?: any, extraFetchParams?: any ) : Promise<InOutBoard> {
			const localVarPath = this.basePath + '/system/inOutBoards';

			let queryParameters: any = assign({}, extraQueryParams);
			let headerParams: any = assign({}, this.defaultHeaders);
			headerParams['Content-Type'] = 'application/json';

			// verify required parameter 'inOutBoard' is set
			if (params.inOutBoard == null) {
				throw new Error('Missing required parameter inOutBoard when calling systemInOutBoardsPost');
			}
			let fetchParams = {
				method: 'POST',
				headers: headerParams,
				body: JSON.stringify(params.inOutBoard),

			};

			if (extraFetchParams) {
				fetchParams = assign(fetchParams, extraFetchParams);
			}

			let localVarPathWithQueryParameters = localVarPath + (localVarPath.indexOf('?') !== -1 ? '&' : '?') + querystring.stringify(queryParameters);

			return fetch(localVarPathWithQueryParameters, fetchParams).then((response) => {
				if (response.status >= 200 && response.status < 300) {
					return response.json();
				} else {
					let error = new Error(response.statusText);
					(error as any).response = response;
					throw error;
				}
			});
		}
	}
//}
//export namespace  {
	'use strict';

	export class InOutTypesApi {
		protected basePath = 'https://api-na.myconnectwise.net/v4_6_release/apis/3.0';
		public defaultHeaders : any = {};

		constructor(basePath?: string) {
			if (basePath) {
				this.basePath = basePath;
			}
		}

		/**
		 *
		 * Get In Out Type Count
		 * @param conditions
		 */
		public systemInOutTypesCountGet (params: {  conditions?: string; }, extraQueryParams?: any, extraFetchParams?: any ) : Promise<Count> {
			const localVarPath = this.basePath + '/system/inOutTypes/count';

			let queryParameters: any = assign({}, extraQueryParams);
			let headerParams: any = assign({}, this.defaultHeaders);
			if (params.conditions !== undefined) {
				queryParameters['conditions'] = params.conditions;
			}

			let fetchParams = {
				method: 'GET',
				headers: headerParams,

			};

			if (extraFetchParams) {
				fetchParams = assign(fetchParams, extraFetchParams);
			}

			let localVarPathWithQueryParameters = localVarPath + (localVarPath.indexOf('?') !== -1 ? '&' : '?') + querystring.stringify(queryParameters);

			return fetch(localVarPathWithQueryParameters, fetchParams).then((response) => {
				if (response.status >= 200 && response.status < 300) {
					return response.json();
				} else {
					let error = new Error(response.statusText);
					(error as any).response = response;
					throw error;
				}
			});
		}
		/**
		 *
		 * Get In Out Type
		 * @param conditions
		 * @param orderBy
		 * @param childconditions
		 * @param customfieldconditions
		 * @param page
		 * @param pageSize
		 */
		public systemInOutTypesGet (params: {  conditions?: string; orderBy?: string; childconditions?: string; customfieldconditions?: string; page?: number; pageSize?: number; }, extraQueryParams?: any, extraFetchParams?: any ) : Promise<Array<InOutType>> {
			const localVarPath = this.basePath + '/system/inOutTypes';

			let queryParameters: any = assign({}, extraQueryParams);
			let headerParams: any = assign({}, this.defaultHeaders);
			if (params.conditions !== undefined) {
				queryParameters['conditions'] = params.conditions;
			}

			if (params.orderBy !== undefined) {
				queryParameters['orderBy'] = params.orderBy;
			}

			if (params.childconditions !== undefined) {
				queryParameters['childconditions'] = params.childconditions;
			}

			if (params.customfieldconditions !== undefined) {
				queryParameters['customfieldconditions'] = params.customfieldconditions;
			}

			if (params.page !== undefined) {
				queryParameters['page'] = params.page;
			}

			if (params.pageSize !== undefined) {
				queryParameters['pageSize'] = params.pageSize;
			}

			let fetchParams = {
				method: 'GET',
				headers: headerParams,

			};

			if (extraFetchParams) {
				fetchParams = assign(fetchParams, extraFetchParams);
			}

			let localVarPathWithQueryParameters = localVarPath + (localVarPath.indexOf('?') !== -1 ? '&' : '?') + querystring.stringify(queryParameters);

			return fetch(localVarPathWithQueryParameters, fetchParams).then((response) => {
				if (response.status >= 200 && response.status < 300) {
					return response.json();
				} else {
					let error = new Error(response.statusText);
					(error as any).response = response;
					throw error;
				}
			});
		}
		/**
		 *
		 * Delete In Out Type By Id
		 * @param id
		 */
		public systemInOutTypesIdDelete (params: {  id: number; }, extraQueryParams?: any, extraFetchParams?: any ) : Promise<{}> {
			const localVarPath = this.basePath + '/system/inOutTypes/{id}'
				.replace('{' + 'id' + '}', String(params.id));

			let queryParameters: any = assign({}, extraQueryParams);
			let headerParams: any = assign({}, this.defaultHeaders);
			// verify required parameter 'id' is set
			if (params.id == null) {
				throw new Error('Missing required parameter id when calling systemInOutTypesIdDelete');
			}
			let fetchParams = {
				method: 'DELETE',
				headers: headerParams,

			};

			if (extraFetchParams) {
				fetchParams = assign(fetchParams, extraFetchParams);
			}

			let localVarPathWithQueryParameters = localVarPath + (localVarPath.indexOf('?') !== -1 ? '&' : '?') + querystring.stringify(queryParameters);

			return fetch(localVarPathWithQueryParameters, fetchParams).then((response) => {
				if (response.status >= 200 && response.status < 300) {
					return response.json();
				} else {
					let error = new Error(response.statusText);
					(error as any).response = response;
					throw error;
				}
			});
		}
		/**
		 *
		 * Get In Out Type By Id
		 * @param id
		 */
		public systemInOutTypesIdGet (params: {  id: number; }, extraQueryParams?: any, extraFetchParams?: any ) : Promise<InOutType> {
			const localVarPath = this.basePath + '/system/inOutTypes/{id}'
				.replace('{' + 'id' + '}', String(params.id));

			let queryParameters: any = assign({}, extraQueryParams);
			let headerParams: any = assign({}, this.defaultHeaders);
			// verify required parameter 'id' is set
			if (params.id == null) {
				throw new Error('Missing required parameter id when calling systemInOutTypesIdGet');
			}
			let fetchParams = {
				method: 'GET',
				headers: headerParams,

			};

			if (extraFetchParams) {
				fetchParams = assign(fetchParams, extraFetchParams);
			}

			let localVarPathWithQueryParameters = localVarPath + (localVarPath.indexOf('?') !== -1 ? '&' : '?') + querystring.stringify(queryParameters);

			return fetch(localVarPathWithQueryParameters, fetchParams).then((response) => {
				if (response.status >= 200 && response.status < 300) {
					return response.json();
				} else {
					let error = new Error(response.statusText);
					(error as any).response = response;
					throw error;
				}
			});
		}
		/**
		 *
		 * Update In Out Type
		 * @param id
		 * @param operations
		 */
		public systemInOutTypesIdPatch (params: {  id: number; operations: Array<PatchOperation>; }, extraQueryParams?: any, extraFetchParams?: any ) : Promise<InOutType> {
			const localVarPath = this.basePath + '/system/inOutTypes/{id}'
				.replace('{' + 'id' + '}', String(params.id));

			let queryParameters: any = assign({}, extraQueryParams);
			let headerParams: any = assign({}, this.defaultHeaders);
			headerParams['Content-Type'] = 'application/json';

			// verify required parameter 'id' is set
			if (params.id == null) {
				throw new Error('Missing required parameter id when calling systemInOutTypesIdPatch');
			}
			// verify required parameter 'operations' is set
			if (params.operations == null) {
				throw new Error('Missing required parameter operations when calling systemInOutTypesIdPatch');
			}
			let fetchParams = {
				method: 'PATCH',
				headers: headerParams,
				body: JSON.stringify(params.operations),

			};

			if (extraFetchParams) {
				fetchParams = assign(fetchParams, extraFetchParams);
			}

			let localVarPathWithQueryParameters = localVarPath + (localVarPath.indexOf('?') !== -1 ? '&' : '?') + querystring.stringify(queryParameters);

			return fetch(localVarPathWithQueryParameters, fetchParams).then((response) => {
				if (response.status >= 200 && response.status < 300) {
					return response.json();
				} else {
					let error = new Error(response.statusText);
					(error as any).response = response;
					throw error;
				}
			});
		}
		/**
		 *
		 * Replace In Out Type
		 * @param id
		 * @param inOutType
		 */
		public systemInOutTypesIdPut (params: {  id: number; inOutType: InOutType; }, extraQueryParams?: any, extraFetchParams?: any ) : Promise<InOutType> {
			const localVarPath = this.basePath + '/system/inOutTypes/{id}'
				.replace('{' + 'id' + '}', String(params.id));

			let queryParameters: any = assign({}, extraQueryParams);
			let headerParams: any = assign({}, this.defaultHeaders);
			headerParams['Content-Type'] = 'application/json';

			// verify required parameter 'id' is set
			if (params.id == null) {
				throw new Error('Missing required parameter id when calling systemInOutTypesIdPut');
			}
			// verify required parameter 'inOutType' is set
			if (params.inOutType == null) {
				throw new Error('Missing required parameter inOutType when calling systemInOutTypesIdPut');
			}
			let fetchParams = {
				method: 'PUT',
				headers: headerParams,
				body: JSON.stringify(params.inOutType),

			};

			if (extraFetchParams) {
				fetchParams = assign(fetchParams, extraFetchParams);
			}

			let localVarPathWithQueryParameters = localVarPath + (localVarPath.indexOf('?') !== -1 ? '&' : '?') + querystring.stringify(queryParameters);

			return fetch(localVarPathWithQueryParameters, fetchParams).then((response) => {
				if (response.status >= 200 && response.status < 300) {
					return response.json();
				} else {
					let error = new Error(response.statusText);
					(error as any).response = response;
					throw error;
				}
			});
		}
		/**
		 *
		 * Create In Out Type
		 * @param inOutType
		 */
		public systemInOutTypesPost (params: {  inOutType: InOutType; }, extraQueryParams?: any, extraFetchParams?: any ) : Promise<InOutType> {
			const localVarPath = this.basePath + '/system/inOutTypes';

			let queryParameters: any = assign({}, extraQueryParams);
			let headerParams: any = assign({}, this.defaultHeaders);
			headerParams['Content-Type'] = 'application/json';

			// verify required parameter 'inOutType' is set
			if (params.inOutType == null) {
				throw new Error('Missing required parameter inOutType when calling systemInOutTypesPost');
			}
			let fetchParams = {
				method: 'POST',
				headers: headerParams,
				body: JSON.stringify(params.inOutType),

			};

			if (extraFetchParams) {
				fetchParams = assign(fetchParams, extraFetchParams);
			}

			let localVarPathWithQueryParameters = localVarPath + (localVarPath.indexOf('?') !== -1 ? '&' : '?') + querystring.stringify(queryParameters);

			return fetch(localVarPathWithQueryParameters, fetchParams).then((response) => {
				if (response.status >= 200 && response.status < 300) {
					return response.json();
				} else {
					let error = new Error(response.statusText);
					(error as any).response = response;
					throw error;
				}
			});
		}
	}
//}
//export namespace  {
	'use strict';

	export class InfoApi {
		protected basePath = 'https://api-na.myconnectwise.net/v4_6_release/apis/3.0';
		public defaultHeaders : any = {};

		constructor(basePath?: string) {
			if (basePath) {
				this.basePath = basePath;
			}
		}

		/**
		 *
		 * Get Infos
		 */
		public systemInfoGet (params: {  }, extraQueryParams?: any, extraFetchParams?: any ) : Promise<Info> {
			const localVarPath = this.basePath + '/system/info';

			let queryParameters: any = assign({}, extraQueryParams);
			let headerParams: any = assign({}, this.defaultHeaders);
			let fetchParams = {
				method: 'GET',
				headers: headerParams,

			};

			if (extraFetchParams) {
				fetchParams = assign(fetchParams, extraFetchParams);
			}

			let localVarPathWithQueryParameters = localVarPath + (localVarPath.indexOf('?') !== -1 ? '&' : '?') + querystring.stringify(queryParameters);

			return fetch(localVarPathWithQueryParameters, fetchParams).then((response) => {
				if (response.status >= 200 && response.status < 300) {
					return response.json();
				} else {
					let error = new Error(response.statusText);
					(error as any).response = response;
					throw error;
				}
			});
		}
	}
//}
//export namespace  {
	'use strict';

	export class InvoicePaymentsApi {
		protected basePath = 'https://api-na.myconnectwise.net/v4_6_release/apis/3.0';
		public defaultHeaders : any = {};

		constructor(basePath?: string) {
			if (basePath) {
				this.basePath = basePath;
			}
		}

		/**
		 *
		 * Get Payments
		 * @param id
		 * @param conditions
		 * @param orderBy
		 * @param childconditions
		 * @param customfieldconditions
		 * @param page
		 * @param pageSize
		 */
		public financeInvoicesIdPaymentsGet (params: {  id: number; conditions?: string; orderBy?: string; childconditions?: string; customfieldconditions?: string; page?: number; pageSize?: number; }, extraQueryParams?: any, extraFetchParams?: any ) : Promise<Array<Payment>> {
			const localVarPath = this.basePath + '/finance/invoices/{id}/payments'
				.replace('{' + 'id' + '}', String(params.id));

			let queryParameters: any = assign({}, extraQueryParams);
			let headerParams: any = assign({}, this.defaultHeaders);
			// verify required parameter 'id' is set
			if (params.id == null) {
				throw new Error('Missing required parameter id when calling financeInvoicesIdPaymentsGet');
			}
			if (params.conditions !== undefined) {
				queryParameters['conditions'] = params.conditions;
			}

			if (params.orderBy !== undefined) {
				queryParameters['orderBy'] = params.orderBy;
			}

			if (params.childconditions !== undefined) {
				queryParameters['childconditions'] = params.childconditions;
			}

			if (params.customfieldconditions !== undefined) {
				queryParameters['customfieldconditions'] = params.customfieldconditions;
			}

			if (params.page !== undefined) {
				queryParameters['page'] = params.page;
			}

			if (params.pageSize !== undefined) {
				queryParameters['pageSize'] = params.pageSize;
			}

			let fetchParams = {
				method: 'GET',
				headers: headerParams,

			};

			if (extraFetchParams) {
				fetchParams = assign(fetchParams, extraFetchParams);
			}

			let localVarPathWithQueryParameters = localVarPath + (localVarPath.indexOf('?') !== -1 ? '&' : '?') + querystring.stringify(queryParameters);

			return fetch(localVarPathWithQueryParameters, fetchParams).then((response) => {
				if (response.status >= 200 && response.status < 300) {
					return response.json();
				} else {
					let error = new Error(response.statusText);
					(error as any).response = response;
					throw error;
				}
			});
		}
		/**
		 *
		 * Delete Payment By Id
		 * @param id
		 * @param paymentId
		 */
		public financeInvoicesIdPaymentsPaymentIdDelete (params: {  id: number; paymentId: number; }, extraQueryParams?: any, extraFetchParams?: any ) : Promise<{}> {
			const localVarPath = this.basePath + '/finance/invoices/{id}/payments/{paymentId}'
				.replace('{' + 'id' + '}', String(params.id))
				.replace('{' + 'paymentId' + '}', String(params.paymentId));

			let queryParameters: any = assign({}, extraQueryParams);
			let headerParams: any = assign({}, this.defaultHeaders);
			// verify required parameter 'id' is set
			if (params.id == null) {
				throw new Error('Missing required parameter id when calling financeInvoicesIdPaymentsPaymentIdDelete');
			}
			// verify required parameter 'paymentId' is set
			if (params.paymentId == null) {
				throw new Error('Missing required parameter paymentId when calling financeInvoicesIdPaymentsPaymentIdDelete');
			}
			let fetchParams = {
				method: 'DELETE',
				headers: headerParams,

			};

			if (extraFetchParams) {
				fetchParams = assign(fetchParams, extraFetchParams);
			}

			let localVarPathWithQueryParameters = localVarPath + (localVarPath.indexOf('?') !== -1 ? '&' : '?') + querystring.stringify(queryParameters);

			return fetch(localVarPathWithQueryParameters, fetchParams).then((response) => {
				if (response.status >= 200 && response.status < 300) {
					return response.json();
				} else {
					let error = new Error(response.statusText);
					(error as any).response = response;
					throw error;
				}
			});
		}
		/**
		 *
		 * Get Payment By Id
		 * @param id
		 * @param paymentId
		 */
		public financeInvoicesIdPaymentsPaymentIdGet (params: {  id: number; paymentId: number; }, extraQueryParams?: any, extraFetchParams?: any ) : Promise<Payment> {
			const localVarPath = this.basePath + '/finance/invoices/{id}/payments/{paymentId}'
				.replace('{' + 'id' + '}', String(params.id))
				.replace('{' + 'paymentId' + '}', String(params.paymentId));

			let queryParameters: any = assign({}, extraQueryParams);
			let headerParams: any = assign({}, this.defaultHeaders);
			// verify required parameter 'id' is set
			if (params.id == null) {
				throw new Error('Missing required parameter id when calling financeInvoicesIdPaymentsPaymentIdGet');
			}
			// verify required parameter 'paymentId' is set
			if (params.paymentId == null) {
				throw new Error('Missing required parameter paymentId when calling financeInvoicesIdPaymentsPaymentIdGet');
			}
			let fetchParams = {
				method: 'GET',
				headers: headerParams,

			};

			if (extraFetchParams) {
				fetchParams = assign(fetchParams, extraFetchParams);
			}

			let localVarPathWithQueryParameters = localVarPath + (localVarPath.indexOf('?') !== -1 ? '&' : '?') + querystring.stringify(queryParameters);

			return fetch(localVarPathWithQueryParameters, fetchParams).then((response) => {
				if (response.status >= 200 && response.status < 300) {
					return response.json();
				} else {
					let error = new Error(response.statusText);
					(error as any).response = response;
					throw error;
				}
			});
		}
		/**
		 *
		 * Update Payment
		 * @param id
		 * @param paymentId
		 * @param operations
		 */
		public financeInvoicesIdPaymentsPaymentIdPatch (params: {  id: number; paymentId: number; operations: Array<PatchOperation>; }, extraQueryParams?: any, extraFetchParams?: any ) : Promise<Payment> {
			const localVarPath = this.basePath + '/finance/invoices/{id}/payments/{paymentId}'
				.replace('{' + 'id' + '}', String(params.id))
				.replace('{' + 'paymentId' + '}', String(params.paymentId));

			let queryParameters: any = assign({}, extraQueryParams);
			let headerParams: any = assign({}, this.defaultHeaders);
			headerParams['Content-Type'] = 'application/json';

			// verify required parameter 'id' is set
			if (params.id == null) {
				throw new Error('Missing required parameter id when calling financeInvoicesIdPaymentsPaymentIdPatch');
			}
			// verify required parameter 'paymentId' is set
			if (params.paymentId == null) {
				throw new Error('Missing required parameter paymentId when calling financeInvoicesIdPaymentsPaymentIdPatch');
			}
			// verify required parameter 'operations' is set
			if (params.operations == null) {
				throw new Error('Missing required parameter operations when calling financeInvoicesIdPaymentsPaymentIdPatch');
			}
			let fetchParams = {
				method: 'PATCH',
				headers: headerParams,
				body: JSON.stringify(params.operations),

			};

			if (extraFetchParams) {
				fetchParams = assign(fetchParams, extraFetchParams);
			}

			let localVarPathWithQueryParameters = localVarPath + (localVarPath.indexOf('?') !== -1 ? '&' : '?') + querystring.stringify(queryParameters);

			return fetch(localVarPathWithQueryParameters, fetchParams).then((response) => {
				if (response.status >= 200 && response.status < 300) {
					return response.json();
				} else {
					let error = new Error(response.statusText);
					(error as any).response = response;
					throw error;
				}
			});
		}
		/**
		 *
		 * Replace Payment
		 * @param id
		 * @param paymentId
		 * @param payment
		 */
		public financeInvoicesIdPaymentsPaymentIdPut (params: {  id: number; paymentId: number; payment: Payment; }, extraQueryParams?: any, extraFetchParams?: any ) : Promise<Payment> {
			const localVarPath = this.basePath + '/finance/invoices/{id}/payments/{paymentId}'
				.replace('{' + 'id' + '}', String(params.id))
				.replace('{' + 'paymentId' + '}', String(params.paymentId));

			let queryParameters: any = assign({}, extraQueryParams);
			let headerParams: any = assign({}, this.defaultHeaders);
			headerParams['Content-Type'] = 'application/json';

			// verify required parameter 'id' is set
			if (params.id == null) {
				throw new Error('Missing required parameter id when calling financeInvoicesIdPaymentsPaymentIdPut');
			}
			// verify required parameter 'paymentId' is set
			if (params.paymentId == null) {
				throw new Error('Missing required parameter paymentId when calling financeInvoicesIdPaymentsPaymentIdPut');
			}
			// verify required parameter 'payment' is set
			if (params.payment == null) {
				throw new Error('Missing required parameter payment when calling financeInvoicesIdPaymentsPaymentIdPut');
			}
			let fetchParams = {
				method: 'PUT',
				headers: headerParams,
				body: JSON.stringify(params.payment),

			};

			if (extraFetchParams) {
				fetchParams = assign(fetchParams, extraFetchParams);
			}

			let localVarPathWithQueryParameters = localVarPath + (localVarPath.indexOf('?') !== -1 ? '&' : '?') + querystring.stringify(queryParameters);

			return fetch(localVarPathWithQueryParameters, fetchParams).then((response) => {
				if (response.status >= 200 && response.status < 300) {
					return response.json();
				} else {
					let error = new Error(response.statusText);
					(error as any).response = response;
					throw error;
				}
			});
		}
		/**
		 *
		 * Create Payment
		 * @param id
		 * @param payment
		 */
		public financeInvoicesIdPaymentsPost (params: {  id: number; payment: Payment; }, extraQueryParams?: any, extraFetchParams?: any ) : Promise<Payment> {
			const localVarPath = this.basePath + '/finance/invoices/{id}/payments'
				.replace('{' + 'id' + '}', String(params.id));

			let queryParameters: any = assign({}, extraQueryParams);
			let headerParams: any = assign({}, this.defaultHeaders);
			headerParams['Content-Type'] = 'application/json';

			// verify required parameter 'id' is set
			if (params.id == null) {
				throw new Error('Missing required parameter id when calling financeInvoicesIdPaymentsPost');
			}
			// verify required parameter 'payment' is set
			if (params.payment == null) {
				throw new Error('Missing required parameter payment when calling financeInvoicesIdPaymentsPost');
			}
			let fetchParams = {
				method: 'POST',
				headers: headerParams,
				body: JSON.stringify(params.payment),

			};

			if (extraFetchParams) {
				fetchParams = assign(fetchParams, extraFetchParams);
			}

			let localVarPathWithQueryParameters = localVarPath + (localVarPath.indexOf('?') !== -1 ? '&' : '?') + querystring.stringify(queryParameters);

			return fetch(localVarPathWithQueryParameters, fetchParams).then((response) => {
				if (response.status >= 200 && response.status < 300) {
					return response.json();
				} else {
					let error = new Error(response.statusText);
					(error as any).response = response;
					throw error;
				}
			});
		}
	}
//}
//export namespace  {
	'use strict';

	export class InvoicesApi {
		protected basePath = 'https://api-na.myconnectwise.net/v4_6_release/apis/3.0';
		public defaultHeaders : any = {};

		constructor(basePath?: string) {
			if (basePath) {
				this.basePath = basePath;
			}
		}

		/**
		 *
		 * Get Invoices Count
		 * @param conditions
		 * @param customFieldConditions
		 */
		public financeInvoicesCountGet (params: {  conditions?: string; customFieldConditions?: string; }, extraQueryParams?: any, extraFetchParams?: any ) : Promise<Count> {
			const localVarPath = this.basePath + '/finance/invoices/count';

			let queryParameters: any = assign({}, extraQueryParams);
			let headerParams: any = assign({}, this.defaultHeaders);
			if (params.conditions !== undefined) {
				queryParameters['conditions'] = params.conditions;
			}

			if (params.customFieldConditions !== undefined) {
				queryParameters['customFieldConditions'] = params.customFieldConditions;
			}

			let fetchParams = {
				method: 'GET',
				headers: headerParams,

			};

			if (extraFetchParams) {
				fetchParams = assign(fetchParams, extraFetchParams);
			}

			let localVarPathWithQueryParameters = localVarPath + (localVarPath.indexOf('?') !== -1 ? '&' : '?') + querystring.stringify(queryParameters);

			return fetch(localVarPathWithQueryParameters, fetchParams).then((response) => {
				if (response.status >= 200 && response.status < 300) {
					return response.json();
				} else {
					let error = new Error(response.statusText);
					(error as any).response = response;
					throw error;
				}
			});
		}
		/**
		 *
		 * Get Invoices
		 * @param conditions
		 * @param orderBy
		 * @param childconditions
		 * @param customfieldconditions
		 * @param page
		 * @param pageSize
		 */
		public financeInvoicesGet (params: {  conditions?: string; orderBy?: string; childconditions?: string; customfieldconditions?: string; page?: number; pageSize?: number; }, extraQueryParams?: any, extraFetchParams?: any ) : Promise<Array<Invoice>> {
			const localVarPath = this.basePath + '/finance/invoices';

			let queryParameters: any = assign({}, extraQueryParams);
			let headerParams: any = assign({}, this.defaultHeaders);
			if (params.conditions !== undefined) {
				queryParameters['conditions'] = params.conditions;
			}

			if (params.orderBy !== undefined) {
				queryParameters['orderBy'] = params.orderBy;
			}

			if (params.childconditions !== undefined) {
				queryParameters['childconditions'] = params.childconditions;
			}

			if (params.customfieldconditions !== undefined) {
				queryParameters['customfieldconditions'] = params.customfieldconditions;
			}

			if (params.page !== undefined) {
				queryParameters['page'] = params.page;
			}

			if (params.pageSize !== undefined) {
				queryParameters['pageSize'] = params.pageSize;
			}

			let fetchParams = {
				method: 'GET',
				headers: headerParams,

			};

			if (extraFetchParams) {
				fetchParams = assign(fetchParams, extraFetchParams);
			}

			let localVarPathWithQueryParameters = localVarPath + (localVarPath.indexOf('?') !== -1 ? '&' : '?') + querystring.stringify(queryParameters);

			return fetch(localVarPathWithQueryParameters, fetchParams).then((response) => {
				if (response.status >= 200 && response.status < 300) {
					return response.json();
				} else {
					let error = new Error(response.statusText);
					(error as any).response = response;
					throw error;
				}
			});
		}
		/**
		 *
		 * Delete Invoice By Id
		 * @param id
		 */
		public financeInvoicesIdDelete (params: {  id: number; }, extraQueryParams?: any, extraFetchParams?: any ) : Promise<{}> {
			const localVarPath = this.basePath + '/finance/invoices/{id}'
				.replace('{' + 'id' + '}', String(params.id));

			let queryParameters: any = assign({}, extraQueryParams);
			let headerParams: any = assign({}, this.defaultHeaders);
			// verify required parameter 'id' is set
			if (params.id == null) {
				throw new Error('Missing required parameter id when calling financeInvoicesIdDelete');
			}
			let fetchParams = {
				method: 'DELETE',
				headers: headerParams,

			};

			if (extraFetchParams) {
				fetchParams = assign(fetchParams, extraFetchParams);
			}

			let localVarPathWithQueryParameters = localVarPath + (localVarPath.indexOf('?') !== -1 ? '&' : '?') + querystring.stringify(queryParameters);

			return fetch(localVarPathWithQueryParameters, fetchParams).then((response) => {
				if (response.status >= 200 && response.status < 300) {
					return response.json();
				} else {
					let error = new Error(response.statusText);
					(error as any).response = response;
					throw error;
				}
			});
		}
		/**
		 *
		 * Get Invoice By Id
		 * @param id
		 */
		public financeInvoicesIdGet (params: {  id: number; }, extraQueryParams?: any, extraFetchParams?: any ) : Promise<Invoice> {
			const localVarPath = this.basePath + '/finance/invoices/{id}'
				.replace('{' + 'id' + '}', String(params.id));

			let queryParameters: any = assign({}, extraQueryParams);
			let headerParams: any = assign({}, this.defaultHeaders);
			// verify required parameter 'id' is set
			if (params.id == null) {
				throw new Error('Missing required parameter id when calling financeInvoicesIdGet');
			}
			let fetchParams = {
				method: 'GET',
				headers: headerParams,

			};

			if (extraFetchParams) {
				fetchParams = assign(fetchParams, extraFetchParams);
			}

			let localVarPathWithQueryParameters = localVarPath + (localVarPath.indexOf('?') !== -1 ? '&' : '?') + querystring.stringify(queryParameters);

			return fetch(localVarPathWithQueryParameters, fetchParams).then((response) => {
				if (response.status >= 200 && response.status < 300) {
					return response.json();
				} else {
					let error = new Error(response.statusText);
					(error as any).response = response;
					throw error;
				}
			});
		}
		/**
		 *
		 * Update Invoice
		 * @param id
		 * @param operations
		 */
		public financeInvoicesIdPatch (params: {  id: number; operations: Array<PatchOperation>; }, extraQueryParams?: any, extraFetchParams?: any ) : Promise<Invoice> {
			const localVarPath = this.basePath + '/finance/invoices/{id}'
				.replace('{' + 'id' + '}', String(params.id));

			let queryParameters: any = assign({}, extraQueryParams);
			let headerParams: any = assign({}, this.defaultHeaders);
			headerParams['Content-Type'] = 'application/json';

			// verify required parameter 'id' is set
			if (params.id == null) {
				throw new Error('Missing required parameter id when calling financeInvoicesIdPatch');
			}
			// verify required parameter 'operations' is set
			if (params.operations == null) {
				throw new Error('Missing required parameter operations when calling financeInvoicesIdPatch');
			}
			let fetchParams = {
				method: 'PATCH',
				headers: headerParams,
				body: JSON.stringify(params.operations),

			};

			if (extraFetchParams) {
				fetchParams = assign(fetchParams, extraFetchParams);
			}

			let localVarPathWithQueryParameters = localVarPath + (localVarPath.indexOf('?') !== -1 ? '&' : '?') + querystring.stringify(queryParameters);

			return fetch(localVarPathWithQueryParameters, fetchParams).then((response) => {
				if (response.status >= 200 && response.status < 300) {
					return response.json();
				} else {
					let error = new Error(response.statusText);
					(error as any).response = response;
					throw error;
				}
			});
		}
		/**
		 *
		 * Get Invoice Pdf
		 * @param id
		 */
		public financeInvoicesIdPdfGet (params: {  id: number; }, extraQueryParams?: any, extraFetchParams?: any ) : Promise<{}> {
			const localVarPath = this.basePath + '/finance/invoices/{id}/pdf'
				.replace('{' + 'id' + '}', String(params.id));

			let queryParameters: any = assign({}, extraQueryParams);
			let headerParams: any = assign({}, this.defaultHeaders);
			// verify required parameter 'id' is set
			if (params.id == null) {
				throw new Error('Missing required parameter id when calling financeInvoicesIdPdfGet');
			}
			let fetchParams = {
				method: 'GET',
				headers: headerParams,

			};

			if (extraFetchParams) {
				fetchParams = assign(fetchParams, extraFetchParams);
			}

			let localVarPathWithQueryParameters = localVarPath + (localVarPath.indexOf('?') !== -1 ? '&' : '?') + querystring.stringify(queryParameters);

			return fetch(localVarPathWithQueryParameters, fetchParams).then((response) => {
				if (response.status >= 200 && response.status < 300) {
					return response.json();
				} else {
					let error = new Error(response.statusText);
					(error as any).response = response;
					throw error;
				}
			});
		}
		/**
		 *
		 * Replace Invoice
		 * @param id
		 * @param invoice
		 */
		public financeInvoicesIdPut (params: {  id: number; invoice: Invoice; }, extraQueryParams?: any, extraFetchParams?: any ) : Promise<Invoice> {
			const localVarPath = this.basePath + '/finance/invoices/{id}'
				.replace('{' + 'id' + '}', String(params.id));

			let queryParameters: any = assign({}, extraQueryParams);
			let headerParams: any = assign({}, this.defaultHeaders);
			headerParams['Content-Type'] = 'application/json';

			// verify required parameter 'id' is set
			if (params.id == null) {
				throw new Error('Missing required parameter id when calling financeInvoicesIdPut');
			}
			// verify required parameter 'invoice' is set
			if (params.invoice == null) {
				throw new Error('Missing required parameter invoice when calling financeInvoicesIdPut');
			}
			let fetchParams = {
				method: 'PUT',
				headers: headerParams,
				body: JSON.stringify(params.invoice),

			};

			if (extraFetchParams) {
				fetchParams = assign(fetchParams, extraFetchParams);
			}

			let localVarPathWithQueryParameters = localVarPath + (localVarPath.indexOf('?') !== -1 ? '&' : '?') + querystring.stringify(queryParameters);

			return fetch(localVarPathWithQueryParameters, fetchParams).then((response) => {
				if (response.status >= 200 && response.status < 300) {
					return response.json();
				} else {
					let error = new Error(response.statusText);
					(error as any).response = response;
					throw error;
				}
			});
		}
		/**
		 *
		 * Create Invoice
		 * @param invoice
		 */
		public financeInvoicesPost (params: {  invoice: Invoice; }, extraQueryParams?: any, extraFetchParams?: any ) : Promise<Invoice> {
			const localVarPath = this.basePath + '/finance/invoices';

			let queryParameters: any = assign({}, extraQueryParams);
			let headerParams: any = assign({}, this.defaultHeaders);
			headerParams['Content-Type'] = 'application/json';

			// verify required parameter 'invoice' is set
			if (params.invoice == null) {
				throw new Error('Missing required parameter invoice when calling financeInvoicesPost');
			}
			let fetchParams = {
				method: 'POST',
				headers: headerParams,
				body: JSON.stringify(params.invoice),

			};

			if (extraFetchParams) {
				fetchParams = assign(fetchParams, extraFetchParams);
			}

			let localVarPathWithQueryParameters = localVarPath + (localVarPath.indexOf('?') !== -1 ? '&' : '?') + querystring.stringify(queryParameters);

			return fetch(localVarPathWithQueryParameters, fetchParams).then((response) => {
				if (response.status >= 200 && response.status < 300) {
					return response.json();
				} else {
					let error = new Error(response.statusText);
					(error as any).response = response;
					throw error;
				}
			});
		}
	}
//}
//export namespace  {
	'use strict';

	export class KnowledgeBaseArticlesApi {
		protected basePath = 'https://api-na.myconnectwise.net/v4_6_release/apis/3.0';
		public defaultHeaders : any = {};

		constructor(basePath?: string) {
			if (basePath) {
				this.basePath = basePath;
			}
		}

		/**
		 *
		 * Get Knowledge Base Articles Count
		 * @param conditions
		 * @param customFieldConditions
		 */
		public serviceKnowledgeBaseArticlesCountGet (params: {  conditions?: string; customFieldConditions?: string; }, extraQueryParams?: any, extraFetchParams?: any ) : Promise<Count> {
			const localVarPath = this.basePath + '/service/knowledgeBaseArticles/count';

			let queryParameters: any = assign({}, extraQueryParams);
			let headerParams: any = assign({}, this.defaultHeaders);
			if (params.conditions !== undefined) {
				queryParameters['conditions'] = params.conditions;
			}

			if (params.customFieldConditions !== undefined) {
				queryParameters['customFieldConditions'] = params.customFieldConditions;
			}

			let fetchParams = {
				method: 'GET',
				headers: headerParams,

			};

			if (extraFetchParams) {
				fetchParams = assign(fetchParams, extraFetchParams);
			}

			let localVarPathWithQueryParameters = localVarPath + (localVarPath.indexOf('?') !== -1 ? '&' : '?') + querystring.stringify(queryParameters);

			return fetch(localVarPathWithQueryParameters, fetchParams).then((response) => {
				if (response.status >= 200 && response.status < 300) {
					return response.json();
				} else {
					let error = new Error(response.statusText);
					(error as any).response = response;
					throw error;
				}
			});
		}
		/**
		 *
		 * Get Knowledge Base Articles
		 * @param conditions
		 * @param orderBy
		 * @param childconditions
		 * @param customfieldconditions
		 * @param page
		 * @param pageSize
		 */
		public serviceKnowledgeBaseArticlesGet (params: {  conditions?: string; orderBy?: string; childconditions?: string; customfieldconditions?: string; page?: number; pageSize?: number; }, extraQueryParams?: any, extraFetchParams?: any ) : Promise<Array<KnowledgeBaseArticle>> {
			const localVarPath = this.basePath + '/service/knowledgeBaseArticles';

			let queryParameters: any = assign({}, extraQueryParams);
			let headerParams: any = assign({}, this.defaultHeaders);
			if (params.conditions !== undefined) {
				queryParameters['conditions'] = params.conditions;
			}

			if (params.orderBy !== undefined) {
				queryParameters['orderBy'] = params.orderBy;
			}

			if (params.childconditions !== undefined) {
				queryParameters['childconditions'] = params.childconditions;
			}

			if (params.customfieldconditions !== undefined) {
				queryParameters['customfieldconditions'] = params.customfieldconditions;
			}

			if (params.page !== undefined) {
				queryParameters['page'] = params.page;
			}

			if (params.pageSize !== undefined) {
				queryParameters['pageSize'] = params.pageSize;
			}

			let fetchParams = {
				method: 'GET',
				headers: headerParams,

			};

			if (extraFetchParams) {
				fetchParams = assign(fetchParams, extraFetchParams);
			}

			let localVarPathWithQueryParameters = localVarPath + (localVarPath.indexOf('?') !== -1 ? '&' : '?') + querystring.stringify(queryParameters);

			return fetch(localVarPathWithQueryParameters, fetchParams).then((response) => {
				if (response.status >= 200 && response.status < 300) {
					return response.json();
				} else {
					let error = new Error(response.statusText);
					(error as any).response = response;
					throw error;
				}
			});
		}
		/**
		 *
		 * Delete Knowledge Base Article By Id
		 * @param id
		 */
		public serviceKnowledgeBaseArticlesIdDelete (params: {  id: number; }, extraQueryParams?: any, extraFetchParams?: any ) : Promise<{}> {
			const localVarPath = this.basePath + '/service/knowledgeBaseArticles/{id}'
				.replace('{' + 'id' + '}', String(params.id));

			let queryParameters: any = assign({}, extraQueryParams);
			let headerParams: any = assign({}, this.defaultHeaders);
			// verify required parameter 'id' is set
			if (params.id == null) {
				throw new Error('Missing required parameter id when calling serviceKnowledgeBaseArticlesIdDelete');
			}
			let fetchParams = {
				method: 'DELETE',
				headers: headerParams,

			};

			if (extraFetchParams) {
				fetchParams = assign(fetchParams, extraFetchParams);
			}

			let localVarPathWithQueryParameters = localVarPath + (localVarPath.indexOf('?') !== -1 ? '&' : '?') + querystring.stringify(queryParameters);

			return fetch(localVarPathWithQueryParameters, fetchParams).then((response) => {
				if (response.status >= 200 && response.status < 300) {
					return response.json();
				} else {
					let error = new Error(response.statusText);
					(error as any).response = response;
					throw error;
				}
			});
		}
		/**
		 *
		 * Get Knowledge Base Article By Id
		 * @param id
		 */
		public serviceKnowledgeBaseArticlesIdGet (params: {  id: number; }, extraQueryParams?: any, extraFetchParams?: any ) : Promise<KnowledgeBaseArticle> {
			const localVarPath = this.basePath + '/service/knowledgeBaseArticles/{id}'
				.replace('{' + 'id' + '}', String(params.id));

			let queryParameters: any = assign({}, extraQueryParams);
			let headerParams: any = assign({}, this.defaultHeaders);
			// verify required parameter 'id' is set
			if (params.id == null) {
				throw new Error('Missing required parameter id when calling serviceKnowledgeBaseArticlesIdGet');
			}
			let fetchParams = {
				method: 'GET',
				headers: headerParams,

			};

			if (extraFetchParams) {
				fetchParams = assign(fetchParams, extraFetchParams);
			}

			let localVarPathWithQueryParameters = localVarPath + (localVarPath.indexOf('?') !== -1 ? '&' : '?') + querystring.stringify(queryParameters);

			return fetch(localVarPathWithQueryParameters, fetchParams).then((response) => {
				if (response.status >= 200 && response.status < 300) {
					return response.json();
				} else {
					let error = new Error(response.statusText);
					(error as any).response = response;
					throw error;
				}
			});
		}
		/**
		 *
		 * Update Knowledge Base Article
		 * @param id
		 * @param operations
		 */
		public serviceKnowledgeBaseArticlesIdPatch (params: {  id: number; operations: Array<PatchOperation>; }, extraQueryParams?: any, extraFetchParams?: any ) : Promise<KnowledgeBaseArticle> {
			const localVarPath = this.basePath + '/service/knowledgeBaseArticles/{id}'
				.replace('{' + 'id' + '}', String(params.id));

			let queryParameters: any = assign({}, extraQueryParams);
			let headerParams: any = assign({}, this.defaultHeaders);
			headerParams['Content-Type'] = 'application/json';

			// verify required parameter 'id' is set
			if (params.id == null) {
				throw new Error('Missing required parameter id when calling serviceKnowledgeBaseArticlesIdPatch');
			}
			// verify required parameter 'operations' is set
			if (params.operations == null) {
				throw new Error('Missing required parameter operations when calling serviceKnowledgeBaseArticlesIdPatch');
			}
			let fetchParams = {
				method: 'PATCH',
				headers: headerParams,
				body: JSON.stringify(params.operations),

			};

			if (extraFetchParams) {
				fetchParams = assign(fetchParams, extraFetchParams);
			}

			let localVarPathWithQueryParameters = localVarPath + (localVarPath.indexOf('?') !== -1 ? '&' : '?') + querystring.stringify(queryParameters);

			return fetch(localVarPathWithQueryParameters, fetchParams).then((response) => {
				if (response.status >= 200 && response.status < 300) {
					return response.json();
				} else {
					let error = new Error(response.statusText);
					(error as any).response = response;
					throw error;
				}
			});
		}
		/**
		 *
		 * Replace Knowledge Base Article
		 * @param id
		 * @param knowledgeBaseArticle
		 */
		public serviceKnowledgeBaseArticlesIdPut (params: {  id: number; knowledgeBaseArticle: KnowledgeBaseArticle; }, extraQueryParams?: any, extraFetchParams?: any ) : Promise<KnowledgeBaseArticle> {
			const localVarPath = this.basePath + '/service/knowledgeBaseArticles/{id}'
				.replace('{' + 'id' + '}', String(params.id));

			let queryParameters: any = assign({}, extraQueryParams);
			let headerParams: any = assign({}, this.defaultHeaders);
			headerParams['Content-Type'] = 'application/json';

			// verify required parameter 'id' is set
			if (params.id == null) {
				throw new Error('Missing required parameter id when calling serviceKnowledgeBaseArticlesIdPut');
			}
			// verify required parameter 'knowledgeBaseArticle' is set
			if (params.knowledgeBaseArticle == null) {
				throw new Error('Missing required parameter knowledgeBaseArticle when calling serviceKnowledgeBaseArticlesIdPut');
			}
			let fetchParams = {
				method: 'PUT',
				headers: headerParams,
				body: JSON.stringify(params.knowledgeBaseArticle),

			};

			if (extraFetchParams) {
				fetchParams = assign(fetchParams, extraFetchParams);
			}

			let localVarPathWithQueryParameters = localVarPath + (localVarPath.indexOf('?') !== -1 ? '&' : '?') + querystring.stringify(queryParameters);

			return fetch(localVarPathWithQueryParameters, fetchParams).then((response) => {
				if (response.status >= 200 && response.status < 300) {
					return response.json();
				} else {
					let error = new Error(response.statusText);
					(error as any).response = response;
					throw error;
				}
			});
		}
		/**
		 *
		 * Create Knowledge Base Article
		 * @param knowledgeBaseArticle
		 */
		public serviceKnowledgeBaseArticlesPost (params: {  knowledgeBaseArticle: KnowledgeBaseArticle; }, extraQueryParams?: any, extraFetchParams?: any ) : Promise<KnowledgeBaseArticle> {
			const localVarPath = this.basePath + '/service/knowledgeBaseArticles';

			let queryParameters: any = assign({}, extraQueryParams);
			let headerParams: any = assign({}, this.defaultHeaders);
			headerParams['Content-Type'] = 'application/json';

			// verify required parameter 'knowledgeBaseArticle' is set
			if (params.knowledgeBaseArticle == null) {
				throw new Error('Missing required parameter knowledgeBaseArticle when calling serviceKnowledgeBaseArticlesPost');
			}
			let fetchParams = {
				method: 'POST',
				headers: headerParams,
				body: JSON.stringify(params.knowledgeBaseArticle),

			};

			if (extraFetchParams) {
				fetchParams = assign(fetchParams, extraFetchParams);
			}

			let localVarPathWithQueryParameters = localVarPath + (localVarPath.indexOf('?') !== -1 ? '&' : '?') + querystring.stringify(queryParameters);

			return fetch(localVarPathWithQueryParameters, fetchParams).then((response) => {
				if (response.status >= 200 && response.status < 300) {
					return response.json();
				} else {
					let error = new Error(response.statusText);
					(error as any).response = response;
					throw error;
				}
			});
		}
	}
//}
//export namespace  {
	'use strict';

	export class LinksApi {
		protected basePath = 'https://api-na.myconnectwise.net/v4_6_release/apis/3.0';
		public defaultHeaders : any = {};

		constructor(basePath?: string) {
			if (basePath) {
				this.basePath = basePath;
			}
		}

		/**
		 *
		 * Get Links Count
		 * @param conditions
		 */
		public systemLinksCountGet (params: {  conditions?: string; }, extraQueryParams?: any, extraFetchParams?: any ) : Promise<Count> {
			const localVarPath = this.basePath + '/system/links/count';

			let queryParameters: any = assign({}, extraQueryParams);
			let headerParams: any = assign({}, this.defaultHeaders);
			if (params.conditions !== undefined) {
				queryParameters['conditions'] = params.conditions;
			}

			let fetchParams = {
				method: 'GET',
				headers: headerParams,

			};

			if (extraFetchParams) {
				fetchParams = assign(fetchParams, extraFetchParams);
			}

			let localVarPathWithQueryParameters = localVarPath + (localVarPath.indexOf('?') !== -1 ? '&' : '?') + querystring.stringify(queryParameters);

			return fetch(localVarPathWithQueryParameters, fetchParams).then((response) => {
				if (response.status >= 200 && response.status < 300) {
					return response.json();
				} else {
					let error = new Error(response.statusText);
					(error as any).response = response;
					throw error;
				}
			});
		}
		/**
		 *
		 * Get Links
		 * @param conditions
		 * @param orderBy
		 * @param childconditions
		 * @param customfieldconditions
		 * @param page
		 * @param pageSize
		 */
		public systemLinksGet (params: {  conditions?: string; orderBy?: string; childconditions?: string; customfieldconditions?: string; page?: number; pageSize?: number; }, extraQueryParams?: any, extraFetchParams?: any ) : Promise<Array<Link>> {
			const localVarPath = this.basePath + '/system/links';

			let queryParameters: any = assign({}, extraQueryParams);
			let headerParams: any = assign({}, this.defaultHeaders);
			if (params.conditions !== undefined) {
				queryParameters['conditions'] = params.conditions;
			}

			if (params.orderBy !== undefined) {
				queryParameters['orderBy'] = params.orderBy;
			}

			if (params.childconditions !== undefined) {
				queryParameters['childconditions'] = params.childconditions;
			}

			if (params.customfieldconditions !== undefined) {
				queryParameters['customfieldconditions'] = params.customfieldconditions;
			}

			if (params.page !== undefined) {
				queryParameters['page'] = params.page;
			}

			if (params.pageSize !== undefined) {
				queryParameters['pageSize'] = params.pageSize;
			}

			let fetchParams = {
				method: 'GET',
				headers: headerParams,

			};

			if (extraFetchParams) {
				fetchParams = assign(fetchParams, extraFetchParams);
			}

			let localVarPathWithQueryParameters = localVarPath + (localVarPath.indexOf('?') !== -1 ? '&' : '?') + querystring.stringify(queryParameters);

			return fetch(localVarPathWithQueryParameters, fetchParams).then((response) => {
				if (response.status >= 200 && response.status < 300) {
					return response.json();
				} else {
					let error = new Error(response.statusText);
					(error as any).response = response;
					throw error;
				}
			});
		}
		/**
		 *
		 * Delete Link By Id
		 * @param id
		 */
		public systemLinksIdDelete (params: {  id: number; }, extraQueryParams?: any, extraFetchParams?: any ) : Promise<{}> {
			const localVarPath = this.basePath + '/system/links/{id}'
				.replace('{' + 'id' + '}', String(params.id));

			let queryParameters: any = assign({}, extraQueryParams);
			let headerParams: any = assign({}, this.defaultHeaders);
			// verify required parameter 'id' is set
			if (params.id == null) {
				throw new Error('Missing required parameter id when calling systemLinksIdDelete');
			}
			let fetchParams = {
				method: 'DELETE',
				headers: headerParams,

			};

			if (extraFetchParams) {
				fetchParams = assign(fetchParams, extraFetchParams);
			}

			let localVarPathWithQueryParameters = localVarPath + (localVarPath.indexOf('?') !== -1 ? '&' : '?') + querystring.stringify(queryParameters);

			return fetch(localVarPathWithQueryParameters, fetchParams).then((response) => {
				if (response.status >= 200 && response.status < 300) {
					return response.json();
				} else {
					let error = new Error(response.statusText);
					(error as any).response = response;
					throw error;
				}
			});
		}
		/**
		 *
		 * Get Link By Id
		 * @param id
		 */
		public systemLinksIdGet (params: {  id: number; }, extraQueryParams?: any, extraFetchParams?: any ) : Promise<Link> {
			const localVarPath = this.basePath + '/system/links/{id}'
				.replace('{' + 'id' + '}', String(params.id));

			let queryParameters: any = assign({}, extraQueryParams);
			let headerParams: any = assign({}, this.defaultHeaders);
			// verify required parameter 'id' is set
			if (params.id == null) {
				throw new Error('Missing required parameter id when calling systemLinksIdGet');
			}
			let fetchParams = {
				method: 'GET',
				headers: headerParams,

			};

			if (extraFetchParams) {
				fetchParams = assign(fetchParams, extraFetchParams);
			}

			let localVarPathWithQueryParameters = localVarPath + (localVarPath.indexOf('?') !== -1 ? '&' : '?') + querystring.stringify(queryParameters);

			return fetch(localVarPathWithQueryParameters, fetchParams).then((response) => {
				if (response.status >= 200 && response.status < 300) {
					return response.json();
				} else {
					let error = new Error(response.statusText);
					(error as any).response = response;
					throw error;
				}
			});
		}
		/**
		 *
		 * Update Link
		 * @param id
		 * @param operations
		 */
		public systemLinksIdPatch (params: {  id: number; operations: Array<PatchOperation>; }, extraQueryParams?: any, extraFetchParams?: any ) : Promise<Link> {
			const localVarPath = this.basePath + '/system/links/{id}'
				.replace('{' + 'id' + '}', String(params.id));

			let queryParameters: any = assign({}, extraQueryParams);
			let headerParams: any = assign({}, this.defaultHeaders);
			headerParams['Content-Type'] = 'application/json';

			// verify required parameter 'id' is set
			if (params.id == null) {
				throw new Error('Missing required parameter id when calling systemLinksIdPatch');
			}
			// verify required parameter 'operations' is set
			if (params.operations == null) {
				throw new Error('Missing required parameter operations when calling systemLinksIdPatch');
			}
			let fetchParams = {
				method: 'PATCH',
				headers: headerParams,
				body: JSON.stringify(params.operations),

			};

			if (extraFetchParams) {
				fetchParams = assign(fetchParams, extraFetchParams);
			}

			let localVarPathWithQueryParameters = localVarPath + (localVarPath.indexOf('?') !== -1 ? '&' : '?') + querystring.stringify(queryParameters);

			return fetch(localVarPathWithQueryParameters, fetchParams).then((response) => {
				if (response.status >= 200 && response.status < 300) {
					return response.json();
				} else {
					let error = new Error(response.statusText);
					(error as any).response = response;
					throw error;
				}
			});
		}
		/**
		 *
		 * Replace Link
		 * @param id
		 * @param link
		 */
		public systemLinksIdPut (params: {  id: number; link: Link; }, extraQueryParams?: any, extraFetchParams?: any ) : Promise<Link> {
			const localVarPath = this.basePath + '/system/links/{id}'
				.replace('{' + 'id' + '}', String(params.id));

			let queryParameters: any = assign({}, extraQueryParams);
			let headerParams: any = assign({}, this.defaultHeaders);
			headerParams['Content-Type'] = 'application/json';

			// verify required parameter 'id' is set
			if (params.id == null) {
				throw new Error('Missing required parameter id when calling systemLinksIdPut');
			}
			// verify required parameter 'link' is set
			if (params.link == null) {
				throw new Error('Missing required parameter link when calling systemLinksIdPut');
			}
			let fetchParams = {
				method: 'PUT',
				headers: headerParams,
				body: JSON.stringify(params.link),

			};

			if (extraFetchParams) {
				fetchParams = assign(fetchParams, extraFetchParams);
			}

			let localVarPathWithQueryParameters = localVarPath + (localVarPath.indexOf('?') !== -1 ? '&' : '?') + querystring.stringify(queryParameters);

			return fetch(localVarPathWithQueryParameters, fetchParams).then((response) => {
				if (response.status >= 200 && response.status < 300) {
					return response.json();
				} else {
					let error = new Error(response.statusText);
					(error as any).response = response;
					throw error;
				}
			});
		}
		/**
		 *
		 * Create Link
		 * @param link
		 */
		public systemLinksPost (params: {  link: Link; }, extraQueryParams?: any, extraFetchParams?: any ) : Promise<Link> {
			const localVarPath = this.basePath + '/system/links';

			let queryParameters: any = assign({}, extraQueryParams);
			let headerParams: any = assign({}, this.defaultHeaders);
			headerParams['Content-Type'] = 'application/json';

			// verify required parameter 'link' is set
			if (params.link == null) {
				throw new Error('Missing required parameter link when calling systemLinksPost');
			}
			let fetchParams = {
				method: 'POST',
				headers: headerParams,
				body: JSON.stringify(params.link),

			};

			if (extraFetchParams) {
				fetchParams = assign(fetchParams, extraFetchParams);
			}

			let localVarPathWithQueryParameters = localVarPath + (localVarPath.indexOf('?') !== -1 ? '&' : '?') + querystring.stringify(queryParameters);

			return fetch(localVarPathWithQueryParameters, fetchParams).then((response) => {
				if (response.status >= 200 && response.status < 300) {
					return response.json();
				} else {
					let error = new Error(response.statusText);
					(error as any).response = response;
					throw error;
				}
			});
		}
	}
//}
//export namespace  {
	'use strict';

	export class LocationsApi {
		protected basePath = 'https://api-na.myconnectwise.net/v4_6_release/apis/3.0';
		public defaultHeaders : any = {};

		constructor(basePath?: string) {
			if (basePath) {
				this.basePath = basePath;
			}
		}

		/**
		 *
		 * Create Locations Count
		 * @param conditions
		 */
		public serviceLocationsCountGet (params: {  conditions?: string; }, extraQueryParams?: any, extraFetchParams?: any ) : Promise<Count> {
			const localVarPath = this.basePath + '/service/locations/count';

			let queryParameters: any = assign({}, extraQueryParams);
			let headerParams: any = assign({}, this.defaultHeaders);
			if (params.conditions !== undefined) {
				queryParameters['conditions'] = params.conditions;
			}

			let fetchParams = {
				method: 'GET',
				headers: headerParams,

			};

			if (extraFetchParams) {
				fetchParams = assign(fetchParams, extraFetchParams);
			}

			let localVarPathWithQueryParameters = localVarPath + (localVarPath.indexOf('?') !== -1 ? '&' : '?') + querystring.stringify(queryParameters);

			return fetch(localVarPathWithQueryParameters, fetchParams).then((response) => {
				if (response.status >= 200 && response.status < 300) {
					return response.json();
				} else {
					let error = new Error(response.statusText);
					(error as any).response = response;
					throw error;
				}
			});
		}
		/**
		 *
		 * Get Locations
		 * @param conditions
		 * @param orderBy
		 * @param childconditions
		 * @param customfieldconditions
		 * @param page
		 * @param pageSize
		 */
		public serviceLocationsGet (params: {  conditions?: string; orderBy?: string; childconditions?: string; customfieldconditions?: string; page?: number; pageSize?: number; }, extraQueryParams?: any, extraFetchParams?: any ) : Promise<Array<Location>> {
			const localVarPath = this.basePath + '/service/locations';

			let queryParameters: any = assign({}, extraQueryParams);
			let headerParams: any = assign({}, this.defaultHeaders);
			if (params.conditions !== undefined) {
				queryParameters['conditions'] = params.conditions;
			}

			if (params.orderBy !== undefined) {
				queryParameters['orderBy'] = params.orderBy;
			}

			if (params.childconditions !== undefined) {
				queryParameters['childconditions'] = params.childconditions;
			}

			if (params.customfieldconditions !== undefined) {
				queryParameters['customfieldconditions'] = params.customfieldconditions;
			}

			if (params.page !== undefined) {
				queryParameters['page'] = params.page;
			}

			if (params.pageSize !== undefined) {
				queryParameters['pageSize'] = params.pageSize;
			}

			let fetchParams = {
				method: 'GET',
				headers: headerParams,

			};

			if (extraFetchParams) {
				fetchParams = assign(fetchParams, extraFetchParams);
			}

			let localVarPathWithQueryParameters = localVarPath + (localVarPath.indexOf('?') !== -1 ? '&' : '?') + querystring.stringify(queryParameters);

			return fetch(localVarPathWithQueryParameters, fetchParams).then((response) => {
				if (response.status >= 200 && response.status < 300) {
					return response.json();
				} else {
					let error = new Error(response.statusText);
					(error as any).response = response;
					throw error;
				}
			});
		}
		/**
		 *
		 * Delete Location By Id
		 * @param id
		 */
		public serviceLocationsIdDelete (params: {  id: number; }, extraQueryParams?: any, extraFetchParams?: any ) : Promise<{}> {
			const localVarPath = this.basePath + '/service/locations/{id}'
				.replace('{' + 'id' + '}', String(params.id));

			let queryParameters: any = assign({}, extraQueryParams);
			let headerParams: any = assign({}, this.defaultHeaders);
			// verify required parameter 'id' is set
			if (params.id == null) {
				throw new Error('Missing required parameter id when calling serviceLocationsIdDelete');
			}
			let fetchParams = {
				method: 'DELETE',
				headers: headerParams,

			};

			if (extraFetchParams) {
				fetchParams = assign(fetchParams, extraFetchParams);
			}

			let localVarPathWithQueryParameters = localVarPath + (localVarPath.indexOf('?') !== -1 ? '&' : '?') + querystring.stringify(queryParameters);

			return fetch(localVarPathWithQueryParameters, fetchParams).then((response) => {
				if (response.status >= 200 && response.status < 300) {
					return response.json();
				} else {
					let error = new Error(response.statusText);
					(error as any).response = response;
					throw error;
				}
			});
		}
		/**
		 *
		 * Get Location By Id
		 * @param id
		 */
		public serviceLocationsIdGet (params: {  id: number; }, extraQueryParams?: any, extraFetchParams?: any ) : Promise<Location> {
			const localVarPath = this.basePath + '/service/locations/{id}'
				.replace('{' + 'id' + '}', String(params.id));

			let queryParameters: any = assign({}, extraQueryParams);
			let headerParams: any = assign({}, this.defaultHeaders);
			// verify required parameter 'id' is set
			if (params.id == null) {
				throw new Error('Missing required parameter id when calling serviceLocationsIdGet');
			}
			let fetchParams = {
				method: 'GET',
				headers: headerParams,

			};

			if (extraFetchParams) {
				fetchParams = assign(fetchParams, extraFetchParams);
			}

			let localVarPathWithQueryParameters = localVarPath + (localVarPath.indexOf('?') !== -1 ? '&' : '?') + querystring.stringify(queryParameters);

			return fetch(localVarPathWithQueryParameters, fetchParams).then((response) => {
				if (response.status >= 200 && response.status < 300) {
					return response.json();
				} else {
					let error = new Error(response.statusText);
					(error as any).response = response;
					throw error;
				}
			});
		}
		/**
		 *
		 * Update Location
		 * @param id
		 * @param operations
		 */
		public serviceLocationsIdPatch (params: {  id: number; operations: Array<PatchOperation>; }, extraQueryParams?: any, extraFetchParams?: any ) : Promise<Location> {
			const localVarPath = this.basePath + '/service/locations/{id}'
				.replace('{' + 'id' + '}', String(params.id));

			let queryParameters: any = assign({}, extraQueryParams);
			let headerParams: any = assign({}, this.defaultHeaders);
			headerParams['Content-Type'] = 'application/json';

			// verify required parameter 'id' is set
			if (params.id == null) {
				throw new Error('Missing required parameter id when calling serviceLocationsIdPatch');
			}
			// verify required parameter 'operations' is set
			if (params.operations == null) {
				throw new Error('Missing required parameter operations when calling serviceLocationsIdPatch');
			}
			let fetchParams = {
				method: 'PATCH',
				headers: headerParams,
				body: JSON.stringify(params.operations),

			};

			if (extraFetchParams) {
				fetchParams = assign(fetchParams, extraFetchParams);
			}

			let localVarPathWithQueryParameters = localVarPath + (localVarPath.indexOf('?') !== -1 ? '&' : '?') + querystring.stringify(queryParameters);

			return fetch(localVarPathWithQueryParameters, fetchParams).then((response) => {
				if (response.status >= 200 && response.status < 300) {
					return response.json();
				} else {
					let error = new Error(response.statusText);
					(error as any).response = response;
					throw error;
				}
			});
		}
		/**
		 *
		 * Replace Location
		 * @param id
		 * @param location
		 */
		public serviceLocationsIdPut (params: {  id: number; location: Location; }, extraQueryParams?: any, extraFetchParams?: any ) : Promise<Location> {
			const localVarPath = this.basePath + '/service/locations/{id}'
				.replace('{' + 'id' + '}', String(params.id));

			let queryParameters: any = assign({}, extraQueryParams);
			let headerParams: any = assign({}, this.defaultHeaders);
			headerParams['Content-Type'] = 'application/json';

			// verify required parameter 'id' is set
			if (params.id == null) {
				throw new Error('Missing required parameter id when calling serviceLocationsIdPut');
			}
			// verify required parameter 'location' is set
			if (params.location == null) {
				throw new Error('Missing required parameter location when calling serviceLocationsIdPut');
			}
			let fetchParams = {
				method: 'PUT',
				headers: headerParams,
				body: JSON.stringify(params.location),

			};

			if (extraFetchParams) {
				fetchParams = assign(fetchParams, extraFetchParams);
			}

			let localVarPathWithQueryParameters = localVarPath + (localVarPath.indexOf('?') !== -1 ? '&' : '?') + querystring.stringify(queryParameters);

			return fetch(localVarPathWithQueryParameters, fetchParams).then((response) => {
				if (response.status >= 200 && response.status < 300) {
					return response.json();
				} else {
					let error = new Error(response.statusText);
					(error as any).response = response;
					throw error;
				}
			});
		}
		/**
		 *
		 * Create Location
		 * @param location
		 */
		public serviceLocationsPost (params: {  location: Location; }, extraQueryParams?: any, extraFetchParams?: any ) : Promise<Location> {
			const localVarPath = this.basePath + '/service/locations';

			let queryParameters: any = assign({}, extraQueryParams);
			let headerParams: any = assign({}, this.defaultHeaders);
			headerParams['Content-Type'] = 'application/json';

			// verify required parameter 'location' is set
			if (params.location == null) {
				throw new Error('Missing required parameter location when calling serviceLocationsPost');
			}
			let fetchParams = {
				method: 'POST',
				headers: headerParams,
				body: JSON.stringify(params.location),

			};

			if (extraFetchParams) {
				fetchParams = assign(fetchParams, extraFetchParams);
			}

			let localVarPathWithQueryParameters = localVarPath + (localVarPath.indexOf('?') !== -1 ? '&' : '?') + querystring.stringify(queryParameters);

			return fetch(localVarPathWithQueryParameters, fetchParams).then((response) => {
				if (response.status >= 200 && response.status < 300) {
					return response.json();
				} else {
					let error = new Error(response.statusText);
					(error as any).response = response;
					throw error;
				}
			});
		}
	}
//}
//export namespace  {
	'use strict';

	export class ManagementBackupsApi {
		protected basePath = 'https://api-na.myconnectwise.net/v4_6_release/apis/3.0';
		public defaultHeaders : any = {};

		constructor(basePath?: string) {
			if (basePath) {
				this.basePath = basePath;
			}
		}

		/**
		 *
		 * Get Management Backup Count
		 * @param conditions
		 */
		public companyManagementBackupsCountGet (params: {  conditions?: string; }, extraQueryParams?: any, extraFetchParams?: any ) : Promise<Count> {
			const localVarPath = this.basePath + '/company/managementBackups/count';

			let queryParameters: any = assign({}, extraQueryParams);
			let headerParams: any = assign({}, this.defaultHeaders);
			if (params.conditions !== undefined) {
				queryParameters['conditions'] = params.conditions;
			}

			let fetchParams = {
				method: 'GET',
				headers: headerParams,

			};

			if (extraFetchParams) {
				fetchParams = assign(fetchParams, extraFetchParams);
			}

			let localVarPathWithQueryParameters = localVarPath + (localVarPath.indexOf('?') !== -1 ? '&' : '?') + querystring.stringify(queryParameters);

			return fetch(localVarPathWithQueryParameters, fetchParams).then((response) => {
				if (response.status >= 200 && response.status < 300) {
					return response.json();
				} else {
					let error = new Error(response.statusText);
					(error as any).response = response;
					throw error;
				}
			});
		}
		/**
		 *
		 * Get Management Backup
		 * @param conditions
		 * @param orderBy
		 * @param childconditions
		 * @param customfieldconditions
		 * @param page
		 * @param pageSize
		 */
		public companyManagementBackupsGet (params: {  conditions?: string; orderBy?: string; childconditions?: string; customfieldconditions?: string; page?: number; pageSize?: number; }, extraQueryParams?: any, extraFetchParams?: any ) : Promise<Array<ManagementBackup>> {
			const localVarPath = this.basePath + '/company/managementBackups';

			let queryParameters: any = assign({}, extraQueryParams);
			let headerParams: any = assign({}, this.defaultHeaders);
			if (params.conditions !== undefined) {
				queryParameters['conditions'] = params.conditions;
			}

			if (params.orderBy !== undefined) {
				queryParameters['orderBy'] = params.orderBy;
			}

			if (params.childconditions !== undefined) {
				queryParameters['childconditions'] = params.childconditions;
			}

			if (params.customfieldconditions !== undefined) {
				queryParameters['customfieldconditions'] = params.customfieldconditions;
			}

			if (params.page !== undefined) {
				queryParameters['page'] = params.page;
			}

			if (params.pageSize !== undefined) {
				queryParameters['pageSize'] = params.pageSize;
			}

			let fetchParams = {
				method: 'GET',
				headers: headerParams,

			};

			if (extraFetchParams) {
				fetchParams = assign(fetchParams, extraFetchParams);
			}

			let localVarPathWithQueryParameters = localVarPath + (localVarPath.indexOf('?') !== -1 ? '&' : '?') + querystring.stringify(queryParameters);

			return fetch(localVarPathWithQueryParameters, fetchParams).then((response) => {
				if (response.status >= 200 && response.status < 300) {
					return response.json();
				} else {
					let error = new Error(response.statusText);
					(error as any).response = response;
					throw error;
				}
			});
		}
		/**
		 *
		 * Delete Management Backup By Id
		 * @param id
		 */
		public companyManagementBackupsIdDelete (params: {  id: number; }, extraQueryParams?: any, extraFetchParams?: any ) : Promise<{}> {
			const localVarPath = this.basePath + '/company/managementBackups/{id}'
				.replace('{' + 'id' + '}', String(params.id));

			let queryParameters: any = assign({}, extraQueryParams);
			let headerParams: any = assign({}, this.defaultHeaders);
			// verify required parameter 'id' is set
			if (params.id == null) {
				throw new Error('Missing required parameter id when calling companyManagementBackupsIdDelete');
			}
			let fetchParams = {
				method: 'DELETE',
				headers: headerParams,

			};

			if (extraFetchParams) {
				fetchParams = assign(fetchParams, extraFetchParams);
			}

			let localVarPathWithQueryParameters = localVarPath + (localVarPath.indexOf('?') !== -1 ? '&' : '?') + querystring.stringify(queryParameters);

			return fetch(localVarPathWithQueryParameters, fetchParams).then((response) => {
				if (response.status >= 200 && response.status < 300) {
					return response.json();
				} else {
					let error = new Error(response.statusText);
					(error as any).response = response;
					throw error;
				}
			});
		}
		/**
		 *
		 * Get Management Backup By Id
		 * @param id
		 */
		public companyManagementBackupsIdGet (params: {  id: number; }, extraQueryParams?: any, extraFetchParams?: any ) : Promise<ManagementBackup> {
			const localVarPath = this.basePath + '/company/managementBackups/{id}'
				.replace('{' + 'id' + '}', String(params.id));

			let queryParameters: any = assign({}, extraQueryParams);
			let headerParams: any = assign({}, this.defaultHeaders);
			// verify required parameter 'id' is set
			if (params.id == null) {
				throw new Error('Missing required parameter id when calling companyManagementBackupsIdGet');
			}
			let fetchParams = {
				method: 'GET',
				headers: headerParams,

			};

			if (extraFetchParams) {
				fetchParams = assign(fetchParams, extraFetchParams);
			}

			let localVarPathWithQueryParameters = localVarPath + (localVarPath.indexOf('?') !== -1 ? '&' : '?') + querystring.stringify(queryParameters);

			return fetch(localVarPathWithQueryParameters, fetchParams).then((response) => {
				if (response.status >= 200 && response.status < 300) {
					return response.json();
				} else {
					let error = new Error(response.statusText);
					(error as any).response = response;
					throw error;
				}
			});
		}
		/**
		 *
		 * Update Management Backup
		 * @param id
		 * @param operations
		 */
		public companyManagementBackupsIdPatch (params: {  id: number; operations: Array<PatchOperation>; }, extraQueryParams?: any, extraFetchParams?: any ) : Promise<ManagementBackup> {
			const localVarPath = this.basePath + '/company/managementBackups/{id}'
				.replace('{' + 'id' + '}', String(params.id));

			let queryParameters: any = assign({}, extraQueryParams);
			let headerParams: any = assign({}, this.defaultHeaders);
			headerParams['Content-Type'] = 'application/json';

			// verify required parameter 'id' is set
			if (params.id == null) {
				throw new Error('Missing required parameter id when calling companyManagementBackupsIdPatch');
			}
			// verify required parameter 'operations' is set
			if (params.operations == null) {
				throw new Error('Missing required parameter operations when calling companyManagementBackupsIdPatch');
			}
			let fetchParams = {
				method: 'PATCH',
				headers: headerParams,
				body: JSON.stringify(params.operations),

			};

			if (extraFetchParams) {
				fetchParams = assign(fetchParams, extraFetchParams);
			}

			let localVarPathWithQueryParameters = localVarPath + (localVarPath.indexOf('?') !== -1 ? '&' : '?') + querystring.stringify(queryParameters);

			return fetch(localVarPathWithQueryParameters, fetchParams).then((response) => {
				if (response.status >= 200 && response.status < 300) {
					return response.json();
				} else {
					let error = new Error(response.statusText);
					(error as any).response = response;
					throw error;
				}
			});
		}
		/**
		 *
		 * Replace Management Backup
		 * @param id
		 * @param managementBackup
		 */
		public companyManagementBackupsIdPut (params: {  id: number; managementBackup: ManagementBackup; }, extraQueryParams?: any, extraFetchParams?: any ) : Promise<ManagementBackup> {
			const localVarPath = this.basePath + '/company/managementBackups/{id}'
				.replace('{' + 'id' + '}', String(params.id));

			let queryParameters: any = assign({}, extraQueryParams);
			let headerParams: any = assign({}, this.defaultHeaders);
			headerParams['Content-Type'] = 'application/json';

			// verify required parameter 'id' is set
			if (params.id == null) {
				throw new Error('Missing required parameter id when calling companyManagementBackupsIdPut');
			}
			// verify required parameter 'managementBackup' is set
			if (params.managementBackup == null) {
				throw new Error('Missing required parameter managementBackup when calling companyManagementBackupsIdPut');
			}
			let fetchParams = {
				method: 'PUT',
				headers: headerParams,
				body: JSON.stringify(params.managementBackup),

			};

			if (extraFetchParams) {
				fetchParams = assign(fetchParams, extraFetchParams);
			}

			let localVarPathWithQueryParameters = localVarPath + (localVarPath.indexOf('?') !== -1 ? '&' : '?') + querystring.stringify(queryParameters);

			return fetch(localVarPathWithQueryParameters, fetchParams).then((response) => {
				if (response.status >= 200 && response.status < 300) {
					return response.json();
				} else {
					let error = new Error(response.statusText);
					(error as any).response = response;
					throw error;
				}
			});
		}
		/**
		 *
		 * Create Management Backup
		 * @param managementBackup
		 */
		public companyManagementBackupsPost (params: {  managementBackup: ManagementBackup; }, extraQueryParams?: any, extraFetchParams?: any ) : Promise<ManagementBackup> {
			const localVarPath = this.basePath + '/company/managementBackups';

			let queryParameters: any = assign({}, extraQueryParams);
			let headerParams: any = assign({}, this.defaultHeaders);
			headerParams['Content-Type'] = 'application/json';

			// verify required parameter 'managementBackup' is set
			if (params.managementBackup == null) {
				throw new Error('Missing required parameter managementBackup when calling companyManagementBackupsPost');
			}
			let fetchParams = {
				method: 'POST',
				headers: headerParams,
				body: JSON.stringify(params.managementBackup),

			};

			if (extraFetchParams) {
				fetchParams = assign(fetchParams, extraFetchParams);
			}

			let localVarPathWithQueryParameters = localVarPath + (localVarPath.indexOf('?') !== -1 ? '&' : '?') + querystring.stringify(queryParameters);

			return fetch(localVarPathWithQueryParameters, fetchParams).then((response) => {
				if (response.status >= 200 && response.status < 300) {
					return response.json();
				} else {
					let error = new Error(response.statusText);
					(error as any).response = response;
					throw error;
				}
			});
		}
	}
//}
//export namespace  {
	'use strict';

	export class ManagementEmailsApi {
		protected basePath = 'https://api-na.myconnectwise.net/v4_6_release/apis/3.0';
		public defaultHeaders : any = {};

		constructor(basePath?: string) {
			if (basePath) {
				this.basePath = basePath;
			}
		}

		/**
		 *
		 * Get Management Email Count
		 * @param conditions
		 */
		public companyManagementEmailsCountGet (params: {  conditions?: string; }, extraQueryParams?: any, extraFetchParams?: any ) : Promise<Count> {
			const localVarPath = this.basePath + '/company/managementEmails/count';

			let queryParameters: any = assign({}, extraQueryParams);
			let headerParams: any = assign({}, this.defaultHeaders);
			if (params.conditions !== undefined) {
				queryParameters['conditions'] = params.conditions;
			}

			let fetchParams = {
				method: 'GET',
				headers: headerParams,

			};

			if (extraFetchParams) {
				fetchParams = assign(fetchParams, extraFetchParams);
			}

			let localVarPathWithQueryParameters = localVarPath + (localVarPath.indexOf('?') !== -1 ? '&' : '?') + querystring.stringify(queryParameters);

			return fetch(localVarPathWithQueryParameters, fetchParams).then((response) => {
				if (response.status >= 200 && response.status < 300) {
					return response.json();
				} else {
					let error = new Error(response.statusText);
					(error as any).response = response;
					throw error;
				}
			});
		}
		/**
		 *
		 * Get Management Email
		 * @param conditions
		 * @param orderBy
		 * @param childconditions
		 * @param customfieldconditions
		 * @param page
		 * @param pageSize
		 */
		public companyManagementEmailsGet (params: {  conditions?: string; orderBy?: string; childconditions?: string; customfieldconditions?: string; page?: number; pageSize?: number; }, extraQueryParams?: any, extraFetchParams?: any ) : Promise<Array<ManagementEmail>> {
			const localVarPath = this.basePath + '/company/managementEmails';

			let queryParameters: any = assign({}, extraQueryParams);
			let headerParams: any = assign({}, this.defaultHeaders);
			if (params.conditions !== undefined) {
				queryParameters['conditions'] = params.conditions;
			}

			if (params.orderBy !== undefined) {
				queryParameters['orderBy'] = params.orderBy;
			}

			if (params.childconditions !== undefined) {
				queryParameters['childconditions'] = params.childconditions;
			}

			if (params.customfieldconditions !== undefined) {
				queryParameters['customfieldconditions'] = params.customfieldconditions;
			}

			if (params.page !== undefined) {
				queryParameters['page'] = params.page;
			}

			if (params.pageSize !== undefined) {
				queryParameters['pageSize'] = params.pageSize;
			}

			let fetchParams = {
				method: 'GET',
				headers: headerParams,

			};

			if (extraFetchParams) {
				fetchParams = assign(fetchParams, extraFetchParams);
			}

			let localVarPathWithQueryParameters = localVarPath + (localVarPath.indexOf('?') !== -1 ? '&' : '?') + querystring.stringify(queryParameters);

			return fetch(localVarPathWithQueryParameters, fetchParams).then((response) => {
				if (response.status >= 200 && response.status < 300) {
					return response.json();
				} else {
					let error = new Error(response.statusText);
					(error as any).response = response;
					throw error;
				}
			});
		}
		/**
		 *
		 * Delete Management Email By Id
		 * @param id
		 */
		public companyManagementEmailsIdDelete (params: {  id: number; }, extraQueryParams?: any, extraFetchParams?: any ) : Promise<{}> {
			const localVarPath = this.basePath + '/company/managementEmails/{id}'
				.replace('{' + 'id' + '}', String(params.id));

			let queryParameters: any = assign({}, extraQueryParams);
			let headerParams: any = assign({}, this.defaultHeaders);
			// verify required parameter 'id' is set
			if (params.id == null) {
				throw new Error('Missing required parameter id when calling companyManagementEmailsIdDelete');
			}
			let fetchParams = {
				method: 'DELETE',
				headers: headerParams,

			};

			if (extraFetchParams) {
				fetchParams = assign(fetchParams, extraFetchParams);
			}

			let localVarPathWithQueryParameters = localVarPath + (localVarPath.indexOf('?') !== -1 ? '&' : '?') + querystring.stringify(queryParameters);

			return fetch(localVarPathWithQueryParameters, fetchParams).then((response) => {
				if (response.status >= 200 && response.status < 300) {
					return response.json();
				} else {
					let error = new Error(response.statusText);
					(error as any).response = response;
					throw error;
				}
			});
		}
		/**
		 *
		 * Get Management Email By Id
		 * @param id
		 */
		public companyManagementEmailsIdGet (params: {  id: number; }, extraQueryParams?: any, extraFetchParams?: any ) : Promise<ManagementEmail> {
			const localVarPath = this.basePath + '/company/managementEmails/{id}'
				.replace('{' + 'id' + '}', String(params.id));

			let queryParameters: any = assign({}, extraQueryParams);
			let headerParams: any = assign({}, this.defaultHeaders);
			// verify required parameter 'id' is set
			if (params.id == null) {
				throw new Error('Missing required parameter id when calling companyManagementEmailsIdGet');
			}
			let fetchParams = {
				method: 'GET',
				headers: headerParams,

			};

			if (extraFetchParams) {
				fetchParams = assign(fetchParams, extraFetchParams);
			}

			let localVarPathWithQueryParameters = localVarPath + (localVarPath.indexOf('?') !== -1 ? '&' : '?') + querystring.stringify(queryParameters);

			return fetch(localVarPathWithQueryParameters, fetchParams).then((response) => {
				if (response.status >= 200 && response.status < 300) {
					return response.json();
				} else {
					let error = new Error(response.statusText);
					(error as any).response = response;
					throw error;
				}
			});
		}
		/**
		 *
		 * Update Management Email
		 * @param id
		 * @param operations
		 */
		public companyManagementEmailsIdPatch (params: {  id: number; operations: Array<PatchOperation>; }, extraQueryParams?: any, extraFetchParams?: any ) : Promise<ManagementEmail> {
			const localVarPath = this.basePath + '/company/managementEmails/{id}'
				.replace('{' + 'id' + '}', String(params.id));

			let queryParameters: any = assign({}, extraQueryParams);
			let headerParams: any = assign({}, this.defaultHeaders);
			headerParams['Content-Type'] = 'application/json';

			// verify required parameter 'id' is set
			if (params.id == null) {
				throw new Error('Missing required parameter id when calling companyManagementEmailsIdPatch');
			}
			// verify required parameter 'operations' is set
			if (params.operations == null) {
				throw new Error('Missing required parameter operations when calling companyManagementEmailsIdPatch');
			}
			let fetchParams = {
				method: 'PATCH',
				headers: headerParams,
				body: JSON.stringify(params.operations),

			};

			if (extraFetchParams) {
				fetchParams = assign(fetchParams, extraFetchParams);
			}

			let localVarPathWithQueryParameters = localVarPath + (localVarPath.indexOf('?') !== -1 ? '&' : '?') + querystring.stringify(queryParameters);

			return fetch(localVarPathWithQueryParameters, fetchParams).then((response) => {
				if (response.status >= 200 && response.status < 300) {
					return response.json();
				} else {
					let error = new Error(response.statusText);
					(error as any).response = response;
					throw error;
				}
			});
		}
		/**
		 *
		 * Replace Management Email
		 * @param id
		 * @param managementEmail
		 */
		public companyManagementEmailsIdPut (params: {  id: number; managementEmail: ManagementEmail; }, extraQueryParams?: any, extraFetchParams?: any ) : Promise<ManagementEmail> {
			const localVarPath = this.basePath + '/company/managementEmails/{id}'
				.replace('{' + 'id' + '}', String(params.id));

			let queryParameters: any = assign({}, extraQueryParams);
			let headerParams: any = assign({}, this.defaultHeaders);
			headerParams['Content-Type'] = 'application/json';

			// verify required parameter 'id' is set
			if (params.id == null) {
				throw new Error('Missing required parameter id when calling companyManagementEmailsIdPut');
			}
			// verify required parameter 'managementEmail' is set
			if (params.managementEmail == null) {
				throw new Error('Missing required parameter managementEmail when calling companyManagementEmailsIdPut');
			}
			let fetchParams = {
				method: 'PUT',
				headers: headerParams,
				body: JSON.stringify(params.managementEmail),

			};

			if (extraFetchParams) {
				fetchParams = assign(fetchParams, extraFetchParams);
			}

			let localVarPathWithQueryParameters = localVarPath + (localVarPath.indexOf('?') !== -1 ? '&' : '?') + querystring.stringify(queryParameters);

			return fetch(localVarPathWithQueryParameters, fetchParams).then((response) => {
				if (response.status >= 200 && response.status < 300) {
					return response.json();
				} else {
					let error = new Error(response.statusText);
					(error as any).response = response;
					throw error;
				}
			});
		}
		/**
		 *
		 * Create Management Email
		 * @param managementEmail
		 */
		public companyManagementEmailsPost (params: {  managementEmail: ManagementEmail; }, extraQueryParams?: any, extraFetchParams?: any ) : Promise<ManagementEmail> {
			const localVarPath = this.basePath + '/company/managementEmails';

			let queryParameters: any = assign({}, extraQueryParams);
			let headerParams: any = assign({}, this.defaultHeaders);
			headerParams['Content-Type'] = 'application/json';

			// verify required parameter 'managementEmail' is set
			if (params.managementEmail == null) {
				throw new Error('Missing required parameter managementEmail when calling companyManagementEmailsPost');
			}
			let fetchParams = {
				method: 'POST',
				headers: headerParams,
				body: JSON.stringify(params.managementEmail),

			};

			if (extraFetchParams) {
				fetchParams = assign(fetchParams, extraFetchParams);
			}

			let localVarPathWithQueryParameters = localVarPath + (localVarPath.indexOf('?') !== -1 ? '&' : '?') + querystring.stringify(queryParameters);

			return fetch(localVarPathWithQueryParameters, fetchParams).then((response) => {
				if (response.status >= 200 && response.status < 300) {
					return response.json();
				} else {
					let error = new Error(response.statusText);
					(error as any).response = response;
					throw error;
				}
			});
		}
	}
//}
//export namespace  {
	'use strict';

	export class ManufacturersApi {
		protected basePath = 'https://api-na.myconnectwise.net/v4_6_release/apis/3.0';
		public defaultHeaders : any = {};

		constructor(basePath?: string) {
			if (basePath) {
				this.basePath = basePath;
			}
		}

		/**
		 *
		 * Get Manufacturers Count
		 * @param conditions
		 */
		public procurementManufacturersCountGet (params: {  conditions?: string; }, extraQueryParams?: any, extraFetchParams?: any ) : Promise<Count> {
			const localVarPath = this.basePath + '/procurement/manufacturers/count';

			let queryParameters: any = assign({}, extraQueryParams);
			let headerParams: any = assign({}, this.defaultHeaders);
			if (params.conditions !== undefined) {
				queryParameters['conditions'] = params.conditions;
			}

			let fetchParams = {
				method: 'GET',
				headers: headerParams,

			};

			if (extraFetchParams) {
				fetchParams = assign(fetchParams, extraFetchParams);
			}

			let localVarPathWithQueryParameters = localVarPath + (localVarPath.indexOf('?') !== -1 ? '&' : '?') + querystring.stringify(queryParameters);

			return fetch(localVarPathWithQueryParameters, fetchParams).then((response) => {
				if (response.status >= 200 && response.status < 300) {
					return response.json();
				} else {
					let error = new Error(response.statusText);
					(error as any).response = response;
					throw error;
				}
			});
		}
		/**
		 *
		 * Get Manufacturers
		 * @param conditions
		 * @param orderBy
		 * @param childconditions
		 * @param customfieldconditions
		 * @param page
		 * @param pageSize
		 */
		public procurementManufacturersGet (params: {  conditions?: string; orderBy?: string; childconditions?: string; customfieldconditions?: string; page?: number; pageSize?: number; }, extraQueryParams?: any, extraFetchParams?: any ) : Promise<Array<Manufacturer>> {
			const localVarPath = this.basePath + '/procurement/manufacturers';

			let queryParameters: any = assign({}, extraQueryParams);
			let headerParams: any = assign({}, this.defaultHeaders);
			if (params.conditions !== undefined) {
				queryParameters['conditions'] = params.conditions;
			}

			if (params.orderBy !== undefined) {
				queryParameters['orderBy'] = params.orderBy;
			}

			if (params.childconditions !== undefined) {
				queryParameters['childconditions'] = params.childconditions;
			}

			if (params.customfieldconditions !== undefined) {
				queryParameters['customfieldconditions'] = params.customfieldconditions;
			}

			if (params.page !== undefined) {
				queryParameters['page'] = params.page;
			}

			if (params.pageSize !== undefined) {
				queryParameters['pageSize'] = params.pageSize;
			}

			let fetchParams = {
				method: 'GET',
				headers: headerParams,

			};

			if (extraFetchParams) {
				fetchParams = assign(fetchParams, extraFetchParams);
			}

			let localVarPathWithQueryParameters = localVarPath + (localVarPath.indexOf('?') !== -1 ? '&' : '?') + querystring.stringify(queryParameters);

			return fetch(localVarPathWithQueryParameters, fetchParams).then((response) => {
				if (response.status >= 200 && response.status < 300) {
					return response.json();
				} else {
					let error = new Error(response.statusText);
					(error as any).response = response;
					throw error;
				}
			});
		}
		/**
		 *
		 * Delete Manufacturer By Id
		 * @param id
		 */
		public procurementManufacturersIdDelete (params: {  id: number; }, extraQueryParams?: any, extraFetchParams?: any ) : Promise<{}> {
			const localVarPath = this.basePath + '/procurement/manufacturers/{id}'
				.replace('{' + 'id' + '}', String(params.id));

			let queryParameters: any = assign({}, extraQueryParams);
			let headerParams: any = assign({}, this.defaultHeaders);
			// verify required parameter 'id' is set
			if (params.id == null) {
				throw new Error('Missing required parameter id when calling procurementManufacturersIdDelete');
			}
			let fetchParams = {
				method: 'DELETE',
				headers: headerParams,

			};

			if (extraFetchParams) {
				fetchParams = assign(fetchParams, extraFetchParams);
			}

			let localVarPathWithQueryParameters = localVarPath + (localVarPath.indexOf('?') !== -1 ? '&' : '?') + querystring.stringify(queryParameters);

			return fetch(localVarPathWithQueryParameters, fetchParams).then((response) => {
				if (response.status >= 200 && response.status < 300) {
					return response.json();
				} else {
					let error = new Error(response.statusText);
					(error as any).response = response;
					throw error;
				}
			});
		}
		/**
		 *
		 * Get Manufacturer By Id
		 * @param id
		 */
		public procurementManufacturersIdGet (params: {  id: number; }, extraQueryParams?: any, extraFetchParams?: any ) : Promise<Manufacturer> {
			const localVarPath = this.basePath + '/procurement/manufacturers/{id}'
				.replace('{' + 'id' + '}', String(params.id));

			let queryParameters: any = assign({}, extraQueryParams);
			let headerParams: any = assign({}, this.defaultHeaders);
			// verify required parameter 'id' is set
			if (params.id == null) {
				throw new Error('Missing required parameter id when calling procurementManufacturersIdGet');
			}
			let fetchParams = {
				method: 'GET',
				headers: headerParams,

			};

			if (extraFetchParams) {
				fetchParams = assign(fetchParams, extraFetchParams);
			}

			let localVarPathWithQueryParameters = localVarPath + (localVarPath.indexOf('?') !== -1 ? '&' : '?') + querystring.stringify(queryParameters);

			return fetch(localVarPathWithQueryParameters, fetchParams).then((response) => {
				if (response.status >= 200 && response.status < 300) {
					return response.json();
				} else {
					let error = new Error(response.statusText);
					(error as any).response = response;
					throw error;
				}
			});
		}
		/**
		 *
		 * Update Manufacturer
		 * @param id
		 * @param operations
		 */
		public procurementManufacturersIdPatch (params: {  id: number; operations: Array<PatchOperation>; }, extraQueryParams?: any, extraFetchParams?: any ) : Promise<Manufacturer> {
			const localVarPath = this.basePath + '/procurement/manufacturers/{id}'
				.replace('{' + 'id' + '}', String(params.id));

			let queryParameters: any = assign({}, extraQueryParams);
			let headerParams: any = assign({}, this.defaultHeaders);
			headerParams['Content-Type'] = 'application/json';

			// verify required parameter 'id' is set
			if (params.id == null) {
				throw new Error('Missing required parameter id when calling procurementManufacturersIdPatch');
			}
			// verify required parameter 'operations' is set
			if (params.operations == null) {
				throw new Error('Missing required parameter operations when calling procurementManufacturersIdPatch');
			}
			let fetchParams = {
				method: 'PATCH',
				headers: headerParams,
				body: JSON.stringify(params.operations),

			};

			if (extraFetchParams) {
				fetchParams = assign(fetchParams, extraFetchParams);
			}

			let localVarPathWithQueryParameters = localVarPath + (localVarPath.indexOf('?') !== -1 ? '&' : '?') + querystring.stringify(queryParameters);

			return fetch(localVarPathWithQueryParameters, fetchParams).then((response) => {
				if (response.status >= 200 && response.status < 300) {
					return response.json();
				} else {
					let error = new Error(response.statusText);
					(error as any).response = response;
					throw error;
				}
			});
		}
		/**
		 *
		 * Replace Manufacturer
		 * @param id
		 * @param manufacturer
		 */
		public procurementManufacturersIdPut (params: {  id: number; manufacturer: Manufacturer; }, extraQueryParams?: any, extraFetchParams?: any ) : Promise<Manufacturer> {
			const localVarPath = this.basePath + '/procurement/manufacturers/{id}'
				.replace('{' + 'id' + '}', String(params.id));

			let queryParameters: any = assign({}, extraQueryParams);
			let headerParams: any = assign({}, this.defaultHeaders);
			headerParams['Content-Type'] = 'application/json';

			// verify required parameter 'id' is set
			if (params.id == null) {
				throw new Error('Missing required parameter id when calling procurementManufacturersIdPut');
			}
			// verify required parameter 'manufacturer' is set
			if (params.manufacturer == null) {
				throw new Error('Missing required parameter manufacturer when calling procurementManufacturersIdPut');
			}
			let fetchParams = {
				method: 'PUT',
				headers: headerParams,
				body: JSON.stringify(params.manufacturer),

			};

			if (extraFetchParams) {
				fetchParams = assign(fetchParams, extraFetchParams);
			}

			let localVarPathWithQueryParameters = localVarPath + (localVarPath.indexOf('?') !== -1 ? '&' : '?') + querystring.stringify(queryParameters);

			return fetch(localVarPathWithQueryParameters, fetchParams).then((response) => {
				if (response.status >= 200 && response.status < 300) {
					return response.json();
				} else {
					let error = new Error(response.statusText);
					(error as any).response = response;
					throw error;
				}
			});
		}
		/**
		 *
		 * Create Manufacturer
		 * @param manufacturer
		 */
		public procurementManufacturersPost (params: {  manufacturer: Manufacturer; }, extraQueryParams?: any, extraFetchParams?: any ) : Promise<Manufacturer> {
			const localVarPath = this.basePath + '/procurement/manufacturers';

			let queryParameters: any = assign({}, extraQueryParams);
			let headerParams: any = assign({}, this.defaultHeaders);
			headerParams['Content-Type'] = 'application/json';

			// verify required parameter 'manufacturer' is set
			if (params.manufacturer == null) {
				throw new Error('Missing required parameter manufacturer when calling procurementManufacturersPost');
			}
			let fetchParams = {
				method: 'POST',
				headers: headerParams,
				body: JSON.stringify(params.manufacturer),

			};

			if (extraFetchParams) {
				fetchParams = assign(fetchParams, extraFetchParams);
			}

			let localVarPathWithQueryParameters = localVarPath + (localVarPath.indexOf('?') !== -1 ? '&' : '?') + querystring.stringify(queryParameters);

			return fetch(localVarPathWithQueryParameters, fetchParams).then((response) => {
				if (response.status >= 200 && response.status < 300) {
					return response.json();
				} else {
					let error = new Error(response.statusText);
					(error as any).response = response;
					throw error;
				}
			});
		}
	}
//}
//export namespace  {
	'use strict';

	export class MarketDescriptionsApi {
		protected basePath = 'https://api-na.myconnectwise.net/v4_6_release/apis/3.0';
		public defaultHeaders : any = {};

		constructor(basePath?: string) {
			if (basePath) {
				this.basePath = basePath;
			}
		}

		/**
		 *
		 * Get Market Description Count
		 * @param conditions
		 */
		public companyMarketDescriptionsCountGet (params: {  conditions?: string; }, extraQueryParams?: any, extraFetchParams?: any ) : Promise<Count> {
			const localVarPath = this.basePath + '/company/marketDescriptions/count';

			let queryParameters: any = assign({}, extraQueryParams);
			let headerParams: any = assign({}, this.defaultHeaders);
			if (params.conditions !== undefined) {
				queryParameters['conditions'] = params.conditions;
			}

			let fetchParams = {
				method: 'GET',
				headers: headerParams,

			};

			if (extraFetchParams) {
				fetchParams = assign(fetchParams, extraFetchParams);
			}

			let localVarPathWithQueryParameters = localVarPath + (localVarPath.indexOf('?') !== -1 ? '&' : '?') + querystring.stringify(queryParameters);

			return fetch(localVarPathWithQueryParameters, fetchParams).then((response) => {
				if (response.status >= 200 && response.status < 300) {
					return response.json();
				} else {
					let error = new Error(response.statusText);
					(error as any).response = response;
					throw error;
				}
			});
		}
		/**
		 *
		 * Get Market Description
		 * @param conditions
		 * @param orderBy
		 * @param childconditions
		 * @param customfieldconditions
		 * @param page
		 * @param pageSize
		 */
		public companyMarketDescriptionsGet (params: {  conditions?: string; orderBy?: string; childconditions?: string; customfieldconditions?: string; page?: number; pageSize?: number; }, extraQueryParams?: any, extraFetchParams?: any ) : Promise<Array<MarketDescription>> {
			const localVarPath = this.basePath + '/company/marketDescriptions';

			let queryParameters: any = assign({}, extraQueryParams);
			let headerParams: any = assign({}, this.defaultHeaders);
			if (params.conditions !== undefined) {
				queryParameters['conditions'] = params.conditions;
			}

			if (params.orderBy !== undefined) {
				queryParameters['orderBy'] = params.orderBy;
			}

			if (params.childconditions !== undefined) {
				queryParameters['childconditions'] = params.childconditions;
			}

			if (params.customfieldconditions !== undefined) {
				queryParameters['customfieldconditions'] = params.customfieldconditions;
			}

			if (params.page !== undefined) {
				queryParameters['page'] = params.page;
			}

			if (params.pageSize !== undefined) {
				queryParameters['pageSize'] = params.pageSize;
			}

			let fetchParams = {
				method: 'GET',
				headers: headerParams,

			};

			if (extraFetchParams) {
				fetchParams = assign(fetchParams, extraFetchParams);
			}

			let localVarPathWithQueryParameters = localVarPath + (localVarPath.indexOf('?') !== -1 ? '&' : '?') + querystring.stringify(queryParameters);

			return fetch(localVarPathWithQueryParameters, fetchParams).then((response) => {
				if (response.status >= 200 && response.status < 300) {
					return response.json();
				} else {
					let error = new Error(response.statusText);
					(error as any).response = response;
					throw error;
				}
			});
		}
		/**
		 *
		 * Delete Market Description By Id
		 * @param id
		 */
		public companyMarketDescriptionsIdDelete (params: {  id: number; }, extraQueryParams?: any, extraFetchParams?: any ) : Promise<{}> {
			const localVarPath = this.basePath + '/company/marketDescriptions/{id}'
				.replace('{' + 'id' + '}', String(params.id));

			let queryParameters: any = assign({}, extraQueryParams);
			let headerParams: any = assign({}, this.defaultHeaders);
			// verify required parameter 'id' is set
			if (params.id == null) {
				throw new Error('Missing required parameter id when calling companyMarketDescriptionsIdDelete');
			}
			let fetchParams = {
				method: 'DELETE',
				headers: headerParams,

			};

			if (extraFetchParams) {
				fetchParams = assign(fetchParams, extraFetchParams);
			}

			let localVarPathWithQueryParameters = localVarPath + (localVarPath.indexOf('?') !== -1 ? '&' : '?') + querystring.stringify(queryParameters);

			return fetch(localVarPathWithQueryParameters, fetchParams).then((response) => {
				if (response.status >= 200 && response.status < 300) {
					return response.json();
				} else {
					let error = new Error(response.statusText);
					(error as any).response = response;
					throw error;
				}
			});
		}
		/**
		 *
		 * Get Market Description By Id
		 * @param id
		 */
		public companyMarketDescriptionsIdGet (params: {  id: number; }, extraQueryParams?: any, extraFetchParams?: any ) : Promise<MarketDescription> {
			const localVarPath = this.basePath + '/company/marketDescriptions/{id}'
				.replace('{' + 'id' + '}', String(params.id));

			let queryParameters: any = assign({}, extraQueryParams);
			let headerParams: any = assign({}, this.defaultHeaders);
			// verify required parameter 'id' is set
			if (params.id == null) {
				throw new Error('Missing required parameter id when calling companyMarketDescriptionsIdGet');
			}
			let fetchParams = {
				method: 'GET',
				headers: headerParams,

			};

			if (extraFetchParams) {
				fetchParams = assign(fetchParams, extraFetchParams);
			}

			let localVarPathWithQueryParameters = localVarPath + (localVarPath.indexOf('?') !== -1 ? '&' : '?') + querystring.stringify(queryParameters);

			return fetch(localVarPathWithQueryParameters, fetchParams).then((response) => {
				if (response.status >= 200 && response.status < 300) {
					return response.json();
				} else {
					let error = new Error(response.statusText);
					(error as any).response = response;
					throw error;
				}
			});
		}
		/**
		 *
		 * Update Market Description
		 * @param id
		 * @param operations
		 */
		public companyMarketDescriptionsIdPatch (params: {  id: number; operations: Array<PatchOperation>; }, extraQueryParams?: any, extraFetchParams?: any ) : Promise<MarketDescription> {
			const localVarPath = this.basePath + '/company/marketDescriptions/{id}'
				.replace('{' + 'id' + '}', String(params.id));

			let queryParameters: any = assign({}, extraQueryParams);
			let headerParams: any = assign({}, this.defaultHeaders);
			headerParams['Content-Type'] = 'application/json';

			// verify required parameter 'id' is set
			if (params.id == null) {
				throw new Error('Missing required parameter id when calling companyMarketDescriptionsIdPatch');
			}
			// verify required parameter 'operations' is set
			if (params.operations == null) {
				throw new Error('Missing required parameter operations when calling companyMarketDescriptionsIdPatch');
			}
			let fetchParams = {
				method: 'PATCH',
				headers: headerParams,
				body: JSON.stringify(params.operations),

			};

			if (extraFetchParams) {
				fetchParams = assign(fetchParams, extraFetchParams);
			}

			let localVarPathWithQueryParameters = localVarPath + (localVarPath.indexOf('?') !== -1 ? '&' : '?') + querystring.stringify(queryParameters);

			return fetch(localVarPathWithQueryParameters, fetchParams).then((response) => {
				if (response.status >= 200 && response.status < 300) {
					return response.json();
				} else {
					let error = new Error(response.statusText);
					(error as any).response = response;
					throw error;
				}
			});
		}
		/**
		 *
		 * Replace Market Description
		 * @param id
		 * @param marketDescription
		 */
		public companyMarketDescriptionsIdPut (params: {  id: number; marketDescription: MarketDescription; }, extraQueryParams?: any, extraFetchParams?: any ) : Promise<MarketDescription> {
			const localVarPath = this.basePath + '/company/marketDescriptions/{id}'
				.replace('{' + 'id' + '}', String(params.id));

			let queryParameters: any = assign({}, extraQueryParams);
			let headerParams: any = assign({}, this.defaultHeaders);
			headerParams['Content-Type'] = 'application/json';

			// verify required parameter 'id' is set
			if (params.id == null) {
				throw new Error('Missing required parameter id when calling companyMarketDescriptionsIdPut');
			}
			// verify required parameter 'marketDescription' is set
			if (params.marketDescription == null) {
				throw new Error('Missing required parameter marketDescription when calling companyMarketDescriptionsIdPut');
			}
			let fetchParams = {
				method: 'PUT',
				headers: headerParams,
				body: JSON.stringify(params.marketDescription),

			};

			if (extraFetchParams) {
				fetchParams = assign(fetchParams, extraFetchParams);
			}

			let localVarPathWithQueryParameters = localVarPath + (localVarPath.indexOf('?') !== -1 ? '&' : '?') + querystring.stringify(queryParameters);

			return fetch(localVarPathWithQueryParameters, fetchParams).then((response) => {
				if (response.status >= 200 && response.status < 300) {
					return response.json();
				} else {
					let error = new Error(response.statusText);
					(error as any).response = response;
					throw error;
				}
			});
		}
		/**
		 *
		 * Create Market Description
		 * @param marketDescription
		 */
		public companyMarketDescriptionsPost (params: {  marketDescription: MarketDescription; }, extraQueryParams?: any, extraFetchParams?: any ) : Promise<MarketDescription> {
			const localVarPath = this.basePath + '/company/marketDescriptions';

			let queryParameters: any = assign({}, extraQueryParams);
			let headerParams: any = assign({}, this.defaultHeaders);
			headerParams['Content-Type'] = 'application/json';

			// verify required parameter 'marketDescription' is set
			if (params.marketDescription == null) {
				throw new Error('Missing required parameter marketDescription when calling companyMarketDescriptionsPost');
			}
			let fetchParams = {
				method: 'POST',
				headers: headerParams,
				body: JSON.stringify(params.marketDescription),

			};

			if (extraFetchParams) {
				fetchParams = assign(fetchParams, extraFetchParams);
			}

			let localVarPathWithQueryParameters = localVarPath + (localVarPath.indexOf('?') !== -1 ? '&' : '?') + querystring.stringify(queryParameters);

			return fetch(localVarPathWithQueryParameters, fetchParams).then((response) => {
				if (response.status >= 200 && response.status < 300) {
					return response.json();
				} else {
					let error = new Error(response.statusText);
					(error as any).response = response;
					throw error;
				}
			});
		}
	}
//}
//export namespace  {
	'use strict';

	export class MemberTypesApi {
		protected basePath = 'https://api-na.myconnectwise.net/v4_6_release/apis/3.0';
		public defaultHeaders : any = {};

		constructor(basePath?: string) {
			if (basePath) {
				this.basePath = basePath;
			}
		}

		/**
		 *
		 * Get Type Count
		 * @param conditions
		 */
		public systemMembersTypesCountGet (params: {  conditions?: string; }, extraQueryParams?: any, extraFetchParams?: any ) : Promise<Count> {
			const localVarPath = this.basePath + '/system/members/types/count';

			let queryParameters: any = assign({}, extraQueryParams);
			let headerParams: any = assign({}, this.defaultHeaders);
			if (params.conditions !== undefined) {
				queryParameters['conditions'] = params.conditions;
			}

			let fetchParams = {
				method: 'GET',
				headers: headerParams,

			};

			if (extraFetchParams) {
				fetchParams = assign(fetchParams, extraFetchParams);
			}

			let localVarPathWithQueryParameters = localVarPath + (localVarPath.indexOf('?') !== -1 ? '&' : '?') + querystring.stringify(queryParameters);

			return fetch(localVarPathWithQueryParameters, fetchParams).then((response) => {
				if (response.status >= 200 && response.status < 300) {
					return response.json();
				} else {
					let error = new Error(response.statusText);
					(error as any).response = response;
					throw error;
				}
			});
		}
		/**
		 *
		 * Get Type
		 * @param conditions
		 * @param orderBy
		 * @param childconditions
		 * @param customfieldconditions
		 * @param page
		 * @param pageSize
		 */
		public systemMembersTypesGet (params: {  conditions?: string; orderBy?: string; childconditions?: string; customfieldconditions?: string; page?: number; pageSize?: number; }, extraQueryParams?: any, extraFetchParams?: any ) : Promise<Array<Type>> {
			const localVarPath = this.basePath + '/system/members/types';

			let queryParameters: any = assign({}, extraQueryParams);
			let headerParams: any = assign({}, this.defaultHeaders);
			if (params.conditions !== undefined) {
				queryParameters['conditions'] = params.conditions;
			}

			if (params.orderBy !== undefined) {
				queryParameters['orderBy'] = params.orderBy;
			}

			if (params.childconditions !== undefined) {
				queryParameters['childconditions'] = params.childconditions;
			}

			if (params.customfieldconditions !== undefined) {
				queryParameters['customfieldconditions'] = params.customfieldconditions;
			}

			if (params.page !== undefined) {
				queryParameters['page'] = params.page;
			}

			if (params.pageSize !== undefined) {
				queryParameters['pageSize'] = params.pageSize;
			}

			let fetchParams = {
				method: 'GET',
				headers: headerParams,

			};

			if (extraFetchParams) {
				fetchParams = assign(fetchParams, extraFetchParams);
			}

			let localVarPathWithQueryParameters = localVarPath + (localVarPath.indexOf('?') !== -1 ? '&' : '?') + querystring.stringify(queryParameters);

			return fetch(localVarPathWithQueryParameters, fetchParams).then((response) => {
				if (response.status >= 200 && response.status < 300) {
					return response.json();
				} else {
					let error = new Error(response.statusText);
					(error as any).response = response;
					throw error;
				}
			});
		}
		/**
		 *
		 * Delete Type By Id
		 * @param id
		 */
		public systemMembersTypesIdDelete (params: {  id: number; }, extraQueryParams?: any, extraFetchParams?: any ) : Promise<{}> {
			const localVarPath = this.basePath + '/system/members/types/{id}'
				.replace('{' + 'id' + '}', String(params.id));

			let queryParameters: any = assign({}, extraQueryParams);
			let headerParams: any = assign({}, this.defaultHeaders);
			// verify required parameter 'id' is set
			if (params.id == null) {
				throw new Error('Missing required parameter id when calling systemMembersTypesIdDelete');
			}
			let fetchParams = {
				method: 'DELETE',
				headers: headerParams,

			};

			if (extraFetchParams) {
				fetchParams = assign(fetchParams, extraFetchParams);
			}

			let localVarPathWithQueryParameters = localVarPath + (localVarPath.indexOf('?') !== -1 ? '&' : '?') + querystring.stringify(queryParameters);

			return fetch(localVarPathWithQueryParameters, fetchParams).then((response) => {
				if (response.status >= 200 && response.status < 300) {
					return response.json();
				} else {
					let error = new Error(response.statusText);
					(error as any).response = response;
					throw error;
				}
			});
		}
		/**
		 *
		 * Get Type By Id
		 * @param id
		 */
		public systemMembersTypesIdGet (params: {  id: number; }, extraQueryParams?: any, extraFetchParams?: any ) : Promise<Type> {
			const localVarPath = this.basePath + '/system/members/types/{id}'
				.replace('{' + 'id' + '}', String(params.id));

			let queryParameters: any = assign({}, extraQueryParams);
			let headerParams: any = assign({}, this.defaultHeaders);
			// verify required parameter 'id' is set
			if (params.id == null) {
				throw new Error('Missing required parameter id when calling systemMembersTypesIdGet');
			}
			let fetchParams = {
				method: 'GET',
				headers: headerParams,

			};

			if (extraFetchParams) {
				fetchParams = assign(fetchParams, extraFetchParams);
			}

			let localVarPathWithQueryParameters = localVarPath + (localVarPath.indexOf('?') !== -1 ? '&' : '?') + querystring.stringify(queryParameters);

			return fetch(localVarPathWithQueryParameters, fetchParams).then((response) => {
				if (response.status >= 200 && response.status < 300) {
					return response.json();
				} else {
					let error = new Error(response.statusText);
					(error as any).response = response;
					throw error;
				}
			});
		}
		/**
		 *
		 * Update Type
		 * @param id
		 * @param operations
		 */
		public systemMembersTypesIdPatch (params: {  id: number; operations: Array<PatchOperation>; }, extraQueryParams?: any, extraFetchParams?: any ) : Promise<Type> {
			const localVarPath = this.basePath + '/system/members/types/{id}'
				.replace('{' + 'id' + '}', String(params.id));

			let queryParameters: any = assign({}, extraQueryParams);
			let headerParams: any = assign({}, this.defaultHeaders);
			headerParams['Content-Type'] = 'application/json';

			// verify required parameter 'id' is set
			if (params.id == null) {
				throw new Error('Missing required parameter id when calling systemMembersTypesIdPatch');
			}
			// verify required parameter 'operations' is set
			if (params.operations == null) {
				throw new Error('Missing required parameter operations when calling systemMembersTypesIdPatch');
			}
			let fetchParams = {
				method: 'PATCH',
				headers: headerParams,
				body: JSON.stringify(params.operations),

			};

			if (extraFetchParams) {
				fetchParams = assign(fetchParams, extraFetchParams);
			}

			let localVarPathWithQueryParameters = localVarPath + (localVarPath.indexOf('?') !== -1 ? '&' : '?') + querystring.stringify(queryParameters);

			return fetch(localVarPathWithQueryParameters, fetchParams).then((response) => {
				if (response.status >= 200 && response.status < 300) {
					return response.json();
				} else {
					let error = new Error(response.statusText);
					(error as any).response = response;
					throw error;
				}
			});
		}
		/**
		 *
		 * Replace Type
		 * @param id
		 * @param type
		 */
		public systemMembersTypesIdPut (params: {  id: number; type: Type; }, extraQueryParams?: any, extraFetchParams?: any ) : Promise<Type> {
			const localVarPath = this.basePath + '/system/members/types/{id}'
				.replace('{' + 'id' + '}', String(params.id));

			let queryParameters: any = assign({}, extraQueryParams);
			let headerParams: any = assign({}, this.defaultHeaders);
			headerParams['Content-Type'] = 'application/json';

			// verify required parameter 'id' is set
			if (params.id == null) {
				throw new Error('Missing required parameter id when calling systemMembersTypesIdPut');
			}
			// verify required parameter 'type' is set
			if (params.type == null) {
				throw new Error('Missing required parameter type when calling systemMembersTypesIdPut');
			}
			let fetchParams = {
				method: 'PUT',
				headers: headerParams,
				body: JSON.stringify(params.type),

			};

			if (extraFetchParams) {
				fetchParams = assign(fetchParams, extraFetchParams);
			}

			let localVarPathWithQueryParameters = localVarPath + (localVarPath.indexOf('?') !== -1 ? '&' : '?') + querystring.stringify(queryParameters);

			return fetch(localVarPathWithQueryParameters, fetchParams).then((response) => {
				if (response.status >= 200 && response.status < 300) {
					return response.json();
				} else {
					let error = new Error(response.statusText);
					(error as any).response = response;
					throw error;
				}
			});
		}
		/**
		 *
		 * Create Type
		 * @param type
		 */
		public systemMembersTypesPost (params: {  type: Type; }, extraQueryParams?: any, extraFetchParams?: any ) : Promise<Type> {
			const localVarPath = this.basePath + '/system/members/types';

			let queryParameters: any = assign({}, extraQueryParams);
			let headerParams: any = assign({}, this.defaultHeaders);
			headerParams['Content-Type'] = 'application/json';

			// verify required parameter 'type' is set
			if (params.type == null) {
				throw new Error('Missing required parameter type when calling systemMembersTypesPost');
			}
			let fetchParams = {
				method: 'POST',
				headers: headerParams,
				body: JSON.stringify(params.type),

			};

			if (extraFetchParams) {
				fetchParams = assign(fetchParams, extraFetchParams);
			}

			let localVarPathWithQueryParameters = localVarPath + (localVarPath.indexOf('?') !== -1 ? '&' : '?') + querystring.stringify(queryParameters);

			return fetch(localVarPathWithQueryParameters, fetchParams).then((response) => {
				if (response.status >= 200 && response.status < 300) {
					return response.json();
				} else {
					let error = new Error(response.statusText);
					(error as any).response = response;
					throw error;
				}
			});
		}
	}
//}
//export namespace  {
	'use strict';

	export class MembersApi {
		protected basePath = 'https://api-na.myconnectwise.net/v4_6_release/apis/3.0';
		public defaultHeaders : any = {};

		constructor(basePath?: string) {
			if (basePath) {
				this.basePath = basePath;
			}
		}

		/**
		 *
		 * Get Members Count
		 * @param conditions
		 */
		public systemMembersCountGet (params: {  conditions?: string; }, extraQueryParams?: any, extraFetchParams?: any ) : Promise<Count> {
			const localVarPath = this.basePath + '/system/members/count';

			let queryParameters: any = assign({}, extraQueryParams);
			let headerParams: any = assign({}, this.defaultHeaders);
			if (params.conditions !== undefined) {
				queryParameters['conditions'] = params.conditions;
			}

			let fetchParams = {
				method: 'GET',
				headers: headerParams,

			};

			if (extraFetchParams) {
				fetchParams = assign(fetchParams, extraFetchParams);
			}

			let localVarPathWithQueryParameters = localVarPath + (localVarPath.indexOf('?') !== -1 ? '&' : '?') + querystring.stringify(queryParameters);

			return fetch(localVarPathWithQueryParameters, fetchParams).then((response) => {
				if (response.status >= 200 && response.status < 300) {
					return response.json();
				} else {
					let error = new Error(response.statusText);
					(error as any).response = response;
					throw error;
				}
			});
		}
		/**
		 *
		 * Get Members
		 * @param conditions
		 * @param orderBy
		 * @param childconditions
		 * @param customfieldconditions
		 * @param page
		 * @param pageSize
		 */
		public systemMembersGet (params: {  conditions?: string; orderBy?: string; childconditions?: string; customfieldconditions?: string; page?: number; pageSize?: number; }, extraQueryParams?: any, extraFetchParams?: any ) : Promise<Array<Member>> {
			const localVarPath = this.basePath + '/system/members';

			let queryParameters: any = assign({}, extraQueryParams);
			let headerParams: any = assign({}, this.defaultHeaders);
			if (params.conditions !== undefined) {
				queryParameters['conditions'] = params.conditions;
			}

			if (params.orderBy !== undefined) {
				queryParameters['orderBy'] = params.orderBy;
			}

			if (params.childconditions !== undefined) {
				queryParameters['childconditions'] = params.childconditions;
			}

			if (params.customfieldconditions !== undefined) {
				queryParameters['customfieldconditions'] = params.customfieldconditions;
			}

			if (params.page !== undefined) {
				queryParameters['page'] = params.page;
			}

			if (params.pageSize !== undefined) {
				queryParameters['pageSize'] = params.pageSize;
			}

			let fetchParams = {
				method: 'GET',
				headers: headerParams,

			};

			if (extraFetchParams) {
				fetchParams = assign(fetchParams, extraFetchParams);
			}

			let localVarPathWithQueryParameters = localVarPath + (localVarPath.indexOf('?') !== -1 ? '&' : '?') + querystring.stringify(queryParameters);

			return fetch(localVarPathWithQueryParameters, fetchParams).then((response) => {
				if (response.status >= 200 && response.status < 300) {
					return response.json();
				} else {
					let error = new Error(response.statusText);
					(error as any).response = response;
					throw error;
				}
			});
		}
		/**
		 *
		 * Get Member By Id
		 * @param memberIdentifier
		 */
		public systemMembersMemberIdentifierGet (params: {  memberIdentifier: string; }, extraQueryParams?: any, extraFetchParams?: any ) : Promise<Member> {
			const localVarPath = this.basePath + '/system/members/{memberIdentifier}'
				.replace('{' + 'memberIdentifier' + '}', String(params.memberIdentifier));

			let queryParameters: any = assign({}, extraQueryParams);
			let headerParams: any = assign({}, this.defaultHeaders);
			// verify required parameter 'memberIdentifier' is set
			if (params.memberIdentifier == null) {
				throw new Error('Missing required parameter memberIdentifier when calling systemMembersMemberIdentifierGet');
			}
			let fetchParams = {
				method: 'GET',
				headers: headerParams,

			};

			if (extraFetchParams) {
				fetchParams = assign(fetchParams, extraFetchParams);
			}

			let localVarPathWithQueryParameters = localVarPath + (localVarPath.indexOf('?') !== -1 ? '&' : '?') + querystring.stringify(queryParameters);

			return fetch(localVarPathWithQueryParameters, fetchParams).then((response) => {
				if (response.status >= 200 && response.status < 300) {
					return response.json();
				} else {
					let error = new Error(response.statusText);
					(error as any).response = response;
					throw error;
				}
			});
		}
		/**
		 *
		 * Get Member Image
		 * @param memberIdentifier
		 * @param useDefaultFlag
		 * @param lastmodified
		 */
		public systemMembersMemberIdentifierImageGet (params: {  memberIdentifier: string; useDefaultFlag?: boolean; lastmodified?: string; }, extraQueryParams?: any, extraFetchParams?: any ) : Promise<{}> {
			const localVarPath = this.basePath + '/system/members/{memberIdentifier}/image'
				.replace('{' + 'memberIdentifier' + '}', String(params.memberIdentifier));

			let queryParameters: any = assign({}, extraQueryParams);
			let headerParams: any = assign({}, this.defaultHeaders);
			// verify required parameter 'memberIdentifier' is set
			if (params.memberIdentifier == null) {
				throw new Error('Missing required parameter memberIdentifier when calling systemMembersMemberIdentifierImageGet');
			}
			if (params.useDefaultFlag !== undefined) {
				queryParameters['useDefaultFlag'] = params.useDefaultFlag;
			}

			if (params.lastmodified !== undefined) {
				queryParameters['lastmodified'] = params.lastmodified;
			}

			let fetchParams = {
				method: 'GET',
				headers: headerParams,

			};

			if (extraFetchParams) {
				fetchParams = assign(fetchParams, extraFetchParams);
			}

			let localVarPathWithQueryParameters = localVarPath + (localVarPath.indexOf('?') !== -1 ? '&' : '?') + querystring.stringify(queryParameters);

			return fetch(localVarPathWithQueryParameters, fetchParams).then((response) => {
				if (response.status >= 200 && response.status < 300) {
					return response.json();
				} else {
					let error = new Error(response.statusText);
					(error as any).response = response;
					throw error;
				}
			});
		}
		/**
		 *
		 * Create Token By Member Identifier
		 * @param memberIdentifier
		 */
		public systemMembersMemberIdentifierTokensPost (params: {  memberIdentifier: string; }, extraQueryParams?: any, extraFetchParams?: any ) : Promise<Token> {
			const localVarPath = this.basePath + '/system/members/{memberIdentifier}/tokens'
				.replace('{' + 'memberIdentifier' + '}', String(params.memberIdentifier));

			let queryParameters: any = assign({}, extraQueryParams);
			let headerParams: any = assign({}, this.defaultHeaders);
			// verify required parameter 'memberIdentifier' is set
			if (params.memberIdentifier == null) {
				throw new Error('Missing required parameter memberIdentifier when calling systemMembersMemberIdentifierTokensPost');
			}
			let fetchParams = {
				method: 'POST',
				headers: headerParams,

			};

			if (extraFetchParams) {
				fetchParams = assign(fetchParams, extraFetchParams);
			}

			let localVarPathWithQueryParameters = localVarPath + (localVarPath.indexOf('?') !== -1 ? '&' : '?') + querystring.stringify(queryParameters);

			return fetch(localVarPathWithQueryParameters, fetchParams).then((response) => {
				if (response.status >= 200 && response.status < 300) {
					return response.json();
				} else {
					let error = new Error(response.statusText);
					(error as any).response = response;
					throw error;
				}
			});
		}
	}
//}
//export namespace  {
	'use strict';

	export class MenuEntriesApi {
		protected basePath = 'https://api-na.myconnectwise.net/v4_6_release/apis/3.0';
		public defaultHeaders : any = {};

		constructor(basePath?: string) {
			if (basePath) {
				this.basePath = basePath;
			}
		}

		/**
		 *
		 * Get Menu Entries Count
		 * @param conditions
		 */
		public systemMenuentriesCountGet (params: {  conditions?: string; }, extraQueryParams?: any, extraFetchParams?: any ) : Promise<Count> {
			const localVarPath = this.basePath + '/system/menuentries/count';

			let queryParameters: any = assign({}, extraQueryParams);
			let headerParams: any = assign({}, this.defaultHeaders);
			if (params.conditions !== undefined) {
				queryParameters['conditions'] = params.conditions;
			}

			let fetchParams = {
				method: 'GET',
				headers: headerParams,

			};

			if (extraFetchParams) {
				fetchParams = assign(fetchParams, extraFetchParams);
			}

			let localVarPathWithQueryParameters = localVarPath + (localVarPath.indexOf('?') !== -1 ? '&' : '?') + querystring.stringify(queryParameters);

			return fetch(localVarPathWithQueryParameters, fetchParams).then((response) => {
				if (response.status >= 200 && response.status < 300) {
					return response.json();
				} else {
					let error = new Error(response.statusText);
					(error as any).response = response;
					throw error;
				}
			});
		}
		/**
		 *
		 * Get Menu Entries
		 * @param conditions
		 * @param orderBy
		 * @param childconditions
		 * @param customfieldconditions
		 * @param page
		 * @param pageSize
		 */
		public systemMenuentriesGet (params: {  conditions?: string; orderBy?: string; childconditions?: string; customfieldconditions?: string; page?: number; pageSize?: number; }, extraQueryParams?: any, extraFetchParams?: any ) : Promise<Array<MenuEntry>> {
			const localVarPath = this.basePath + '/system/menuentries';

			let queryParameters: any = assign({}, extraQueryParams);
			let headerParams: any = assign({}, this.defaultHeaders);
			if (params.conditions !== undefined) {
				queryParameters['conditions'] = params.conditions;
			}

			if (params.orderBy !== undefined) {
				queryParameters['orderBy'] = params.orderBy;
			}

			if (params.childconditions !== undefined) {
				queryParameters['childconditions'] = params.childconditions;
			}

			if (params.customfieldconditions !== undefined) {
				queryParameters['customfieldconditions'] = params.customfieldconditions;
			}

			if (params.page !== undefined) {
				queryParameters['page'] = params.page;
			}

			if (params.pageSize !== undefined) {
				queryParameters['pageSize'] = params.pageSize;
			}

			let fetchParams = {
				method: 'GET',
				headers: headerParams,

			};

			if (extraFetchParams) {
				fetchParams = assign(fetchParams, extraFetchParams);
			}

			let localVarPathWithQueryParameters = localVarPath + (localVarPath.indexOf('?') !== -1 ? '&' : '?') + querystring.stringify(queryParameters);

			return fetch(localVarPathWithQueryParameters, fetchParams).then((response) => {
				if (response.status >= 200 && response.status < 300) {
					return response.json();
				} else {
					let error = new Error(response.statusText);
					(error as any).response = response;
					throw error;
				}
			});
		}
		/**
		 *
		 * Delete Menu Entry By Id
		 * @param id
		 */
		public systemMenuentriesIdDelete (params: {  id: number; }, extraQueryParams?: any, extraFetchParams?: any ) : Promise<{}> {
			const localVarPath = this.basePath + '/system/menuentries/{id}'
				.replace('{' + 'id' + '}', String(params.id));

			let queryParameters: any = assign({}, extraQueryParams);
			let headerParams: any = assign({}, this.defaultHeaders);
			// verify required parameter 'id' is set
			if (params.id == null) {
				throw new Error('Missing required parameter id when calling systemMenuentriesIdDelete');
			}
			let fetchParams = {
				method: 'DELETE',
				headers: headerParams,

			};

			if (extraFetchParams) {
				fetchParams = assign(fetchParams, extraFetchParams);
			}

			let localVarPathWithQueryParameters = localVarPath + (localVarPath.indexOf('?') !== -1 ? '&' : '?') + querystring.stringify(queryParameters);

			return fetch(localVarPathWithQueryParameters, fetchParams).then((response) => {
				if (response.status >= 200 && response.status < 300) {
					return response.json();
				} else {
					let error = new Error(response.statusText);
					(error as any).response = response;
					throw error;
				}
			});
		}
		/**
		 *
		 * Get Menu Entry By Id
		 * @param id
		 */
		public systemMenuentriesIdGet (params: {  id: number; }, extraQueryParams?: any, extraFetchParams?: any ) : Promise<MenuEntry> {
			const localVarPath = this.basePath + '/system/menuentries/{id}'
				.replace('{' + 'id' + '}', String(params.id));

			let queryParameters: any = assign({}, extraQueryParams);
			let headerParams: any = assign({}, this.defaultHeaders);
			// verify required parameter 'id' is set
			if (params.id == null) {
				throw new Error('Missing required parameter id when calling systemMenuentriesIdGet');
			}
			let fetchParams = {
				method: 'GET',
				headers: headerParams,

			};

			if (extraFetchParams) {
				fetchParams = assign(fetchParams, extraFetchParams);
			}

			let localVarPathWithQueryParameters = localVarPath + (localVarPath.indexOf('?') !== -1 ? '&' : '?') + querystring.stringify(queryParameters);

			return fetch(localVarPathWithQueryParameters, fetchParams).then((response) => {
				if (response.status >= 200 && response.status < 300) {
					return response.json();
				} else {
					let error = new Error(response.statusText);
					(error as any).response = response;
					throw error;
				}
			});
		}
		/**
		 *
		 * Get Menu Entry Image
		 * @param id
		 * @param lastmodified
		 * @param largeFlag
		 */
		public systemMenuentriesIdImageGet (params: {  id: number; lastmodified?: string; largeFlag?: boolean; }, extraQueryParams?: any, extraFetchParams?: any ) : Promise<{}> {
			const localVarPath = this.basePath + '/system/menuentries/{id}/image'
				.replace('{' + 'id' + '}', String(params.id));

			let queryParameters: any = assign({}, extraQueryParams);
			let headerParams: any = assign({}, this.defaultHeaders);
			// verify required parameter 'id' is set
			if (params.id == null) {
				throw new Error('Missing required parameter id when calling systemMenuentriesIdImageGet');
			}
			if (params.lastmodified !== undefined) {
				queryParameters['lastmodified'] = params.lastmodified;
			}

			if (params.largeFlag !== undefined) {
				queryParameters['largeFlag'] = params.largeFlag;
			}

			let fetchParams = {
				method: 'GET',
				headers: headerParams,

			};

			if (extraFetchParams) {
				fetchParams = assign(fetchParams, extraFetchParams);
			}

			let localVarPathWithQueryParameters = localVarPath + (localVarPath.indexOf('?') !== -1 ? '&' : '?') + querystring.stringify(queryParameters);

			return fetch(localVarPathWithQueryParameters, fetchParams).then((response) => {
				if (response.status >= 200 && response.status < 300) {
					return response.json();
				} else {
					let error = new Error(response.statusText);
					(error as any).response = response;
					throw error;
				}
			});
		}
		/**
		 *
		 * Upload Menu Entry Image
		 * @param id
		 * @param file File to upload
		 */
		public systemMenuentriesIdImagePost (params: {  id: number; file?: any; }, extraQueryParams?: any, extraFetchParams?: any ) : Promise<{}> {
			const localVarPath = this.basePath + '/system/menuentries/{id}/image'
				.replace('{' + 'id' + '}', String(params.id));

			let queryParameters: any = assign({}, extraQueryParams);
			let headerParams: any = assign({}, this.defaultHeaders);
			let formParams: any = {};
			headerParams['Content-Type'] = 'application/x-www-form-urlencoded';

			// verify required parameter 'id' is set
			if (params.id == null) {
				throw new Error('Missing required parameter id when calling systemMenuentriesIdImagePost');
			}
			formParams['file'] = params.file;

			let fetchParams = {
				method: 'POST',
				headers: headerParams,
								body: querystring.stringify(formParams),

			};

			if (extraFetchParams) {
				fetchParams = assign(fetchParams, extraFetchParams);
			}

			let localVarPathWithQueryParameters = localVarPath + (localVarPath.indexOf('?') !== -1 ? '&' : '?') + querystring.stringify(queryParameters);

			return fetch(localVarPathWithQueryParameters, fetchParams).then((response) => {
				if (response.status >= 200 && response.status < 300) {
					return response.json();
				} else {
					let error = new Error(response.statusText);
					(error as any).response = response;
					throw error;
				}
			});
		}
		/**
		 *
		 * Update Menu Entry
		 * @param id
		 * @param operations
		 */
		public systemMenuentriesIdPatch (params: {  id: number; operations: Array<PatchOperation>; }, extraQueryParams?: any, extraFetchParams?: any ) : Promise<MenuEntry> {
			const localVarPath = this.basePath + '/system/menuentries/{id}'
				.replace('{' + 'id' + '}', String(params.id));

			let queryParameters: any = assign({}, extraQueryParams);
			let headerParams: any = assign({}, this.defaultHeaders);
			headerParams['Content-Type'] = 'application/json';

			// verify required parameter 'id' is set
			if (params.id == null) {
				throw new Error('Missing required parameter id when calling systemMenuentriesIdPatch');
			}
			// verify required parameter 'operations' is set
			if (params.operations == null) {
				throw new Error('Missing required parameter operations when calling systemMenuentriesIdPatch');
			}
			let fetchParams = {
				method: 'PATCH',
				headers: headerParams,
				body: JSON.stringify(params.operations),

			};

			if (extraFetchParams) {
				fetchParams = assign(fetchParams, extraFetchParams);
			}

			let localVarPathWithQueryParameters = localVarPath + (localVarPath.indexOf('?') !== -1 ? '&' : '?') + querystring.stringify(queryParameters);

			return fetch(localVarPathWithQueryParameters, fetchParams).then((response) => {
				if (response.status >= 200 && response.status < 300) {
					return response.json();
				} else {
					let error = new Error(response.statusText);
					(error as any).response = response;
					throw error;
				}
			});
		}
		/**
		 *
		 * Replace Menu Entry
		 * @param id
		 * @param menuEntry
		 */
		public systemMenuentriesIdPut (params: {  id: number; menuEntry: MenuEntry; }, extraQueryParams?: any, extraFetchParams?: any ) : Promise<MenuEntry> {
			const localVarPath = this.basePath + '/system/menuentries/{id}'
				.replace('{' + 'id' + '}', String(params.id));

			let queryParameters: any = assign({}, extraQueryParams);
			let headerParams: any = assign({}, this.defaultHeaders);
			headerParams['Content-Type'] = 'application/json';

			// verify required parameter 'id' is set
			if (params.id == null) {
				throw new Error('Missing required parameter id when calling systemMenuentriesIdPut');
			}
			// verify required parameter 'menuEntry' is set
			if (params.menuEntry == null) {
				throw new Error('Missing required parameter menuEntry when calling systemMenuentriesIdPut');
			}
			let fetchParams = {
				method: 'PUT',
				headers: headerParams,
				body: JSON.stringify(params.menuEntry),

			};

			if (extraFetchParams) {
				fetchParams = assign(fetchParams, extraFetchParams);
			}

			let localVarPathWithQueryParameters = localVarPath + (localVarPath.indexOf('?') !== -1 ? '&' : '?') + querystring.stringify(queryParameters);

			return fetch(localVarPathWithQueryParameters, fetchParams).then((response) => {
				if (response.status >= 200 && response.status < 300) {
					return response.json();
				} else {
					let error = new Error(response.statusText);
					(error as any).response = response;
					throw error;
				}
			});
		}
		/**
		 *
		 * Create Menu Entry
		 * @param menuEntry
		 */
		public systemMenuentriesPost (params: {  menuEntry: MenuEntry; }, extraQueryParams?: any, extraFetchParams?: any ) : Promise<MenuEntry> {
			const localVarPath = this.basePath + '/system/menuentries';

			let queryParameters: any = assign({}, extraQueryParams);
			let headerParams: any = assign({}, this.defaultHeaders);
			headerParams['Content-Type'] = 'application/json';

			// verify required parameter 'menuEntry' is set
			if (params.menuEntry == null) {
				throw new Error('Missing required parameter menuEntry when calling systemMenuentriesPost');
			}
			let fetchParams = {
				method: 'POST',
				headers: headerParams,
				body: JSON.stringify(params.menuEntry),

			};

			if (extraFetchParams) {
				fetchParams = assign(fetchParams, extraFetchParams);
			}

			let localVarPathWithQueryParameters = localVarPath + (localVarPath.indexOf('?') !== -1 ? '&' : '?') + querystring.stringify(queryParameters);

			return fetch(localVarPathWithQueryParameters, fetchParams).then((response) => {
				if (response.status >= 200 && response.status < 300) {
					return response.json();
				} else {
					let error = new Error(response.statusText);
					(error as any).response = response;
					throw error;
				}
			});
		}
	}
//}
//export namespace  {
	'use strict';

	export class OpportunitiesApi {
		protected basePath = 'https://api-na.myconnectwise.net/v4_6_release/apis/3.0';
		public defaultHeaders : any = {};

		constructor(basePath?: string) {
			if (basePath) {
				this.basePath = basePath;
			}
		}

		/**
		 *
		 * Get Opportunities Count
		 * @param conditions
		 * @param customFieldConditions
		 */
		public salesOpportunitiesCountGet (params: {  conditions?: string; customFieldConditions?: string; }, extraQueryParams?: any, extraFetchParams?: any ) : Promise<Count> {
			const localVarPath = this.basePath + '/sales/opportunities/count';

			let queryParameters: any = assign({}, extraQueryParams);
			let headerParams: any = assign({}, this.defaultHeaders);
			if (params.conditions !== undefined) {
				queryParameters['conditions'] = params.conditions;
			}

			if (params.customFieldConditions !== undefined) {
				queryParameters['customFieldConditions'] = params.customFieldConditions;
			}

			let fetchParams = {
				method: 'GET',
				headers: headerParams,

			};

			if (extraFetchParams) {
				fetchParams = assign(fetchParams, extraFetchParams);
			}

			let localVarPathWithQueryParameters = localVarPath + (localVarPath.indexOf('?') !== -1 ? '&' : '?') + querystring.stringify(queryParameters);

			return fetch(localVarPathWithQueryParameters, fetchParams).then((response) => {
				if (response.status >= 200 && response.status < 300) {
					return response.json();
				} else {
					let error = new Error(response.statusText);
					(error as any).response = response;
					throw error;
				}
			});
		}
		/**
		 *
		 * Get Opportunities
		 * @param conditions
		 * @param orderBy
		 * @param childconditions
		 * @param customfieldconditions
		 * @param page
		 * @param pageSize
		 */
		public salesOpportunitiesGet (params: {  conditions?: string; orderBy?: string; childconditions?: string; customfieldconditions?: string; page?: number; pageSize?: number; }, extraQueryParams?: any, extraFetchParams?: any ) : Promise<Array<Opportunity>> {
			const localVarPath = this.basePath + '/sales/opportunities';

			let queryParameters: any = assign({}, extraQueryParams);
			let headerParams: any = assign({}, this.defaultHeaders);
			if (params.conditions !== undefined) {
				queryParameters['conditions'] = params.conditions;
			}

			if (params.orderBy !== undefined) {
				queryParameters['orderBy'] = params.orderBy;
			}

			if (params.childconditions !== undefined) {
				queryParameters['childconditions'] = params.childconditions;
			}

			if (params.customfieldconditions !== undefined) {
				queryParameters['customfieldconditions'] = params.customfieldconditions;
			}

			if (params.page !== undefined) {
				queryParameters['page'] = params.page;
			}

			if (params.pageSize !== undefined) {
				queryParameters['pageSize'] = params.pageSize;
			}

			let fetchParams = {
				method: 'GET',
				headers: headerParams,

			};

			if (extraFetchParams) {
				fetchParams = assign(fetchParams, extraFetchParams);
			}

			let localVarPathWithQueryParameters = localVarPath + (localVarPath.indexOf('?') !== -1 ? '&' : '?') + querystring.stringify(queryParameters);

			return fetch(localVarPathWithQueryParameters, fetchParams).then((response) => {
				if (response.status >= 200 && response.status < 300) {
					return response.json();
				} else {
					let error = new Error(response.statusText);
					(error as any).response = response;
					throw error;
				}
			});
		}
		/**
		 *
		 * Convert Opportunity To Agreement
		 * @param id
		 * @param conversion
		 */
		public salesOpportunitiesIdConvertToAgreementPost (params: {  id: number; conversion: OpportunityToAgreementConversion; }, extraQueryParams?: any, extraFetchParams?: any ) : Promise<Agreement> {
			const localVarPath = this.basePath + '/sales/opportunities/{id}/convertToAgreement'
				.replace('{' + 'id' + '}', String(params.id));

			let queryParameters: any = assign({}, extraQueryParams);
			let headerParams: any = assign({}, this.defaultHeaders);
			headerParams['Content-Type'] = 'application/json';

			// verify required parameter 'id' is set
			if (params.id == null) {
				throw new Error('Missing required parameter id when calling salesOpportunitiesIdConvertToAgreementPost');
			}
			// verify required parameter 'conversion' is set
			if (params.conversion == null) {
				throw new Error('Missing required parameter conversion when calling salesOpportunitiesIdConvertToAgreementPost');
			}
			let fetchParams = {
				method: 'POST',
				headers: headerParams,
				body: JSON.stringify(params.conversion),

			};

			if (extraFetchParams) {
				fetchParams = assign(fetchParams, extraFetchParams);
			}

			let localVarPathWithQueryParameters = localVarPath + (localVarPath.indexOf('?') !== -1 ? '&' : '?') + querystring.stringify(queryParameters);

			return fetch(localVarPathWithQueryParameters, fetchParams).then((response) => {
				if (response.status >= 200 && response.status < 300) {
					return response.json();
				} else {
					let error = new Error(response.statusText);
					(error as any).response = response;
					throw error;
				}
			});
		}
		/**
		 *
		 * Convert Opportunity To Project
		 * @param id
		 * @param conversion
		 */
		public salesOpportunitiesIdConvertToProjectPost (params: {  id: number; conversion: OpportunityToProjectConversion; }, extraQueryParams?: any, extraFetchParams?: any ) : Promise<Project> {
			const localVarPath = this.basePath + '/sales/opportunities/{id}/convertToProject'
				.replace('{' + 'id' + '}', String(params.id));

			let queryParameters: any = assign({}, extraQueryParams);
			let headerParams: any = assign({}, this.defaultHeaders);
			headerParams['Content-Type'] = 'application/json';

			// verify required parameter 'id' is set
			if (params.id == null) {
				throw new Error('Missing required parameter id when calling salesOpportunitiesIdConvertToProjectPost');
			}
			// verify required parameter 'conversion' is set
			if (params.conversion == null) {
				throw new Error('Missing required parameter conversion when calling salesOpportunitiesIdConvertToProjectPost');
			}
			let fetchParams = {
				method: 'POST',
				headers: headerParams,
				body: JSON.stringify(params.conversion),

			};

			if (extraFetchParams) {
				fetchParams = assign(fetchParams, extraFetchParams);
			}

			let localVarPathWithQueryParameters = localVarPath + (localVarPath.indexOf('?') !== -1 ? '&' : '?') + querystring.stringify(queryParameters);

			return fetch(localVarPathWithQueryParameters, fetchParams).then((response) => {
				if (response.status >= 200 && response.status < 300) {
					return response.json();
				} else {
					let error = new Error(response.statusText);
					(error as any).response = response;
					throw error;
				}
			});
		}
		/**
		 *
		 * Convert Opportunity To Sales Order
		 * @param id
		 * @param conversion
		 */
		public salesOpportunitiesIdConvertToSalesOrderPost (params: {  id: number; conversion: OpportunityToSalesOrderConversion; }, extraQueryParams?: any, extraFetchParams?: any ) : Promise<Order> {
			const localVarPath = this.basePath + '/sales/opportunities/{id}/convertToSalesOrder'
				.replace('{' + 'id' + '}', String(params.id));

			let queryParameters: any = assign({}, extraQueryParams);
			let headerParams: any = assign({}, this.defaultHeaders);
			headerParams['Content-Type'] = 'application/json';

			// verify required parameter 'id' is set
			if (params.id == null) {
				throw new Error('Missing required parameter id when calling salesOpportunitiesIdConvertToSalesOrderPost');
			}
			// verify required parameter 'conversion' is set
			if (params.conversion == null) {
				throw new Error('Missing required parameter conversion when calling salesOpportunitiesIdConvertToSalesOrderPost');
			}
			let fetchParams = {
				method: 'POST',
				headers: headerParams,
				body: JSON.stringify(params.conversion),

			};

			if (extraFetchParams) {
				fetchParams = assign(fetchParams, extraFetchParams);
			}

			let localVarPathWithQueryParameters = localVarPath + (localVarPath.indexOf('?') !== -1 ? '&' : '?') + querystring.stringify(queryParameters);

			return fetch(localVarPathWithQueryParameters, fetchParams).then((response) => {
				if (response.status >= 200 && response.status < 300) {
					return response.json();
				} else {
					let error = new Error(response.statusText);
					(error as any).response = response;
					throw error;
				}
			});
		}
		/**
		 *
		 * Convert Opportunity To Service Ticket
		 * @param id
		 * @param conversion
		 */
		public salesOpportunitiesIdConvertToServiceTicketPost (params: {  id: number; conversion: OpportunityToServiceTicketConversion; }, extraQueryParams?: any, extraFetchParams?: any ) : Promise<Ticket> {
			const localVarPath = this.basePath + '/sales/opportunities/{id}/convertToServiceTicket'
				.replace('{' + 'id' + '}', String(params.id));

			let queryParameters: any = assign({}, extraQueryParams);
			let headerParams: any = assign({}, this.defaultHeaders);
			headerParams['Content-Type'] = 'application/json';

			// verify required parameter 'id' is set
			if (params.id == null) {
				throw new Error('Missing required parameter id when calling salesOpportunitiesIdConvertToServiceTicketPost');
			}
			// verify required parameter 'conversion' is set
			if (params.conversion == null) {
				throw new Error('Missing required parameter conversion when calling salesOpportunitiesIdConvertToServiceTicketPost');
			}
			let fetchParams = {
				method: 'POST',
				headers: headerParams,
				body: JSON.stringify(params.conversion),

			};

			if (extraFetchParams) {
				fetchParams = assign(fetchParams, extraFetchParams);
			}

			let localVarPathWithQueryParameters = localVarPath + (localVarPath.indexOf('?') !== -1 ? '&' : '?') + querystring.stringify(queryParameters);

			return fetch(localVarPathWithQueryParameters, fetchParams).then((response) => {
				if (response.status >= 200 && response.status < 300) {
					return response.json();
				} else {
					let error = new Error(response.statusText);
					(error as any).response = response;
					throw error;
				}
			});
		}
		/**
		 *
		 * Delete Opportunity By Id
		 * @param id
		 */
		public salesOpportunitiesIdDelete (params: {  id: number; }, extraQueryParams?: any, extraFetchParams?: any ) : Promise<{}> {
			const localVarPath = this.basePath + '/sales/opportunities/{id}'
				.replace('{' + 'id' + '}', String(params.id));

			let queryParameters: any = assign({}, extraQueryParams);
			let headerParams: any = assign({}, this.defaultHeaders);
			// verify required parameter 'id' is set
			if (params.id == null) {
				throw new Error('Missing required parameter id when calling salesOpportunitiesIdDelete');
			}
			let fetchParams = {
				method: 'DELETE',
				headers: headerParams,

			};

			if (extraFetchParams) {
				fetchParams = assign(fetchParams, extraFetchParams);
			}

			let localVarPathWithQueryParameters = localVarPath + (localVarPath.indexOf('?') !== -1 ? '&' : '?') + querystring.stringify(queryParameters);

			return fetch(localVarPathWithQueryParameters, fetchParams).then((response) => {
				if (response.status >= 200 && response.status < 300) {
					return response.json();
				} else {
					let error = new Error(response.statusText);
					(error as any).response = response;
					throw error;
				}
			});
		}
		/**
		 *
		 * Get Opportunity By Id
		 * @param id
		 */
		public salesOpportunitiesIdGet (params: {  id: number; }, extraQueryParams?: any, extraFetchParams?: any ) : Promise<Opportunity> {
			const localVarPath = this.basePath + '/sales/opportunities/{id}'
				.replace('{' + 'id' + '}', String(params.id));

			let queryParameters: any = assign({}, extraQueryParams);
			let headerParams: any = assign({}, this.defaultHeaders);
			// verify required parameter 'id' is set
			if (params.id == null) {
				throw new Error('Missing required parameter id when calling salesOpportunitiesIdGet');
			}
			let fetchParams = {
				method: 'GET',
				headers: headerParams,

			};

			if (extraFetchParams) {
				fetchParams = assign(fetchParams, extraFetchParams);
			}

			let localVarPathWithQueryParameters = localVarPath + (localVarPath.indexOf('?') !== -1 ? '&' : '?') + querystring.stringify(queryParameters);

			return fetch(localVarPathWithQueryParameters, fetchParams).then((response) => {
				if (response.status >= 200 && response.status < 300) {
					return response.json();
				} else {
					let error = new Error(response.statusText);
					(error as any).response = response;
					throw error;
				}
			});
		}
		/**
		 *
		 * Update Opportunity
		 * @param id
		 * @param operations
		 */
		public salesOpportunitiesIdPatch (params: {  id: number; operations: Array<PatchOperation>; }, extraQueryParams?: any, extraFetchParams?: any ) : Promise<Opportunity> {
			const localVarPath = this.basePath + '/sales/opportunities/{id}'
				.replace('{' + 'id' + '}', String(params.id));

			let queryParameters: any = assign({}, extraQueryParams);
			let headerParams: any = assign({}, this.defaultHeaders);
			headerParams['Content-Type'] = 'application/json';

			// verify required parameter 'id' is set
			if (params.id == null) {
				throw new Error('Missing required parameter id when calling salesOpportunitiesIdPatch');
			}
			// verify required parameter 'operations' is set
			if (params.operations == null) {
				throw new Error('Missing required parameter operations when calling salesOpportunitiesIdPatch');
			}
			let fetchParams = {
				method: 'PATCH',
				headers: headerParams,
				body: JSON.stringify(params.operations),

			};

			if (extraFetchParams) {
				fetchParams = assign(fetchParams, extraFetchParams);
			}

			let localVarPathWithQueryParameters = localVarPath + (localVarPath.indexOf('?') !== -1 ? '&' : '?') + querystring.stringify(queryParameters);

			return fetch(localVarPathWithQueryParameters, fetchParams).then((response) => {
				if (response.status >= 200 && response.status < 300) {
					return response.json();
				} else {
					let error = new Error(response.statusText);
					(error as any).response = response;
					throw error;
				}
			});
		}
		/**
		 *
		 * Replace Opportunity
		 * @param id
		 * @param opportunity
		 */
		public salesOpportunitiesIdPut (params: {  id: number; opportunity: Opportunity; }, extraQueryParams?: any, extraFetchParams?: any ) : Promise<Opportunity> {
			const localVarPath = this.basePath + '/sales/opportunities/{id}'
				.replace('{' + 'id' + '}', String(params.id));

			let queryParameters: any = assign({}, extraQueryParams);
			let headerParams: any = assign({}, this.defaultHeaders);
			headerParams['Content-Type'] = 'application/json';

			// verify required parameter 'id' is set
			if (params.id == null) {
				throw new Error('Missing required parameter id when calling salesOpportunitiesIdPut');
			}
			// verify required parameter 'opportunity' is set
			if (params.opportunity == null) {
				throw new Error('Missing required parameter opportunity when calling salesOpportunitiesIdPut');
			}
			let fetchParams = {
				method: 'PUT',
				headers: headerParams,
				body: JSON.stringify(params.opportunity),

			};

			if (extraFetchParams) {
				fetchParams = assign(fetchParams, extraFetchParams);
			}

			let localVarPathWithQueryParameters = localVarPath + (localVarPath.indexOf('?') !== -1 ? '&' : '?') + querystring.stringify(queryParameters);

			return fetch(localVarPathWithQueryParameters, fetchParams).then((response) => {
				if (response.status >= 200 && response.status < 300) {
					return response.json();
				} else {
					let error = new Error(response.statusText);
					(error as any).response = response;
					throw error;
				}
			});
		}
		/**
		 *
		 * Create Opportunity
		 * @param opportunity
		 */
		public salesOpportunitiesPost (params: {  opportunity: Opportunity; }, extraQueryParams?: any, extraFetchParams?: any ) : Promise<Opportunity> {
			const localVarPath = this.basePath + '/sales/opportunities';

			let queryParameters: any = assign({}, extraQueryParams);
			let headerParams: any = assign({}, this.defaultHeaders);
			headerParams['Content-Type'] = 'application/json';

			// verify required parameter 'opportunity' is set
			if (params.opportunity == null) {
				throw new Error('Missing required parameter opportunity when calling salesOpportunitiesPost');
			}
			let fetchParams = {
				method: 'POST',
				headers: headerParams,
				body: JSON.stringify(params.opportunity),

			};

			if (extraFetchParams) {
				fetchParams = assign(fetchParams, extraFetchParams);
			}

			let localVarPathWithQueryParameters = localVarPath + (localVarPath.indexOf('?') !== -1 ? '&' : '?') + querystring.stringify(queryParameters);

			return fetch(localVarPathWithQueryParameters, fetchParams).then((response) => {
				if (response.status >= 200 && response.status < 300) {
					return response.json();
				} else {
					let error = new Error(response.statusText);
					(error as any).response = response;
					throw error;
				}
			});
		}
	}
//}
//export namespace  {
	'use strict';

	export class OpportunityContactsApi {
		protected basePath = 'https://api-na.myconnectwise.net/v4_6_release/apis/3.0';
		public defaultHeaders : any = {};

		constructor(basePath?: string) {
			if (basePath) {
				this.basePath = basePath;
			}
		}

		/**
		 *
		 * Delete Opportunity Contact By Id
		 * @param id
		 * @param contactId
		 */
		public salesOpportunitiesIdContactsContactIdDelete (params: {  id: number; contactId: number; }, extraQueryParams?: any, extraFetchParams?: any ) : Promise<{}> {
			const localVarPath = this.basePath + '/sales/opportunities/{id}/contacts/{contactId}'
				.replace('{' + 'id' + '}', String(params.id))
				.replace('{' + 'contactId' + '}', String(params.contactId));

			let queryParameters: any = assign({}, extraQueryParams);
			let headerParams: any = assign({}, this.defaultHeaders);
			// verify required parameter 'id' is set
			if (params.id == null) {
				throw new Error('Missing required parameter id when calling salesOpportunitiesIdContactsContactIdDelete');
			}
			// verify required parameter 'contactId' is set
			if (params.contactId == null) {
				throw new Error('Missing required parameter contactId when calling salesOpportunitiesIdContactsContactIdDelete');
			}
			let fetchParams = {
				method: 'DELETE',
				headers: headerParams,

			};

			if (extraFetchParams) {
				fetchParams = assign(fetchParams, extraFetchParams);
			}

			let localVarPathWithQueryParameters = localVarPath + (localVarPath.indexOf('?') !== -1 ? '&' : '?') + querystring.stringify(queryParameters);

			return fetch(localVarPathWithQueryParameters, fetchParams).then((response) => {
				if (response.status >= 200 && response.status < 300) {
					return response.json();
				} else {
					let error = new Error(response.statusText);
					(error as any).response = response;
					throw error;
				}
			});
		}
		/**
		 *
		 * Get Opportunity Contact By Id
		 * @param id
		 * @param contactId
		 */
		public salesOpportunitiesIdContactsContactIdGet (params: {  id: number; contactId: number; }, extraQueryParams?: any, extraFetchParams?: any ) : Promise<OpportunityContact> {
			const localVarPath = this.basePath + '/sales/opportunities/{id}/contacts/{contactId}'
				.replace('{' + 'id' + '}', String(params.id))
				.replace('{' + 'contactId' + '}', String(params.contactId));

			let queryParameters: any = assign({}, extraQueryParams);
			let headerParams: any = assign({}, this.defaultHeaders);
			// verify required parameter 'id' is set
			if (params.id == null) {
				throw new Error('Missing required parameter id when calling salesOpportunitiesIdContactsContactIdGet');
			}
			// verify required parameter 'contactId' is set
			if (params.contactId == null) {
				throw new Error('Missing required parameter contactId when calling salesOpportunitiesIdContactsContactIdGet');
			}
			let fetchParams = {
				method: 'GET',
				headers: headerParams,

			};

			if (extraFetchParams) {
				fetchParams = assign(fetchParams, extraFetchParams);
			}

			let localVarPathWithQueryParameters = localVarPath + (localVarPath.indexOf('?') !== -1 ? '&' : '?') + querystring.stringify(queryParameters);

			return fetch(localVarPathWithQueryParameters, fetchParams).then((response) => {
				if (response.status >= 200 && response.status < 300) {
					return response.json();
				} else {
					let error = new Error(response.statusText);
					(error as any).response = response;
					throw error;
				}
			});
		}
		/**
		 *
		 * Update Opportunity Contact
		 * @param id
		 * @param contactId
		 * @param operations
		 */
		public salesOpportunitiesIdContactsContactIdPatch (params: {  id: number; contactId: number; operations: Array<PatchOperation>; }, extraQueryParams?: any, extraFetchParams?: any ) : Promise<OpportunityContact> {
			const localVarPath = this.basePath + '/sales/opportunities/{id}/contacts/{contactId}'
				.replace('{' + 'id' + '}', String(params.id))
				.replace('{' + 'contactId' + '}', String(params.contactId));

			let queryParameters: any = assign({}, extraQueryParams);
			let headerParams: any = assign({}, this.defaultHeaders);
			headerParams['Content-Type'] = 'application/json';

			// verify required parameter 'id' is set
			if (params.id == null) {
				throw new Error('Missing required parameter id when calling salesOpportunitiesIdContactsContactIdPatch');
			}
			// verify required parameter 'contactId' is set
			if (params.contactId == null) {
				throw new Error('Missing required parameter contactId when calling salesOpportunitiesIdContactsContactIdPatch');
			}
			// verify required parameter 'operations' is set
			if (params.operations == null) {
				throw new Error('Missing required parameter operations when calling salesOpportunitiesIdContactsContactIdPatch');
			}
			let fetchParams = {
				method: 'PATCH',
				headers: headerParams,
				body: JSON.stringify(params.operations),

			};

			if (extraFetchParams) {
				fetchParams = assign(fetchParams, extraFetchParams);
			}

			let localVarPathWithQueryParameters = localVarPath + (localVarPath.indexOf('?') !== -1 ? '&' : '?') + querystring.stringify(queryParameters);

			return fetch(localVarPathWithQueryParameters, fetchParams).then((response) => {
				if (response.status >= 200 && response.status < 300) {
					return response.json();
				} else {
					let error = new Error(response.statusText);
					(error as any).response = response;
					throw error;
				}
			});
		}
		/**
		 *
		 * Replace Opportunity Contact
		 * @param id
		 * @param contactId
		 * @param opportunityContact
		 */
		public salesOpportunitiesIdContactsContactIdPut (params: {  id: number; contactId: number; opportunityContact: OpportunityContact; }, extraQueryParams?: any, extraFetchParams?: any ) : Promise<OpportunityContact> {
			const localVarPath = this.basePath + '/sales/opportunities/{id}/contacts/{contactId}'
				.replace('{' + 'id' + '}', String(params.id))
				.replace('{' + 'contactId' + '}', String(params.contactId));

			let queryParameters: any = assign({}, extraQueryParams);
			let headerParams: any = assign({}, this.defaultHeaders);
			headerParams['Content-Type'] = 'application/json';

			// verify required parameter 'id' is set
			if (params.id == null) {
				throw new Error('Missing required parameter id when calling salesOpportunitiesIdContactsContactIdPut');
			}
			// verify required parameter 'contactId' is set
			if (params.contactId == null) {
				throw new Error('Missing required parameter contactId when calling salesOpportunitiesIdContactsContactIdPut');
			}
			// verify required parameter 'opportunityContact' is set
			if (params.opportunityContact == null) {
				throw new Error('Missing required parameter opportunityContact when calling salesOpportunitiesIdContactsContactIdPut');
			}
			let fetchParams = {
				method: 'PUT',
				headers: headerParams,
				body: JSON.stringify(params.opportunityContact),

			};

			if (extraFetchParams) {
				fetchParams = assign(fetchParams, extraFetchParams);
			}

			let localVarPathWithQueryParameters = localVarPath + (localVarPath.indexOf('?') !== -1 ? '&' : '?') + querystring.stringify(queryParameters);

			return fetch(localVarPathWithQueryParameters, fetchParams).then((response) => {
				if (response.status >= 200 && response.status < 300) {
					return response.json();
				} else {
					let error = new Error(response.statusText);
					(error as any).response = response;
					throw error;
				}
			});
		}
		/**
		 *
		 * Get Opportunity Contacts Count
		 * @param id
		 * @param conditions
		 */
		public salesOpportunitiesIdContactsCountGet (params: {  id: number; conditions?: string; }, extraQueryParams?: any, extraFetchParams?: any ) : Promise<Count> {
			const localVarPath = this.basePath + '/sales/opportunities/{id}/contacts/count'
				.replace('{' + 'id' + '}', String(params.id));

			let queryParameters: any = assign({}, extraQueryParams);
			let headerParams: any = assign({}, this.defaultHeaders);
			// verify required parameter 'id' is set
			if (params.id == null) {
				throw new Error('Missing required parameter id when calling salesOpportunitiesIdContactsCountGet');
			}
			if (params.conditions !== undefined) {
				queryParameters['conditions'] = params.conditions;
			}

			let fetchParams = {
				method: 'GET',
				headers: headerParams,

			};

			if (extraFetchParams) {
				fetchParams = assign(fetchParams, extraFetchParams);
			}

			let localVarPathWithQueryParameters = localVarPath + (localVarPath.indexOf('?') !== -1 ? '&' : '?') + querystring.stringify(queryParameters);

			return fetch(localVarPathWithQueryParameters, fetchParams).then((response) => {
				if (response.status >= 200 && response.status < 300) {
					return response.json();
				} else {
					let error = new Error(response.statusText);
					(error as any).response = response;
					throw error;
				}
			});
		}
		/**
		 *
		 * Get Opportunity Contacts
		 * @param id
		 * @param conditions
		 * @param orderBy
		 * @param childconditions
		 * @param customfieldconditions
		 * @param page
		 * @param pageSize
		 */
		public salesOpportunitiesIdContactsGet (params: {  id: number; conditions?: string; orderBy?: string; childconditions?: string; customfieldconditions?: string; page?: number; pageSize?: number; }, extraQueryParams?: any, extraFetchParams?: any ) : Promise<Array<OpportunityContact>> {
			const localVarPath = this.basePath + '/sales/opportunities/{id}/contacts'
				.replace('{' + 'id' + '}', String(params.id));

			let queryParameters: any = assign({}, extraQueryParams);
			let headerParams: any = assign({}, this.defaultHeaders);
			// verify required parameter 'id' is set
			if (params.id == null) {
				throw new Error('Missing required parameter id when calling salesOpportunitiesIdContactsGet');
			}
			if (params.conditions !== undefined) {
				queryParameters['conditions'] = params.conditions;
			}

			if (params.orderBy !== undefined) {
				queryParameters['orderBy'] = params.orderBy;
			}

			if (params.childconditions !== undefined) {
				queryParameters['childconditions'] = params.childconditions;
			}

			if (params.customfieldconditions !== undefined) {
				queryParameters['customfieldconditions'] = params.customfieldconditions;
			}

			if (params.page !== undefined) {
				queryParameters['page'] = params.page;
			}

			if (params.pageSize !== undefined) {
				queryParameters['pageSize'] = params.pageSize;
			}

			let fetchParams = {
				method: 'GET',
				headers: headerParams,

			};

			if (extraFetchParams) {
				fetchParams = assign(fetchParams, extraFetchParams);
			}

			let localVarPathWithQueryParameters = localVarPath + (localVarPath.indexOf('?') !== -1 ? '&' : '?') + querystring.stringify(queryParameters);

			return fetch(localVarPathWithQueryParameters, fetchParams).then((response) => {
				if (response.status >= 200 && response.status < 300) {
					return response.json();
				} else {
					let error = new Error(response.statusText);
					(error as any).response = response;
					throw error;
				}
			});
		}
		/**
		 *
		 * Create Opportunity Contact
		 * @param id
		 * @param opportunityContact
		 */
		public salesOpportunitiesIdContactsPost (params: {  id: number; opportunityContact: OpportunityContact; }, extraQueryParams?: any, extraFetchParams?: any ) : Promise<OpportunityContact> {
			const localVarPath = this.basePath + '/sales/opportunities/{id}/contacts'
				.replace('{' + 'id' + '}', String(params.id));

			let queryParameters: any = assign({}, extraQueryParams);
			let headerParams: any = assign({}, this.defaultHeaders);
			headerParams['Content-Type'] = 'application/json';

			// verify required parameter 'id' is set
			if (params.id == null) {
				throw new Error('Missing required parameter id when calling salesOpportunitiesIdContactsPost');
			}
			// verify required parameter 'opportunityContact' is set
			if (params.opportunityContact == null) {
				throw new Error('Missing required parameter opportunityContact when calling salesOpportunitiesIdContactsPost');
			}
			let fetchParams = {
				method: 'POST',
				headers: headerParams,
				body: JSON.stringify(params.opportunityContact),

			};

			if (extraFetchParams) {
				fetchParams = assign(fetchParams, extraFetchParams);
			}

			let localVarPathWithQueryParameters = localVarPath + (localVarPath.indexOf('?') !== -1 ? '&' : '?') + querystring.stringify(queryParameters);

			return fetch(localVarPathWithQueryParameters, fetchParams).then((response) => {
				if (response.status >= 200 && response.status < 300) {
					return response.json();
				} else {
					let error = new Error(response.statusText);
					(error as any).response = response;
					throw error;
				}
			});
		}
	}
//}
//export namespace  {
	'use strict';

	export class OpportunityForecastsApi {
		protected basePath = 'https://api-na.myconnectwise.net/v4_6_release/apis/3.0';
		public defaultHeaders : any = {};

		constructor(basePath?: string) {
			if (basePath) {
				this.basePath = basePath;
			}
		}

		/**
		 *
		 * Get Forecasts Count
		 * @param id
		 * @param conditions
		 */
		public salesOpportunitiesIdForecastCountGet (params: {  id: number; conditions?: string; }, extraQueryParams?: any, extraFetchParams?: any ) : Promise<Count> {
			const localVarPath = this.basePath + '/sales/opportunities/{id}/forecast/count'
				.replace('{' + 'id' + '}', String(params.id));

			let queryParameters: any = assign({}, extraQueryParams);
			let headerParams: any = assign({}, this.defaultHeaders);
			// verify required parameter 'id' is set
			if (params.id == null) {
				throw new Error('Missing required parameter id when calling salesOpportunitiesIdForecastCountGet');
			}
			if (params.conditions !== undefined) {
				queryParameters['conditions'] = params.conditions;
			}

			let fetchParams = {
				method: 'GET',
				headers: headerParams,

			};

			if (extraFetchParams) {
				fetchParams = assign(fetchParams, extraFetchParams);
			}

			let localVarPathWithQueryParameters = localVarPath + (localVarPath.indexOf('?') !== -1 ? '&' : '?') + querystring.stringify(queryParameters);

			return fetch(localVarPathWithQueryParameters, fetchParams).then((response) => {
				if (response.status >= 200 && response.status < 300) {
					return response.json();
				} else {
					let error = new Error(response.statusText);
					(error as any).response = response;
					throw error;
				}
			});
		}
		/**
		 *
		 * Delete Forecast By Id
		 * @param id
		 * @param forecastId
		 */
		public salesOpportunitiesIdForecastForecastIdDelete (params: {  id: number; forecastId: number; }, extraQueryParams?: any, extraFetchParams?: any ) : Promise<{}> {
			const localVarPath = this.basePath + '/sales/opportunities/{id}/forecast/{forecastId}'
				.replace('{' + 'id' + '}', String(params.id))
				.replace('{' + 'forecastId' + '}', String(params.forecastId));

			let queryParameters: any = assign({}, extraQueryParams);
			let headerParams: any = assign({}, this.defaultHeaders);
			// verify required parameter 'id' is set
			if (params.id == null) {
				throw new Error('Missing required parameter id when calling salesOpportunitiesIdForecastForecastIdDelete');
			}
			// verify required parameter 'forecastId' is set
			if (params.forecastId == null) {
				throw new Error('Missing required parameter forecastId when calling salesOpportunitiesIdForecastForecastIdDelete');
			}
			let fetchParams = {
				method: 'DELETE',
				headers: headerParams,

			};

			if (extraFetchParams) {
				fetchParams = assign(fetchParams, extraFetchParams);
			}

			let localVarPathWithQueryParameters = localVarPath + (localVarPath.indexOf('?') !== -1 ? '&' : '?') + querystring.stringify(queryParameters);

			return fetch(localVarPathWithQueryParameters, fetchParams).then((response) => {
				if (response.status >= 200 && response.status < 300) {
					return response.json();
				} else {
					let error = new Error(response.statusText);
					(error as any).response = response;
					throw error;
				}
			});
		}
		/**
		 *
		 * Get Forecast By Id
		 * @param id
		 * @param forecastId
		 */
		public salesOpportunitiesIdForecastForecastIdGet (params: {  id: number; forecastId: number; }, extraQueryParams?: any, extraFetchParams?: any ) : Promise<Forecast> {
			const localVarPath = this.basePath + '/sales/opportunities/{id}/forecast/{forecastId}'
				.replace('{' + 'id' + '}', String(params.id))
				.replace('{' + 'forecastId' + '}', String(params.forecastId));

			let queryParameters: any = assign({}, extraQueryParams);
			let headerParams: any = assign({}, this.defaultHeaders);
			// verify required parameter 'id' is set
			if (params.id == null) {
				throw new Error('Missing required parameter id when calling salesOpportunitiesIdForecastForecastIdGet');
			}
			// verify required parameter 'forecastId' is set
			if (params.forecastId == null) {
				throw new Error('Missing required parameter forecastId when calling salesOpportunitiesIdForecastForecastIdGet');
			}
			let fetchParams = {
				method: 'GET',
				headers: headerParams,

			};

			if (extraFetchParams) {
				fetchParams = assign(fetchParams, extraFetchParams);
			}

			let localVarPathWithQueryParameters = localVarPath + (localVarPath.indexOf('?') !== -1 ? '&' : '?') + querystring.stringify(queryParameters);

			return fetch(localVarPathWithQueryParameters, fetchParams).then((response) => {
				if (response.status >= 200 && response.status < 300) {
					return response.json();
				} else {
					let error = new Error(response.statusText);
					(error as any).response = response;
					throw error;
				}
			});
		}
		/**
		 *
		 * Update Forecast
		 * @param id
		 * @param forecastId
		 * @param operations
		 */
		public salesOpportunitiesIdForecastForecastIdPatch (params: {  id: number; forecastId: number; operations: Array<PatchOperation>; }, extraQueryParams?: any, extraFetchParams?: any ) : Promise<Forecast> {
			const localVarPath = this.basePath + '/sales/opportunities/{id}/forecast/{forecastId}'
				.replace('{' + 'id' + '}', String(params.id))
				.replace('{' + 'forecastId' + '}', String(params.forecastId));

			let queryParameters: any = assign({}, extraQueryParams);
			let headerParams: any = assign({}, this.defaultHeaders);
			headerParams['Content-Type'] = 'application/json';

			// verify required parameter 'id' is set
			if (params.id == null) {
				throw new Error('Missing required parameter id when calling salesOpportunitiesIdForecastForecastIdPatch');
			}
			// verify required parameter 'forecastId' is set
			if (params.forecastId == null) {
				throw new Error('Missing required parameter forecastId when calling salesOpportunitiesIdForecastForecastIdPatch');
			}
			// verify required parameter 'operations' is set
			if (params.operations == null) {
				throw new Error('Missing required parameter operations when calling salesOpportunitiesIdForecastForecastIdPatch');
			}
			let fetchParams = {
				method: 'PATCH',
				headers: headerParams,
				body: JSON.stringify(params.operations),

			};

			if (extraFetchParams) {
				fetchParams = assign(fetchParams, extraFetchParams);
			}

			let localVarPathWithQueryParameters = localVarPath + (localVarPath.indexOf('?') !== -1 ? '&' : '?') + querystring.stringify(queryParameters);

			return fetch(localVarPathWithQueryParameters, fetchParams).then((response) => {
				if (response.status >= 200 && response.status < 300) {
					return response.json();
				} else {
					let error = new Error(response.statusText);
					(error as any).response = response;
					throw error;
				}
			});
		}
		/**
		 *
		 * Replace Forecast
		 * @param id
		 * @param forecastId
		 * @param forecast
		 */
		public salesOpportunitiesIdForecastForecastIdPut (params: {  id: number; forecastId: number; forecast: Forecast; }, extraQueryParams?: any, extraFetchParams?: any ) : Promise<Forecast> {
			const localVarPath = this.basePath + '/sales/opportunities/{id}/forecast/{forecastId}'
				.replace('{' + 'id' + '}', String(params.id))
				.replace('{' + 'forecastId' + '}', String(params.forecastId));

			let queryParameters: any = assign({}, extraQueryParams);
			let headerParams: any = assign({}, this.defaultHeaders);
			headerParams['Content-Type'] = 'application/json';

			// verify required parameter 'id' is set
			if (params.id == null) {
				throw new Error('Missing required parameter id when calling salesOpportunitiesIdForecastForecastIdPut');
			}
			// verify required parameter 'forecastId' is set
			if (params.forecastId == null) {
				throw new Error('Missing required parameter forecastId when calling salesOpportunitiesIdForecastForecastIdPut');
			}
			// verify required parameter 'forecast' is set
			if (params.forecast == null) {
				throw new Error('Missing required parameter forecast when calling salesOpportunitiesIdForecastForecastIdPut');
			}
			let fetchParams = {
				method: 'PUT',
				headers: headerParams,
				body: JSON.stringify(params.forecast),

			};

			if (extraFetchParams) {
				fetchParams = assign(fetchParams, extraFetchParams);
			}

			let localVarPathWithQueryParameters = localVarPath + (localVarPath.indexOf('?') !== -1 ? '&' : '?') + querystring.stringify(queryParameters);

			return fetch(localVarPathWithQueryParameters, fetchParams).then((response) => {
				if (response.status >= 200 && response.status < 300) {
					return response.json();
				} else {
					let error = new Error(response.statusText);
					(error as any).response = response;
					throw error;
				}
			});
		}
		/**
		 *
		 * Get Forecasts
		 * @param id
		 * @param conditions
		 * @param orderBy
		 * @param childconditions
		 * @param customfieldconditions
		 * @param page
		 * @param pageSize
		 */
		public salesOpportunitiesIdForecastGet (params: {  id: number; conditions?: string; orderBy?: string; childconditions?: string; customfieldconditions?: string; page?: number; pageSize?: number; }, extraQueryParams?: any, extraFetchParams?: any ) : Promise<Array<Forecast>> {
			const localVarPath = this.basePath + '/sales/opportunities/{id}/forecast'
				.replace('{' + 'id' + '}', String(params.id));

			let queryParameters: any = assign({}, extraQueryParams);
			let headerParams: any = assign({}, this.defaultHeaders);
			// verify required parameter 'id' is set
			if (params.id == null) {
				throw new Error('Missing required parameter id when calling salesOpportunitiesIdForecastGet');
			}
			if (params.conditions !== undefined) {
				queryParameters['conditions'] = params.conditions;
			}

			if (params.orderBy !== undefined) {
				queryParameters['orderBy'] = params.orderBy;
			}

			if (params.childconditions !== undefined) {
				queryParameters['childconditions'] = params.childconditions;
			}

			if (params.customfieldconditions !== undefined) {
				queryParameters['customfieldconditions'] = params.customfieldconditions;
			}

			if (params.page !== undefined) {
				queryParameters['page'] = params.page;
			}

			if (params.pageSize !== undefined) {
				queryParameters['pageSize'] = params.pageSize;
			}

			let fetchParams = {
				method: 'GET',
				headers: headerParams,

			};

			if (extraFetchParams) {
				fetchParams = assign(fetchParams, extraFetchParams);
			}

			let localVarPathWithQueryParameters = localVarPath + (localVarPath.indexOf('?') !== -1 ? '&' : '?') + querystring.stringify(queryParameters);

			return fetch(localVarPathWithQueryParameters, fetchParams).then((response) => {
				if (response.status >= 200 && response.status < 300) {
					return response.json();
				} else {
					let error = new Error(response.statusText);
					(error as any).response = response;
					throw error;
				}
			});
		}
		/**
		 *
		 * Create Forecast
		 * @param id
		 * @param forecast
		 */
		public salesOpportunitiesIdForecastPost (params: {  id: number; forecast: Forecast; }, extraQueryParams?: any, extraFetchParams?: any ) : Promise<Forecast> {
			const localVarPath = this.basePath + '/sales/opportunities/{id}/forecast'
				.replace('{' + 'id' + '}', String(params.id));

			let queryParameters: any = assign({}, extraQueryParams);
			let headerParams: any = assign({}, this.defaultHeaders);
			headerParams['Content-Type'] = 'application/json';

			// verify required parameter 'id' is set
			if (params.id == null) {
				throw new Error('Missing required parameter id when calling salesOpportunitiesIdForecastPost');
			}
			// verify required parameter 'forecast' is set
			if (params.forecast == null) {
				throw new Error('Missing required parameter forecast when calling salesOpportunitiesIdForecastPost');
			}
			let fetchParams = {
				method: 'POST',
				headers: headerParams,
				body: JSON.stringify(params.forecast),

			};

			if (extraFetchParams) {
				fetchParams = assign(fetchParams, extraFetchParams);
			}

			let localVarPathWithQueryParameters = localVarPath + (localVarPath.indexOf('?') !== -1 ? '&' : '?') + querystring.stringify(queryParameters);

			return fetch(localVarPathWithQueryParameters, fetchParams).then((response) => {
				if (response.status >= 200 && response.status < 300) {
					return response.json();
				} else {
					let error = new Error(response.statusText);
					(error as any).response = response;
					throw error;
				}
			});
		}
	}
//}
//export namespace  {
	'use strict';

	export class OpportunityNotesApi {
		protected basePath = 'https://api-na.myconnectwise.net/v4_6_release/apis/3.0';
		public defaultHeaders : any = {};

		constructor(basePath?: string) {
			if (basePath) {
				this.basePath = basePath;
			}
		}

		/**
		 *
		 * Get Opportunity Notes Count
		 * @param id
		 * @param conditions
		 */
		public salesOpportunitiesIdNotesCountGet (params: {  id: number; conditions?: string; }, extraQueryParams?: any, extraFetchParams?: any ) : Promise<Array<OpportunityNote>> {
			const localVarPath = this.basePath + '/sales/opportunities/{id}/notes/count'
				.replace('{' + 'id' + '}', String(params.id));

			let queryParameters: any = assign({}, extraQueryParams);
			let headerParams: any = assign({}, this.defaultHeaders);
			// verify required parameter 'id' is set
			if (params.id == null) {
				throw new Error('Missing required parameter id when calling salesOpportunitiesIdNotesCountGet');
			}
			if (params.conditions !== undefined) {
				queryParameters['conditions'] = params.conditions;
			}

			let fetchParams = {
				method: 'GET',
				headers: headerParams,

			};

			if (extraFetchParams) {
				fetchParams = assign(fetchParams, extraFetchParams);
			}

			let localVarPathWithQueryParameters = localVarPath + (localVarPath.indexOf('?') !== -1 ? '&' : '?') + querystring.stringify(queryParameters);

			return fetch(localVarPathWithQueryParameters, fetchParams).then((response) => {
				if (response.status >= 200 && response.status < 300) {
					return response.json();
				} else {
					let error = new Error(response.statusText);
					(error as any).response = response;
					throw error;
				}
			});
		}
		/**
		 *
		 * Get Opportunity Notes
		 * @param id
		 * @param conditions
		 * @param orderBy
		 * @param childconditions
		 * @param customfieldconditions
		 * @param page
		 * @param pageSize
		 */
		public salesOpportunitiesIdNotesGet (params: {  id: number; conditions?: string; orderBy?: string; childconditions?: string; customfieldconditions?: string; page?: number; pageSize?: number; }, extraQueryParams?: any, extraFetchParams?: any ) : Promise<Array<OpportunityNote>> {
			const localVarPath = this.basePath + '/sales/opportunities/{id}/notes'
				.replace('{' + 'id' + '}', String(params.id));

			let queryParameters: any = assign({}, extraQueryParams);
			let headerParams: any = assign({}, this.defaultHeaders);
			// verify required parameter 'id' is set
			if (params.id == null) {
				throw new Error('Missing required parameter id when calling salesOpportunitiesIdNotesGet');
			}
			if (params.conditions !== undefined) {
				queryParameters['conditions'] = params.conditions;
			}

			if (params.orderBy !== undefined) {
				queryParameters['orderBy'] = params.orderBy;
			}

			if (params.childconditions !== undefined) {
				queryParameters['childconditions'] = params.childconditions;
			}

			if (params.customfieldconditions !== undefined) {
				queryParameters['customfieldconditions'] = params.customfieldconditions;
			}

			if (params.page !== undefined) {
				queryParameters['page'] = params.page;
			}

			if (params.pageSize !== undefined) {
				queryParameters['pageSize'] = params.pageSize;
			}

			let fetchParams = {
				method: 'GET',
				headers: headerParams,

			};

			if (extraFetchParams) {
				fetchParams = assign(fetchParams, extraFetchParams);
			}

			let localVarPathWithQueryParameters = localVarPath + (localVarPath.indexOf('?') !== -1 ? '&' : '?') + querystring.stringify(queryParameters);

			return fetch(localVarPathWithQueryParameters, fetchParams).then((response) => {
				if (response.status >= 200 && response.status < 300) {
					return response.json();
				} else {
					let error = new Error(response.statusText);
					(error as any).response = response;
					throw error;
				}
			});
		}
		/**
		 *
		 * Delete Opportunity Note By Id
		 * @param id
		 * @param noteId
		 */
		public salesOpportunitiesIdNotesNoteIdDelete (params: {  id: number; noteId: number; }, extraQueryParams?: any, extraFetchParams?: any ) : Promise<{}> {
			const localVarPath = this.basePath + '/sales/opportunities/{id}/notes/{noteId}'
				.replace('{' + 'id' + '}', String(params.id))
				.replace('{' + 'noteId' + '}', String(params.noteId));

			let queryParameters: any = assign({}, extraQueryParams);
			let headerParams: any = assign({}, this.defaultHeaders);
			// verify required parameter 'id' is set
			if (params.id == null) {
				throw new Error('Missing required parameter id when calling salesOpportunitiesIdNotesNoteIdDelete');
			}
			// verify required parameter 'noteId' is set
			if (params.noteId == null) {
				throw new Error('Missing required parameter noteId when calling salesOpportunitiesIdNotesNoteIdDelete');
			}
			let fetchParams = {
				method: 'DELETE',
				headers: headerParams,

			};

			if (extraFetchParams) {
				fetchParams = assign(fetchParams, extraFetchParams);
			}

			let localVarPathWithQueryParameters = localVarPath + (localVarPath.indexOf('?') !== -1 ? '&' : '?') + querystring.stringify(queryParameters);

			return fetch(localVarPathWithQueryParameters, fetchParams).then((response) => {
				if (response.status >= 200 && response.status < 300) {
					return response.json();
				} else {
					let error = new Error(response.statusText);
					(error as any).response = response;
					throw error;
				}
			});
		}
		/**
		 *
		 * Get Opportunity Note By Id
		 * @param id
		 * @param noteId
		 */
		public salesOpportunitiesIdNotesNoteIdGet (params: {  id: number; noteId: number; }, extraQueryParams?: any, extraFetchParams?: any ) : Promise<OpportunityNote> {
			const localVarPath = this.basePath + '/sales/opportunities/{id}/notes/{noteId}'
				.replace('{' + 'id' + '}', String(params.id))
				.replace('{' + 'noteId' + '}', String(params.noteId));

			let queryParameters: any = assign({}, extraQueryParams);
			let headerParams: any = assign({}, this.defaultHeaders);
			// verify required parameter 'id' is set
			if (params.id == null) {
				throw new Error('Missing required parameter id when calling salesOpportunitiesIdNotesNoteIdGet');
			}
			// verify required parameter 'noteId' is set
			if (params.noteId == null) {
				throw new Error('Missing required parameter noteId when calling salesOpportunitiesIdNotesNoteIdGet');
			}
			let fetchParams = {
				method: 'GET',
				headers: headerParams,

			};

			if (extraFetchParams) {
				fetchParams = assign(fetchParams, extraFetchParams);
			}

			let localVarPathWithQueryParameters = localVarPath + (localVarPath.indexOf('?') !== -1 ? '&' : '?') + querystring.stringify(queryParameters);

			return fetch(localVarPathWithQueryParameters, fetchParams).then((response) => {
				if (response.status >= 200 && response.status < 300) {
					return response.json();
				} else {
					let error = new Error(response.statusText);
					(error as any).response = response;
					throw error;
				}
			});
		}
		/**
		 *
		 * Update Opportunity Note
		 * @param id
		 * @param noteId
		 * @param operations
		 */
		public salesOpportunitiesIdNotesNoteIdPatch (params: {  id: number; noteId: number; operations: Array<PatchOperation>; }, extraQueryParams?: any, extraFetchParams?: any ) : Promise<OpportunityNote> {
			const localVarPath = this.basePath + '/sales/opportunities/{id}/notes/{noteId}'
				.replace('{' + 'id' + '}', String(params.id))
				.replace('{' + 'noteId' + '}', String(params.noteId));

			let queryParameters: any = assign({}, extraQueryParams);
			let headerParams: any = assign({}, this.defaultHeaders);
			headerParams['Content-Type'] = 'application/json';

			// verify required parameter 'id' is set
			if (params.id == null) {
				throw new Error('Missing required parameter id when calling salesOpportunitiesIdNotesNoteIdPatch');
			}
			// verify required parameter 'noteId' is set
			if (params.noteId == null) {
				throw new Error('Missing required parameter noteId when calling salesOpportunitiesIdNotesNoteIdPatch');
			}
			// verify required parameter 'operations' is set
			if (params.operations == null) {
				throw new Error('Missing required parameter operations when calling salesOpportunitiesIdNotesNoteIdPatch');
			}
			let fetchParams = {
				method: 'PATCH',
				headers: headerParams,
				body: JSON.stringify(params.operations),

			};

			if (extraFetchParams) {
				fetchParams = assign(fetchParams, extraFetchParams);
			}

			let localVarPathWithQueryParameters = localVarPath + (localVarPath.indexOf('?') !== -1 ? '&' : '?') + querystring.stringify(queryParameters);

			return fetch(localVarPathWithQueryParameters, fetchParams).then((response) => {
				if (response.status >= 200 && response.status < 300) {
					return response.json();
				} else {
					let error = new Error(response.statusText);
					(error as any).response = response;
					throw error;
				}
			});
		}
		/**
		 *
		 * Replace Opportunity Note
		 * @param id
		 * @param noteId
		 * @param note
		 */
		public salesOpportunitiesIdNotesNoteIdPut (params: {  id: number; noteId: number; note: OpportunityNote; }, extraQueryParams?: any, extraFetchParams?: any ) : Promise<OpportunityNote> {
			const localVarPath = this.basePath + '/sales/opportunities/{id}/notes/{noteId}'
				.replace('{' + 'id' + '}', String(params.id))
				.replace('{' + 'noteId' + '}', String(params.noteId));

			let queryParameters: any = assign({}, extraQueryParams);
			let headerParams: any = assign({}, this.defaultHeaders);
			headerParams['Content-Type'] = 'application/json';

			// verify required parameter 'id' is set
			if (params.id == null) {
				throw new Error('Missing required parameter id when calling salesOpportunitiesIdNotesNoteIdPut');
			}
			// verify required parameter 'noteId' is set
			if (params.noteId == null) {
				throw new Error('Missing required parameter noteId when calling salesOpportunitiesIdNotesNoteIdPut');
			}
			// verify required parameter 'note' is set
			if (params.note == null) {
				throw new Error('Missing required parameter note when calling salesOpportunitiesIdNotesNoteIdPut');
			}
			let fetchParams = {
				method: 'PUT',
				headers: headerParams,
				body: JSON.stringify(params.note),

			};

			if (extraFetchParams) {
				fetchParams = assign(fetchParams, extraFetchParams);
			}

			let localVarPathWithQueryParameters = localVarPath + (localVarPath.indexOf('?') !== -1 ? '&' : '?') + querystring.stringify(queryParameters);

			return fetch(localVarPathWithQueryParameters, fetchParams).then((response) => {
				if (response.status >= 200 && response.status < 300) {
					return response.json();
				} else {
					let error = new Error(response.statusText);
					(error as any).response = response;
					throw error;
				}
			});
		}
		/**
		 *
		 * Create Opportunity Note
		 * @param id
		 * @param note
		 */
		public salesOpportunitiesIdNotesPost (params: {  id: number; note: OpportunityNote; }, extraQueryParams?: any, extraFetchParams?: any ) : Promise<OpportunityNote> {
			const localVarPath = this.basePath + '/sales/opportunities/{id}/notes'
				.replace('{' + 'id' + '}', String(params.id));

			let queryParameters: any = assign({}, extraQueryParams);
			let headerParams: any = assign({}, this.defaultHeaders);
			headerParams['Content-Type'] = 'application/json';

			// verify required parameter 'id' is set
			if (params.id == null) {
				throw new Error('Missing required parameter id when calling salesOpportunitiesIdNotesPost');
			}
			// verify required parameter 'note' is set
			if (params.note == null) {
				throw new Error('Missing required parameter note when calling salesOpportunitiesIdNotesPost');
			}
			let fetchParams = {
				method: 'POST',
				headers: headerParams,
				body: JSON.stringify(params.note),

			};

			if (extraFetchParams) {
				fetchParams = assign(fetchParams, extraFetchParams);
			}

			let localVarPathWithQueryParameters = localVarPath + (localVarPath.indexOf('?') !== -1 ? '&' : '?') + querystring.stringify(queryParameters);

			return fetch(localVarPathWithQueryParameters, fetchParams).then((response) => {
				if (response.status >= 200 && response.status < 300) {
					return response.json();
				} else {
					let error = new Error(response.statusText);
					(error as any).response = response;
					throw error;
				}
			});
		}
	}
//}
//export namespace  {
	'use strict';

	export class OpportunityRatingsApi {
		protected basePath = 'https://api-na.myconnectwise.net/v4_6_release/apis/3.0';
		public defaultHeaders : any = {};

		constructor(basePath?: string) {
			if (basePath) {
				this.basePath = basePath;
			}
		}

		/**
		 *
		 * Get Opportunity Ratings Count
		 * @param conditions
		 */
		public salesOpportunitiesRatingsCountGet (params: {  conditions?: string; }, extraQueryParams?: any, extraFetchParams?: any ) : Promise<Count> {
			const localVarPath = this.basePath + '/sales/opportunities/ratings/count';

			let queryParameters: any = assign({}, extraQueryParams);
			let headerParams: any = assign({}, this.defaultHeaders);
			if (params.conditions !== undefined) {
				queryParameters['conditions'] = params.conditions;
			}

			let fetchParams = {
				method: 'GET',
				headers: headerParams,

			};

			if (extraFetchParams) {
				fetchParams = assign(fetchParams, extraFetchParams);
			}

			let localVarPathWithQueryParameters = localVarPath + (localVarPath.indexOf('?') !== -1 ? '&' : '?') + querystring.stringify(queryParameters);

			return fetch(localVarPathWithQueryParameters, fetchParams).then((response) => {
				if (response.status >= 200 && response.status < 300) {
					return response.json();
				} else {
					let error = new Error(response.statusText);
					(error as any).response = response;
					throw error;
				}
			});
		}
		/**
		 *
		 * Get Opportunity Ratings
		 * @param conditions
		 * @param orderBy
		 * @param childconditions
		 * @param customfieldconditions
		 * @param page
		 * @param pageSize
		 */
		public salesOpportunitiesRatingsGet (params: {  conditions?: string; orderBy?: string; childconditions?: string; customfieldconditions?: string; page?: number; pageSize?: number; }, extraQueryParams?: any, extraFetchParams?: any ) : Promise<Array<OpportunityRating>> {
			const localVarPath = this.basePath + '/sales/opportunities/ratings';

			let queryParameters: any = assign({}, extraQueryParams);
			let headerParams: any = assign({}, this.defaultHeaders);
			if (params.conditions !== undefined) {
				queryParameters['conditions'] = params.conditions;
			}

			if (params.orderBy !== undefined) {
				queryParameters['orderBy'] = params.orderBy;
			}

			if (params.childconditions !== undefined) {
				queryParameters['childconditions'] = params.childconditions;
			}

			if (params.customfieldconditions !== undefined) {
				queryParameters['customfieldconditions'] = params.customfieldconditions;
			}

			if (params.page !== undefined) {
				queryParameters['page'] = params.page;
			}

			if (params.pageSize !== undefined) {
				queryParameters['pageSize'] = params.pageSize;
			}

			let fetchParams = {
				method: 'GET',
				headers: headerParams,

			};

			if (extraFetchParams) {
				fetchParams = assign(fetchParams, extraFetchParams);
			}

			let localVarPathWithQueryParameters = localVarPath + (localVarPath.indexOf('?') !== -1 ? '&' : '?') + querystring.stringify(queryParameters);

			return fetch(localVarPathWithQueryParameters, fetchParams).then((response) => {
				if (response.status >= 200 && response.status < 300) {
					return response.json();
				} else {
					let error = new Error(response.statusText);
					(error as any).response = response;
					throw error;
				}
			});
		}
		/**
		 *
		 * Delete Opportunity Rating By Id
		 * @param id
		 */
		public salesOpportunitiesRatingsIdDelete (params: {  id: number; }, extraQueryParams?: any, extraFetchParams?: any ) : Promise<{}> {
			const localVarPath = this.basePath + '/sales/opportunities/ratings/{id}'
				.replace('{' + 'id' + '}', String(params.id));

			let queryParameters: any = assign({}, extraQueryParams);
			let headerParams: any = assign({}, this.defaultHeaders);
			// verify required parameter 'id' is set
			if (params.id == null) {
				throw new Error('Missing required parameter id when calling salesOpportunitiesRatingsIdDelete');
			}
			let fetchParams = {
				method: 'DELETE',
				headers: headerParams,

			};

			if (extraFetchParams) {
				fetchParams = assign(fetchParams, extraFetchParams);
			}

			let localVarPathWithQueryParameters = localVarPath + (localVarPath.indexOf('?') !== -1 ? '&' : '?') + querystring.stringify(queryParameters);

			return fetch(localVarPathWithQueryParameters, fetchParams).then((response) => {
				if (response.status >= 200 && response.status < 300) {
					return response.json();
				} else {
					let error = new Error(response.statusText);
					(error as any).response = response;
					throw error;
				}
			});
		}
		/**
		 *
		 * Get Opportunity Rating By Id
		 * @param id
		 */
		public salesOpportunitiesRatingsIdGet (params: {  id: number; }, extraQueryParams?: any, extraFetchParams?: any ) : Promise<OpportunityRating> {
			const localVarPath = this.basePath + '/sales/opportunities/ratings/{id}'
				.replace('{' + 'id' + '}', String(params.id));

			let queryParameters: any = assign({}, extraQueryParams);
			let headerParams: any = assign({}, this.defaultHeaders);
			// verify required parameter 'id' is set
			if (params.id == null) {
				throw new Error('Missing required parameter id when calling salesOpportunitiesRatingsIdGet');
			}
			let fetchParams = {
				method: 'GET',
				headers: headerParams,

			};

			if (extraFetchParams) {
				fetchParams = assign(fetchParams, extraFetchParams);
			}

			let localVarPathWithQueryParameters = localVarPath + (localVarPath.indexOf('?') !== -1 ? '&' : '?') + querystring.stringify(queryParameters);

			return fetch(localVarPathWithQueryParameters, fetchParams).then((response) => {
				if (response.status >= 200 && response.status < 300) {
					return response.json();
				} else {
					let error = new Error(response.statusText);
					(error as any).response = response;
					throw error;
				}
			});
		}
		/**
		 *
		 * Update Opportunity Rating
		 * @param id
		 * @param operations
		 */
		public salesOpportunitiesRatingsIdPatch (params: {  id: number; operations: Array<PatchOperation>; }, extraQueryParams?: any, extraFetchParams?: any ) : Promise<OpportunityRating> {
			const localVarPath = this.basePath + '/sales/opportunities/ratings/{id}'
				.replace('{' + 'id' + '}', String(params.id));

			let queryParameters: any = assign({}, extraQueryParams);
			let headerParams: any = assign({}, this.defaultHeaders);
			headerParams['Content-Type'] = 'application/json';

			// verify required parameter 'id' is set
			if (params.id == null) {
				throw new Error('Missing required parameter id when calling salesOpportunitiesRatingsIdPatch');
			}
			// verify required parameter 'operations' is set
			if (params.operations == null) {
				throw new Error('Missing required parameter operations when calling salesOpportunitiesRatingsIdPatch');
			}
			let fetchParams = {
				method: 'PATCH',
				headers: headerParams,
				body: JSON.stringify(params.operations),

			};

			if (extraFetchParams) {
				fetchParams = assign(fetchParams, extraFetchParams);
			}

			let localVarPathWithQueryParameters = localVarPath + (localVarPath.indexOf('?') !== -1 ? '&' : '?') + querystring.stringify(queryParameters);

			return fetch(localVarPathWithQueryParameters, fetchParams).then((response) => {
				if (response.status >= 200 && response.status < 300) {
					return response.json();
				} else {
					let error = new Error(response.statusText);
					(error as any).response = response;
					throw error;
				}
			});
		}
		/**
		 *
		 * Replace Opportunity Rating
		 * @param id
		 * @param opportunityRating
		 */
		public salesOpportunitiesRatingsIdPut (params: {  id: number; opportunityRating: OpportunityRating; }, extraQueryParams?: any, extraFetchParams?: any ) : Promise<OpportunityRating> {
			const localVarPath = this.basePath + '/sales/opportunities/ratings/{id}'
				.replace('{' + 'id' + '}', String(params.id));

			let queryParameters: any = assign({}, extraQueryParams);
			let headerParams: any = assign({}, this.defaultHeaders);
			headerParams['Content-Type'] = 'application/json';

			// verify required parameter 'id' is set
			if (params.id == null) {
				throw new Error('Missing required parameter id when calling salesOpportunitiesRatingsIdPut');
			}
			// verify required parameter 'opportunityRating' is set
			if (params.opportunityRating == null) {
				throw new Error('Missing required parameter opportunityRating when calling salesOpportunitiesRatingsIdPut');
			}
			let fetchParams = {
				method: 'PUT',
				headers: headerParams,
				body: JSON.stringify(params.opportunityRating),

			};

			if (extraFetchParams) {
				fetchParams = assign(fetchParams, extraFetchParams);
			}

			let localVarPathWithQueryParameters = localVarPath + (localVarPath.indexOf('?') !== -1 ? '&' : '?') + querystring.stringify(queryParameters);

			return fetch(localVarPathWithQueryParameters, fetchParams).then((response) => {
				if (response.status >= 200 && response.status < 300) {
					return response.json();
				} else {
					let error = new Error(response.statusText);
					(error as any).response = response;
					throw error;
				}
			});
		}
		/**
		 *
		 * Create Opportunity Rating
		 * @param opportunityRating
		 */
		public salesOpportunitiesRatingsPost (params: {  opportunityRating: OpportunityRating; }, extraQueryParams?: any, extraFetchParams?: any ) : Promise<OpportunityRating> {
			const localVarPath = this.basePath + '/sales/opportunities/ratings';

			let queryParameters: any = assign({}, extraQueryParams);
			let headerParams: any = assign({}, this.defaultHeaders);
			headerParams['Content-Type'] = 'application/json';

			// verify required parameter 'opportunityRating' is set
			if (params.opportunityRating == null) {
				throw new Error('Missing required parameter opportunityRating when calling salesOpportunitiesRatingsPost');
			}
			let fetchParams = {
				method: 'POST',
				headers: headerParams,
				body: JSON.stringify(params.opportunityRating),

			};

			if (extraFetchParams) {
				fetchParams = assign(fetchParams, extraFetchParams);
			}

			let localVarPathWithQueryParameters = localVarPath + (localVarPath.indexOf('?') !== -1 ? '&' : '?') + querystring.stringify(queryParameters);

			return fetch(localVarPathWithQueryParameters, fetchParams).then((response) => {
				if (response.status >= 200 && response.status < 300) {
					return response.json();
				} else {
					let error = new Error(response.statusText);
					(error as any).response = response;
					throw error;
				}
			});
		}
	}
//}
//export namespace  {
	'use strict';

	export class OpportunityStagesApi {
		protected basePath = 'https://api-na.myconnectwise.net/v4_6_release/apis/3.0';
		public defaultHeaders : any = {};

		constructor(basePath?: string) {
			if (basePath) {
				this.basePath = basePath;
			}
		}

		/**
		 *
		 * Get Stage Count
		 * @param conditions
		 */
		public salesStagesCountGet (params: {  conditions?: string; }, extraQueryParams?: any, extraFetchParams?: any ) : Promise<Count> {
			const localVarPath = this.basePath + '/sales/stages/count';

			let queryParameters: any = assign({}, extraQueryParams);
			let headerParams: any = assign({}, this.defaultHeaders);
			if (params.conditions !== undefined) {
				queryParameters['conditions'] = params.conditions;
			}

			let fetchParams = {
				method: 'GET',
				headers: headerParams,

			};

			if (extraFetchParams) {
				fetchParams = assign(fetchParams, extraFetchParams);
			}

			let localVarPathWithQueryParameters = localVarPath + (localVarPath.indexOf('?') !== -1 ? '&' : '?') + querystring.stringify(queryParameters);

			return fetch(localVarPathWithQueryParameters, fetchParams).then((response) => {
				if (response.status >= 200 && response.status < 300) {
					return response.json();
				} else {
					let error = new Error(response.statusText);
					(error as any).response = response;
					throw error;
				}
			});
		}
		/**
		 *
		 * Get Stage
		 * @param conditions
		 * @param orderBy
		 * @param childconditions
		 * @param customfieldconditions
		 * @param page
		 * @param pageSize
		 */
		public salesStagesGet (params: {  conditions?: string; orderBy?: string; childconditions?: string; customfieldconditions?: string; page?: number; pageSize?: number; }, extraQueryParams?: any, extraFetchParams?: any ) : Promise<Array<OpportunityStage>> {
			const localVarPath = this.basePath + '/sales/stages';

			let queryParameters: any = assign({}, extraQueryParams);
			let headerParams: any = assign({}, this.defaultHeaders);
			if (params.conditions !== undefined) {
				queryParameters['conditions'] = params.conditions;
			}

			if (params.orderBy !== undefined) {
				queryParameters['orderBy'] = params.orderBy;
			}

			if (params.childconditions !== undefined) {
				queryParameters['childconditions'] = params.childconditions;
			}

			if (params.customfieldconditions !== undefined) {
				queryParameters['customfieldconditions'] = params.customfieldconditions;
			}

			if (params.page !== undefined) {
				queryParameters['page'] = params.page;
			}

			if (params.pageSize !== undefined) {
				queryParameters['pageSize'] = params.pageSize;
			}

			let fetchParams = {
				method: 'GET',
				headers: headerParams,

			};

			if (extraFetchParams) {
				fetchParams = assign(fetchParams, extraFetchParams);
			}

			let localVarPathWithQueryParameters = localVarPath + (localVarPath.indexOf('?') !== -1 ? '&' : '?') + querystring.stringify(queryParameters);

			return fetch(localVarPathWithQueryParameters, fetchParams).then((response) => {
				if (response.status >= 200 && response.status < 300) {
					return response.json();
				} else {
					let error = new Error(response.statusText);
					(error as any).response = response;
					throw error;
				}
			});
		}
		/**
		 *
		 * Delete Stage By Id
		 * @param id
		 */
		public salesStagesIdDelete (params: {  id: number; }, extraQueryParams?: any, extraFetchParams?: any ) : Promise<{}> {
			const localVarPath = this.basePath + '/sales/stages/{id}'
				.replace('{' + 'id' + '}', String(params.id));

			let queryParameters: any = assign({}, extraQueryParams);
			let headerParams: any = assign({}, this.defaultHeaders);
			// verify required parameter 'id' is set
			if (params.id == null) {
				throw new Error('Missing required parameter id when calling salesStagesIdDelete');
			}
			let fetchParams = {
				method: 'DELETE',
				headers: headerParams,

			};

			if (extraFetchParams) {
				fetchParams = assign(fetchParams, extraFetchParams);
			}

			let localVarPathWithQueryParameters = localVarPath + (localVarPath.indexOf('?') !== -1 ? '&' : '?') + querystring.stringify(queryParameters);

			return fetch(localVarPathWithQueryParameters, fetchParams).then((response) => {
				if (response.status >= 200 && response.status < 300) {
					return response.json();
				} else {
					let error = new Error(response.statusText);
					(error as any).response = response;
					throw error;
				}
			});
		}
		/**
		 *
		 * Get Stage By Id
		 * @param id
		 */
		public salesStagesIdGet (params: {  id: number; }, extraQueryParams?: any, extraFetchParams?: any ) : Promise<OpportunityStage> {
			const localVarPath = this.basePath + '/sales/stages/{id}'
				.replace('{' + 'id' + '}', String(params.id));

			let queryParameters: any = assign({}, extraQueryParams);
			let headerParams: any = assign({}, this.defaultHeaders);
			// verify required parameter 'id' is set
			if (params.id == null) {
				throw new Error('Missing required parameter id when calling salesStagesIdGet');
			}
			let fetchParams = {
				method: 'GET',
				headers: headerParams,

			};

			if (extraFetchParams) {
				fetchParams = assign(fetchParams, extraFetchParams);
			}

			let localVarPathWithQueryParameters = localVarPath + (localVarPath.indexOf('?') !== -1 ? '&' : '?') + querystring.stringify(queryParameters);

			return fetch(localVarPathWithQueryParameters, fetchParams).then((response) => {
				if (response.status >= 200 && response.status < 300) {
					return response.json();
				} else {
					let error = new Error(response.statusText);
					(error as any).response = response;
					throw error;
				}
			});
		}
		/**
		 *
		 * Update Stage
		 * @param id
		 * @param operations
		 */
		public salesStagesIdPatch (params: {  id: number; operations: Array<PatchOperation>; }, extraQueryParams?: any, extraFetchParams?: any ) : Promise<OpportunityStage> {
			const localVarPath = this.basePath + '/sales/stages/{id}'
				.replace('{' + 'id' + '}', String(params.id));

			let queryParameters: any = assign({}, extraQueryParams);
			let headerParams: any = assign({}, this.defaultHeaders);
			headerParams['Content-Type'] = 'application/json';

			// verify required parameter 'id' is set
			if (params.id == null) {
				throw new Error('Missing required parameter id when calling salesStagesIdPatch');
			}
			// verify required parameter 'operations' is set
			if (params.operations == null) {
				throw new Error('Missing required parameter operations when calling salesStagesIdPatch');
			}
			let fetchParams = {
				method: 'PATCH',
				headers: headerParams,
				body: JSON.stringify(params.operations),

			};

			if (extraFetchParams) {
				fetchParams = assign(fetchParams, extraFetchParams);
			}

			let localVarPathWithQueryParameters = localVarPath + (localVarPath.indexOf('?') !== -1 ? '&' : '?') + querystring.stringify(queryParameters);

			return fetch(localVarPathWithQueryParameters, fetchParams).then((response) => {
				if (response.status >= 200 && response.status < 300) {
					return response.json();
				} else {
					let error = new Error(response.statusText);
					(error as any).response = response;
					throw error;
				}
			});
		}
		/**
		 *
		 * Replace Stage
		 * @param id
		 * @param stage
		 */
		public salesStagesIdPut (params: {  id: number; stage: OpportunityStage; }, extraQueryParams?: any, extraFetchParams?: any ) : Promise<OpportunityStage> {
			const localVarPath = this.basePath + '/sales/stages/{id}'
				.replace('{' + 'id' + '}', String(params.id));

			let queryParameters: any = assign({}, extraQueryParams);
			let headerParams: any = assign({}, this.defaultHeaders);
			headerParams['Content-Type'] = 'application/json';

			// verify required parameter 'id' is set
			if (params.id == null) {
				throw new Error('Missing required parameter id when calling salesStagesIdPut');
			}
			// verify required parameter 'stage' is set
			if (params.stage == null) {
				throw new Error('Missing required parameter stage when calling salesStagesIdPut');
			}
			let fetchParams = {
				method: 'PUT',
				headers: headerParams,
				body: JSON.stringify(params.stage),

			};

			if (extraFetchParams) {
				fetchParams = assign(fetchParams, extraFetchParams);
			}

			let localVarPathWithQueryParameters = localVarPath + (localVarPath.indexOf('?') !== -1 ? '&' : '?') + querystring.stringify(queryParameters);

			return fetch(localVarPathWithQueryParameters, fetchParams).then((response) => {
				if (response.status >= 200 && response.status < 300) {
					return response.json();
				} else {
					let error = new Error(response.statusText);
					(error as any).response = response;
					throw error;
				}
			});
		}
		/**
		 *
		 * Create Stage
		 * @param stage
		 */
		public salesStagesPost (params: {  stage: OpportunityStage; }, extraQueryParams?: any, extraFetchParams?: any ) : Promise<OpportunityStage> {
			const localVarPath = this.basePath + '/sales/stages';

			let queryParameters: any = assign({}, extraQueryParams);
			let headerParams: any = assign({}, this.defaultHeaders);
			headerParams['Content-Type'] = 'application/json';

			// verify required parameter 'stage' is set
			if (params.stage == null) {
				throw new Error('Missing required parameter stage when calling salesStagesPost');
			}
			let fetchParams = {
				method: 'POST',
				headers: headerParams,
				body: JSON.stringify(params.stage),

			};

			if (extraFetchParams) {
				fetchParams = assign(fetchParams, extraFetchParams);
			}

			let localVarPathWithQueryParameters = localVarPath + (localVarPath.indexOf('?') !== -1 ? '&' : '?') + querystring.stringify(queryParameters);

			return fetch(localVarPathWithQueryParameters, fetchParams).then((response) => {
				if (response.status >= 200 && response.status < 300) {
					return response.json();
				} else {
					let error = new Error(response.statusText);
					(error as any).response = response;
					throw error;
				}
			});
		}
	}
//}
//export namespace  {
	'use strict';

	export class OpportunityStatusesApi {
		protected basePath = 'https://api-na.myconnectwise.net/v4_6_release/apis/3.0';
		public defaultHeaders : any = {};

		constructor(basePath?: string) {
			if (basePath) {
				this.basePath = basePath;
			}
		}

		/**
		 *
		 * Get Statuses Count
		 * @param conditions
		 */
		public salesOpportunitiesStatusesCountGet (params: {  conditions?: string; }, extraQueryParams?: any, extraFetchParams?: any ) : Promise<Count> {
			const localVarPath = this.basePath + '/sales/opportunities/statuses/count';

			let queryParameters: any = assign({}, extraQueryParams);
			let headerParams: any = assign({}, this.defaultHeaders);
			if (params.conditions !== undefined) {
				queryParameters['conditions'] = params.conditions;
			}

			let fetchParams = {
				method: 'GET',
				headers: headerParams,

			};

			if (extraFetchParams) {
				fetchParams = assign(fetchParams, extraFetchParams);
			}

			let localVarPathWithQueryParameters = localVarPath + (localVarPath.indexOf('?') !== -1 ? '&' : '?') + querystring.stringify(queryParameters);

			return fetch(localVarPathWithQueryParameters, fetchParams).then((response) => {
				if (response.status >= 200 && response.status < 300) {
					return response.json();
				} else {
					let error = new Error(response.statusText);
					(error as any).response = response;
					throw error;
				}
			});
		}
		/**
		 *
		 * Get Statuses
		 * @param conditions
		 * @param orderBy
		 * @param childconditions
		 * @param customfieldconditions
		 * @param page
		 * @param pageSize
		 */
		public salesOpportunitiesStatusesGet (params: {  conditions?: string; orderBy?: string; childconditions?: string; customfieldconditions?: string; page?: number; pageSize?: number; }, extraQueryParams?: any, extraFetchParams?: any ) : Promise<Array<OpportunityStatus>> {
			const localVarPath = this.basePath + '/sales/opportunities/statuses';

			let queryParameters: any = assign({}, extraQueryParams);
			let headerParams: any = assign({}, this.defaultHeaders);
			if (params.conditions !== undefined) {
				queryParameters['conditions'] = params.conditions;
			}

			if (params.orderBy !== undefined) {
				queryParameters['orderBy'] = params.orderBy;
			}

			if (params.childconditions !== undefined) {
				queryParameters['childconditions'] = params.childconditions;
			}

			if (params.customfieldconditions !== undefined) {
				queryParameters['customfieldconditions'] = params.customfieldconditions;
			}

			if (params.page !== undefined) {
				queryParameters['page'] = params.page;
			}

			if (params.pageSize !== undefined) {
				queryParameters['pageSize'] = params.pageSize;
			}

			let fetchParams = {
				method: 'GET',
				headers: headerParams,

			};

			if (extraFetchParams) {
				fetchParams = assign(fetchParams, extraFetchParams);
			}

			let localVarPathWithQueryParameters = localVarPath + (localVarPath.indexOf('?') !== -1 ? '&' : '?') + querystring.stringify(queryParameters);

			return fetch(localVarPathWithQueryParameters, fetchParams).then((response) => {
				if (response.status >= 200 && response.status < 300) {
					return response.json();
				} else {
					let error = new Error(response.statusText);
					(error as any).response = response;
					throw error;
				}
			});
		}
		/**
		 *
		 * Delete Status By Id
		 * @param id
		 */
		public salesOpportunitiesStatusesIdDelete (params: {  id: number; }, extraQueryParams?: any, extraFetchParams?: any ) : Promise<{}> {
			const localVarPath = this.basePath + '/sales/opportunities/statuses/{id}'
				.replace('{' + 'id' + '}', String(params.id));

			let queryParameters: any = assign({}, extraQueryParams);
			let headerParams: any = assign({}, this.defaultHeaders);
			// verify required parameter 'id' is set
			if (params.id == null) {
				throw new Error('Missing required parameter id when calling salesOpportunitiesStatusesIdDelete');
			}
			let fetchParams = {
				method: 'DELETE',
				headers: headerParams,

			};

			if (extraFetchParams) {
				fetchParams = assign(fetchParams, extraFetchParams);
			}

			let localVarPathWithQueryParameters = localVarPath + (localVarPath.indexOf('?') !== -1 ? '&' : '?') + querystring.stringify(queryParameters);

			return fetch(localVarPathWithQueryParameters, fetchParams).then((response) => {
				if (response.status >= 200 && response.status < 300) {
					return response.json();
				} else {
					let error = new Error(response.statusText);
					(error as any).response = response;
					throw error;
				}
			});
		}
		/**
		 *
		 * Get Status By Id
		 * @param id
		 */
		public salesOpportunitiesStatusesIdGet (params: {  id: number; }, extraQueryParams?: any, extraFetchParams?: any ) : Promise<OpportunityStatus> {
			const localVarPath = this.basePath + '/sales/opportunities/statuses/{id}'
				.replace('{' + 'id' + '}', String(params.id));

			let queryParameters: any = assign({}, extraQueryParams);
			let headerParams: any = assign({}, this.defaultHeaders);
			// verify required parameter 'id' is set
			if (params.id == null) {
				throw new Error('Missing required parameter id when calling salesOpportunitiesStatusesIdGet');
			}
			let fetchParams = {
				method: 'GET',
				headers: headerParams,

			};

			if (extraFetchParams) {
				fetchParams = assign(fetchParams, extraFetchParams);
			}

			let localVarPathWithQueryParameters = localVarPath + (localVarPath.indexOf('?') !== -1 ? '&' : '?') + querystring.stringify(queryParameters);

			return fetch(localVarPathWithQueryParameters, fetchParams).then((response) => {
				if (response.status >= 200 && response.status < 300) {
					return response.json();
				} else {
					let error = new Error(response.statusText);
					(error as any).response = response;
					throw error;
				}
			});
		}
		/**
		 *
		 * Update Status
		 * @param id
		 * @param operations
		 */
		public salesOpportunitiesStatusesIdPatch (params: {  id: number; operations: Array<PatchOperation>; }, extraQueryParams?: any, extraFetchParams?: any ) : Promise<OpportunityStatus> {
			const localVarPath = this.basePath + '/sales/opportunities/statuses/{id}'
				.replace('{' + 'id' + '}', String(params.id));

			let queryParameters: any = assign({}, extraQueryParams);
			let headerParams: any = assign({}, this.defaultHeaders);
			headerParams['Content-Type'] = 'application/json';

			// verify required parameter 'id' is set
			if (params.id == null) {
				throw new Error('Missing required parameter id when calling salesOpportunitiesStatusesIdPatch');
			}
			// verify required parameter 'operations' is set
			if (params.operations == null) {
				throw new Error('Missing required parameter operations when calling salesOpportunitiesStatusesIdPatch');
			}
			let fetchParams = {
				method: 'PATCH',
				headers: headerParams,
				body: JSON.stringify(params.operations),

			};

			if (extraFetchParams) {
				fetchParams = assign(fetchParams, extraFetchParams);
			}

			let localVarPathWithQueryParameters = localVarPath + (localVarPath.indexOf('?') !== -1 ? '&' : '?') + querystring.stringify(queryParameters);

			return fetch(localVarPathWithQueryParameters, fetchParams).then((response) => {
				if (response.status >= 200 && response.status < 300) {
					return response.json();
				} else {
					let error = new Error(response.statusText);
					(error as any).response = response;
					throw error;
				}
			});
		}
		/**
		 *
		 * Replace Status
		 * @param id
		 * @param status
		 */
		public salesOpportunitiesStatusesIdPut (params: {  id: number; status: OpportunityStatus; }, extraQueryParams?: any, extraFetchParams?: any ) : Promise<OpportunityStatus> {
			const localVarPath = this.basePath + '/sales/opportunities/statuses/{id}'
				.replace('{' + 'id' + '}', String(params.id));

			let queryParameters: any = assign({}, extraQueryParams);
			let headerParams: any = assign({}, this.defaultHeaders);
			headerParams['Content-Type'] = 'application/json';

			// verify required parameter 'id' is set
			if (params.id == null) {
				throw new Error('Missing required parameter id when calling salesOpportunitiesStatusesIdPut');
			}
			// verify required parameter 'status' is set
			if (params.status == null) {
				throw new Error('Missing required parameter status when calling salesOpportunitiesStatusesIdPut');
			}
			let fetchParams = {
				method: 'PUT',
				headers: headerParams,
				body: JSON.stringify(params.status),

			};

			if (extraFetchParams) {
				fetchParams = assign(fetchParams, extraFetchParams);
			}

			let localVarPathWithQueryParameters = localVarPath + (localVarPath.indexOf('?') !== -1 ? '&' : '?') + querystring.stringify(queryParameters);

			return fetch(localVarPathWithQueryParameters, fetchParams).then((response) => {
				if (response.status >= 200 && response.status < 300) {
					return response.json();
				} else {
					let error = new Error(response.statusText);
					(error as any).response = response;
					throw error;
				}
			});
		}
		/**
		 *
		 * Create Status
		 * @param status
		 */
		public salesOpportunitiesStatusesPost (params: {  status: OpportunityStatus; }, extraQueryParams?: any, extraFetchParams?: any ) : Promise<OpportunityStatus> {
			const localVarPath = this.basePath + '/sales/opportunities/statuses';

			let queryParameters: any = assign({}, extraQueryParams);
			let headerParams: any = assign({}, this.defaultHeaders);
			headerParams['Content-Type'] = 'application/json';

			// verify required parameter 'status' is set
			if (params.status == null) {
				throw new Error('Missing required parameter status when calling salesOpportunitiesStatusesPost');
			}
			let fetchParams = {
				method: 'POST',
				headers: headerParams,
				body: JSON.stringify(params.status),

			};

			if (extraFetchParams) {
				fetchParams = assign(fetchParams, extraFetchParams);
			}

			let localVarPathWithQueryParameters = localVarPath + (localVarPath.indexOf('?') !== -1 ? '&' : '?') + querystring.stringify(queryParameters);

			return fetch(localVarPathWithQueryParameters, fetchParams).then((response) => {
				if (response.status >= 200 && response.status < 300) {
					return response.json();
				} else {
					let error = new Error(response.statusText);
					(error as any).response = response;
					throw error;
				}
			});
		}
	}
//}
//export namespace  {
	'use strict';

	export class OpportunityTeamsApi {
		protected basePath = 'https://api-na.myconnectwise.net/v4_6_release/apis/3.0';
		public defaultHeaders : any = {};

		constructor(basePath?: string) {
			if (basePath) {
				this.basePath = basePath;
			}
		}

		/**
		 *
		 * Get Teams Count
		 * @param id
		 * @param conditions
		 */
		public salesOpportunitiesIdTeamCountGet (params: {  id: number; conditions?: string; }, extraQueryParams?: any, extraFetchParams?: any ) : Promise<Count> {
			const localVarPath = this.basePath + '/sales/opportunities/{id}/team/count'
				.replace('{' + 'id' + '}', String(params.id));

			let queryParameters: any = assign({}, extraQueryParams);
			let headerParams: any = assign({}, this.defaultHeaders);
			// verify required parameter 'id' is set
			if (params.id == null) {
				throw new Error('Missing required parameter id when calling salesOpportunitiesIdTeamCountGet');
			}
			if (params.conditions !== undefined) {
				queryParameters['conditions'] = params.conditions;
			}

			let fetchParams = {
				method: 'GET',
				headers: headerParams,

			};

			if (extraFetchParams) {
				fetchParams = assign(fetchParams, extraFetchParams);
			}

			let localVarPathWithQueryParameters = localVarPath + (localVarPath.indexOf('?') !== -1 ? '&' : '?') + querystring.stringify(queryParameters);

			return fetch(localVarPathWithQueryParameters, fetchParams).then((response) => {
				if (response.status >= 200 && response.status < 300) {
					return response.json();
				} else {
					let error = new Error(response.statusText);
					(error as any).response = response;
					throw error;
				}
			});
		}
		/**
		 *
		 * Get Teams
		 * @param id
		 * @param conditions
		 * @param orderBy
		 * @param childconditions
		 * @param customfieldconditions
		 * @param page
		 * @param pageSize
		 */
		public salesOpportunitiesIdTeamGet (params: {  id: number; conditions?: string; orderBy?: string; childconditions?: string; customfieldconditions?: string; page?: number; pageSize?: number; }, extraQueryParams?: any, extraFetchParams?: any ) : Promise<Array<Team>> {
			const localVarPath = this.basePath + '/sales/opportunities/{id}/team'
				.replace('{' + 'id' + '}', String(params.id));

			let queryParameters: any = assign({}, extraQueryParams);
			let headerParams: any = assign({}, this.defaultHeaders);
			// verify required parameter 'id' is set
			if (params.id == null) {
				throw new Error('Missing required parameter id when calling salesOpportunitiesIdTeamGet');
			}
			if (params.conditions !== undefined) {
				queryParameters['conditions'] = params.conditions;
			}

			if (params.orderBy !== undefined) {
				queryParameters['orderBy'] = params.orderBy;
			}

			if (params.childconditions !== undefined) {
				queryParameters['childconditions'] = params.childconditions;
			}

			if (params.customfieldconditions !== undefined) {
				queryParameters['customfieldconditions'] = params.customfieldconditions;
			}

			if (params.page !== undefined) {
				queryParameters['page'] = params.page;
			}

			if (params.pageSize !== undefined) {
				queryParameters['pageSize'] = params.pageSize;
			}

			let fetchParams = {
				method: 'GET',
				headers: headerParams,

			};

			if (extraFetchParams) {
				fetchParams = assign(fetchParams, extraFetchParams);
			}

			let localVarPathWithQueryParameters = localVarPath + (localVarPath.indexOf('?') !== -1 ? '&' : '?') + querystring.stringify(queryParameters);

			return fetch(localVarPathWithQueryParameters, fetchParams).then((response) => {
				if (response.status >= 200 && response.status < 300) {
					return response.json();
				} else {
					let error = new Error(response.statusText);
					(error as any).response = response;
					throw error;
				}
			});
		}
		/**
		 *
		 * Create Team
		 * @param id
		 * @param team
		 */
		public salesOpportunitiesIdTeamPost (params: {  id: number; team: Team; }, extraQueryParams?: any, extraFetchParams?: any ) : Promise<Team> {
			const localVarPath = this.basePath + '/sales/opportunities/{id}/team'
				.replace('{' + 'id' + '}', String(params.id));

			let queryParameters: any = assign({}, extraQueryParams);
			let headerParams: any = assign({}, this.defaultHeaders);
			headerParams['Content-Type'] = 'application/json';

			// verify required parameter 'id' is set
			if (params.id == null) {
				throw new Error('Missing required parameter id when calling salesOpportunitiesIdTeamPost');
			}
			// verify required parameter 'team' is set
			if (params.team == null) {
				throw new Error('Missing required parameter team when calling salesOpportunitiesIdTeamPost');
			}
			let fetchParams = {
				method: 'POST',
				headers: headerParams,
				body: JSON.stringify(params.team),

			};

			if (extraFetchParams) {
				fetchParams = assign(fetchParams, extraFetchParams);
			}

			let localVarPathWithQueryParameters = localVarPath + (localVarPath.indexOf('?') !== -1 ? '&' : '?') + querystring.stringify(queryParameters);

			return fetch(localVarPathWithQueryParameters, fetchParams).then((response) => {
				if (response.status >= 200 && response.status < 300) {
					return response.json();
				} else {
					let error = new Error(response.statusText);
					(error as any).response = response;
					throw error;
				}
			});
		}
		/**
		 *
		 * Delete Team By Id
		 * @param id
		 * @param teamId
		 */
		public salesOpportunitiesIdTeamTeamIdDelete (params: {  id: number; teamId: number; }, extraQueryParams?: any, extraFetchParams?: any ) : Promise<{}> {
			const localVarPath = this.basePath + '/sales/opportunities/{id}/team/{teamId}'
				.replace('{' + 'id' + '}', String(params.id))
				.replace('{' + 'teamId' + '}', String(params.teamId));

			let queryParameters: any = assign({}, extraQueryParams);
			let headerParams: any = assign({}, this.defaultHeaders);
			// verify required parameter 'id' is set
			if (params.id == null) {
				throw new Error('Missing required parameter id when calling salesOpportunitiesIdTeamTeamIdDelete');
			}
			// verify required parameter 'teamId' is set
			if (params.teamId == null) {
				throw new Error('Missing required parameter teamId when calling salesOpportunitiesIdTeamTeamIdDelete');
			}
			let fetchParams = {
				method: 'DELETE',
				headers: headerParams,

			};

			if (extraFetchParams) {
				fetchParams = assign(fetchParams, extraFetchParams);
			}

			let localVarPathWithQueryParameters = localVarPath + (localVarPath.indexOf('?') !== -1 ? '&' : '?') + querystring.stringify(queryParameters);

			return fetch(localVarPathWithQueryParameters, fetchParams).then((response) => {
				if (response.status >= 200 && response.status < 300) {
					return response.json();
				} else {
					let error = new Error(response.statusText);
					(error as any).response = response;
					throw error;
				}
			});
		}
		/**
		 *
		 * Get Team By Id
		 * @param id
		 * @param teamId
		 */
		public salesOpportunitiesIdTeamTeamIdGet (params: {  id: number; teamId: number; }, extraQueryParams?: any, extraFetchParams?: any ) : Promise<Team> {
			const localVarPath = this.basePath + '/sales/opportunities/{id}/team/{teamId}'
				.replace('{' + 'id' + '}', String(params.id))
				.replace('{' + 'teamId' + '}', String(params.teamId));

			let queryParameters: any = assign({}, extraQueryParams);
			let headerParams: any = assign({}, this.defaultHeaders);
			// verify required parameter 'id' is set
			if (params.id == null) {
				throw new Error('Missing required parameter id when calling salesOpportunitiesIdTeamTeamIdGet');
			}
			// verify required parameter 'teamId' is set
			if (params.teamId == null) {
				throw new Error('Missing required parameter teamId when calling salesOpportunitiesIdTeamTeamIdGet');
			}
			let fetchParams = {
				method: 'GET',
				headers: headerParams,

			};

			if (extraFetchParams) {
				fetchParams = assign(fetchParams, extraFetchParams);
			}

			let localVarPathWithQueryParameters = localVarPath + (localVarPath.indexOf('?') !== -1 ? '&' : '?') + querystring.stringify(queryParameters);

			return fetch(localVarPathWithQueryParameters, fetchParams).then((response) => {
				if (response.status >= 200 && response.status < 300) {
					return response.json();
				} else {
					let error = new Error(response.statusText);
					(error as any).response = response;
					throw error;
				}
			});
		}
		/**
		 *
		 * Update Team
		 * @param id
		 * @param teamId
		 * @param operations
		 */
		public salesOpportunitiesIdTeamTeamIdPatch (params: {  id: number; teamId: number; operations: Array<PatchOperation>; }, extraQueryParams?: any, extraFetchParams?: any ) : Promise<Team> {
			const localVarPath = this.basePath + '/sales/opportunities/{id}/team/{teamId}'
				.replace('{' + 'id' + '}', String(params.id))
				.replace('{' + 'teamId' + '}', String(params.teamId));

			let queryParameters: any = assign({}, extraQueryParams);
			let headerParams: any = assign({}, this.defaultHeaders);
			headerParams['Content-Type'] = 'application/json';

			// verify required parameter 'id' is set
			if (params.id == null) {
				throw new Error('Missing required parameter id when calling salesOpportunitiesIdTeamTeamIdPatch');
			}
			// verify required parameter 'teamId' is set
			if (params.teamId == null) {
				throw new Error('Missing required parameter teamId when calling salesOpportunitiesIdTeamTeamIdPatch');
			}
			// verify required parameter 'operations' is set
			if (params.operations == null) {
				throw new Error('Missing required parameter operations when calling salesOpportunitiesIdTeamTeamIdPatch');
			}
			let fetchParams = {
				method: 'PATCH',
				headers: headerParams,
				body: JSON.stringify(params.operations),

			};

			if (extraFetchParams) {
				fetchParams = assign(fetchParams, extraFetchParams);
			}

			let localVarPathWithQueryParameters = localVarPath + (localVarPath.indexOf('?') !== -1 ? '&' : '?') + querystring.stringify(queryParameters);

			return fetch(localVarPathWithQueryParameters, fetchParams).then((response) => {
				if (response.status >= 200 && response.status < 300) {
					return response.json();
				} else {
					let error = new Error(response.statusText);
					(error as any).response = response;
					throw error;
				}
			});
		}
		/**
		 *
		 * Replace Team
		 * @param id
		 * @param teamId
		 * @param team
		 */
		public salesOpportunitiesIdTeamTeamIdPut (params: {  id: number; teamId: number; team: Team; }, extraQueryParams?: any, extraFetchParams?: any ) : Promise<Team> {
			const localVarPath = this.basePath + '/sales/opportunities/{id}/team/{teamId}'
				.replace('{' + 'id' + '}', String(params.id))
				.replace('{' + 'teamId' + '}', String(params.teamId));

			let queryParameters: any = assign({}, extraQueryParams);
			let headerParams: any = assign({}, this.defaultHeaders);
			headerParams['Content-Type'] = 'application/json';

			// verify required parameter 'id' is set
			if (params.id == null) {
				throw new Error('Missing required parameter id when calling salesOpportunitiesIdTeamTeamIdPut');
			}
			// verify required parameter 'teamId' is set
			if (params.teamId == null) {
				throw new Error('Missing required parameter teamId when calling salesOpportunitiesIdTeamTeamIdPut');
			}
			// verify required parameter 'team' is set
			if (params.team == null) {
				throw new Error('Missing required parameter team when calling salesOpportunitiesIdTeamTeamIdPut');
			}
			let fetchParams = {
				method: 'PUT',
				headers: headerParams,
				body: JSON.stringify(params.team),

			};

			if (extraFetchParams) {
				fetchParams = assign(fetchParams, extraFetchParams);
			}

			let localVarPathWithQueryParameters = localVarPath + (localVarPath.indexOf('?') !== -1 ? '&' : '?') + querystring.stringify(queryParameters);

			return fetch(localVarPathWithQueryParameters, fetchParams).then((response) => {
				if (response.status >= 200 && response.status < 300) {
					return response.json();
				} else {
					let error = new Error(response.statusText);
					(error as any).response = response;
					throw error;
				}
			});
		}
	}
//}
//export namespace  {
	'use strict';

	export class OpportunityTypesApi {
		protected basePath = 'https://api-na.myconnectwise.net/v4_6_release/apis/3.0';
		public defaultHeaders : any = {};

		constructor(basePath?: string) {
			if (basePath) {
				this.basePath = basePath;
			}
		}

		/**
		 *
		 * Get Opportunity Types Count
		 * @param conditions
		 */
		public salesOpportunitiesTypesCountGet (params: {  conditions?: string; }, extraQueryParams?: any, extraFetchParams?: any ) : Promise<Count> {
			const localVarPath = this.basePath + '/sales/opportunities/types/count';

			let queryParameters: any = assign({}, extraQueryParams);
			let headerParams: any = assign({}, this.defaultHeaders);
			if (params.conditions !== undefined) {
				queryParameters['conditions'] = params.conditions;
			}

			let fetchParams = {
				method: 'GET',
				headers: headerParams,

			};

			if (extraFetchParams) {
				fetchParams = assign(fetchParams, extraFetchParams);
			}

			let localVarPathWithQueryParameters = localVarPath + (localVarPath.indexOf('?') !== -1 ? '&' : '?') + querystring.stringify(queryParameters);

			return fetch(localVarPathWithQueryParameters, fetchParams).then((response) => {
				if (response.status >= 200 && response.status < 300) {
					return response.json();
				} else {
					let error = new Error(response.statusText);
					(error as any).response = response;
					throw error;
				}
			});
		}
		/**
		 *
		 * Get Opportunity Types
		 * @param conditions
		 * @param orderBy
		 * @param childconditions
		 * @param customfieldconditions
		 * @param page
		 * @param pageSize
		 */
		public salesOpportunitiesTypesGet (params: {  conditions?: string; orderBy?: string; childconditions?: string; customfieldconditions?: string; page?: number; pageSize?: number; }, extraQueryParams?: any, extraFetchParams?: any ) : Promise<Array<OpportunityType>> {
			const localVarPath = this.basePath + '/sales/opportunities/types';

			let queryParameters: any = assign({}, extraQueryParams);
			let headerParams: any = assign({}, this.defaultHeaders);
			if (params.conditions !== undefined) {
				queryParameters['conditions'] = params.conditions;
			}

			if (params.orderBy !== undefined) {
				queryParameters['orderBy'] = params.orderBy;
			}

			if (params.childconditions !== undefined) {
				queryParameters['childconditions'] = params.childconditions;
			}

			if (params.customfieldconditions !== undefined) {
				queryParameters['customfieldconditions'] = params.customfieldconditions;
			}

			if (params.page !== undefined) {
				queryParameters['page'] = params.page;
			}

			if (params.pageSize !== undefined) {
				queryParameters['pageSize'] = params.pageSize;
			}

			let fetchParams = {
				method: 'GET',
				headers: headerParams,

			};

			if (extraFetchParams) {
				fetchParams = assign(fetchParams, extraFetchParams);
			}

			let localVarPathWithQueryParameters = localVarPath + (localVarPath.indexOf('?') !== -1 ? '&' : '?') + querystring.stringify(queryParameters);

			return fetch(localVarPathWithQueryParameters, fetchParams).then((response) => {
				if (response.status >= 200 && response.status < 300) {
					return response.json();
				} else {
					let error = new Error(response.statusText);
					(error as any).response = response;
					throw error;
				}
			});
		}
		/**
		 *
		 * Delete Opportunity Type By Id
		 * @param id
		 */
		public salesOpportunitiesTypesIdDelete (params: {  id: number; }, extraQueryParams?: any, extraFetchParams?: any ) : Promise<{}> {
			const localVarPath = this.basePath + '/sales/opportunities/types/{id}'
				.replace('{' + 'id' + '}', String(params.id));

			let queryParameters: any = assign({}, extraQueryParams);
			let headerParams: any = assign({}, this.defaultHeaders);
			// verify required parameter 'id' is set
			if (params.id == null) {
				throw new Error('Missing required parameter id when calling salesOpportunitiesTypesIdDelete');
			}
			let fetchParams = {
				method: 'DELETE',
				headers: headerParams,

			};

			if (extraFetchParams) {
				fetchParams = assign(fetchParams, extraFetchParams);
			}

			let localVarPathWithQueryParameters = localVarPath + (localVarPath.indexOf('?') !== -1 ? '&' : '?') + querystring.stringify(queryParameters);

			return fetch(localVarPathWithQueryParameters, fetchParams).then((response) => {
				if (response.status >= 200 && response.status < 300) {
					return response.json();
				} else {
					let error = new Error(response.statusText);
					(error as any).response = response;
					throw error;
				}
			});
		}
		/**
		 *
		 * Get Opportunity Type By Id
		 * @param id
		 */
		public salesOpportunitiesTypesIdGet (params: {  id: number; }, extraQueryParams?: any, extraFetchParams?: any ) : Promise<OpportunityType> {
			const localVarPath = this.basePath + '/sales/opportunities/types/{id}'
				.replace('{' + 'id' + '}', String(params.id));

			let queryParameters: any = assign({}, extraQueryParams);
			let headerParams: any = assign({}, this.defaultHeaders);
			// verify required parameter 'id' is set
			if (params.id == null) {
				throw new Error('Missing required parameter id when calling salesOpportunitiesTypesIdGet');
			}
			let fetchParams = {
				method: 'GET',
				headers: headerParams,

			};

			if (extraFetchParams) {
				fetchParams = assign(fetchParams, extraFetchParams);
			}

			let localVarPathWithQueryParameters = localVarPath + (localVarPath.indexOf('?') !== -1 ? '&' : '?') + querystring.stringify(queryParameters);

			return fetch(localVarPathWithQueryParameters, fetchParams).then((response) => {
				if (response.status >= 200 && response.status < 300) {
					return response.json();
				} else {
					let error = new Error(response.statusText);
					(error as any).response = response;
					throw error;
				}
			});
		}
		/**
		 *
		 * Update Opportunity Type
		 * @param id
		 * @param operations
		 */
		public salesOpportunitiesTypesIdPatch (params: {  id: number; operations: Array<PatchOperation>; }, extraQueryParams?: any, extraFetchParams?: any ) : Promise<OpportunityType> {
			const localVarPath = this.basePath + '/sales/opportunities/types/{id}'
				.replace('{' + 'id' + '}', String(params.id));

			let queryParameters: any = assign({}, extraQueryParams);
			let headerParams: any = assign({}, this.defaultHeaders);
			headerParams['Content-Type'] = 'application/json';

			// verify required parameter 'id' is set
			if (params.id == null) {
				throw new Error('Missing required parameter id when calling salesOpportunitiesTypesIdPatch');
			}
			// verify required parameter 'operations' is set
			if (params.operations == null) {
				throw new Error('Missing required parameter operations when calling salesOpportunitiesTypesIdPatch');
			}
			let fetchParams = {
				method: 'PATCH',
				headers: headerParams,
				body: JSON.stringify(params.operations),

			};

			if (extraFetchParams) {
				fetchParams = assign(fetchParams, extraFetchParams);
			}

			let localVarPathWithQueryParameters = localVarPath + (localVarPath.indexOf('?') !== -1 ? '&' : '?') + querystring.stringify(queryParameters);

			return fetch(localVarPathWithQueryParameters, fetchParams).then((response) => {
				if (response.status >= 200 && response.status < 300) {
					return response.json();
				} else {
					let error = new Error(response.statusText);
					(error as any).response = response;
					throw error;
				}
			});
		}
		/**
		 *
		 * Replace Opportunity Type
		 * @param id
		 * @param opportunityType
		 */
		public salesOpportunitiesTypesIdPut (params: {  id: number; opportunityType: OpportunityType; }, extraQueryParams?: any, extraFetchParams?: any ) : Promise<OpportunityType> {
			const localVarPath = this.basePath + '/sales/opportunities/types/{id}'
				.replace('{' + 'id' + '}', String(params.id));

			let queryParameters: any = assign({}, extraQueryParams);
			let headerParams: any = assign({}, this.defaultHeaders);
			headerParams['Content-Type'] = 'application/json';

			// verify required parameter 'id' is set
			if (params.id == null) {
				throw new Error('Missing required parameter id when calling salesOpportunitiesTypesIdPut');
			}
			// verify required parameter 'opportunityType' is set
			if (params.opportunityType == null) {
				throw new Error('Missing required parameter opportunityType when calling salesOpportunitiesTypesIdPut');
			}
			let fetchParams = {
				method: 'PUT',
				headers: headerParams,
				body: JSON.stringify(params.opportunityType),

			};

			if (extraFetchParams) {
				fetchParams = assign(fetchParams, extraFetchParams);
			}

			let localVarPathWithQueryParameters = localVarPath + (localVarPath.indexOf('?') !== -1 ? '&' : '?') + querystring.stringify(queryParameters);

			return fetch(localVarPathWithQueryParameters, fetchParams).then((response) => {
				if (response.status >= 200 && response.status < 300) {
					return response.json();
				} else {
					let error = new Error(response.statusText);
					(error as any).response = response;
					throw error;
				}
			});
		}
		/**
		 *
		 * Create Opportunity Type
		 * @param opportunityType
		 */
		public salesOpportunitiesTypesPost (params: {  opportunityType: OpportunityType; }, extraQueryParams?: any, extraFetchParams?: any ) : Promise<OpportunityType> {
			const localVarPath = this.basePath + '/sales/opportunities/types';

			let queryParameters: any = assign({}, extraQueryParams);
			let headerParams: any = assign({}, this.defaultHeaders);
			headerParams['Content-Type'] = 'application/json';

			// verify required parameter 'opportunityType' is set
			if (params.opportunityType == null) {
				throw new Error('Missing required parameter opportunityType when calling salesOpportunitiesTypesPost');
			}
			let fetchParams = {
				method: 'POST',
				headers: headerParams,
				body: JSON.stringify(params.opportunityType),

			};

			if (extraFetchParams) {
				fetchParams = assign(fetchParams, extraFetchParams);
			}

			let localVarPathWithQueryParameters = localVarPath + (localVarPath.indexOf('?') !== -1 ? '&' : '?') + querystring.stringify(queryParameters);

			return fetch(localVarPathWithQueryParameters, fetchParams).then((response) => {
				if (response.status >= 200 && response.status < 300) {
					return response.json();
				} else {
					let error = new Error(response.statusText);
					(error as any).response = response;
					throw error;
				}
			});
		}
	}
//}
//export namespace  {
	'use strict';

	export class OrderStatusesApi {
		protected basePath = 'https://api-na.myconnectwise.net/v4_6_release/apis/3.0';
		public defaultHeaders : any = {};

		constructor(basePath?: string) {
			if (basePath) {
				this.basePath = basePath;
			}
		}

		/**
		 *
		 * Get Order Statuses Count
		 * @param conditions
		 */
		public salesOrdersStatusesCountGet (params: {  conditions?: string; }, extraQueryParams?: any, extraFetchParams?: any ) : Promise<Count> {
			const localVarPath = this.basePath + '/sales/orders/statuses/count';

			let queryParameters: any = assign({}, extraQueryParams);
			let headerParams: any = assign({}, this.defaultHeaders);
			if (params.conditions !== undefined) {
				queryParameters['conditions'] = params.conditions;
			}

			let fetchParams = {
				method: 'GET',
				headers: headerParams,

			};

			if (extraFetchParams) {
				fetchParams = assign(fetchParams, extraFetchParams);
			}

			let localVarPathWithQueryParameters = localVarPath + (localVarPath.indexOf('?') !== -1 ? '&' : '?') + querystring.stringify(queryParameters);

			return fetch(localVarPathWithQueryParameters, fetchParams).then((response) => {
				if (response.status >= 200 && response.status < 300) {
					return response.json();
				} else {
					let error = new Error(response.statusText);
					(error as any).response = response;
					throw error;
				}
			});
		}
		/**
		 *
		 * Get Order Statuses
		 * @param conditions
		 * @param orderBy
		 * @param childconditions
		 * @param customfieldconditions
		 * @param page
		 * @param pageSize
		 */
		public salesOrdersStatusesGet (params: {  conditions?: string; orderBy?: string; childconditions?: string; customfieldconditions?: string; page?: number; pageSize?: number; }, extraQueryParams?: any, extraFetchParams?: any ) : Promise<Array<OrderStatus>> {
			const localVarPath = this.basePath + '/sales/orders/statuses';

			let queryParameters: any = assign({}, extraQueryParams);
			let headerParams: any = assign({}, this.defaultHeaders);
			if (params.conditions !== undefined) {
				queryParameters['conditions'] = params.conditions;
			}

			if (params.orderBy !== undefined) {
				queryParameters['orderBy'] = params.orderBy;
			}

			if (params.childconditions !== undefined) {
				queryParameters['childconditions'] = params.childconditions;
			}

			if (params.customfieldconditions !== undefined) {
				queryParameters['customfieldconditions'] = params.customfieldconditions;
			}

			if (params.page !== undefined) {
				queryParameters['page'] = params.page;
			}

			if (params.pageSize !== undefined) {
				queryParameters['pageSize'] = params.pageSize;
			}

			let fetchParams = {
				method: 'GET',
				headers: headerParams,

			};

			if (extraFetchParams) {
				fetchParams = assign(fetchParams, extraFetchParams);
			}

			let localVarPathWithQueryParameters = localVarPath + (localVarPath.indexOf('?') !== -1 ? '&' : '?') + querystring.stringify(queryParameters);

			return fetch(localVarPathWithQueryParameters, fetchParams).then((response) => {
				if (response.status >= 200 && response.status < 300) {
					return response.json();
				} else {
					let error = new Error(response.statusText);
					(error as any).response = response;
					throw error;
				}
			});
		}
		/**
		 *
		 * Delete Order Status By Id
		 * @param id
		 */
		public salesOrdersStatusesIdDelete (params: {  id: number; }, extraQueryParams?: any, extraFetchParams?: any ) : Promise<{}> {
			const localVarPath = this.basePath + '/sales/orders/statuses/{id}'
				.replace('{' + 'id' + '}', String(params.id));

			let queryParameters: any = assign({}, extraQueryParams);
			let headerParams: any = assign({}, this.defaultHeaders);
			// verify required parameter 'id' is set
			if (params.id == null) {
				throw new Error('Missing required parameter id when calling salesOrdersStatusesIdDelete');
			}
			let fetchParams = {
				method: 'DELETE',
				headers: headerParams,

			};

			if (extraFetchParams) {
				fetchParams = assign(fetchParams, extraFetchParams);
			}

			let localVarPathWithQueryParameters = localVarPath + (localVarPath.indexOf('?') !== -1 ? '&' : '?') + querystring.stringify(queryParameters);

			return fetch(localVarPathWithQueryParameters, fetchParams).then((response) => {
				if (response.status >= 200 && response.status < 300) {
					return response.json();
				} else {
					let error = new Error(response.statusText);
					(error as any).response = response;
					throw error;
				}
			});
		}
		/**
		 *
		 * Get Order Status By Id
		 * @param id
		 */
		public salesOrdersStatusesIdGet (params: {  id: number; }, extraQueryParams?: any, extraFetchParams?: any ) : Promise<OrderStatus> {
			const localVarPath = this.basePath + '/sales/orders/statuses/{id}'
				.replace('{' + 'id' + '}', String(params.id));

			let queryParameters: any = assign({}, extraQueryParams);
			let headerParams: any = assign({}, this.defaultHeaders);
			// verify required parameter 'id' is set
			if (params.id == null) {
				throw new Error('Missing required parameter id when calling salesOrdersStatusesIdGet');
			}
			let fetchParams = {
				method: 'GET',
				headers: headerParams,

			};

			if (extraFetchParams) {
				fetchParams = assign(fetchParams, extraFetchParams);
			}

			let localVarPathWithQueryParameters = localVarPath + (localVarPath.indexOf('?') !== -1 ? '&' : '?') + querystring.stringify(queryParameters);

			return fetch(localVarPathWithQueryParameters, fetchParams).then((response) => {
				if (response.status >= 200 && response.status < 300) {
					return response.json();
				} else {
					let error = new Error(response.statusText);
					(error as any).response = response;
					throw error;
				}
			});
		}
		/**
		 *
		 * Update Order Status
		 * @param id
		 * @param operations
		 */
		public salesOrdersStatusesIdPatch (params: {  id: number; operations: Array<PatchOperation>; }, extraQueryParams?: any, extraFetchParams?: any ) : Promise<OrderStatus> {
			const localVarPath = this.basePath + '/sales/orders/statuses/{id}'
				.replace('{' + 'id' + '}', String(params.id));

			let queryParameters: any = assign({}, extraQueryParams);
			let headerParams: any = assign({}, this.defaultHeaders);
			headerParams['Content-Type'] = 'application/json';

			// verify required parameter 'id' is set
			if (params.id == null) {
				throw new Error('Missing required parameter id when calling salesOrdersStatusesIdPatch');
			}
			// verify required parameter 'operations' is set
			if (params.operations == null) {
				throw new Error('Missing required parameter operations when calling salesOrdersStatusesIdPatch');
			}
			let fetchParams = {
				method: 'PATCH',
				headers: headerParams,
				body: JSON.stringify(params.operations),

			};

			if (extraFetchParams) {
				fetchParams = assign(fetchParams, extraFetchParams);
			}

			let localVarPathWithQueryParameters = localVarPath + (localVarPath.indexOf('?') !== -1 ? '&' : '?') + querystring.stringify(queryParameters);

			return fetch(localVarPathWithQueryParameters, fetchParams).then((response) => {
				if (response.status >= 200 && response.status < 300) {
					return response.json();
				} else {
					let error = new Error(response.statusText);
					(error as any).response = response;
					throw error;
				}
			});
		}
		/**
		 *
		 * Replace Order Status
		 * @param id
		 * @param status
		 */
		public salesOrdersStatusesIdPut (params: {  id: number; status: OrderStatus; }, extraQueryParams?: any, extraFetchParams?: any ) : Promise<OrderStatus> {
			const localVarPath = this.basePath + '/sales/orders/statuses/{id}'
				.replace('{' + 'id' + '}', String(params.id));

			let queryParameters: any = assign({}, extraQueryParams);
			let headerParams: any = assign({}, this.defaultHeaders);
			headerParams['Content-Type'] = 'application/json';

			// verify required parameter 'id' is set
			if (params.id == null) {
				throw new Error('Missing required parameter id when calling salesOrdersStatusesIdPut');
			}
			// verify required parameter 'status' is set
			if (params.status == null) {
				throw new Error('Missing required parameter status when calling salesOrdersStatusesIdPut');
			}
			let fetchParams = {
				method: 'PUT',
				headers: headerParams,
				body: JSON.stringify(params.status),

			};

			if (extraFetchParams) {
				fetchParams = assign(fetchParams, extraFetchParams);
			}

			let localVarPathWithQueryParameters = localVarPath + (localVarPath.indexOf('?') !== -1 ? '&' : '?') + querystring.stringify(queryParameters);

			return fetch(localVarPathWithQueryParameters, fetchParams).then((response) => {
				if (response.status >= 200 && response.status < 300) {
					return response.json();
				} else {
					let error = new Error(response.statusText);
					(error as any).response = response;
					throw error;
				}
			});
		}
		/**
		 *
		 * Create Order Status
		 * @param status
		 */
		public salesOrdersStatusesPost (params: {  status: OrderStatus; }, extraQueryParams?: any, extraFetchParams?: any ) : Promise<Array<OrderStatus>> {
			const localVarPath = this.basePath + '/sales/orders/statuses';

			let queryParameters: any = assign({}, extraQueryParams);
			let headerParams: any = assign({}, this.defaultHeaders);
			headerParams['Content-Type'] = 'application/json';

			// verify required parameter 'status' is set
			if (params.status == null) {
				throw new Error('Missing required parameter status when calling salesOrdersStatusesPost');
			}
			let fetchParams = {
				method: 'POST',
				headers: headerParams,
				body: JSON.stringify(params.status),

			};

			if (extraFetchParams) {
				fetchParams = assign(fetchParams, extraFetchParams);
			}

			let localVarPathWithQueryParameters = localVarPath + (localVarPath.indexOf('?') !== -1 ? '&' : '?') + querystring.stringify(queryParameters);

			return fetch(localVarPathWithQueryParameters, fetchParams).then((response) => {
				if (response.status >= 200 && response.status < 300) {
					return response.json();
				} else {
					let error = new Error(response.statusText);
					(error as any).response = response;
					throw error;
				}
			});
		}
	}
//}
//export namespace  {
	'use strict';

	export class OrdersApi {
		protected basePath = 'https://api-na.myconnectwise.net/v4_6_release/apis/3.0';
		public defaultHeaders : any = {};

		constructor(basePath?: string) {
			if (basePath) {
				this.basePath = basePath;
			}
		}

		/**
		 *
		 * Get Sales Orders Count
		 * @param conditions
		 * @param customFieldConditions
		 */
		public salesOrdersCountGet (params: {  conditions?: string; customFieldConditions?: string; }, extraQueryParams?: any, extraFetchParams?: any ) : Promise<Count> {
			const localVarPath = this.basePath + '/sales/orders/count';

			let queryParameters: any = assign({}, extraQueryParams);
			let headerParams: any = assign({}, this.defaultHeaders);
			if (params.conditions !== undefined) {
				queryParameters['conditions'] = params.conditions;
			}

			if (params.customFieldConditions !== undefined) {
				queryParameters['customFieldConditions'] = params.customFieldConditions;
			}

			let fetchParams = {
				method: 'GET',
				headers: headerParams,

			};

			if (extraFetchParams) {
				fetchParams = assign(fetchParams, extraFetchParams);
			}

			let localVarPathWithQueryParameters = localVarPath + (localVarPath.indexOf('?') !== -1 ? '&' : '?') + querystring.stringify(queryParameters);

			return fetch(localVarPathWithQueryParameters, fetchParams).then((response) => {
				if (response.status >= 200 && response.status < 300) {
					return response.json();
				} else {
					let error = new Error(response.statusText);
					(error as any).response = response;
					throw error;
				}
			});
		}
		/**
		 *
		 * Get Sales Orders
		 * @param conditions
		 * @param orderBy
		 * @param childconditions
		 * @param customfieldconditions
		 * @param page
		 * @param pageSize
		 */
		public salesOrdersGet (params: {  conditions?: string; orderBy?: string; childconditions?: string; customfieldconditions?: string; page?: number; pageSize?: number; }, extraQueryParams?: any, extraFetchParams?: any ) : Promise<Array<Order>> {
			const localVarPath = this.basePath + '/sales/orders';

			let queryParameters: any = assign({}, extraQueryParams);
			let headerParams: any = assign({}, this.defaultHeaders);
			if (params.conditions !== undefined) {
				queryParameters['conditions'] = params.conditions;
			}

			if (params.orderBy !== undefined) {
				queryParameters['orderBy'] = params.orderBy;
			}

			if (params.childconditions !== undefined) {
				queryParameters['childconditions'] = params.childconditions;
			}

			if (params.customfieldconditions !== undefined) {
				queryParameters['customfieldconditions'] = params.customfieldconditions;
			}

			if (params.page !== undefined) {
				queryParameters['page'] = params.page;
			}

			if (params.pageSize !== undefined) {
				queryParameters['pageSize'] = params.pageSize;
			}

			let fetchParams = {
				method: 'GET',
				headers: headerParams,

			};

			if (extraFetchParams) {
				fetchParams = assign(fetchParams, extraFetchParams);
			}

			let localVarPathWithQueryParameters = localVarPath + (localVarPath.indexOf('?') !== -1 ? '&' : '?') + querystring.stringify(queryParameters);

			return fetch(localVarPathWithQueryParameters, fetchParams).then((response) => {
				if (response.status >= 200 && response.status < 300) {
					return response.json();
				} else {
					let error = new Error(response.statusText);
					(error as any).response = response;
					throw error;
				}
			});
		}
		/**
		 *
		 * Delete Sales Order By Id
		 * @param id
		 */
		public salesOrdersIdDelete (params: {  id: number; }, extraQueryParams?: any, extraFetchParams?: any ) : Promise<{}> {
			const localVarPath = this.basePath + '/sales/orders/{id}'
				.replace('{' + 'id' + '}', String(params.id));

			let queryParameters: any = assign({}, extraQueryParams);
			let headerParams: any = assign({}, this.defaultHeaders);
			// verify required parameter 'id' is set
			if (params.id == null) {
				throw new Error('Missing required parameter id when calling salesOrdersIdDelete');
			}
			let fetchParams = {
				method: 'DELETE',
				headers: headerParams,

			};

			if (extraFetchParams) {
				fetchParams = assign(fetchParams, extraFetchParams);
			}

			let localVarPathWithQueryParameters = localVarPath + (localVarPath.indexOf('?') !== -1 ? '&' : '?') + querystring.stringify(queryParameters);

			return fetch(localVarPathWithQueryParameters, fetchParams).then((response) => {
				if (response.status >= 200 && response.status < 300) {
					return response.json();
				} else {
					let error = new Error(response.statusText);
					(error as any).response = response;
					throw error;
				}
			});
		}
		/**
		 *
		 * Get Sales Order By Id
		 * @param id
		 */
		public salesOrdersIdGet (params: {  id: number; }, extraQueryParams?: any, extraFetchParams?: any ) : Promise<Order> {
			const localVarPath = this.basePath + '/sales/orders/{id}'
				.replace('{' + 'id' + '}', String(params.id));

			let queryParameters: any = assign({}, extraQueryParams);
			let headerParams: any = assign({}, this.defaultHeaders);
			// verify required parameter 'id' is set
			if (params.id == null) {
				throw new Error('Missing required parameter id when calling salesOrdersIdGet');
			}
			let fetchParams = {
				method: 'GET',
				headers: headerParams,

			};

			if (extraFetchParams) {
				fetchParams = assign(fetchParams, extraFetchParams);
			}

			let localVarPathWithQueryParameters = localVarPath + (localVarPath.indexOf('?') !== -1 ? '&' : '?') + querystring.stringify(queryParameters);

			return fetch(localVarPathWithQueryParameters, fetchParams).then((response) => {
				if (response.status >= 200 && response.status < 300) {
					return response.json();
				} else {
					let error = new Error(response.statusText);
					(error as any).response = response;
					throw error;
				}
			});
		}
		/**
		 *
		 * Update Sales Order
		 * @param id
		 * @param operations
		 */
		public salesOrdersIdPatch (params: {  id: number; operations: Array<PatchOperation>; }, extraQueryParams?: any, extraFetchParams?: any ) : Promise<Order> {
			const localVarPath = this.basePath + '/sales/orders/{id}'
				.replace('{' + 'id' + '}', String(params.id));

			let queryParameters: any = assign({}, extraQueryParams);
			let headerParams: any = assign({}, this.defaultHeaders);
			headerParams['Content-Type'] = 'application/json';

			// verify required parameter 'id' is set
			if (params.id == null) {
				throw new Error('Missing required parameter id when calling salesOrdersIdPatch');
			}
			// verify required parameter 'operations' is set
			if (params.operations == null) {
				throw new Error('Missing required parameter operations when calling salesOrdersIdPatch');
			}
			let fetchParams = {
				method: 'PATCH',
				headers: headerParams,
				body: JSON.stringify(params.operations),

			};

			if (extraFetchParams) {
				fetchParams = assign(fetchParams, extraFetchParams);
			}

			let localVarPathWithQueryParameters = localVarPath + (localVarPath.indexOf('?') !== -1 ? '&' : '?') + querystring.stringify(queryParameters);

			return fetch(localVarPathWithQueryParameters, fetchParams).then((response) => {
				if (response.status >= 200 && response.status < 300) {
					return response.json();
				} else {
					let error = new Error(response.statusText);
					(error as any).response = response;
					throw error;
				}
			});
		}
		/**
		 *
		 * Replace Sales Order
		 * @param id
		 * @param order
		 */
		public salesOrdersIdPut (params: {  id: number; order: Order; }, extraQueryParams?: any, extraFetchParams?: any ) : Promise<Order> {
			const localVarPath = this.basePath + '/sales/orders/{id}'
				.replace('{' + 'id' + '}', String(params.id));

			let queryParameters: any = assign({}, extraQueryParams);
			let headerParams: any = assign({}, this.defaultHeaders);
			headerParams['Content-Type'] = 'application/json';

			// verify required parameter 'id' is set
			if (params.id == null) {
				throw new Error('Missing required parameter id when calling salesOrdersIdPut');
			}
			// verify required parameter 'order' is set
			if (params.order == null) {
				throw new Error('Missing required parameter order when calling salesOrdersIdPut');
			}
			let fetchParams = {
				method: 'PUT',
				headers: headerParams,
				body: JSON.stringify(params.order),

			};

			if (extraFetchParams) {
				fetchParams = assign(fetchParams, extraFetchParams);
			}

			let localVarPathWithQueryParameters = localVarPath + (localVarPath.indexOf('?') !== -1 ? '&' : '?') + querystring.stringify(queryParameters);

			return fetch(localVarPathWithQueryParameters, fetchParams).then((response) => {
				if (response.status >= 200 && response.status < 300) {
					return response.json();
				} else {
					let error = new Error(response.statusText);
					(error as any).response = response;
					throw error;
				}
			});
		}
		/**
		 *
		 * Create Sales Order
		 * @param order
		 */
		public salesOrdersPost (params: {  order: Order; }, extraQueryParams?: any, extraFetchParams?: any ) : Promise<Array<Order>> {
			const localVarPath = this.basePath + '/sales/orders';

			let queryParameters: any = assign({}, extraQueryParams);
			let headerParams: any = assign({}, this.defaultHeaders);
			headerParams['Content-Type'] = 'application/json';

			// verify required parameter 'order' is set
			if (params.order == null) {
				throw new Error('Missing required parameter order when calling salesOrdersPost');
			}
			let fetchParams = {
				method: 'POST',
				headers: headerParams,
				body: JSON.stringify(params.order),

			};

			if (extraFetchParams) {
				fetchParams = assign(fetchParams, extraFetchParams);
			}

			let localVarPathWithQueryParameters = localVarPath + (localVarPath.indexOf('?') !== -1 ? '&' : '?') + querystring.stringify(queryParameters);

			return fetch(localVarPathWithQueryParameters, fetchParams).then((response) => {
				if (response.status >= 200 && response.status < 300) {
					return response.json();
				} else {
					let error = new Error(response.statusText);
					(error as any).response = response;
					throw error;
				}
			});
		}
	}
//}
//export namespace  {
	'use strict';

	export class OwnershipTypesApi {
		protected basePath = 'https://api-na.myconnectwise.net/v4_6_release/apis/3.0';
		public defaultHeaders : any = {};

		constructor(basePath?: string) {
			if (basePath) {
				this.basePath = basePath;
			}
		}

		/**
		 *
		 * Get Ownership Type Count
		 * @param conditions
		 */
		public companyOwnershipTypesCountGet (params: {  conditions?: string; }, extraQueryParams?: any, extraFetchParams?: any ) : Promise<Count> {
			const localVarPath = this.basePath + '/company/ownershipTypes/count';

			let queryParameters: any = assign({}, extraQueryParams);
			let headerParams: any = assign({}, this.defaultHeaders);
			if (params.conditions !== undefined) {
				queryParameters['conditions'] = params.conditions;
			}

			let fetchParams = {
				method: 'GET',
				headers: headerParams,

			};

			if (extraFetchParams) {
				fetchParams = assign(fetchParams, extraFetchParams);
			}

			let localVarPathWithQueryParameters = localVarPath + (localVarPath.indexOf('?') !== -1 ? '&' : '?') + querystring.stringify(queryParameters);

			return fetch(localVarPathWithQueryParameters, fetchParams).then((response) => {
				if (response.status >= 200 && response.status < 300) {
					return response.json();
				} else {
					let error = new Error(response.statusText);
					(error as any).response = response;
					throw error;
				}
			});
		}
		/**
		 *
		 * Get Ownership Type
		 * @param conditions
		 * @param orderBy
		 * @param childconditions
		 * @param customfieldconditions
		 * @param page
		 * @param pageSize
		 */
		public companyOwnershipTypesGet (params: {  conditions?: string; orderBy?: string; childconditions?: string; customfieldconditions?: string; page?: number; pageSize?: number; }, extraQueryParams?: any, extraFetchParams?: any ) : Promise<Array<OwnershipType>> {
			const localVarPath = this.basePath + '/company/ownershipTypes';

			let queryParameters: any = assign({}, extraQueryParams);
			let headerParams: any = assign({}, this.defaultHeaders);
			if (params.conditions !== undefined) {
				queryParameters['conditions'] = params.conditions;
			}

			if (params.orderBy !== undefined) {
				queryParameters['orderBy'] = params.orderBy;
			}

			if (params.childconditions !== undefined) {
				queryParameters['childconditions'] = params.childconditions;
			}

			if (params.customfieldconditions !== undefined) {
				queryParameters['customfieldconditions'] = params.customfieldconditions;
			}

			if (params.page !== undefined) {
				queryParameters['page'] = params.page;
			}

			if (params.pageSize !== undefined) {
				queryParameters['pageSize'] = params.pageSize;
			}

			let fetchParams = {
				method: 'GET',
				headers: headerParams,

			};

			if (extraFetchParams) {
				fetchParams = assign(fetchParams, extraFetchParams);
			}

			let localVarPathWithQueryParameters = localVarPath + (localVarPath.indexOf('?') !== -1 ? '&' : '?') + querystring.stringify(queryParameters);

			return fetch(localVarPathWithQueryParameters, fetchParams).then((response) => {
				if (response.status >= 200 && response.status < 300) {
					return response.json();
				} else {
					let error = new Error(response.statusText);
					(error as any).response = response;
					throw error;
				}
			});
		}
		/**
		 *
		 * Delete Ownership Type By Id
		 * @param id
		 */
		public companyOwnershipTypesIdDelete (params: {  id: number; }, extraQueryParams?: any, extraFetchParams?: any ) : Promise<{}> {
			const localVarPath = this.basePath + '/company/ownershipTypes/{id}'
				.replace('{' + 'id' + '}', String(params.id));

			let queryParameters: any = assign({}, extraQueryParams);
			let headerParams: any = assign({}, this.defaultHeaders);
			// verify required parameter 'id' is set
			if (params.id == null) {
				throw new Error('Missing required parameter id when calling companyOwnershipTypesIdDelete');
			}
			let fetchParams = {
				method: 'DELETE',
				headers: headerParams,

			};

			if (extraFetchParams) {
				fetchParams = assign(fetchParams, extraFetchParams);
			}

			let localVarPathWithQueryParameters = localVarPath + (localVarPath.indexOf('?') !== -1 ? '&' : '?') + querystring.stringify(queryParameters);

			return fetch(localVarPathWithQueryParameters, fetchParams).then((response) => {
				if (response.status >= 200 && response.status < 300) {
					return response.json();
				} else {
					let error = new Error(response.statusText);
					(error as any).response = response;
					throw error;
				}
			});
		}
		/**
		 *
		 * Get Ownership Type By Id
		 * @param id
		 */
		public companyOwnershipTypesIdGet (params: {  id: number; }, extraQueryParams?: any, extraFetchParams?: any ) : Promise<OwnershipType> {
			const localVarPath = this.basePath + '/company/ownershipTypes/{id}'
				.replace('{' + 'id' + '}', String(params.id));

			let queryParameters: any = assign({}, extraQueryParams);
			let headerParams: any = assign({}, this.defaultHeaders);
			// verify required parameter 'id' is set
			if (params.id == null) {
				throw new Error('Missing required parameter id when calling companyOwnershipTypesIdGet');
			}
			let fetchParams = {
				method: 'GET',
				headers: headerParams,

			};

			if (extraFetchParams) {
				fetchParams = assign(fetchParams, extraFetchParams);
			}

			let localVarPathWithQueryParameters = localVarPath + (localVarPath.indexOf('?') !== -1 ? '&' : '?') + querystring.stringify(queryParameters);

			return fetch(localVarPathWithQueryParameters, fetchParams).then((response) => {
				if (response.status >= 200 && response.status < 300) {
					return response.json();
				} else {
					let error = new Error(response.statusText);
					(error as any).response = response;
					throw error;
				}
			});
		}
		/**
		 *
		 * Update Ownership Type
		 * @param id
		 * @param operations
		 */
		public companyOwnershipTypesIdPatch (params: {  id: number; operations: Array<PatchOperation>; }, extraQueryParams?: any, extraFetchParams?: any ) : Promise<OwnershipType> {
			const localVarPath = this.basePath + '/company/ownershipTypes/{id}'
				.replace('{' + 'id' + '}', String(params.id));

			let queryParameters: any = assign({}, extraQueryParams);
			let headerParams: any = assign({}, this.defaultHeaders);
			headerParams['Content-Type'] = 'application/json';

			// verify required parameter 'id' is set
			if (params.id == null) {
				throw new Error('Missing required parameter id when calling companyOwnershipTypesIdPatch');
			}
			// verify required parameter 'operations' is set
			if (params.operations == null) {
				throw new Error('Missing required parameter operations when calling companyOwnershipTypesIdPatch');
			}
			let fetchParams = {
				method: 'PATCH',
				headers: headerParams,
				body: JSON.stringify(params.operations),

			};

			if (extraFetchParams) {
				fetchParams = assign(fetchParams, extraFetchParams);
			}

			let localVarPathWithQueryParameters = localVarPath + (localVarPath.indexOf('?') !== -1 ? '&' : '?') + querystring.stringify(queryParameters);

			return fetch(localVarPathWithQueryParameters, fetchParams).then((response) => {
				if (response.status >= 200 && response.status < 300) {
					return response.json();
				} else {
					let error = new Error(response.statusText);
					(error as any).response = response;
					throw error;
				}
			});
		}
		/**
		 *
		 * Replace Ownership Type
		 * @param id
		 * @param ownershipType
		 */
		public companyOwnershipTypesIdPut (params: {  id: number; ownershipType: OwnershipType; }, extraQueryParams?: any, extraFetchParams?: any ) : Promise<OwnershipType> {
			const localVarPath = this.basePath + '/company/ownershipTypes/{id}'
				.replace('{' + 'id' + '}', String(params.id));

			let queryParameters: any = assign({}, extraQueryParams);
			let headerParams: any = assign({}, this.defaultHeaders);
			headerParams['Content-Type'] = 'application/json';

			// verify required parameter 'id' is set
			if (params.id == null) {
				throw new Error('Missing required parameter id when calling companyOwnershipTypesIdPut');
			}
			// verify required parameter 'ownershipType' is set
			if (params.ownershipType == null) {
				throw new Error('Missing required parameter ownershipType when calling companyOwnershipTypesIdPut');
			}
			let fetchParams = {
				method: 'PUT',
				headers: headerParams,
				body: JSON.stringify(params.ownershipType),

			};

			if (extraFetchParams) {
				fetchParams = assign(fetchParams, extraFetchParams);
			}

			let localVarPathWithQueryParameters = localVarPath + (localVarPath.indexOf('?') !== -1 ? '&' : '?') + querystring.stringify(queryParameters);

			return fetch(localVarPathWithQueryParameters, fetchParams).then((response) => {
				if (response.status >= 200 && response.status < 300) {
					return response.json();
				} else {
					let error = new Error(response.statusText);
					(error as any).response = response;
					throw error;
				}
			});
		}
		/**
		 *
		 * Create Ownership Type
		 * @param ownershipType
		 */
		public companyOwnershipTypesPost (params: {  ownershipType: OwnershipType; }, extraQueryParams?: any, extraFetchParams?: any ) : Promise<OwnershipType> {
			const localVarPath = this.basePath + '/company/ownershipTypes';

			let queryParameters: any = assign({}, extraQueryParams);
			let headerParams: any = assign({}, this.defaultHeaders);
			headerParams['Content-Type'] = 'application/json';

			// verify required parameter 'ownershipType' is set
			if (params.ownershipType == null) {
				throw new Error('Missing required parameter ownershipType when calling companyOwnershipTypesPost');
			}
			let fetchParams = {
				method: 'POST',
				headers: headerParams,
				body: JSON.stringify(params.ownershipType),

			};

			if (extraFetchParams) {
				fetchParams = assign(fetchParams, extraFetchParams);
			}

			let localVarPathWithQueryParameters = localVarPath + (localVarPath.indexOf('?') !== -1 ? '&' : '?') + querystring.stringify(queryParameters);

			return fetch(localVarPathWithQueryParameters, fetchParams).then((response) => {
				if (response.status >= 200 && response.status < 300) {
					return response.json();
				} else {
					let error = new Error(response.statusText);
					(error as any).response = response;
					throw error;
				}
			});
		}
	}
//}
//export namespace  {
	'use strict';

	export class PricingBreaksApi {
		protected basePath = 'https://api-na.myconnectwise.net/v4_6_release/apis/3.0';
		public defaultHeaders : any = {};

		constructor(basePath?: string) {
			if (basePath) {
				this.basePath = basePath;
			}
		}

		/**
		 *
		 * Delete Pricing Break By Id
		 * @param schedId
		 * @param detailId
		 * @param breakId
		 */
		public procurementPricingschedulesSchedIdDetailsDetailIdBreaksBreakIdDelete (params: {  schedId: number; detailId: number; breakId: number; }, extraQueryParams?: any, extraFetchParams?: any ) : Promise<{}> {
			const localVarPath = this.basePath + '/procurement/pricingschedules/{schedId}/details/{detailId}/breaks/{breakId}'
				.replace('{' + 'schedId' + '}', String(params.schedId))
				.replace('{' + 'detailId' + '}', String(params.detailId))
				.replace('{' + 'breakId' + '}', String(params.breakId));

			let queryParameters: any = assign({}, extraQueryParams);
			let headerParams: any = assign({}, this.defaultHeaders);
			// verify required parameter 'schedId' is set
			if (params.schedId == null) {
				throw new Error('Missing required parameter schedId when calling procurementPricingschedulesSchedIdDetailsDetailIdBreaksBreakIdDelete');
			}
			// verify required parameter 'detailId' is set
			if (params.detailId == null) {
				throw new Error('Missing required parameter detailId when calling procurementPricingschedulesSchedIdDetailsDetailIdBreaksBreakIdDelete');
			}
			// verify required parameter 'breakId' is set
			if (params.breakId == null) {
				throw new Error('Missing required parameter breakId when calling procurementPricingschedulesSchedIdDetailsDetailIdBreaksBreakIdDelete');
			}
			let fetchParams = {
				method: 'DELETE',
				headers: headerParams,

			};

			if (extraFetchParams) {
				fetchParams = assign(fetchParams, extraFetchParams);
			}

			let localVarPathWithQueryParameters = localVarPath + (localVarPath.indexOf('?') !== -1 ? '&' : '?') + querystring.stringify(queryParameters);

			return fetch(localVarPathWithQueryParameters, fetchParams).then((response) => {
				if (response.status >= 200 && response.status < 300) {
					return response.json();
				} else {
					let error = new Error(response.statusText);
					(error as any).response = response;
					throw error;
				}
			});
		}
		/**
		 *
		 * Get Pricing Break By Id
		 * @param schedId
		 * @param detailId
		 * @param breakId
		 */
		public procurementPricingschedulesSchedIdDetailsDetailIdBreaksBreakIdGet (params: {  schedId: number; detailId: number; breakId: number; }, extraQueryParams?: any, extraFetchParams?: any ) : Promise<PricingBreak> {
			const localVarPath = this.basePath + '/procurement/pricingschedules/{schedId}/details/{detailId}/breaks/{breakId}'
				.replace('{' + 'schedId' + '}', String(params.schedId))
				.replace('{' + 'detailId' + '}', String(params.detailId))
				.replace('{' + 'breakId' + '}', String(params.breakId));

			let queryParameters: any = assign({}, extraQueryParams);
			let headerParams: any = assign({}, this.defaultHeaders);
			// verify required parameter 'schedId' is set
			if (params.schedId == null) {
				throw new Error('Missing required parameter schedId when calling procurementPricingschedulesSchedIdDetailsDetailIdBreaksBreakIdGet');
			}
			// verify required parameter 'detailId' is set
			if (params.detailId == null) {
				throw new Error('Missing required parameter detailId when calling procurementPricingschedulesSchedIdDetailsDetailIdBreaksBreakIdGet');
			}
			// verify required parameter 'breakId' is set
			if (params.breakId == null) {
				throw new Error('Missing required parameter breakId when calling procurementPricingschedulesSchedIdDetailsDetailIdBreaksBreakIdGet');
			}
			let fetchParams = {
				method: 'GET',
				headers: headerParams,

			};

			if (extraFetchParams) {
				fetchParams = assign(fetchParams, extraFetchParams);
			}

			let localVarPathWithQueryParameters = localVarPath + (localVarPath.indexOf('?') !== -1 ? '&' : '?') + querystring.stringify(queryParameters);

			return fetch(localVarPathWithQueryParameters, fetchParams).then((response) => {
				if (response.status >= 200 && response.status < 300) {
					return response.json();
				} else {
					let error = new Error(response.statusText);
					(error as any).response = response;
					throw error;
				}
			});
		}
		/**
		 *
		 * Update Pricing Break
		 * @param schedId
		 * @param detailId
		 * @param breakId
		 * @param operations
		 */
		public procurementPricingschedulesSchedIdDetailsDetailIdBreaksBreakIdPatch (params: {  schedId: number; detailId: number; breakId: number; operations: Array<PatchOperation>; }, extraQueryParams?: any, extraFetchParams?: any ) : Promise<PricingBreak> {
			const localVarPath = this.basePath + '/procurement/pricingschedules/{schedId}/details/{detailId}/breaks/{breakId}'
				.replace('{' + 'schedId' + '}', String(params.schedId))
				.replace('{' + 'detailId' + '}', String(params.detailId))
				.replace('{' + 'breakId' + '}', String(params.breakId));

			let queryParameters: any = assign({}, extraQueryParams);
			let headerParams: any = assign({}, this.defaultHeaders);
			headerParams['Content-Type'] = 'application/json';

			// verify required parameter 'schedId' is set
			if (params.schedId == null) {
				throw new Error('Missing required parameter schedId when calling procurementPricingschedulesSchedIdDetailsDetailIdBreaksBreakIdPatch');
			}
			// verify required parameter 'detailId' is set
			if (params.detailId == null) {
				throw new Error('Missing required parameter detailId when calling procurementPricingschedulesSchedIdDetailsDetailIdBreaksBreakIdPatch');
			}
			// verify required parameter 'breakId' is set
			if (params.breakId == null) {
				throw new Error('Missing required parameter breakId when calling procurementPricingschedulesSchedIdDetailsDetailIdBreaksBreakIdPatch');
			}
			// verify required parameter 'operations' is set
			if (params.operations == null) {
				throw new Error('Missing required parameter operations when calling procurementPricingschedulesSchedIdDetailsDetailIdBreaksBreakIdPatch');
			}
			let fetchParams = {
				method: 'PATCH',
				headers: headerParams,
				body: JSON.stringify(params.operations),

			};

			if (extraFetchParams) {
				fetchParams = assign(fetchParams, extraFetchParams);
			}

			let localVarPathWithQueryParameters = localVarPath + (localVarPath.indexOf('?') !== -1 ? '&' : '?') + querystring.stringify(queryParameters);

			return fetch(localVarPathWithQueryParameters, fetchParams).then((response) => {
				if (response.status >= 200 && response.status < 300) {
					return response.json();
				} else {
					let error = new Error(response.statusText);
					(error as any).response = response;
					throw error;
				}
			});
		}
		/**
		 *
		 * Replace Pricing Break
		 * @param schedId
		 * @param detailId
		 * @param breakId
		 * @param pricingBreak
		 */
		public procurementPricingschedulesSchedIdDetailsDetailIdBreaksBreakIdPut (params: {  schedId: number; detailId: number; breakId: number; pricingBreak: PricingBreak; }, extraQueryParams?: any, extraFetchParams?: any ) : Promise<PricingBreak> {
			const localVarPath = this.basePath + '/procurement/pricingschedules/{schedId}/details/{detailId}/breaks/{breakId}'
				.replace('{' + 'schedId' + '}', String(params.schedId))
				.replace('{' + 'detailId' + '}', String(params.detailId))
				.replace('{' + 'breakId' + '}', String(params.breakId));

			let queryParameters: any = assign({}, extraQueryParams);
			let headerParams: any = assign({}, this.defaultHeaders);
			headerParams['Content-Type'] = 'application/json';

			// verify required parameter 'schedId' is set
			if (params.schedId == null) {
				throw new Error('Missing required parameter schedId when calling procurementPricingschedulesSchedIdDetailsDetailIdBreaksBreakIdPut');
			}
			// verify required parameter 'detailId' is set
			if (params.detailId == null) {
				throw new Error('Missing required parameter detailId when calling procurementPricingschedulesSchedIdDetailsDetailIdBreaksBreakIdPut');
			}
			// verify required parameter 'breakId' is set
			if (params.breakId == null) {
				throw new Error('Missing required parameter breakId when calling procurementPricingschedulesSchedIdDetailsDetailIdBreaksBreakIdPut');
			}
			// verify required parameter 'pricingBreak' is set
			if (params.pricingBreak == null) {
				throw new Error('Missing required parameter pricingBreak when calling procurementPricingschedulesSchedIdDetailsDetailIdBreaksBreakIdPut');
			}
			let fetchParams = {
				method: 'PUT',
				headers: headerParams,
				body: JSON.stringify(params.pricingBreak),

			};

			if (extraFetchParams) {
				fetchParams = assign(fetchParams, extraFetchParams);
			}

			let localVarPathWithQueryParameters = localVarPath + (localVarPath.indexOf('?') !== -1 ? '&' : '?') + querystring.stringify(queryParameters);

			return fetch(localVarPathWithQueryParameters, fetchParams).then((response) => {
				if (response.status >= 200 && response.status < 300) {
					return response.json();
				} else {
					let error = new Error(response.statusText);
					(error as any).response = response;
					throw error;
				}
			});
		}
		/**
		 *
		 * Get Pricing Break Count
		 * @param schedId
		 * @param detailId
		 * @param conditions
		 */
		public procurementPricingschedulesSchedIdDetailsDetailIdBreaksCountGet (params: {  schedId: number; detailId: number; conditions?: string; }, extraQueryParams?: any, extraFetchParams?: any ) : Promise<Count> {
			const localVarPath = this.basePath + '/procurement/pricingschedules/{schedId}/details/{detailId}/breaks/count'
				.replace('{' + 'schedId' + '}', String(params.schedId))
				.replace('{' + 'detailId' + '}', String(params.detailId));

			let queryParameters: any = assign({}, extraQueryParams);
			let headerParams: any = assign({}, this.defaultHeaders);
			// verify required parameter 'schedId' is set
			if (params.schedId == null) {
				throw new Error('Missing required parameter schedId when calling procurementPricingschedulesSchedIdDetailsDetailIdBreaksCountGet');
			}
			// verify required parameter 'detailId' is set
			if (params.detailId == null) {
				throw new Error('Missing required parameter detailId when calling procurementPricingschedulesSchedIdDetailsDetailIdBreaksCountGet');
			}
			if (params.conditions !== undefined) {
				queryParameters['conditions'] = params.conditions;
			}

			let fetchParams = {
				method: 'GET',
				headers: headerParams,

			};

			if (extraFetchParams) {
				fetchParams = assign(fetchParams, extraFetchParams);
			}

			let localVarPathWithQueryParameters = localVarPath + (localVarPath.indexOf('?') !== -1 ? '&' : '?') + querystring.stringify(queryParameters);

			return fetch(localVarPathWithQueryParameters, fetchParams).then((response) => {
				if (response.status >= 200 && response.status < 300) {
					return response.json();
				} else {
					let error = new Error(response.statusText);
					(error as any).response = response;
					throw error;
				}
			});
		}
		/**
		 *
		 * Get Pricing Break
		 * @param schedId
		 * @param detailId
		 * @param conditions
		 * @param orderBy
		 * @param childconditions
		 * @param customfieldconditions
		 * @param page
		 * @param pageSize
		 */
		public procurementPricingschedulesSchedIdDetailsDetailIdBreaksGet (params: {  schedId: number; detailId: number; conditions?: string; orderBy?: string; childconditions?: string; customfieldconditions?: string; page?: number; pageSize?: number; }, extraQueryParams?: any, extraFetchParams?: any ) : Promise<Array<PricingBreak>> {
			const localVarPath = this.basePath + '/procurement/pricingschedules/{schedId}/details/{detailId}/breaks'
				.replace('{' + 'schedId' + '}', String(params.schedId))
				.replace('{' + 'detailId' + '}', String(params.detailId));

			let queryParameters: any = assign({}, extraQueryParams);
			let headerParams: any = assign({}, this.defaultHeaders);
			// verify required parameter 'schedId' is set
			if (params.schedId == null) {
				throw new Error('Missing required parameter schedId when calling procurementPricingschedulesSchedIdDetailsDetailIdBreaksGet');
			}
			// verify required parameter 'detailId' is set
			if (params.detailId == null) {
				throw new Error('Missing required parameter detailId when calling procurementPricingschedulesSchedIdDetailsDetailIdBreaksGet');
			}
			if (params.conditions !== undefined) {
				queryParameters['conditions'] = params.conditions;
			}

			if (params.orderBy !== undefined) {
				queryParameters['orderBy'] = params.orderBy;
			}

			if (params.childconditions !== undefined) {
				queryParameters['childconditions'] = params.childconditions;
			}

			if (params.customfieldconditions !== undefined) {
				queryParameters['customfieldconditions'] = params.customfieldconditions;
			}

			if (params.page !== undefined) {
				queryParameters['page'] = params.page;
			}

			if (params.pageSize !== undefined) {
				queryParameters['pageSize'] = params.pageSize;
			}

			let fetchParams = {
				method: 'GET',
				headers: headerParams,

			};

			if (extraFetchParams) {
				fetchParams = assign(fetchParams, extraFetchParams);
			}

			let localVarPathWithQueryParameters = localVarPath + (localVarPath.indexOf('?') !== -1 ? '&' : '?') + querystring.stringify(queryParameters);

			return fetch(localVarPathWithQueryParameters, fetchParams).then((response) => {
				if (response.status >= 200 && response.status < 300) {
					return response.json();
				} else {
					let error = new Error(response.statusText);
					(error as any).response = response;
					throw error;
				}
			});
		}
		/**
		 *
		 * Create Pricing Break
		 * @param schedId
		 * @param detailId
		 * @param pricingBreak
		 */
		public procurementPricingschedulesSchedIdDetailsDetailIdBreaksPost (params: {  schedId: number; detailId: number; pricingBreak: PricingBreak; }, extraQueryParams?: any, extraFetchParams?: any ) : Promise<PricingBreak> {
			const localVarPath = this.basePath + '/procurement/pricingschedules/{schedId}/details/{detailId}/breaks'
				.replace('{' + 'schedId' + '}', String(params.schedId))
				.replace('{' + 'detailId' + '}', String(params.detailId));

			let queryParameters: any = assign({}, extraQueryParams);
			let headerParams: any = assign({}, this.defaultHeaders);
			headerParams['Content-Type'] = 'application/json';

			// verify required parameter 'schedId' is set
			if (params.schedId == null) {
				throw new Error('Missing required parameter schedId when calling procurementPricingschedulesSchedIdDetailsDetailIdBreaksPost');
			}
			// verify required parameter 'detailId' is set
			if (params.detailId == null) {
				throw new Error('Missing required parameter detailId when calling procurementPricingschedulesSchedIdDetailsDetailIdBreaksPost');
			}
			// verify required parameter 'pricingBreak' is set
			if (params.pricingBreak == null) {
				throw new Error('Missing required parameter pricingBreak when calling procurementPricingschedulesSchedIdDetailsDetailIdBreaksPost');
			}
			let fetchParams = {
				method: 'POST',
				headers: headerParams,
				body: JSON.stringify(params.pricingBreak),

			};

			if (extraFetchParams) {
				fetchParams = assign(fetchParams, extraFetchParams);
			}

			let localVarPathWithQueryParameters = localVarPath + (localVarPath.indexOf('?') !== -1 ? '&' : '?') + querystring.stringify(queryParameters);

			return fetch(localVarPathWithQueryParameters, fetchParams).then((response) => {
				if (response.status >= 200 && response.status < 300) {
					return response.json();
				} else {
					let error = new Error(response.statusText);
					(error as any).response = response;
					throw error;
				}
			});
		}
	}
//}
//export namespace  {
	'use strict';

	export class PricingDetailsApi {
		protected basePath = 'https://api-na.myconnectwise.net/v4_6_release/apis/3.0';
		public defaultHeaders : any = {};

		constructor(basePath?: string) {
			if (basePath) {
				this.basePath = basePath;
			}
		}

		/**
		 *
		 * Get Pricing Detail Count
		 * @param id
		 * @param conditions
		 */
		public procurementPricingschedulesIdDetailsCountGet (params: {  id: number; conditions?: string; }, extraQueryParams?: any, extraFetchParams?: any ) : Promise<Count> {
			const localVarPath = this.basePath + '/procurement/pricingschedules/{id}/details/count'
				.replace('{' + 'id' + '}', String(params.id));

			let queryParameters: any = assign({}, extraQueryParams);
			let headerParams: any = assign({}, this.defaultHeaders);
			// verify required parameter 'id' is set
			if (params.id == null) {
				throw new Error('Missing required parameter id when calling procurementPricingschedulesIdDetailsCountGet');
			}
			if (params.conditions !== undefined) {
				queryParameters['conditions'] = params.conditions;
			}

			let fetchParams = {
				method: 'GET',
				headers: headerParams,

			};

			if (extraFetchParams) {
				fetchParams = assign(fetchParams, extraFetchParams);
			}

			let localVarPathWithQueryParameters = localVarPath + (localVarPath.indexOf('?') !== -1 ? '&' : '?') + querystring.stringify(queryParameters);

			return fetch(localVarPathWithQueryParameters, fetchParams).then((response) => {
				if (response.status >= 200 && response.status < 300) {
					return response.json();
				} else {
					let error = new Error(response.statusText);
					(error as any).response = response;
					throw error;
				}
			});
		}
		/**
		 *
		 * Delete Pricing Detail By Id
		 * @param id
		 * @param detailID
		 */
		public procurementPricingschedulesIdDetailsDetailIDDelete (params: {  id: number; detailID: number; }, extraQueryParams?: any, extraFetchParams?: any ) : Promise<{}> {
			const localVarPath = this.basePath + '/procurement/pricingschedules/{id}/details/{detailID}'
				.replace('{' + 'id' + '}', String(params.id))
				.replace('{' + 'detailID' + '}', String(params.detailID));

			let queryParameters: any = assign({}, extraQueryParams);
			let headerParams: any = assign({}, this.defaultHeaders);
			// verify required parameter 'id' is set
			if (params.id == null) {
				throw new Error('Missing required parameter id when calling procurementPricingschedulesIdDetailsDetailIDDelete');
			}
			// verify required parameter 'detailID' is set
			if (params.detailID == null) {
				throw new Error('Missing required parameter detailID when calling procurementPricingschedulesIdDetailsDetailIDDelete');
			}
			let fetchParams = {
				method: 'DELETE',
				headers: headerParams,

			};

			if (extraFetchParams) {
				fetchParams = assign(fetchParams, extraFetchParams);
			}

			let localVarPathWithQueryParameters = localVarPath + (localVarPath.indexOf('?') !== -1 ? '&' : '?') + querystring.stringify(queryParameters);

			return fetch(localVarPathWithQueryParameters, fetchParams).then((response) => {
				if (response.status >= 200 && response.status < 300) {
					return response.json();
				} else {
					let error = new Error(response.statusText);
					(error as any).response = response;
					throw error;
				}
			});
		}
		/**
		 *
		 * Get Pricing Detail By Id
		 * @param id
		 * @param detailID
		 */
		public procurementPricingschedulesIdDetailsDetailIDGet (params: {  id: number; detailID: number; }, extraQueryParams?: any, extraFetchParams?: any ) : Promise<PricingDetail> {
			const localVarPath = this.basePath + '/procurement/pricingschedules/{id}/details/{detailID}'
				.replace('{' + 'id' + '}', String(params.id))
				.replace('{' + 'detailID' + '}', String(params.detailID));

			let queryParameters: any = assign({}, extraQueryParams);
			let headerParams: any = assign({}, this.defaultHeaders);
			// verify required parameter 'id' is set
			if (params.id == null) {
				throw new Error('Missing required parameter id when calling procurementPricingschedulesIdDetailsDetailIDGet');
			}
			// verify required parameter 'detailID' is set
			if (params.detailID == null) {
				throw new Error('Missing required parameter detailID when calling procurementPricingschedulesIdDetailsDetailIDGet');
			}
			let fetchParams = {
				method: 'GET',
				headers: headerParams,

			};

			if (extraFetchParams) {
				fetchParams = assign(fetchParams, extraFetchParams);
			}

			let localVarPathWithQueryParameters = localVarPath + (localVarPath.indexOf('?') !== -1 ? '&' : '?') + querystring.stringify(queryParameters);

			return fetch(localVarPathWithQueryParameters, fetchParams).then((response) => {
				if (response.status >= 200 && response.status < 300) {
					return response.json();
				} else {
					let error = new Error(response.statusText);
					(error as any).response = response;
					throw error;
				}
			});
		}
		/**
		 *
		 * Update Pricing Detail
		 * @param id
		 * @param detailID
		 * @param operations
		 */
		public procurementPricingschedulesIdDetailsDetailIDPatch (params: {  id: number; detailID: number; operations: Array<PatchOperation>; }, extraQueryParams?: any, extraFetchParams?: any ) : Promise<PricingDetail> {
			const localVarPath = this.basePath + '/procurement/pricingschedules/{id}/details/{detailID}'
				.replace('{' + 'id' + '}', String(params.id))
				.replace('{' + 'detailID' + '}', String(params.detailID));

			let queryParameters: any = assign({}, extraQueryParams);
			let headerParams: any = assign({}, this.defaultHeaders);
			headerParams['Content-Type'] = 'application/json';

			// verify required parameter 'id' is set
			if (params.id == null) {
				throw new Error('Missing required parameter id when calling procurementPricingschedulesIdDetailsDetailIDPatch');
			}
			// verify required parameter 'detailID' is set
			if (params.detailID == null) {
				throw new Error('Missing required parameter detailID when calling procurementPricingschedulesIdDetailsDetailIDPatch');
			}
			// verify required parameter 'operations' is set
			if (params.operations == null) {
				throw new Error('Missing required parameter operations when calling procurementPricingschedulesIdDetailsDetailIDPatch');
			}
			let fetchParams = {
				method: 'PATCH',
				headers: headerParams,
				body: JSON.stringify(params.operations),

			};

			if (extraFetchParams) {
				fetchParams = assign(fetchParams, extraFetchParams);
			}

			let localVarPathWithQueryParameters = localVarPath + (localVarPath.indexOf('?') !== -1 ? '&' : '?') + querystring.stringify(queryParameters);

			return fetch(localVarPathWithQueryParameters, fetchParams).then((response) => {
				if (response.status >= 200 && response.status < 300) {
					return response.json();
				} else {
					let error = new Error(response.statusText);
					(error as any).response = response;
					throw error;
				}
			});
		}
		/**
		 *
		 * Replace Pricing Detail
		 * @param id
		 * @param detailID
		 * @param pricingDetail
		 */
		public procurementPricingschedulesIdDetailsDetailIDPut (params: {  id: number; detailID: number; pricingDetail: PricingDetail; }, extraQueryParams?: any, extraFetchParams?: any ) : Promise<PricingDetail> {
			const localVarPath = this.basePath + '/procurement/pricingschedules/{id}/details/{detailID}'
				.replace('{' + 'id' + '}', String(params.id))
				.replace('{' + 'detailID' + '}', String(params.detailID));

			let queryParameters: any = assign({}, extraQueryParams);
			let headerParams: any = assign({}, this.defaultHeaders);
			headerParams['Content-Type'] = 'application/json';

			// verify required parameter 'id' is set
			if (params.id == null) {
				throw new Error('Missing required parameter id when calling procurementPricingschedulesIdDetailsDetailIDPut');
			}
			// verify required parameter 'detailID' is set
			if (params.detailID == null) {
				throw new Error('Missing required parameter detailID when calling procurementPricingschedulesIdDetailsDetailIDPut');
			}
			// verify required parameter 'pricingDetail' is set
			if (params.pricingDetail == null) {
				throw new Error('Missing required parameter pricingDetail when calling procurementPricingschedulesIdDetailsDetailIDPut');
			}
			let fetchParams = {
				method: 'PUT',
				headers: headerParams,
				body: JSON.stringify(params.pricingDetail),

			};

			if (extraFetchParams) {
				fetchParams = assign(fetchParams, extraFetchParams);
			}

			let localVarPathWithQueryParameters = localVarPath + (localVarPath.indexOf('?') !== -1 ? '&' : '?') + querystring.stringify(queryParameters);

			return fetch(localVarPathWithQueryParameters, fetchParams).then((response) => {
				if (response.status >= 200 && response.status < 300) {
					return response.json();
				} else {
					let error = new Error(response.statusText);
					(error as any).response = response;
					throw error;
				}
			});
		}
		/**
		 *
		 * Get Pricing Detail
		 * @param id
		 * @param conditions
		 * @param orderBy
		 * @param childconditions
		 * @param customfieldconditions
		 * @param page
		 * @param pageSize
		 */
		public procurementPricingschedulesIdDetailsGet (params: {  id: number; conditions?: string; orderBy?: string; childconditions?: string; customfieldconditions?: string; page?: number; pageSize?: number; }, extraQueryParams?: any, extraFetchParams?: any ) : Promise<Array<PricingDetail>> {
			const localVarPath = this.basePath + '/procurement/pricingschedules/{id}/details'
				.replace('{' + 'id' + '}', String(params.id));

			let queryParameters: any = assign({}, extraQueryParams);
			let headerParams: any = assign({}, this.defaultHeaders);
			// verify required parameter 'id' is set
			if (params.id == null) {
				throw new Error('Missing required parameter id when calling procurementPricingschedulesIdDetailsGet');
			}
			if (params.conditions !== undefined) {
				queryParameters['conditions'] = params.conditions;
			}

			if (params.orderBy !== undefined) {
				queryParameters['orderBy'] = params.orderBy;
			}

			if (params.childconditions !== undefined) {
				queryParameters['childconditions'] = params.childconditions;
			}

			if (params.customfieldconditions !== undefined) {
				queryParameters['customfieldconditions'] = params.customfieldconditions;
			}

			if (params.page !== undefined) {
				queryParameters['page'] = params.page;
			}

			if (params.pageSize !== undefined) {
				queryParameters['pageSize'] = params.pageSize;
			}

			let fetchParams = {
				method: 'GET',
				headers: headerParams,

			};

			if (extraFetchParams) {
				fetchParams = assign(fetchParams, extraFetchParams);
			}

			let localVarPathWithQueryParameters = localVarPath + (localVarPath.indexOf('?') !== -1 ? '&' : '?') + querystring.stringify(queryParameters);

			return fetch(localVarPathWithQueryParameters, fetchParams).then((response) => {
				if (response.status >= 200 && response.status < 300) {
					return response.json();
				} else {
					let error = new Error(response.statusText);
					(error as any).response = response;
					throw error;
				}
			});
		}
		/**
		 *
		 * Create Pricing Detail
		 * @param id
		 * @param pricingDetail
		 */
		public procurementPricingschedulesIdDetailsPost (params: {  id: number; pricingDetail: PricingDetail; }, extraQueryParams?: any, extraFetchParams?: any ) : Promise<PricingDetail> {
			const localVarPath = this.basePath + '/procurement/pricingschedules/{id}/details'
				.replace('{' + 'id' + '}', String(params.id));

			let queryParameters: any = assign({}, extraQueryParams);
			let headerParams: any = assign({}, this.defaultHeaders);
			headerParams['Content-Type'] = 'application/json';

			// verify required parameter 'id' is set
			if (params.id == null) {
				throw new Error('Missing required parameter id when calling procurementPricingschedulesIdDetailsPost');
			}
			// verify required parameter 'pricingDetail' is set
			if (params.pricingDetail == null) {
				throw new Error('Missing required parameter pricingDetail when calling procurementPricingschedulesIdDetailsPost');
			}
			let fetchParams = {
				method: 'POST',
				headers: headerParams,
				body: JSON.stringify(params.pricingDetail),

			};

			if (extraFetchParams) {
				fetchParams = assign(fetchParams, extraFetchParams);
			}

			let localVarPathWithQueryParameters = localVarPath + (localVarPath.indexOf('?') !== -1 ? '&' : '?') + querystring.stringify(queryParameters);

			return fetch(localVarPathWithQueryParameters, fetchParams).then((response) => {
				if (response.status >= 200 && response.status < 300) {
					return response.json();
				} else {
					let error = new Error(response.statusText);
					(error as any).response = response;
					throw error;
				}
			});
		}
	}
//}
//export namespace  {
	'use strict';

	export class PricingSchedulesApi {
		protected basePath = 'https://api-na.myconnectwise.net/v4_6_release/apis/3.0';
		public defaultHeaders : any = {};

		constructor(basePath?: string) {
			if (basePath) {
				this.basePath = basePath;
			}
		}

		/**
		 *
		 * Get Pricing Schedules Count
		 * @param conditions
		 */
		public procurementPricingschedulesCountGet (params: {  conditions?: string; }, extraQueryParams?: any, extraFetchParams?: any ) : Promise<Count> {
			const localVarPath = this.basePath + '/procurement/pricingschedules/count';

			let queryParameters: any = assign({}, extraQueryParams);
			let headerParams: any = assign({}, this.defaultHeaders);
			if (params.conditions !== undefined) {
				queryParameters['conditions'] = params.conditions;
			}

			let fetchParams = {
				method: 'GET',
				headers: headerParams,

			};

			if (extraFetchParams) {
				fetchParams = assign(fetchParams, extraFetchParams);
			}

			let localVarPathWithQueryParameters = localVarPath + (localVarPath.indexOf('?') !== -1 ? '&' : '?') + querystring.stringify(queryParameters);

			return fetch(localVarPathWithQueryParameters, fetchParams).then((response) => {
				if (response.status >= 200 && response.status < 300) {
					return response.json();
				} else {
					let error = new Error(response.statusText);
					(error as any).response = response;
					throw error;
				}
			});
		}
		/**
		 *
		 * Get Pricing Schedules
		 * @param conditions
		 * @param orderBy
		 * @param childconditions
		 * @param customfieldconditions
		 * @param page
		 * @param pageSize
		 */
		public procurementPricingschedulesGet (params: {  conditions?: string; orderBy?: string; childconditions?: string; customfieldconditions?: string; page?: number; pageSize?: number; }, extraQueryParams?: any, extraFetchParams?: any ) : Promise<Array<PricingSchedule>> {
			const localVarPath = this.basePath + '/procurement/pricingschedules';

			let queryParameters: any = assign({}, extraQueryParams);
			let headerParams: any = assign({}, this.defaultHeaders);
			if (params.conditions !== undefined) {
				queryParameters['conditions'] = params.conditions;
			}

			if (params.orderBy !== undefined) {
				queryParameters['orderBy'] = params.orderBy;
			}

			if (params.childconditions !== undefined) {
				queryParameters['childconditions'] = params.childconditions;
			}

			if (params.customfieldconditions !== undefined) {
				queryParameters['customfieldconditions'] = params.customfieldconditions;
			}

			if (params.page !== undefined) {
				queryParameters['page'] = params.page;
			}

			if (params.pageSize !== undefined) {
				queryParameters['pageSize'] = params.pageSize;
			}

			let fetchParams = {
				method: 'GET',
				headers: headerParams,

			};

			if (extraFetchParams) {
				fetchParams = assign(fetchParams, extraFetchParams);
			}

			let localVarPathWithQueryParameters = localVarPath + (localVarPath.indexOf('?') !== -1 ? '&' : '?') + querystring.stringify(queryParameters);

			return fetch(localVarPathWithQueryParameters, fetchParams).then((response) => {
				if (response.status >= 200 && response.status < 300) {
					return response.json();
				} else {
					let error = new Error(response.statusText);
					(error as any).response = response;
					throw error;
				}
			});
		}
		/**
		 *
		 * Delete Pricing Schedule By Id
		 * @param id
		 */
		public procurementPricingschedulesIdDelete (params: {  id: number; }, extraQueryParams?: any, extraFetchParams?: any ) : Promise<{}> {
			const localVarPath = this.basePath + '/procurement/pricingschedules/{id}'
				.replace('{' + 'id' + '}', String(params.id));

			let queryParameters: any = assign({}, extraQueryParams);
			let headerParams: any = assign({}, this.defaultHeaders);
			// verify required parameter 'id' is set
			if (params.id == null) {
				throw new Error('Missing required parameter id when calling procurementPricingschedulesIdDelete');
			}
			let fetchParams = {
				method: 'DELETE',
				headers: headerParams,

			};

			if (extraFetchParams) {
				fetchParams = assign(fetchParams, extraFetchParams);
			}

			let localVarPathWithQueryParameters = localVarPath + (localVarPath.indexOf('?') !== -1 ? '&' : '?') + querystring.stringify(queryParameters);

			return fetch(localVarPathWithQueryParameters, fetchParams).then((response) => {
				if (response.status >= 200 && response.status < 300) {
					return response.json();
				} else {
					let error = new Error(response.statusText);
					(error as any).response = response;
					throw error;
				}
			});
		}
		/**
		 *
		 * Get Pricing Schedule By Id
		 * @param id
		 */
		public procurementPricingschedulesIdGet (params: {  id: number; }, extraQueryParams?: any, extraFetchParams?: any ) : Promise<PricingSchedule> {
			const localVarPath = this.basePath + '/procurement/pricingschedules/{id}'
				.replace('{' + 'id' + '}', String(params.id));

			let queryParameters: any = assign({}, extraQueryParams);
			let headerParams: any = assign({}, this.defaultHeaders);
			// verify required parameter 'id' is set
			if (params.id == null) {
				throw new Error('Missing required parameter id when calling procurementPricingschedulesIdGet');
			}
			let fetchParams = {
				method: 'GET',
				headers: headerParams,

			};

			if (extraFetchParams) {
				fetchParams = assign(fetchParams, extraFetchParams);
			}

			let localVarPathWithQueryParameters = localVarPath + (localVarPath.indexOf('?') !== -1 ? '&' : '?') + querystring.stringify(queryParameters);

			return fetch(localVarPathWithQueryParameters, fetchParams).then((response) => {
				if (response.status >= 200 && response.status < 300) {
					return response.json();
				} else {
					let error = new Error(response.statusText);
					(error as any).response = response;
					throw error;
				}
			});
		}
		/**
		 *
		 * Update Pricing Schedule
		 * @param id
		 * @param operations
		 */
		public procurementPricingschedulesIdPatch (params: {  id: number; operations: Array<PatchOperation>; }, extraQueryParams?: any, extraFetchParams?: any ) : Promise<PricingSchedule> {
			const localVarPath = this.basePath + '/procurement/pricingschedules/{id}'
				.replace('{' + 'id' + '}', String(params.id));

			let queryParameters: any = assign({}, extraQueryParams);
			let headerParams: any = assign({}, this.defaultHeaders);
			headerParams['Content-Type'] = 'application/json';

			// verify required parameter 'id' is set
			if (params.id == null) {
				throw new Error('Missing required parameter id when calling procurementPricingschedulesIdPatch');
			}
			// verify required parameter 'operations' is set
			if (params.operations == null) {
				throw new Error('Missing required parameter operations when calling procurementPricingschedulesIdPatch');
			}
			let fetchParams = {
				method: 'PATCH',
				headers: headerParams,
				body: JSON.stringify(params.operations),

			};

			if (extraFetchParams) {
				fetchParams = assign(fetchParams, extraFetchParams);
			}

			let localVarPathWithQueryParameters = localVarPath + (localVarPath.indexOf('?') !== -1 ? '&' : '?') + querystring.stringify(queryParameters);

			return fetch(localVarPathWithQueryParameters, fetchParams).then((response) => {
				if (response.status >= 200 && response.status < 300) {
					return response.json();
				} else {
					let error = new Error(response.statusText);
					(error as any).response = response;
					throw error;
				}
			});
		}
		/**
		 *
		 * Replace Pricing Schedule
		 * @param id
		 * @param pricingSchedule
		 */
		public procurementPricingschedulesIdPut (params: {  id: number; pricingSchedule: PricingSchedule; }, extraQueryParams?: any, extraFetchParams?: any ) : Promise<PricingSchedule> {
			const localVarPath = this.basePath + '/procurement/pricingschedules/{id}'
				.replace('{' + 'id' + '}', String(params.id));

			let queryParameters: any = assign({}, extraQueryParams);
			let headerParams: any = assign({}, this.defaultHeaders);
			headerParams['Content-Type'] = 'application/json';

			// verify required parameter 'id' is set
			if (params.id == null) {
				throw new Error('Missing required parameter id when calling procurementPricingschedulesIdPut');
			}
			// verify required parameter 'pricingSchedule' is set
			if (params.pricingSchedule == null) {
				throw new Error('Missing required parameter pricingSchedule when calling procurementPricingschedulesIdPut');
			}
			let fetchParams = {
				method: 'PUT',
				headers: headerParams,
				body: JSON.stringify(params.pricingSchedule),

			};

			if (extraFetchParams) {
				fetchParams = assign(fetchParams, extraFetchParams);
			}

			let localVarPathWithQueryParameters = localVarPath + (localVarPath.indexOf('?') !== -1 ? '&' : '?') + querystring.stringify(queryParameters);

			return fetch(localVarPathWithQueryParameters, fetchParams).then((response) => {
				if (response.status >= 200 && response.status < 300) {
					return response.json();
				} else {
					let error = new Error(response.statusText);
					(error as any).response = response;
					throw error;
				}
			});
		}
		/**
		 *
		 * Create Pricing Schedule
		 * @param pricingSchedule
		 */
		public procurementPricingschedulesPost (params: {  pricingSchedule: PricingSchedule; }, extraQueryParams?: any, extraFetchParams?: any ) : Promise<PricingSchedule> {
			const localVarPath = this.basePath + '/procurement/pricingschedules';

			let queryParameters: any = assign({}, extraQueryParams);
			let headerParams: any = assign({}, this.defaultHeaders);
			headerParams['Content-Type'] = 'application/json';

			// verify required parameter 'pricingSchedule' is set
			if (params.pricingSchedule == null) {
				throw new Error('Missing required parameter pricingSchedule when calling procurementPricingschedulesPost');
			}
			let fetchParams = {
				method: 'POST',
				headers: headerParams,
				body: JSON.stringify(params.pricingSchedule),

			};

			if (extraFetchParams) {
				fetchParams = assign(fetchParams, extraFetchParams);
			}

			let localVarPathWithQueryParameters = localVarPath + (localVarPath.indexOf('?') !== -1 ? '&' : '?') + querystring.stringify(queryParameters);

			return fetch(localVarPathWithQueryParameters, fetchParams).then((response) => {
				if (response.status >= 200 && response.status < 300) {
					return response.json();
				} else {
					let error = new Error(response.statusText);
					(error as any).response = response;
					throw error;
				}
			});
		}
	}
//}
//export namespace  {
	'use strict';

	export class PrioritiesApi {
		protected basePath = 'https://api-na.myconnectwise.net/v4_6_release/apis/3.0';
		public defaultHeaders : any = {};

		constructor(basePath?: string) {
			if (basePath) {
				this.basePath = basePath;
			}
		}

		/**
		 *
		 * Create Priorities Count
		 * @param conditions
		 */
		public servicePrioritiesCountGet (params: {  conditions?: string; }, extraQueryParams?: any, extraFetchParams?: any ) : Promise<Count> {
			const localVarPath = this.basePath + '/service/priorities/count';

			let queryParameters: any = assign({}, extraQueryParams);
			let headerParams: any = assign({}, this.defaultHeaders);
			if (params.conditions !== undefined) {
				queryParameters['conditions'] = params.conditions;
			}

			let fetchParams = {
				method: 'GET',
				headers: headerParams,

			};

			if (extraFetchParams) {
				fetchParams = assign(fetchParams, extraFetchParams);
			}

			let localVarPathWithQueryParameters = localVarPath + (localVarPath.indexOf('?') !== -1 ? '&' : '?') + querystring.stringify(queryParameters);

			return fetch(localVarPathWithQueryParameters, fetchParams).then((response) => {
				if (response.status >= 200 && response.status < 300) {
					return response.json();
				} else {
					let error = new Error(response.statusText);
					(error as any).response = response;
					throw error;
				}
			});
		}
		/**
		 *
		 * Get Priorities
		 * @param conditions
		 * @param orderBy
		 * @param childconditions
		 * @param customfieldconditions
		 * @param page
		 * @param pageSize
		 */
		public servicePrioritiesGet (params: {  conditions?: string; orderBy?: string; childconditions?: string; customfieldconditions?: string; page?: number; pageSize?: number; }, extraQueryParams?: any, extraFetchParams?: any ) : Promise<Array<Priority>> {
			const localVarPath = this.basePath + '/service/priorities';

			let queryParameters: any = assign({}, extraQueryParams);
			let headerParams: any = assign({}, this.defaultHeaders);
			if (params.conditions !== undefined) {
				queryParameters['conditions'] = params.conditions;
			}

			if (params.orderBy !== undefined) {
				queryParameters['orderBy'] = params.orderBy;
			}

			if (params.childconditions !== undefined) {
				queryParameters['childconditions'] = params.childconditions;
			}

			if (params.customfieldconditions !== undefined) {
				queryParameters['customfieldconditions'] = params.customfieldconditions;
			}

			if (params.page !== undefined) {
				queryParameters['page'] = params.page;
			}

			if (params.pageSize !== undefined) {
				queryParameters['pageSize'] = params.pageSize;
			}

			let fetchParams = {
				method: 'GET',
				headers: headerParams,

			};

			if (extraFetchParams) {
				fetchParams = assign(fetchParams, extraFetchParams);
			}

			let localVarPathWithQueryParameters = localVarPath + (localVarPath.indexOf('?') !== -1 ? '&' : '?') + querystring.stringify(queryParameters);

			return fetch(localVarPathWithQueryParameters, fetchParams).then((response) => {
				if (response.status >= 200 && response.status < 300) {
					return response.json();
				} else {
					let error = new Error(response.statusText);
					(error as any).response = response;
					throw error;
				}
			});
		}
		/**
		 *
		 * Delete Priority By Id
		 * @param id
		 */
		public servicePrioritiesIdDelete (params: {  id: number; }, extraQueryParams?: any, extraFetchParams?: any ) : Promise<{}> {
			const localVarPath = this.basePath + '/service/priorities/{id}'
				.replace('{' + 'id' + '}', String(params.id));

			let queryParameters: any = assign({}, extraQueryParams);
			let headerParams: any = assign({}, this.defaultHeaders);
			// verify required parameter 'id' is set
			if (params.id == null) {
				throw new Error('Missing required parameter id when calling servicePrioritiesIdDelete');
			}
			let fetchParams = {
				method: 'DELETE',
				headers: headerParams,

			};

			if (extraFetchParams) {
				fetchParams = assign(fetchParams, extraFetchParams);
			}

			let localVarPathWithQueryParameters = localVarPath + (localVarPath.indexOf('?') !== -1 ? '&' : '?') + querystring.stringify(queryParameters);

			return fetch(localVarPathWithQueryParameters, fetchParams).then((response) => {
				if (response.status >= 200 && response.status < 300) {
					return response.json();
				} else {
					let error = new Error(response.statusText);
					(error as any).response = response;
					throw error;
				}
			});
		}
		/**
		 *
		 * Get Priority By Id
		 * @param id
		 */
		public servicePrioritiesIdGet (params: {  id: number; }, extraQueryParams?: any, extraFetchParams?: any ) : Promise<Priority> {
			const localVarPath = this.basePath + '/service/priorities/{id}'
				.replace('{' + 'id' + '}', String(params.id));

			let queryParameters: any = assign({}, extraQueryParams);
			let headerParams: any = assign({}, this.defaultHeaders);
			// verify required parameter 'id' is set
			if (params.id == null) {
				throw new Error('Missing required parameter id when calling servicePrioritiesIdGet');
			}
			let fetchParams = {
				method: 'GET',
				headers: headerParams,

			};

			if (extraFetchParams) {
				fetchParams = assign(fetchParams, extraFetchParams);
			}

			let localVarPathWithQueryParameters = localVarPath + (localVarPath.indexOf('?') !== -1 ? '&' : '?') + querystring.stringify(queryParameters);

			return fetch(localVarPathWithQueryParameters, fetchParams).then((response) => {
				if (response.status >= 200 && response.status < 300) {
					return response.json();
				} else {
					let error = new Error(response.statusText);
					(error as any).response = response;
					throw error;
				}
			});
		}
		/**
		 *
		 * Get Priority Image
		 * @param id
		 * @param useDefaultFlag
		 * @param lastModified
		 */
		public servicePrioritiesIdImageGet (params: {  id: number; useDefaultFlag?: boolean; lastModified?: string; }, extraQueryParams?: any, extraFetchParams?: any ) : Promise<{}> {
			const localVarPath = this.basePath + '/service/priorities/{id}/image'
				.replace('{' + 'id' + '}', String(params.id));

			let queryParameters: any = assign({}, extraQueryParams);
			let headerParams: any = assign({}, this.defaultHeaders);
			// verify required parameter 'id' is set
			if (params.id == null) {
				throw new Error('Missing required parameter id when calling servicePrioritiesIdImageGet');
			}
			if (params.useDefaultFlag !== undefined) {
				queryParameters['useDefaultFlag'] = params.useDefaultFlag;
			}

			if (params.lastModified !== undefined) {
				queryParameters['lastModified'] = params.lastModified;
			}

			let fetchParams = {
				method: 'GET',
				headers: headerParams,

			};

			if (extraFetchParams) {
				fetchParams = assign(fetchParams, extraFetchParams);
			}

			let localVarPathWithQueryParameters = localVarPath + (localVarPath.indexOf('?') !== -1 ? '&' : '?') + querystring.stringify(queryParameters);

			return fetch(localVarPathWithQueryParameters, fetchParams).then((response) => {
				if (response.status >= 200 && response.status < 300) {
					return response.json();
				} else {
					let error = new Error(response.statusText);
					(error as any).response = response;
					throw error;
				}
			});
		}
		/**
		 *
		 * Update Priority
		 * @param id
		 * @param operations
		 */
		public servicePrioritiesIdPatch (params: {  id: number; operations: Array<PatchOperation>; }, extraQueryParams?: any, extraFetchParams?: any ) : Promise<Priority> {
			const localVarPath = this.basePath + '/service/priorities/{id}'
				.replace('{' + 'id' + '}', String(params.id));

			let queryParameters: any = assign({}, extraQueryParams);
			let headerParams: any = assign({}, this.defaultHeaders);
			headerParams['Content-Type'] = 'application/json';

			// verify required parameter 'id' is set
			if (params.id == null) {
				throw new Error('Missing required parameter id when calling servicePrioritiesIdPatch');
			}
			// verify required parameter 'operations' is set
			if (params.operations == null) {
				throw new Error('Missing required parameter operations when calling servicePrioritiesIdPatch');
			}
			let fetchParams = {
				method: 'PATCH',
				headers: headerParams,
				body: JSON.stringify(params.operations),

			};

			if (extraFetchParams) {
				fetchParams = assign(fetchParams, extraFetchParams);
			}

			let localVarPathWithQueryParameters = localVarPath + (localVarPath.indexOf('?') !== -1 ? '&' : '?') + querystring.stringify(queryParameters);

			return fetch(localVarPathWithQueryParameters, fetchParams).then((response) => {
				if (response.status >= 200 && response.status < 300) {
					return response.json();
				} else {
					let error = new Error(response.statusText);
					(error as any).response = response;
					throw error;
				}
			});
		}
		/**
		 *
		 * Replace Priority
		 * @param id
		 * @param priority
		 */
		public servicePrioritiesIdPut (params: {  id: number; priority: Priority; }, extraQueryParams?: any, extraFetchParams?: any ) : Promise<Priority> {
			const localVarPath = this.basePath + '/service/priorities/{id}'
				.replace('{' + 'id' + '}', String(params.id));

			let queryParameters: any = assign({}, extraQueryParams);
			let headerParams: any = assign({}, this.defaultHeaders);
			headerParams['Content-Type'] = 'application/json';

			// verify required parameter 'id' is set
			if (params.id == null) {
				throw new Error('Missing required parameter id when calling servicePrioritiesIdPut');
			}
			// verify required parameter 'priority' is set
			if (params.priority == null) {
				throw new Error('Missing required parameter priority when calling servicePrioritiesIdPut');
			}
			let fetchParams = {
				method: 'PUT',
				headers: headerParams,
				body: JSON.stringify(params.priority),

			};

			if (extraFetchParams) {
				fetchParams = assign(fetchParams, extraFetchParams);
			}

			let localVarPathWithQueryParameters = localVarPath + (localVarPath.indexOf('?') !== -1 ? '&' : '?') + querystring.stringify(queryParameters);

			return fetch(localVarPathWithQueryParameters, fetchParams).then((response) => {
				if (response.status >= 200 && response.status < 300) {
					return response.json();
				} else {
					let error = new Error(response.statusText);
					(error as any).response = response;
					throw error;
				}
			});
		}
		/**
		 *
		 * Create Priority
		 * @param priority
		 */
		public servicePrioritiesPost (params: {  priority: Priority; }, extraQueryParams?: any, extraFetchParams?: any ) : Promise<Priority> {
			const localVarPath = this.basePath + '/service/priorities';

			let queryParameters: any = assign({}, extraQueryParams);
			let headerParams: any = assign({}, this.defaultHeaders);
			headerParams['Content-Type'] = 'application/json';

			// verify required parameter 'priority' is set
			if (params.priority == null) {
				throw new Error('Missing required parameter priority when calling servicePrioritiesPost');
			}
			let fetchParams = {
				method: 'POST',
				headers: headerParams,
				body: JSON.stringify(params.priority),

			};

			if (extraFetchParams) {
				fetchParams = assign(fetchParams, extraFetchParams);
			}

			let localVarPathWithQueryParameters = localVarPath + (localVarPath.indexOf('?') !== -1 ? '&' : '?') + querystring.stringify(queryParameters);

			return fetch(localVarPathWithQueryParameters, fetchParams).then((response) => {
				if (response.status >= 200 && response.status < 300) {
					return response.json();
				} else {
					let error = new Error(response.statusText);
					(error as any).response = response;
					throw error;
				}
			});
		}
	}
//}
//export namespace  {
	'use strict';

	export class ProductComponentsApi {
		protected basePath = 'https://api-na.myconnectwise.net/v4_6_release/apis/3.0';
		public defaultHeaders : any = {};

		constructor(basePath?: string) {
			if (basePath) {
				this.basePath = basePath;
			}
		}

		/**
		 *
		 * Delete Product Component By Id
		 * @param id
		 * @param componentId
		 */
		public procurementProductsIdComponentsComponentIdDelete (params: {  id: number; componentId: number; }, extraQueryParams?: any, extraFetchParams?: any ) : Promise<{}> {
			const localVarPath = this.basePath + '/procurement/products/{id}/components/{componentId}'
				.replace('{' + 'id' + '}', String(params.id))
				.replace('{' + 'componentId' + '}', String(params.componentId));

			let queryParameters: any = assign({}, extraQueryParams);
			let headerParams: any = assign({}, this.defaultHeaders);
			// verify required parameter 'id' is set
			if (params.id == null) {
				throw new Error('Missing required parameter id when calling procurementProductsIdComponentsComponentIdDelete');
			}
			// verify required parameter 'componentId' is set
			if (params.componentId == null) {
				throw new Error('Missing required parameter componentId when calling procurementProductsIdComponentsComponentIdDelete');
			}
			let fetchParams = {
				method: 'DELETE',
				headers: headerParams,

			};

			if (extraFetchParams) {
				fetchParams = assign(fetchParams, extraFetchParams);
			}

			let localVarPathWithQueryParameters = localVarPath + (localVarPath.indexOf('?') !== -1 ? '&' : '?') + querystring.stringify(queryParameters);

			return fetch(localVarPathWithQueryParameters, fetchParams).then((response) => {
				if (response.status >= 200 && response.status < 300) {
					return response.json();
				} else {
					let error = new Error(response.statusText);
					(error as any).response = response;
					throw error;
				}
			});
		}
		/**
		 *
		 * Get Product Component By Id
		 * @param id
		 * @param componentId
		 */
		public procurementProductsIdComponentsComponentIdGet (params: {  id: number; componentId: number; }, extraQueryParams?: any, extraFetchParams?: any ) : Promise<Array<ProductComponent>> {
			const localVarPath = this.basePath + '/procurement/products/{id}/components/{componentId}'
				.replace('{' + 'id' + '}', String(params.id))
				.replace('{' + 'componentId' + '}', String(params.componentId));

			let queryParameters: any = assign({}, extraQueryParams);
			let headerParams: any = assign({}, this.defaultHeaders);
			// verify required parameter 'id' is set
			if (params.id == null) {
				throw new Error('Missing required parameter id when calling procurementProductsIdComponentsComponentIdGet');
			}
			// verify required parameter 'componentId' is set
			if (params.componentId == null) {
				throw new Error('Missing required parameter componentId when calling procurementProductsIdComponentsComponentIdGet');
			}
			let fetchParams = {
				method: 'GET',
				headers: headerParams,

			};

			if (extraFetchParams) {
				fetchParams = assign(fetchParams, extraFetchParams);
			}

			let localVarPathWithQueryParameters = localVarPath + (localVarPath.indexOf('?') !== -1 ? '&' : '?') + querystring.stringify(queryParameters);

			return fetch(localVarPathWithQueryParameters, fetchParams).then((response) => {
				if (response.status >= 200 && response.status < 300) {
					return response.json();
				} else {
					let error = new Error(response.statusText);
					(error as any).response = response;
					throw error;
				}
			});
		}
		/**
		 *
		 * Update Product Component
		 * @param id
		 * @param componentId
		 * @param operations
		 */
		public procurementProductsIdComponentsComponentIdPatch (params: {  id: number; componentId: number; operations: Array<PatchOperation>; }, extraQueryParams?: any, extraFetchParams?: any ) : Promise<Array<ProductComponent>> {
			const localVarPath = this.basePath + '/procurement/products/{id}/components/{componentId}'
				.replace('{' + 'id' + '}', String(params.id))
				.replace('{' + 'componentId' + '}', String(params.componentId));

			let queryParameters: any = assign({}, extraQueryParams);
			let headerParams: any = assign({}, this.defaultHeaders);
			headerParams['Content-Type'] = 'application/json';

			// verify required parameter 'id' is set
			if (params.id == null) {
				throw new Error('Missing required parameter id when calling procurementProductsIdComponentsComponentIdPatch');
			}
			// verify required parameter 'componentId' is set
			if (params.componentId == null) {
				throw new Error('Missing required parameter componentId when calling procurementProductsIdComponentsComponentIdPatch');
			}
			// verify required parameter 'operations' is set
			if (params.operations == null) {
				throw new Error('Missing required parameter operations when calling procurementProductsIdComponentsComponentIdPatch');
			}
			let fetchParams = {
				method: 'PATCH',
				headers: headerParams,
				body: JSON.stringify(params.operations),

			};

			if (extraFetchParams) {
				fetchParams = assign(fetchParams, extraFetchParams);
			}

			let localVarPathWithQueryParameters = localVarPath + (localVarPath.indexOf('?') !== -1 ? '&' : '?') + querystring.stringify(queryParameters);

			return fetch(localVarPathWithQueryParameters, fetchParams).then((response) => {
				if (response.status >= 200 && response.status < 300) {
					return response.json();
				} else {
					let error = new Error(response.statusText);
					(error as any).response = response;
					throw error;
				}
			});
		}
		/**
		 *
		 * Replace Product Component
		 * @param id
		 * @param componentId
		 * @param productComponent
		 */
		public procurementProductsIdComponentsComponentIdPut (params: {  id: number; componentId: number; productComponent: ProductComponent; }, extraQueryParams?: any, extraFetchParams?: any ) : Promise<Array<ProductComponent>> {
			const localVarPath = this.basePath + '/procurement/products/{id}/components/{componentId}'
				.replace('{' + 'id' + '}', String(params.id))
				.replace('{' + 'componentId' + '}', String(params.componentId));

			let queryParameters: any = assign({}, extraQueryParams);
			let headerParams: any = assign({}, this.defaultHeaders);
			headerParams['Content-Type'] = 'application/json';

			// verify required parameter 'id' is set
			if (params.id == null) {
				throw new Error('Missing required parameter id when calling procurementProductsIdComponentsComponentIdPut');
			}
			// verify required parameter 'componentId' is set
			if (params.componentId == null) {
				throw new Error('Missing required parameter componentId when calling procurementProductsIdComponentsComponentIdPut');
			}
			// verify required parameter 'productComponent' is set
			if (params.productComponent == null) {
				throw new Error('Missing required parameter productComponent when calling procurementProductsIdComponentsComponentIdPut');
			}
			let fetchParams = {
				method: 'PUT',
				headers: headerParams,
				body: JSON.stringify(params.productComponent),

			};

			if (extraFetchParams) {
				fetchParams = assign(fetchParams, extraFetchParams);
			}

			let localVarPathWithQueryParameters = localVarPath + (localVarPath.indexOf('?') !== -1 ? '&' : '?') + querystring.stringify(queryParameters);

			return fetch(localVarPathWithQueryParameters, fetchParams).then((response) => {
				if (response.status >= 200 && response.status < 300) {
					return response.json();
				} else {
					let error = new Error(response.statusText);
					(error as any).response = response;
					throw error;
				}
			});
		}
		/**
		 *
		 * Get Product Components Count
		 * @param id
		 * @param conditions
		 */
		public procurementProductsIdComponentsCountGet (params: {  id: number; conditions?: string; }, extraQueryParams?: any, extraFetchParams?: any ) : Promise<Count> {
			const localVarPath = this.basePath + '/procurement/products/{id}/components/count'
				.replace('{' + 'id' + '}', String(params.id));

			let queryParameters: any = assign({}, extraQueryParams);
			let headerParams: any = assign({}, this.defaultHeaders);
			// verify required parameter 'id' is set
			if (params.id == null) {
				throw new Error('Missing required parameter id when calling procurementProductsIdComponentsCountGet');
			}
			if (params.conditions !== undefined) {
				queryParameters['conditions'] = params.conditions;
			}

			let fetchParams = {
				method: 'GET',
				headers: headerParams,

			};

			if (extraFetchParams) {
				fetchParams = assign(fetchParams, extraFetchParams);
			}

			let localVarPathWithQueryParameters = localVarPath + (localVarPath.indexOf('?') !== -1 ? '&' : '?') + querystring.stringify(queryParameters);

			return fetch(localVarPathWithQueryParameters, fetchParams).then((response) => {
				if (response.status >= 200 && response.status < 300) {
					return response.json();
				} else {
					let error = new Error(response.statusText);
					(error as any).response = response;
					throw error;
				}
			});
		}
		/**
		 *
		 * Get Product Components
		 * @param id
		 * @param conditions
		 * @param orderBy
		 * @param childconditions
		 * @param customfieldconditions
		 * @param page
		 * @param pageSize
		 */
		public procurementProductsIdComponentsGet (params: {  id: number; conditions?: string; orderBy?: string; childconditions?: string; customfieldconditions?: string; page?: number; pageSize?: number; }, extraQueryParams?: any, extraFetchParams?: any ) : Promise<Array<ProductComponent>> {
			const localVarPath = this.basePath + '/procurement/products/{id}/components'
				.replace('{' + 'id' + '}', String(params.id));

			let queryParameters: any = assign({}, extraQueryParams);
			let headerParams: any = assign({}, this.defaultHeaders);
			// verify required parameter 'id' is set
			if (params.id == null) {
				throw new Error('Missing required parameter id when calling procurementProductsIdComponentsGet');
			}
			if (params.conditions !== undefined) {
				queryParameters['conditions'] = params.conditions;
			}

			if (params.orderBy !== undefined) {
				queryParameters['orderBy'] = params.orderBy;
			}

			if (params.childconditions !== undefined) {
				queryParameters['childconditions'] = params.childconditions;
			}

			if (params.customfieldconditions !== undefined) {
				queryParameters['customfieldconditions'] = params.customfieldconditions;
			}

			if (params.page !== undefined) {
				queryParameters['page'] = params.page;
			}

			if (params.pageSize !== undefined) {
				queryParameters['pageSize'] = params.pageSize;
			}

			let fetchParams = {
				method: 'GET',
				headers: headerParams,

			};

			if (extraFetchParams) {
				fetchParams = assign(fetchParams, extraFetchParams);
			}

			let localVarPathWithQueryParameters = localVarPath + (localVarPath.indexOf('?') !== -1 ? '&' : '?') + querystring.stringify(queryParameters);

			return fetch(localVarPathWithQueryParameters, fetchParams).then((response) => {
				if (response.status >= 200 && response.status < 300) {
					return response.json();
				} else {
					let error = new Error(response.statusText);
					(error as any).response = response;
					throw error;
				}
			});
		}
		/**
		 *
		 * Create Product Component
		 * @param id
		 * @param productComponent
		 */
		public procurementProductsIdComponentsPost (params: {  id: number; productComponent: ProductComponent; }, extraQueryParams?: any, extraFetchParams?: any ) : Promise<Array<ProductComponent>> {
			const localVarPath = this.basePath + '/procurement/products/{id}/components'
				.replace('{' + 'id' + '}', String(params.id));

			let queryParameters: any = assign({}, extraQueryParams);
			let headerParams: any = assign({}, this.defaultHeaders);
			headerParams['Content-Type'] = 'application/json';

			// verify required parameter 'id' is set
			if (params.id == null) {
				throw new Error('Missing required parameter id when calling procurementProductsIdComponentsPost');
			}
			// verify required parameter 'productComponent' is set
			if (params.productComponent == null) {
				throw new Error('Missing required parameter productComponent when calling procurementProductsIdComponentsPost');
			}
			let fetchParams = {
				method: 'POST',
				headers: headerParams,
				body: JSON.stringify(params.productComponent),

			};

			if (extraFetchParams) {
				fetchParams = assign(fetchParams, extraFetchParams);
			}

			let localVarPathWithQueryParameters = localVarPath + (localVarPath.indexOf('?') !== -1 ? '&' : '?') + querystring.stringify(queryParameters);

			return fetch(localVarPathWithQueryParameters, fetchParams).then((response) => {
				if (response.status >= 200 && response.status < 300) {
					return response.json();
				} else {
					let error = new Error(response.statusText);
					(error as any).response = response;
					throw error;
				}
			});
		}
	}
//}
//export namespace  {
	'use strict';

	export class ProductPickingShippingDetailsApi {
		protected basePath = 'https://api-na.myconnectwise.net/v4_6_release/apis/3.0';
		public defaultHeaders : any = {};

		constructor(basePath?: string) {
			if (basePath) {
				this.basePath = basePath;
			}
		}

		/**
		 *
		 * Get Product Picking Shipping Details Count
		 * @param id
		 * @param conditions
		 */
		public procurementProductsIdPickingShippingDetailsCountGet (params: {  id: number; conditions?: string; }, extraQueryParams?: any, extraFetchParams?: any ) : Promise<Count> {
			const localVarPath = this.basePath + '/procurement/products/{id}/pickingShippingDetails/count'
				.replace('{' + 'id' + '}', String(params.id));

			let queryParameters: any = assign({}, extraQueryParams);
			let headerParams: any = assign({}, this.defaultHeaders);
			// verify required parameter 'id' is set
			if (params.id == null) {
				throw new Error('Missing required parameter id when calling procurementProductsIdPickingShippingDetailsCountGet');
			}
			if (params.conditions !== undefined) {
				queryParameters['conditions'] = params.conditions;
			}

			let fetchParams = {
				method: 'GET',
				headers: headerParams,

			};

			if (extraFetchParams) {
				fetchParams = assign(fetchParams, extraFetchParams);
			}

			let localVarPathWithQueryParameters = localVarPath + (localVarPath.indexOf('?') !== -1 ? '&' : '?') + querystring.stringify(queryParameters);

			return fetch(localVarPathWithQueryParameters, fetchParams).then((response) => {
				if (response.status >= 200 && response.status < 300) {
					return response.json();
				} else {
					let error = new Error(response.statusText);
					(error as any).response = response;
					throw error;
				}
			});
		}
		/**
		 *
		 * Get Product Picking Shipping Details
		 * @param id
		 * @param conditions
		 * @param orderBy
		 * @param childconditions
		 * @param customfieldconditions
		 * @param page
		 * @param pageSize
		 */
		public procurementProductsIdPickingShippingDetailsGet (params: {  id: number; conditions?: string; orderBy?: string; childconditions?: string; customfieldconditions?: string; page?: number; pageSize?: number; }, extraQueryParams?: any, extraFetchParams?: any ) : Promise<Array<ProductPickingShippingDetail>> {
			const localVarPath = this.basePath + '/procurement/products/{id}/pickingShippingDetails'
				.replace('{' + 'id' + '}', String(params.id));

			let queryParameters: any = assign({}, extraQueryParams);
			let headerParams: any = assign({}, this.defaultHeaders);
			// verify required parameter 'id' is set
			if (params.id == null) {
				throw new Error('Missing required parameter id when calling procurementProductsIdPickingShippingDetailsGet');
			}
			if (params.conditions !== undefined) {
				queryParameters['conditions'] = params.conditions;
			}

			if (params.orderBy !== undefined) {
				queryParameters['orderBy'] = params.orderBy;
			}

			if (params.childconditions !== undefined) {
				queryParameters['childconditions'] = params.childconditions;
			}

			if (params.customfieldconditions !== undefined) {
				queryParameters['customfieldconditions'] = params.customfieldconditions;
			}

			if (params.page !== undefined) {
				queryParameters['page'] = params.page;
			}

			if (params.pageSize !== undefined) {
				queryParameters['pageSize'] = params.pageSize;
			}

			let fetchParams = {
				method: 'GET',
				headers: headerParams,

			};

			if (extraFetchParams) {
				fetchParams = assign(fetchParams, extraFetchParams);
			}

			let localVarPathWithQueryParameters = localVarPath + (localVarPath.indexOf('?') !== -1 ? '&' : '?') + querystring.stringify(queryParameters);

			return fetch(localVarPathWithQueryParameters, fetchParams).then((response) => {
				if (response.status >= 200 && response.status < 300) {
					return response.json();
				} else {
					let error = new Error(response.statusText);
					(error as any).response = response;
					throw error;
				}
			});
		}
		/**
		 *
		 * Delete Products By Id
		 * @param id
		 * @param pickingShippingDetailId
		 */
		public procurementProductsIdPickingShippingDetailsPickingShippingDetailIdDelete (params: {  id: number; pickingShippingDetailId: number; }, extraQueryParams?: any, extraFetchParams?: any ) : Promise<{}> {
			const localVarPath = this.basePath + '/procurement/products/{id}/pickingShippingDetails/{pickingShippingDetailId}'
				.replace('{' + 'id' + '}', String(params.id))
				.replace('{' + 'pickingShippingDetailId' + '}', String(params.pickingShippingDetailId));

			let queryParameters: any = assign({}, extraQueryParams);
			let headerParams: any = assign({}, this.defaultHeaders);
			// verify required parameter 'id' is set
			if (params.id == null) {
				throw new Error('Missing required parameter id when calling procurementProductsIdPickingShippingDetailsPickingShippingDetailIdDelete');
			}
			// verify required parameter 'pickingShippingDetailId' is set
			if (params.pickingShippingDetailId == null) {
				throw new Error('Missing required parameter pickingShippingDetailId when calling procurementProductsIdPickingShippingDetailsPickingShippingDetailIdDelete');
			}
			let fetchParams = {
				method: 'DELETE',
				headers: headerParams,

			};

			if (extraFetchParams) {
				fetchParams = assign(fetchParams, extraFetchParams);
			}

			let localVarPathWithQueryParameters = localVarPath + (localVarPath.indexOf('?') !== -1 ? '&' : '?') + querystring.stringify(queryParameters);

			return fetch(localVarPathWithQueryParameters, fetchParams).then((response) => {
				if (response.status >= 200 && response.status < 300) {
					return response.json();
				} else {
					let error = new Error(response.statusText);
					(error as any).response = response;
					throw error;
				}
			});
		}
		/**
		 *
		 * Get Products By Id
		 * @param id
		 * @param pickingShippingDetailId
		 */
		public procurementProductsIdPickingShippingDetailsPickingShippingDetailIdGet (params: {  id: number; pickingShippingDetailId: number; }, extraQueryParams?: any, extraFetchParams?: any ) : Promise<Array<ProductPickingShippingDetail>> {
			const localVarPath = this.basePath + '/procurement/products/{id}/pickingShippingDetails/{pickingShippingDetailId}'
				.replace('{' + 'id' + '}', String(params.id))
				.replace('{' + 'pickingShippingDetailId' + '}', String(params.pickingShippingDetailId));

			let queryParameters: any = assign({}, extraQueryParams);
			let headerParams: any = assign({}, this.defaultHeaders);
			// verify required parameter 'id' is set
			if (params.id == null) {
				throw new Error('Missing required parameter id when calling procurementProductsIdPickingShippingDetailsPickingShippingDetailIdGet');
			}
			// verify required parameter 'pickingShippingDetailId' is set
			if (params.pickingShippingDetailId == null) {
				throw new Error('Missing required parameter pickingShippingDetailId when calling procurementProductsIdPickingShippingDetailsPickingShippingDetailIdGet');
			}
			let fetchParams = {
				method: 'GET',
				headers: headerParams,

			};

			if (extraFetchParams) {
				fetchParams = assign(fetchParams, extraFetchParams);
			}

			let localVarPathWithQueryParameters = localVarPath + (localVarPath.indexOf('?') !== -1 ? '&' : '?') + querystring.stringify(queryParameters);

			return fetch(localVarPathWithQueryParameters, fetchParams).then((response) => {
				if (response.status >= 200 && response.status < 300) {
					return response.json();
				} else {
					let error = new Error(response.statusText);
					(error as any).response = response;
					throw error;
				}
			});
		}
		/**
		 *
		 * Update Products
		 * @param id
		 * @param pickingShippingDetailId
		 * @param operations
		 */
		public procurementProductsIdPickingShippingDetailsPickingShippingDetailIdPatch (params: {  id: number; pickingShippingDetailId: number; operations: Array<PatchOperation>; }, extraQueryParams?: any, extraFetchParams?: any ) : Promise<Array<ProductPickingShippingDetail>> {
			const localVarPath = this.basePath + '/procurement/products/{id}/pickingShippingDetails/{pickingShippingDetailId}'
				.replace('{' + 'id' + '}', String(params.id))
				.replace('{' + 'pickingShippingDetailId' + '}', String(params.pickingShippingDetailId));

			let queryParameters: any = assign({}, extraQueryParams);
			let headerParams: any = assign({}, this.defaultHeaders);
			headerParams['Content-Type'] = 'application/json';

			// verify required parameter 'id' is set
			if (params.id == null) {
				throw new Error('Missing required parameter id when calling procurementProductsIdPickingShippingDetailsPickingShippingDetailIdPatch');
			}
			// verify required parameter 'pickingShippingDetailId' is set
			if (params.pickingShippingDetailId == null) {
				throw new Error('Missing required parameter pickingShippingDetailId when calling procurementProductsIdPickingShippingDetailsPickingShippingDetailIdPatch');
			}
			// verify required parameter 'operations' is set
			if (params.operations == null) {
				throw new Error('Missing required parameter operations when calling procurementProductsIdPickingShippingDetailsPickingShippingDetailIdPatch');
			}
			let fetchParams = {
				method: 'PATCH',
				headers: headerParams,
				body: JSON.stringify(params.operations),

			};

			if (extraFetchParams) {
				fetchParams = assign(fetchParams, extraFetchParams);
			}

			let localVarPathWithQueryParameters = localVarPath + (localVarPath.indexOf('?') !== -1 ? '&' : '?') + querystring.stringify(queryParameters);

			return fetch(localVarPathWithQueryParameters, fetchParams).then((response) => {
				if (response.status >= 200 && response.status < 300) {
					return response.json();
				} else {
					let error = new Error(response.statusText);
					(error as any).response = response;
					throw error;
				}
			});
		}
		/**
		 *
		 * Replace Products
		 * @param id
		 * @param pickingShippingDetailId
		 * @param productPickingShippingDetails
		 */
		public procurementProductsIdPickingShippingDetailsPickingShippingDetailIdPut (params: {  id: number; pickingShippingDetailId: number; productPickingShippingDetails: ProductPickingShippingDetail; }, extraQueryParams?: any, extraFetchParams?: any ) : Promise<Array<ProductPickingShippingDetail>> {
			const localVarPath = this.basePath + '/procurement/products/{id}/pickingShippingDetails/{pickingShippingDetailId}'
				.replace('{' + 'id' + '}', String(params.id))
				.replace('{' + 'pickingShippingDetailId' + '}', String(params.pickingShippingDetailId));

			let queryParameters: any = assign({}, extraQueryParams);
			let headerParams: any = assign({}, this.defaultHeaders);
			headerParams['Content-Type'] = 'application/json';

			// verify required parameter 'id' is set
			if (params.id == null) {
				throw new Error('Missing required parameter id when calling procurementProductsIdPickingShippingDetailsPickingShippingDetailIdPut');
			}
			// verify required parameter 'pickingShippingDetailId' is set
			if (params.pickingShippingDetailId == null) {
				throw new Error('Missing required parameter pickingShippingDetailId when calling procurementProductsIdPickingShippingDetailsPickingShippingDetailIdPut');
			}
			// verify required parameter 'productPickingShippingDetails' is set
			if (params.productPickingShippingDetails == null) {
				throw new Error('Missing required parameter productPickingShippingDetails when calling procurementProductsIdPickingShippingDetailsPickingShippingDetailIdPut');
			}
			let fetchParams = {
				method: 'PUT',
				headers: headerParams,
				body: JSON.stringify(params.productPickingShippingDetails),

			};

			if (extraFetchParams) {
				fetchParams = assign(fetchParams, extraFetchParams);
			}

			let localVarPathWithQueryParameters = localVarPath + (localVarPath.indexOf('?') !== -1 ? '&' : '?') + querystring.stringify(queryParameters);

			return fetch(localVarPathWithQueryParameters, fetchParams).then((response) => {
				if (response.status >= 200 && response.status < 300) {
					return response.json();
				} else {
					let error = new Error(response.statusText);
					(error as any).response = response;
					throw error;
				}
			});
		}
		/**
		 *
		 * Create Product Picking Shipping Detail
		 * @param id
		 * @param productPickingShippingDetails
		 */
		public procurementProductsIdPickingShippingDetailsPost (params: {  id: number; productPickingShippingDetails: ProductPickingShippingDetail; }, extraQueryParams?: any, extraFetchParams?: any ) : Promise<Array<ProductPickingShippingDetail>> {
			const localVarPath = this.basePath + '/procurement/products/{id}/pickingShippingDetails'
				.replace('{' + 'id' + '}', String(params.id));

			let queryParameters: any = assign({}, extraQueryParams);
			let headerParams: any = assign({}, this.defaultHeaders);
			headerParams['Content-Type'] = 'application/json';

			// verify required parameter 'id' is set
			if (params.id == null) {
				throw new Error('Missing required parameter id when calling procurementProductsIdPickingShippingDetailsPost');
			}
			// verify required parameter 'productPickingShippingDetails' is set
			if (params.productPickingShippingDetails == null) {
				throw new Error('Missing required parameter productPickingShippingDetails when calling procurementProductsIdPickingShippingDetailsPost');
			}
			let fetchParams = {
				method: 'POST',
				headers: headerParams,
				body: JSON.stringify(params.productPickingShippingDetails),

			};

			if (extraFetchParams) {
				fetchParams = assign(fetchParams, extraFetchParams);
			}

			let localVarPathWithQueryParameters = localVarPath + (localVarPath.indexOf('?') !== -1 ? '&' : '?') + querystring.stringify(queryParameters);

			return fetch(localVarPathWithQueryParameters, fetchParams).then((response) => {
				if (response.status >= 200 && response.status < 300) {
					return response.json();
				} else {
					let error = new Error(response.statusText);
					(error as any).response = response;
					throw error;
				}
			});
		}
	}
//}
//export namespace  {
	'use strict';

	export class ProductTypesApi {
		protected basePath = 'https://api-na.myconnectwise.net/v4_6_release/apis/3.0';
		public defaultHeaders : any = {};

		constructor(basePath?: string) {
			if (basePath) {
				this.basePath = basePath;
			}
		}

		/**
		 *
		 * Get Product Typess Count
		 * @param conditions
		 */
		public procurementTypesCountGet (params: {  conditions?: string; }, extraQueryParams?: any, extraFetchParams?: any ) : Promise<Count> {
			const localVarPath = this.basePath + '/procurement/types/count';

			let queryParameters: any = assign({}, extraQueryParams);
			let headerParams: any = assign({}, this.defaultHeaders);
			if (params.conditions !== undefined) {
				queryParameters['conditions'] = params.conditions;
			}

			let fetchParams = {
				method: 'GET',
				headers: headerParams,

			};

			if (extraFetchParams) {
				fetchParams = assign(fetchParams, extraFetchParams);
			}

			let localVarPathWithQueryParameters = localVarPath + (localVarPath.indexOf('?') !== -1 ? '&' : '?') + querystring.stringify(queryParameters);

			return fetch(localVarPathWithQueryParameters, fetchParams).then((response) => {
				if (response.status >= 200 && response.status < 300) {
					return response.json();
				} else {
					let error = new Error(response.statusText);
					(error as any).response = response;
					throw error;
				}
			});
		}
		/**
		 *
		 * Get Product Typess
		 * @param conditions
		 * @param orderBy
		 * @param childconditions
		 * @param customfieldconditions
		 * @param page
		 * @param pageSize
		 */
		public procurementTypesGet (params: {  conditions?: string; orderBy?: string; childconditions?: string; customfieldconditions?: string; page?: number; pageSize?: number; }, extraQueryParams?: any, extraFetchParams?: any ) : Promise<Array<ProductType>> {
			const localVarPath = this.basePath + '/procurement/types';

			let queryParameters: any = assign({}, extraQueryParams);
			let headerParams: any = assign({}, this.defaultHeaders);
			if (params.conditions !== undefined) {
				queryParameters['conditions'] = params.conditions;
			}

			if (params.orderBy !== undefined) {
				queryParameters['orderBy'] = params.orderBy;
			}

			if (params.childconditions !== undefined) {
				queryParameters['childconditions'] = params.childconditions;
			}

			if (params.customfieldconditions !== undefined) {
				queryParameters['customfieldconditions'] = params.customfieldconditions;
			}

			if (params.page !== undefined) {
				queryParameters['page'] = params.page;
			}

			if (params.pageSize !== undefined) {
				queryParameters['pageSize'] = params.pageSize;
			}

			let fetchParams = {
				method: 'GET',
				headers: headerParams,

			};

			if (extraFetchParams) {
				fetchParams = assign(fetchParams, extraFetchParams);
			}

			let localVarPathWithQueryParameters = localVarPath + (localVarPath.indexOf('?') !== -1 ? '&' : '?') + querystring.stringify(queryParameters);

			return fetch(localVarPathWithQueryParameters, fetchParams).then((response) => {
				if (response.status >= 200 && response.status < 300) {
					return response.json();
				} else {
					let error = new Error(response.statusText);
					(error as any).response = response;
					throw error;
				}
			});
		}
		/**
		 *
		 * Delete Product Types By Id
		 * @param id
		 */
		public procurementTypesIdDelete (params: {  id: number; }, extraQueryParams?: any, extraFetchParams?: any ) : Promise<{}> {
			const localVarPath = this.basePath + '/procurement/types/{id}'
				.replace('{' + 'id' + '}', String(params.id));

			let queryParameters: any = assign({}, extraQueryParams);
			let headerParams: any = assign({}, this.defaultHeaders);
			// verify required parameter 'id' is set
			if (params.id == null) {
				throw new Error('Missing required parameter id when calling procurementTypesIdDelete');
			}
			let fetchParams = {
				method: 'DELETE',
				headers: headerParams,

			};

			if (extraFetchParams) {
				fetchParams = assign(fetchParams, extraFetchParams);
			}

			let localVarPathWithQueryParameters = localVarPath + (localVarPath.indexOf('?') !== -1 ? '&' : '?') + querystring.stringify(queryParameters);

			return fetch(localVarPathWithQueryParameters, fetchParams).then((response) => {
				if (response.status >= 200 && response.status < 300) {
					return response.json();
				} else {
					let error = new Error(response.statusText);
					(error as any).response = response;
					throw error;
				}
			});
		}
		/**
		 *
		 * Get Product Types By Id
		 * @param id
		 */
		public procurementTypesIdGet (params: {  id: number; }, extraQueryParams?: any, extraFetchParams?: any ) : Promise<ProductType> {
			const localVarPath = this.basePath + '/procurement/types/{id}'
				.replace('{' + 'id' + '}', String(params.id));

			let queryParameters: any = assign({}, extraQueryParams);
			let headerParams: any = assign({}, this.defaultHeaders);
			// verify required parameter 'id' is set
			if (params.id == null) {
				throw new Error('Missing required parameter id when calling procurementTypesIdGet');
			}
			let fetchParams = {
				method: 'GET',
				headers: headerParams,

			};

			if (extraFetchParams) {
				fetchParams = assign(fetchParams, extraFetchParams);
			}

			let localVarPathWithQueryParameters = localVarPath + (localVarPath.indexOf('?') !== -1 ? '&' : '?') + querystring.stringify(queryParameters);

			return fetch(localVarPathWithQueryParameters, fetchParams).then((response) => {
				if (response.status >= 200 && response.status < 300) {
					return response.json();
				} else {
					let error = new Error(response.statusText);
					(error as any).response = response;
					throw error;
				}
			});
		}
		/**
		 *
		 * Update Product Types
		 * @param id
		 * @param operations
		 */
		public procurementTypesIdPatch (params: {  id: number; operations: Array<PatchOperation>; }, extraQueryParams?: any, extraFetchParams?: any ) : Promise<ProductType> {
			const localVarPath = this.basePath + '/procurement/types/{id}'
				.replace('{' + 'id' + '}', String(params.id));

			let queryParameters: any = assign({}, extraQueryParams);
			let headerParams: any = assign({}, this.defaultHeaders);
			headerParams['Content-Type'] = 'application/json';

			// verify required parameter 'id' is set
			if (params.id == null) {
				throw new Error('Missing required parameter id when calling procurementTypesIdPatch');
			}
			// verify required parameter 'operations' is set
			if (params.operations == null) {
				throw new Error('Missing required parameter operations when calling procurementTypesIdPatch');
			}
			let fetchParams = {
				method: 'PATCH',
				headers: headerParams,
				body: JSON.stringify(params.operations),

			};

			if (extraFetchParams) {
				fetchParams = assign(fetchParams, extraFetchParams);
			}

			let localVarPathWithQueryParameters = localVarPath + (localVarPath.indexOf('?') !== -1 ? '&' : '?') + querystring.stringify(queryParameters);

			return fetch(localVarPathWithQueryParameters, fetchParams).then((response) => {
				if (response.status >= 200 && response.status < 300) {
					return response.json();
				} else {
					let error = new Error(response.statusText);
					(error as any).response = response;
					throw error;
				}
			});
		}
		/**
		 *
		 * Replace Product Types
		 * @param id
		 * @param productTypes
		 */
		public procurementTypesIdPut (params: {  id: number; productTypes: ProductType; }, extraQueryParams?: any, extraFetchParams?: any ) : Promise<ProductType> {
			const localVarPath = this.basePath + '/procurement/types/{id}'
				.replace('{' + 'id' + '}', String(params.id));

			let queryParameters: any = assign({}, extraQueryParams);
			let headerParams: any = assign({}, this.defaultHeaders);
			headerParams['Content-Type'] = 'application/json';

			// verify required parameter 'id' is set
			if (params.id == null) {
				throw new Error('Missing required parameter id when calling procurementTypesIdPut');
			}
			// verify required parameter 'productTypes' is set
			if (params.productTypes == null) {
				throw new Error('Missing required parameter productTypes when calling procurementTypesIdPut');
			}
			let fetchParams = {
				method: 'PUT',
				headers: headerParams,
				body: JSON.stringify(params.productTypes),

			};

			if (extraFetchParams) {
				fetchParams = assign(fetchParams, extraFetchParams);
			}

			let localVarPathWithQueryParameters = localVarPath + (localVarPath.indexOf('?') !== -1 ? '&' : '?') + querystring.stringify(queryParameters);

			return fetch(localVarPathWithQueryParameters, fetchParams).then((response) => {
				if (response.status >= 200 && response.status < 300) {
					return response.json();
				} else {
					let error = new Error(response.statusText);
					(error as any).response = response;
					throw error;
				}
			});
		}
		/**
		 *
		 * Create Product Types
		 * @param productTypes
		 */
		public procurementTypesPost (params: {  productTypes: ProductType; }, extraQueryParams?: any, extraFetchParams?: any ) : Promise<ProductType> {
			const localVarPath = this.basePath + '/procurement/types';

			let queryParameters: any = assign({}, extraQueryParams);
			let headerParams: any = assign({}, this.defaultHeaders);
			headerParams['Content-Type'] = 'application/json';

			// verify required parameter 'productTypes' is set
			if (params.productTypes == null) {
				throw new Error('Missing required parameter productTypes when calling procurementTypesPost');
			}
			let fetchParams = {
				method: 'POST',
				headers: headerParams,
				body: JSON.stringify(params.productTypes),

			};

			if (extraFetchParams) {
				fetchParams = assign(fetchParams, extraFetchParams);
			}

			let localVarPathWithQueryParameters = localVarPath + (localVarPath.indexOf('?') !== -1 ? '&' : '?') + querystring.stringify(queryParameters);

			return fetch(localVarPathWithQueryParameters, fetchParams).then((response) => {
				if (response.status >= 200 && response.status < 300) {
					return response.json();
				} else {
					let error = new Error(response.statusText);
					(error as any).response = response;
					throw error;
				}
			});
		}
	}
//}
//export namespace  {
	'use strict';

	export class ProductsItemApi {
		protected basePath = 'https://api-na.myconnectwise.net/v4_6_release/apis/3.0';
		public defaultHeaders : any = {};

		constructor(basePath?: string) {
			if (basePath) {
				this.basePath = basePath;
			}
		}

		/**
		 *
		 * Get Products Count
		 * @param conditions
		 */
		public procurementProductsCountGet (params: {  conditions?: string; }, extraQueryParams?: any, extraFetchParams?: any ) : Promise<Count> {
			const localVarPath = this.basePath + '/procurement/products/count';

			let queryParameters: any = assign({}, extraQueryParams);
			let headerParams: any = assign({}, this.defaultHeaders);
			if (params.conditions !== undefined) {
				queryParameters['conditions'] = params.conditions;
			}

			let fetchParams = {
				method: 'GET',
				headers: headerParams,

			};

			if (extraFetchParams) {
				fetchParams = assign(fetchParams, extraFetchParams);
			}

			let localVarPathWithQueryParameters = localVarPath + (localVarPath.indexOf('?') !== -1 ? '&' : '?') + querystring.stringify(queryParameters);

			return fetch(localVarPathWithQueryParameters, fetchParams).then((response) => {
				if (response.status >= 200 && response.status < 300) {
					return response.json();
				} else {
					let error = new Error(response.statusText);
					(error as any).response = response;
					throw error;
				}
			});
		}
		/**
		 *
		 * Get Products
		 * @param conditions
		 * @param orderBy
		 * @param childconditions
		 * @param customfieldconditions
		 * @param page
		 * @param pageSize
		 */
		public procurementProductsGet (params: {  conditions?: string; orderBy?: string; childconditions?: string; customfieldconditions?: string; page?: number; pageSize?: number; }, extraQueryParams?: any, extraFetchParams?: any ) : Promise<Array<ProductItem>> {
			const localVarPath = this.basePath + '/procurement/products';

			let queryParameters: any = assign({}, extraQueryParams);
			let headerParams: any = assign({}, this.defaultHeaders);
			if (params.conditions !== undefined) {
				queryParameters['conditions'] = params.conditions;
			}

			if (params.orderBy !== undefined) {
				queryParameters['orderBy'] = params.orderBy;
			}

			if (params.childconditions !== undefined) {
				queryParameters['childconditions'] = params.childconditions;
			}

			if (params.customfieldconditions !== undefined) {
				queryParameters['customfieldconditions'] = params.customfieldconditions;
			}

			if (params.page !== undefined) {
				queryParameters['page'] = params.page;
			}

			if (params.pageSize !== undefined) {
				queryParameters['pageSize'] = params.pageSize;
			}

			let fetchParams = {
				method: 'GET',
				headers: headerParams,

			};

			if (extraFetchParams) {
				fetchParams = assign(fetchParams, extraFetchParams);
			}

			let localVarPathWithQueryParameters = localVarPath + (localVarPath.indexOf('?') !== -1 ? '&' : '?') + querystring.stringify(queryParameters);

			return fetch(localVarPathWithQueryParameters, fetchParams).then((response) => {
				if (response.status >= 200 && response.status < 300) {
					return response.json();
				} else {
					let error = new Error(response.statusText);
					(error as any).response = response;
					throw error;
				}
			});
		}
		/**
		 *
		 * Delete Product By Id
		 * @param id
		 */
		public procurementProductsIdDelete (params: {  id: number; }, extraQueryParams?: any, extraFetchParams?: any ) : Promise<{}> {
			const localVarPath = this.basePath + '/procurement/products/{id}'
				.replace('{' + 'id' + '}', String(params.id));

			let queryParameters: any = assign({}, extraQueryParams);
			let headerParams: any = assign({}, this.defaultHeaders);
			// verify required parameter 'id' is set
			if (params.id == null) {
				throw new Error('Missing required parameter id when calling procurementProductsIdDelete');
			}
			let fetchParams = {
				method: 'DELETE',
				headers: headerParams,

			};

			if (extraFetchParams) {
				fetchParams = assign(fetchParams, extraFetchParams);
			}

			let localVarPathWithQueryParameters = localVarPath + (localVarPath.indexOf('?') !== -1 ? '&' : '?') + querystring.stringify(queryParameters);

			return fetch(localVarPathWithQueryParameters, fetchParams).then((response) => {
				if (response.status >= 200 && response.status < 300) {
					return response.json();
				} else {
					let error = new Error(response.statusText);
					(error as any).response = response;
					throw error;
				}
			});
		}
		/**
		 *
		 * Get Product By Id
		 * @param id
		 */
		public procurementProductsIdGet (params: {  id: number; }, extraQueryParams?: any, extraFetchParams?: any ) : Promise<ProductItem> {
			const localVarPath = this.basePath + '/procurement/products/{id}'
				.replace('{' + 'id' + '}', String(params.id));

			let queryParameters: any = assign({}, extraQueryParams);
			let headerParams: any = assign({}, this.defaultHeaders);
			// verify required parameter 'id' is set
			if (params.id == null) {
				throw new Error('Missing required parameter id when calling procurementProductsIdGet');
			}
			let fetchParams = {
				method: 'GET',
				headers: headerParams,

			};

			if (extraFetchParams) {
				fetchParams = assign(fetchParams, extraFetchParams);
			}

			let localVarPathWithQueryParameters = localVarPath + (localVarPath.indexOf('?') !== -1 ? '&' : '?') + querystring.stringify(queryParameters);

			return fetch(localVarPathWithQueryParameters, fetchParams).then((response) => {
				if (response.status >= 200 && response.status < 300) {
					return response.json();
				} else {
					let error = new Error(response.statusText);
					(error as any).response = response;
					throw error;
				}
			});
		}
		/**
		 *
		 * Update Product
		 * @param id
		 * @param operations
		 */
		public procurementProductsIdPatch (params: {  id: number; operations: Array<PatchOperation>; }, extraQueryParams?: any, extraFetchParams?: any ) : Promise<ProductItem> {
			const localVarPath = this.basePath + '/procurement/products/{id}'
				.replace('{' + 'id' + '}', String(params.id));

			let queryParameters: any = assign({}, extraQueryParams);
			let headerParams: any = assign({}, this.defaultHeaders);
			headerParams['Content-Type'] = 'application/json';

			// verify required parameter 'id' is set
			if (params.id == null) {
				throw new Error('Missing required parameter id when calling procurementProductsIdPatch');
			}
			// verify required parameter 'operations' is set
			if (params.operations == null) {
				throw new Error('Missing required parameter operations when calling procurementProductsIdPatch');
			}
			let fetchParams = {
				method: 'PATCH',
				headers: headerParams,
				body: JSON.stringify(params.operations),

			};

			if (extraFetchParams) {
				fetchParams = assign(fetchParams, extraFetchParams);
			}

			let localVarPathWithQueryParameters = localVarPath + (localVarPath.indexOf('?') !== -1 ? '&' : '?') + querystring.stringify(queryParameters);

			return fetch(localVarPathWithQueryParameters, fetchParams).then((response) => {
				if (response.status >= 200 && response.status < 300) {
					return response.json();
				} else {
					let error = new Error(response.statusText);
					(error as any).response = response;
					throw error;
				}
			});
		}
		/**
		 *
		 * Replace Product
		 * @param id
		 * @param productItem
		 */
		public procurementProductsIdPut (params: {  id: number; productItem: ProductItem; }, extraQueryParams?: any, extraFetchParams?: any ) : Promise<ProductItem> {
			const localVarPath = this.basePath + '/procurement/products/{id}'
				.replace('{' + 'id' + '}', String(params.id));

			let queryParameters: any = assign({}, extraQueryParams);
			let headerParams: any = assign({}, this.defaultHeaders);
			headerParams['Content-Type'] = 'application/json';

			// verify required parameter 'id' is set
			if (params.id == null) {
				throw new Error('Missing required parameter id when calling procurementProductsIdPut');
			}
			// verify required parameter 'productItem' is set
			if (params.productItem == null) {
				throw new Error('Missing required parameter productItem when calling procurementProductsIdPut');
			}
			let fetchParams = {
				method: 'PUT',
				headers: headerParams,
				body: JSON.stringify(params.productItem),

			};

			if (extraFetchParams) {
				fetchParams = assign(fetchParams, extraFetchParams);
			}

			let localVarPathWithQueryParameters = localVarPath + (localVarPath.indexOf('?') !== -1 ? '&' : '?') + querystring.stringify(queryParameters);

			return fetch(localVarPathWithQueryParameters, fetchParams).then((response) => {
				if (response.status >= 200 && response.status < 300) {
					return response.json();
				} else {
					let error = new Error(response.statusText);
					(error as any).response = response;
					throw error;
				}
			});
		}
		/**
		 *
		 * Create Product
		 * @param productItem
		 */
		public procurementProductsPost (params: {  productItem: ProductItem; }, extraQueryParams?: any, extraFetchParams?: any ) : Promise<ProductItem> {
			const localVarPath = this.basePath + '/procurement/products';

			let queryParameters: any = assign({}, extraQueryParams);
			let headerParams: any = assign({}, this.defaultHeaders);
			headerParams['Content-Type'] = 'application/json';

			// verify required parameter 'productItem' is set
			if (params.productItem == null) {
				throw new Error('Missing required parameter productItem when calling procurementProductsPost');
			}
			let fetchParams = {
				method: 'POST',
				headers: headerParams,
				body: JSON.stringify(params.productItem),

			};

			if (extraFetchParams) {
				fetchParams = assign(fetchParams, extraFetchParams);
			}

			let localVarPathWithQueryParameters = localVarPath + (localVarPath.indexOf('?') !== -1 ? '&' : '?') + querystring.stringify(queryParameters);

			return fetch(localVarPathWithQueryParameters, fetchParams).then((response) => {
				if (response.status >= 200 && response.status < 300) {
					return response.json();
				} else {
					let error = new Error(response.statusText);
					(error as any).response = response;
					throw error;
				}
			});
		}
	}
//}
//export namespace  {
	'use strict';

	export class ProjectContactsApi {
		protected basePath = 'https://api-na.myconnectwise.net/v4_6_release/apis/3.0';
		public defaultHeaders : any = {};

		constructor(basePath?: string) {
			if (basePath) {
				this.basePath = basePath;
			}
		}

		/**
		 *
		 * Delete Project Contact By Id
		 * @param id
		 * @param contactId
		 */
		public projectProjectsIdContactsContactIdDelete (params: {  id: number; contactId: number; }, extraQueryParams?: any, extraFetchParams?: any ) : Promise<{}> {
			const localVarPath = this.basePath + '/project/projects/{id}/contacts/{contactId}'
				.replace('{' + 'id' + '}', String(params.id))
				.replace('{' + 'contactId' + '}', String(params.contactId));

			let queryParameters: any = assign({}, extraQueryParams);
			let headerParams: any = assign({}, this.defaultHeaders);
			// verify required parameter 'id' is set
			if (params.id == null) {
				throw new Error('Missing required parameter id when calling projectProjectsIdContactsContactIdDelete');
			}
			// verify required parameter 'contactId' is set
			if (params.contactId == null) {
				throw new Error('Missing required parameter contactId when calling projectProjectsIdContactsContactIdDelete');
			}
			let fetchParams = {
				method: 'DELETE',
				headers: headerParams,

			};

			if (extraFetchParams) {
				fetchParams = assign(fetchParams, extraFetchParams);
			}

			let localVarPathWithQueryParameters = localVarPath + (localVarPath.indexOf('?') !== -1 ? '&' : '?') + querystring.stringify(queryParameters);

			return fetch(localVarPathWithQueryParameters, fetchParams).then((response) => {
				if (response.status >= 200 && response.status < 300) {
					return response.json();
				} else {
					let error = new Error(response.statusText);
					(error as any).response = response;
					throw error;
				}
			});
		}
		/**
		 *
		 * Get Project Contact By Id
		 * @param id
		 * @param contactId
		 */
		public projectProjectsIdContactsContactIdGet (params: {  id: number; contactId: number; }, extraQueryParams?: any, extraFetchParams?: any ) : Promise<ProjectContact> {
			const localVarPath = this.basePath + '/project/projects/{id}/contacts/{contactId}'
				.replace('{' + 'id' + '}', String(params.id))
				.replace('{' + 'contactId' + '}', String(params.contactId));

			let queryParameters: any = assign({}, extraQueryParams);
			let headerParams: any = assign({}, this.defaultHeaders);
			// verify required parameter 'id' is set
			if (params.id == null) {
				throw new Error('Missing required parameter id when calling projectProjectsIdContactsContactIdGet');
			}
			// verify required parameter 'contactId' is set
			if (params.contactId == null) {
				throw new Error('Missing required parameter contactId when calling projectProjectsIdContactsContactIdGet');
			}
			let fetchParams = {
				method: 'GET',
				headers: headerParams,

			};

			if (extraFetchParams) {
				fetchParams = assign(fetchParams, extraFetchParams);
			}

			let localVarPathWithQueryParameters = localVarPath + (localVarPath.indexOf('?') !== -1 ? '&' : '?') + querystring.stringify(queryParameters);

			return fetch(localVarPathWithQueryParameters, fetchParams).then((response) => {
				if (response.status >= 200 && response.status < 300) {
					return response.json();
				} else {
					let error = new Error(response.statusText);
					(error as any).response = response;
					throw error;
				}
			});
		}
		/**
		 *
		 * Get Project Contacts
		 * @param id
		 * @param conditions
		 * @param orderBy
		 * @param childconditions
		 * @param customfieldconditions
		 * @param page
		 * @param pageSize
		 */
		public projectProjectsIdContactsGet (params: {  id: number; conditions?: string; orderBy?: string; childconditions?: string; customfieldconditions?: string; page?: number; pageSize?: number; }, extraQueryParams?: any, extraFetchParams?: any ) : Promise<Array<ProjectContact>> {
			const localVarPath = this.basePath + '/project/projects/{id}/contacts'
				.replace('{' + 'id' + '}', String(params.id));

			let queryParameters: any = assign({}, extraQueryParams);
			let headerParams: any = assign({}, this.defaultHeaders);
			// verify required parameter 'id' is set
			if (params.id == null) {
				throw new Error('Missing required parameter id when calling projectProjectsIdContactsGet');
			}
			if (params.conditions !== undefined) {
				queryParameters['conditions'] = params.conditions;
			}

			if (params.orderBy !== undefined) {
				queryParameters['orderBy'] = params.orderBy;
			}

			if (params.childconditions !== undefined) {
				queryParameters['childconditions'] = params.childconditions;
			}

			if (params.customfieldconditions !== undefined) {
				queryParameters['customfieldconditions'] = params.customfieldconditions;
			}

			if (params.page !== undefined) {
				queryParameters['page'] = params.page;
			}

			if (params.pageSize !== undefined) {
				queryParameters['pageSize'] = params.pageSize;
			}

			let fetchParams = {
				method: 'GET',
				headers: headerParams,

			};

			if (extraFetchParams) {
				fetchParams = assign(fetchParams, extraFetchParams);
			}

			let localVarPathWithQueryParameters = localVarPath + (localVarPath.indexOf('?') !== -1 ? '&' : '?') + querystring.stringify(queryParameters);

			return fetch(localVarPathWithQueryParameters, fetchParams).then((response) => {
				if (response.status >= 200 && response.status < 300) {
					return response.json();
				} else {
					let error = new Error(response.statusText);
					(error as any).response = response;
					throw error;
				}
			});
		}
		/**
		 *
		 * Create Project Contact
		 * @param id
		 * @param contact
		 */
		public projectProjectsIdContactsPost (params: {  id: number; contact: ProjectContact; }, extraQueryParams?: any, extraFetchParams?: any ) : Promise<ProjectContact> {
			const localVarPath = this.basePath + '/project/projects/{id}/contacts'
				.replace('{' + 'id' + '}', String(params.id));

			let queryParameters: any = assign({}, extraQueryParams);
			let headerParams: any = assign({}, this.defaultHeaders);
			headerParams['Content-Type'] = 'application/json';

			// verify required parameter 'id' is set
			if (params.id == null) {
				throw new Error('Missing required parameter id when calling projectProjectsIdContactsPost');
			}
			// verify required parameter 'contact' is set
			if (params.contact == null) {
				throw new Error('Missing required parameter contact when calling projectProjectsIdContactsPost');
			}
			let fetchParams = {
				method: 'POST',
				headers: headerParams,
				body: JSON.stringify(params.contact),

			};

			if (extraFetchParams) {
				fetchParams = assign(fetchParams, extraFetchParams);
			}

			let localVarPathWithQueryParameters = localVarPath + (localVarPath.indexOf('?') !== -1 ? '&' : '?') + querystring.stringify(queryParameters);

			return fetch(localVarPathWithQueryParameters, fetchParams).then((response) => {
				if (response.status >= 200 && response.status < 300) {
					return response.json();
				} else {
					let error = new Error(response.statusText);
					(error as any).response = response;
					throw error;
				}
			});
		}
	}
//}
//export namespace  {
	'use strict';

	export class ProjectNotesApi {
		protected basePath = 'https://api-na.myconnectwise.net/v4_6_release/apis/3.0';
		public defaultHeaders : any = {};

		constructor(basePath?: string) {
			if (basePath) {
				this.basePath = basePath;
			}
		}

		/**
		 *
		 * Get Project Notes Count
		 * @param id
		 * @param conditions
		 */
		public projectProjectsIdNotesCountGet (params: {  id: number; conditions?: string; }, extraQueryParams?: any, extraFetchParams?: any ) : Promise<Count> {
			const localVarPath = this.basePath + '/project/projects/{id}/notes/count'
				.replace('{' + 'id' + '}', String(params.id));

			let queryParameters: any = assign({}, extraQueryParams);
			let headerParams: any = assign({}, this.defaultHeaders);
			// verify required parameter 'id' is set
			if (params.id == null) {
				throw new Error('Missing required parameter id when calling projectProjectsIdNotesCountGet');
			}
			if (params.conditions !== undefined) {
				queryParameters['conditions'] = params.conditions;
			}

			let fetchParams = {
				method: 'GET',
				headers: headerParams,

			};

			if (extraFetchParams) {
				fetchParams = assign(fetchParams, extraFetchParams);
			}

			let localVarPathWithQueryParameters = localVarPath + (localVarPath.indexOf('?') !== -1 ? '&' : '?') + querystring.stringify(queryParameters);

			return fetch(localVarPathWithQueryParameters, fetchParams).then((response) => {
				if (response.status >= 200 && response.status < 300) {
					return response.json();
				} else {
					let error = new Error(response.statusText);
					(error as any).response = response;
					throw error;
				}
			});
		}
		/**
		 *
		 * Get Project Notes
		 * @param id
		 * @param conditions
		 * @param orderBy
		 * @param childconditions
		 * @param customfieldconditions
		 * @param page
		 * @param pageSize
		 */
		public projectProjectsIdNotesGet (params: {  id: number; conditions?: string; orderBy?: string; childconditions?: string; customfieldconditions?: string; page?: number; pageSize?: number; }, extraQueryParams?: any, extraFetchParams?: any ) : Promise<Array<ProjectNote>> {
			const localVarPath = this.basePath + '/project/projects/{id}/notes'
				.replace('{' + 'id' + '}', String(params.id));

			let queryParameters: any = assign({}, extraQueryParams);
			let headerParams: any = assign({}, this.defaultHeaders);
			// verify required parameter 'id' is set
			if (params.id == null) {
				throw new Error('Missing required parameter id when calling projectProjectsIdNotesGet');
			}
			if (params.conditions !== undefined) {
				queryParameters['conditions'] = params.conditions;
			}

			if (params.orderBy !== undefined) {
				queryParameters['orderBy'] = params.orderBy;
			}

			if (params.childconditions !== undefined) {
				queryParameters['childconditions'] = params.childconditions;
			}

			if (params.customfieldconditions !== undefined) {
				queryParameters['customfieldconditions'] = params.customfieldconditions;
			}

			if (params.page !== undefined) {
				queryParameters['page'] = params.page;
			}

			if (params.pageSize !== undefined) {
				queryParameters['pageSize'] = params.pageSize;
			}

			let fetchParams = {
				method: 'GET',
				headers: headerParams,

			};

			if (extraFetchParams) {
				fetchParams = assign(fetchParams, extraFetchParams);
			}

			let localVarPathWithQueryParameters = localVarPath + (localVarPath.indexOf('?') !== -1 ? '&' : '?') + querystring.stringify(queryParameters);

			return fetch(localVarPathWithQueryParameters, fetchParams).then((response) => {
				if (response.status >= 200 && response.status < 300) {
					return response.json();
				} else {
					let error = new Error(response.statusText);
					(error as any).response = response;
					throw error;
				}
			});
		}
		/**
		 *
		 * Delete Project Note By Id
		 * @param id
		 * @param noteId
		 */
		public projectProjectsIdNotesNoteIdDelete (params: {  id: number; noteId: number; }, extraQueryParams?: any, extraFetchParams?: any ) : Promise<{}> {
			const localVarPath = this.basePath + '/project/projects/{id}/notes/{noteId}'
				.replace('{' + 'id' + '}', String(params.id))
				.replace('{' + 'noteId' + '}', String(params.noteId));

			let queryParameters: any = assign({}, extraQueryParams);
			let headerParams: any = assign({}, this.defaultHeaders);
			// verify required parameter 'id' is set
			if (params.id == null) {
				throw new Error('Missing required parameter id when calling projectProjectsIdNotesNoteIdDelete');
			}
			// verify required parameter 'noteId' is set
			if (params.noteId == null) {
				throw new Error('Missing required parameter noteId when calling projectProjectsIdNotesNoteIdDelete');
			}
			let fetchParams = {
				method: 'DELETE',
				headers: headerParams,

			};

			if (extraFetchParams) {
				fetchParams = assign(fetchParams, extraFetchParams);
			}

			let localVarPathWithQueryParameters = localVarPath + (localVarPath.indexOf('?') !== -1 ? '&' : '?') + querystring.stringify(queryParameters);

			return fetch(localVarPathWithQueryParameters, fetchParams).then((response) => {
				if (response.status >= 200 && response.status < 300) {
					return response.json();
				} else {
					let error = new Error(response.statusText);
					(error as any).response = response;
					throw error;
				}
			});
		}
		/**
		 *
		 * Get Project Note By Id
		 * @param id
		 * @param noteId
		 */
		public projectProjectsIdNotesNoteIdGet (params: {  id: number; noteId: number; }, extraQueryParams?: any, extraFetchParams?: any ) : Promise<ProjectNote> {
			const localVarPath = this.basePath + '/project/projects/{id}/notes/{noteId}'
				.replace('{' + 'id' + '}', String(params.id))
				.replace('{' + 'noteId' + '}', String(params.noteId));

			let queryParameters: any = assign({}, extraQueryParams);
			let headerParams: any = assign({}, this.defaultHeaders);
			// verify required parameter 'id' is set
			if (params.id == null) {
				throw new Error('Missing required parameter id when calling projectProjectsIdNotesNoteIdGet');
			}
			// verify required parameter 'noteId' is set
			if (params.noteId == null) {
				throw new Error('Missing required parameter noteId when calling projectProjectsIdNotesNoteIdGet');
			}
			let fetchParams = {
				method: 'GET',
				headers: headerParams,

			};

			if (extraFetchParams) {
				fetchParams = assign(fetchParams, extraFetchParams);
			}

			let localVarPathWithQueryParameters = localVarPath + (localVarPath.indexOf('?') !== -1 ? '&' : '?') + querystring.stringify(queryParameters);

			return fetch(localVarPathWithQueryParameters, fetchParams).then((response) => {
				if (response.status >= 200 && response.status < 300) {
					return response.json();
				} else {
					let error = new Error(response.statusText);
					(error as any).response = response;
					throw error;
				}
			});
		}
		/**
		 *
		 * Update Project Note
		 * @param id
		 * @param noteId
		 * @param operations
		 */
		public projectProjectsIdNotesNoteIdPatch (params: {  id: number; noteId: number; operations: Array<PatchOperation>; }, extraQueryParams?: any, extraFetchParams?: any ) : Promise<ProjectNote> {
			const localVarPath = this.basePath + '/project/projects/{id}/notes/{noteId}'
				.replace('{' + 'id' + '}', String(params.id))
				.replace('{' + 'noteId' + '}', String(params.noteId));

			let queryParameters: any = assign({}, extraQueryParams);
			let headerParams: any = assign({}, this.defaultHeaders);
			headerParams['Content-Type'] = 'application/json';

			// verify required parameter 'id' is set
			if (params.id == null) {
				throw new Error('Missing required parameter id when calling projectProjectsIdNotesNoteIdPatch');
			}
			// verify required parameter 'noteId' is set
			if (params.noteId == null) {
				throw new Error('Missing required parameter noteId when calling projectProjectsIdNotesNoteIdPatch');
			}
			// verify required parameter 'operations' is set
			if (params.operations == null) {
				throw new Error('Missing required parameter operations when calling projectProjectsIdNotesNoteIdPatch');
			}
			let fetchParams = {
				method: 'PATCH',
				headers: headerParams,
				body: JSON.stringify(params.operations),

			};

			if (extraFetchParams) {
				fetchParams = assign(fetchParams, extraFetchParams);
			}

			let localVarPathWithQueryParameters = localVarPath + (localVarPath.indexOf('?') !== -1 ? '&' : '?') + querystring.stringify(queryParameters);

			return fetch(localVarPathWithQueryParameters, fetchParams).then((response) => {
				if (response.status >= 200 && response.status < 300) {
					return response.json();
				} else {
					let error = new Error(response.statusText);
					(error as any).response = response;
					throw error;
				}
			});
		}
		/**
		 *
		 * Replace Project Note
		 * @param id
		 * @param noteId
		 * @param note
		 */
		public projectProjectsIdNotesNoteIdPut (params: {  id: number; noteId: number; note: ProjectNote; }, extraQueryParams?: any, extraFetchParams?: any ) : Promise<ProjectNote> {
			const localVarPath = this.basePath + '/project/projects/{id}/notes/{noteId}'
				.replace('{' + 'id' + '}', String(params.id))
				.replace('{' + 'noteId' + '}', String(params.noteId));

			let queryParameters: any = assign({}, extraQueryParams);
			let headerParams: any = assign({}, this.defaultHeaders);
			headerParams['Content-Type'] = 'application/json';

			// verify required parameter 'id' is set
			if (params.id == null) {
				throw new Error('Missing required parameter id when calling projectProjectsIdNotesNoteIdPut');
			}
			// verify required parameter 'noteId' is set
			if (params.noteId == null) {
				throw new Error('Missing required parameter noteId when calling projectProjectsIdNotesNoteIdPut');
			}
			// verify required parameter 'note' is set
			if (params.note == null) {
				throw new Error('Missing required parameter note when calling projectProjectsIdNotesNoteIdPut');
			}
			let fetchParams = {
				method: 'PUT',
				headers: headerParams,
				body: JSON.stringify(params.note),

			};

			if (extraFetchParams) {
				fetchParams = assign(fetchParams, extraFetchParams);
			}

			let localVarPathWithQueryParameters = localVarPath + (localVarPath.indexOf('?') !== -1 ? '&' : '?') + querystring.stringify(queryParameters);

			return fetch(localVarPathWithQueryParameters, fetchParams).then((response) => {
				if (response.status >= 200 && response.status < 300) {
					return response.json();
				} else {
					let error = new Error(response.statusText);
					(error as any).response = response;
					throw error;
				}
			});
		}
		/**
		 *
		 * Create Project Note
		 * @param id
		 * @param note
		 */
		public projectProjectsIdNotesPost (params: {  id: number; note: ProjectNote; }, extraQueryParams?: any, extraFetchParams?: any ) : Promise<ProjectNote> {
			const localVarPath = this.basePath + '/project/projects/{id}/notes'
				.replace('{' + 'id' + '}', String(params.id));

			let queryParameters: any = assign({}, extraQueryParams);
			let headerParams: any = assign({}, this.defaultHeaders);
			headerParams['Content-Type'] = 'application/json';

			// verify required parameter 'id' is set
			if (params.id == null) {
				throw new Error('Missing required parameter id when calling projectProjectsIdNotesPost');
			}
			// verify required parameter 'note' is set
			if (params.note == null) {
				throw new Error('Missing required parameter note when calling projectProjectsIdNotesPost');
			}
			let fetchParams = {
				method: 'POST',
				headers: headerParams,
				body: JSON.stringify(params.note),

			};

			if (extraFetchParams) {
				fetchParams = assign(fetchParams, extraFetchParams);
			}

			let localVarPathWithQueryParameters = localVarPath + (localVarPath.indexOf('?') !== -1 ? '&' : '?') + querystring.stringify(queryParameters);

			return fetch(localVarPathWithQueryParameters, fetchParams).then((response) => {
				if (response.status >= 200 && response.status < 300) {
					return response.json();
				} else {
					let error = new Error(response.statusText);
					(error as any).response = response;
					throw error;
				}
			});
		}
	}
//}
//export namespace  {
	'use strict';

	export class ProjectPhasesApi {
		protected basePath = 'https://api-na.myconnectwise.net/v4_6_release/apis/3.0';
		public defaultHeaders : any = {};

		constructor(basePath?: string) {
			if (basePath) {
				this.basePath = basePath;
			}
		}

		/**
		 *
		 * Get Project Phases Count
		 * @param id
		 * @param conditions
		 */
		public projectProjectsIdPhasesCountGet (params: {  id: number; conditions?: string; }, extraQueryParams?: any, extraFetchParams?: any ) : Promise<Count> {
			const localVarPath = this.basePath + '/project/projects/{id}/phases/count'
				.replace('{' + 'id' + '}', String(params.id));

			let queryParameters: any = assign({}, extraQueryParams);
			let headerParams: any = assign({}, this.defaultHeaders);
			// verify required parameter 'id' is set
			if (params.id == null) {
				throw new Error('Missing required parameter id when calling projectProjectsIdPhasesCountGet');
			}
			if (params.conditions !== undefined) {
				queryParameters['conditions'] = params.conditions;
			}

			let fetchParams = {
				method: 'GET',
				headers: headerParams,

			};

			if (extraFetchParams) {
				fetchParams = assign(fetchParams, extraFetchParams);
			}

			let localVarPathWithQueryParameters = localVarPath + (localVarPath.indexOf('?') !== -1 ? '&' : '?') + querystring.stringify(queryParameters);

			return fetch(localVarPathWithQueryParameters, fetchParams).then((response) => {
				if (response.status >= 200 && response.status < 300) {
					return response.json();
				} else {
					let error = new Error(response.statusText);
					(error as any).response = response;
					throw error;
				}
			});
		}
		/**
		 *
		 * Get Project Phases
		 * @param id
		 * @param conditions
		 * @param orderBy
		 * @param childconditions
		 * @param customfieldconditions
		 * @param page
		 * @param pageSize
		 */
		public projectProjectsIdPhasesGet (params: {  id: number; conditions?: string; orderBy?: string; childconditions?: string; customfieldconditions?: string; page?: number; pageSize?: number; }, extraQueryParams?: any, extraFetchParams?: any ) : Promise<Array<ProjectPhase>> {
			const localVarPath = this.basePath + '/project/projects/{id}/phases'
				.replace('{' + 'id' + '}', String(params.id));

			let queryParameters: any = assign({}, extraQueryParams);
			let headerParams: any = assign({}, this.defaultHeaders);
			// verify required parameter 'id' is set
			if (params.id == null) {
				throw new Error('Missing required parameter id when calling projectProjectsIdPhasesGet');
			}
			if (params.conditions !== undefined) {
				queryParameters['conditions'] = params.conditions;
			}

			if (params.orderBy !== undefined) {
				queryParameters['orderBy'] = params.orderBy;
			}

			if (params.childconditions !== undefined) {
				queryParameters['childconditions'] = params.childconditions;
			}

			if (params.customfieldconditions !== undefined) {
				queryParameters['customfieldconditions'] = params.customfieldconditions;
			}

			if (params.page !== undefined) {
				queryParameters['page'] = params.page;
			}

			if (params.pageSize !== undefined) {
				queryParameters['pageSize'] = params.pageSize;
			}

			let fetchParams = {
				method: 'GET',
				headers: headerParams,

			};

			if (extraFetchParams) {
				fetchParams = assign(fetchParams, extraFetchParams);
			}

			let localVarPathWithQueryParameters = localVarPath + (localVarPath.indexOf('?') !== -1 ? '&' : '?') + querystring.stringify(queryParameters);

			return fetch(localVarPathWithQueryParameters, fetchParams).then((response) => {
				if (response.status >= 200 && response.status < 300) {
					return response.json();
				} else {
					let error = new Error(response.statusText);
					(error as any).response = response;
					throw error;
				}
			});
		}
		/**
		 *
		 * Delete Project Phase By Id
		 * @param id
		 * @param phaseId
		 */
		public projectProjectsIdPhasesPhaseIdDelete (params: {  id: number; phaseId: number; }, extraQueryParams?: any, extraFetchParams?: any ) : Promise<{}> {
			const localVarPath = this.basePath + '/project/projects/{id}/phases/{phaseId}'
				.replace('{' + 'id' + '}', String(params.id))
				.replace('{' + 'phaseId' + '}', String(params.phaseId));

			let queryParameters: any = assign({}, extraQueryParams);
			let headerParams: any = assign({}, this.defaultHeaders);
			// verify required parameter 'id' is set
			if (params.id == null) {
				throw new Error('Missing required parameter id when calling projectProjectsIdPhasesPhaseIdDelete');
			}
			// verify required parameter 'phaseId' is set
			if (params.phaseId == null) {
				throw new Error('Missing required parameter phaseId when calling projectProjectsIdPhasesPhaseIdDelete');
			}
			let fetchParams = {
				method: 'DELETE',
				headers: headerParams,

			};

			if (extraFetchParams) {
				fetchParams = assign(fetchParams, extraFetchParams);
			}

			let localVarPathWithQueryParameters = localVarPath + (localVarPath.indexOf('?') !== -1 ? '&' : '?') + querystring.stringify(queryParameters);

			return fetch(localVarPathWithQueryParameters, fetchParams).then((response) => {
				if (response.status >= 200 && response.status < 300) {
					return response.json();
				} else {
					let error = new Error(response.statusText);
					(error as any).response = response;
					throw error;
				}
			});
		}
		/**
		 *
		 * Get Project Phase By Id
		 * @param id
		 * @param phaseId
		 */
		public projectProjectsIdPhasesPhaseIdGet (params: {  id: number; phaseId: number; }, extraQueryParams?: any, extraFetchParams?: any ) : Promise<ProjectPhase> {
			const localVarPath = this.basePath + '/project/projects/{id}/phases/{phaseId}'
				.replace('{' + 'id' + '}', String(params.id))
				.replace('{' + 'phaseId' + '}', String(params.phaseId));

			let queryParameters: any = assign({}, extraQueryParams);
			let headerParams: any = assign({}, this.defaultHeaders);
			// verify required parameter 'id' is set
			if (params.id == null) {
				throw new Error('Missing required parameter id when calling projectProjectsIdPhasesPhaseIdGet');
			}
			// verify required parameter 'phaseId' is set
			if (params.phaseId == null) {
				throw new Error('Missing required parameter phaseId when calling projectProjectsIdPhasesPhaseIdGet');
			}
			let fetchParams = {
				method: 'GET',
				headers: headerParams,

			};

			if (extraFetchParams) {
				fetchParams = assign(fetchParams, extraFetchParams);
			}

			let localVarPathWithQueryParameters = localVarPath + (localVarPath.indexOf('?') !== -1 ? '&' : '?') + querystring.stringify(queryParameters);

			return fetch(localVarPathWithQueryParameters, fetchParams).then((response) => {
				if (response.status >= 200 && response.status < 300) {
					return response.json();
				} else {
					let error = new Error(response.statusText);
					(error as any).response = response;
					throw error;
				}
			});
		}
		/**
		 *
		 * Update Project Phase
		 * @param id
		 * @param phaseId
		 * @param operations
		 */
		public projectProjectsIdPhasesPhaseIdPatch (params: {  id: number; phaseId: number; operations: Array<PatchOperation>; }, extraQueryParams?: any, extraFetchParams?: any ) : Promise<ProjectPhase> {
			const localVarPath = this.basePath + '/project/projects/{id}/phases/{phaseId}'
				.replace('{' + 'id' + '}', String(params.id))
				.replace('{' + 'phaseId' + '}', String(params.phaseId));

			let queryParameters: any = assign({}, extraQueryParams);
			let headerParams: any = assign({}, this.defaultHeaders);
			headerParams['Content-Type'] = 'application/json';

			// verify required parameter 'id' is set
			if (params.id == null) {
				throw new Error('Missing required parameter id when calling projectProjectsIdPhasesPhaseIdPatch');
			}
			// verify required parameter 'phaseId' is set
			if (params.phaseId == null) {
				throw new Error('Missing required parameter phaseId when calling projectProjectsIdPhasesPhaseIdPatch');
			}
			// verify required parameter 'operations' is set
			if (params.operations == null) {
				throw new Error('Missing required parameter operations when calling projectProjectsIdPhasesPhaseIdPatch');
			}
			let fetchParams = {
				method: 'PATCH',
				headers: headerParams,
				body: JSON.stringify(params.operations),

			};

			if (extraFetchParams) {
				fetchParams = assign(fetchParams, extraFetchParams);
			}

			let localVarPathWithQueryParameters = localVarPath + (localVarPath.indexOf('?') !== -1 ? '&' : '?') + querystring.stringify(queryParameters);

			return fetch(localVarPathWithQueryParameters, fetchParams).then((response) => {
				if (response.status >= 200 && response.status < 300) {
					return response.json();
				} else {
					let error = new Error(response.statusText);
					(error as any).response = response;
					throw error;
				}
			});
		}
		/**
		 *
		 * Replace Project Phase
		 * @param id
		 * @param phaseId
		 * @param projectPhase
		 */
		public projectProjectsIdPhasesPhaseIdPut (params: {  id: number; phaseId: number; projectPhase: ProjectPhase; }, extraQueryParams?: any, extraFetchParams?: any ) : Promise<ProjectPhase> {
			const localVarPath = this.basePath + '/project/projects/{id}/phases/{phaseId}'
				.replace('{' + 'id' + '}', String(params.id))
				.replace('{' + 'phaseId' + '}', String(params.phaseId));

			let queryParameters: any = assign({}, extraQueryParams);
			let headerParams: any = assign({}, this.defaultHeaders);
			headerParams['Content-Type'] = 'application/json';

			// verify required parameter 'id' is set
			if (params.id == null) {
				throw new Error('Missing required parameter id when calling projectProjectsIdPhasesPhaseIdPut');
			}
			// verify required parameter 'phaseId' is set
			if (params.phaseId == null) {
				throw new Error('Missing required parameter phaseId when calling projectProjectsIdPhasesPhaseIdPut');
			}
			// verify required parameter 'projectPhase' is set
			if (params.projectPhase == null) {
				throw new Error('Missing required parameter projectPhase when calling projectProjectsIdPhasesPhaseIdPut');
			}
			let fetchParams = {
				method: 'PUT',
				headers: headerParams,
				body: JSON.stringify(params.projectPhase),

			};

			if (extraFetchParams) {
				fetchParams = assign(fetchParams, extraFetchParams);
			}

			let localVarPathWithQueryParameters = localVarPath + (localVarPath.indexOf('?') !== -1 ? '&' : '?') + querystring.stringify(queryParameters);

			return fetch(localVarPathWithQueryParameters, fetchParams).then((response) => {
				if (response.status >= 200 && response.status < 300) {
					return response.json();
				} else {
					let error = new Error(response.statusText);
					(error as any).response = response;
					throw error;
				}
			});
		}
		/**
		 *
		 * Create Project Phase
		 * @param id
		 * @param projectPhase
		 */
		public projectProjectsIdPhasesPost (params: {  id: number; projectPhase: ProjectPhase; }, extraQueryParams?: any, extraFetchParams?: any ) : Promise<ProjectPhase> {
			const localVarPath = this.basePath + '/project/projects/{id}/phases'
				.replace('{' + 'id' + '}', String(params.id));

			let queryParameters: any = assign({}, extraQueryParams);
			let headerParams: any = assign({}, this.defaultHeaders);
			headerParams['Content-Type'] = 'application/json';

			// verify required parameter 'id' is set
			if (params.id == null) {
				throw new Error('Missing required parameter id when calling projectProjectsIdPhasesPost');
			}
			// verify required parameter 'projectPhase' is set
			if (params.projectPhase == null) {
				throw new Error('Missing required parameter projectPhase when calling projectProjectsIdPhasesPost');
			}
			let fetchParams = {
				method: 'POST',
				headers: headerParams,
				body: JSON.stringify(params.projectPhase),

			};

			if (extraFetchParams) {
				fetchParams = assign(fetchParams, extraFetchParams);
			}

			let localVarPathWithQueryParameters = localVarPath + (localVarPath.indexOf('?') !== -1 ? '&' : '?') + querystring.stringify(queryParameters);

			return fetch(localVarPathWithQueryParameters, fetchParams).then((response) => {
				if (response.status >= 200 && response.status < 300) {
					return response.json();
				} else {
					let error = new Error(response.statusText);
					(error as any).response = response;
					throw error;
				}
			});
		}
	}
//}
//export namespace  {
	'use strict';

	export class ProjectsApi {
		protected basePath = 'https://api-na.myconnectwise.net/v4_6_release/apis/3.0';
		public defaultHeaders : any = {};

		constructor(basePath?: string) {
			if (basePath) {
				this.basePath = basePath;
			}
		}

		/**
		 *
		 * Get Projects Count
		 * @param conditions
		 * @param customFieldConditions
		 */
		public projectProjectsCountGet (params: {  conditions?: string; customFieldConditions?: string; }, extraQueryParams?: any, extraFetchParams?: any ) : Promise<Count> {
			const localVarPath = this.basePath + '/project/projects/count';

			let queryParameters: any = assign({}, extraQueryParams);
			let headerParams: any = assign({}, this.defaultHeaders);
			if (params.conditions !== undefined) {
				queryParameters['conditions'] = params.conditions;
			}

			if (params.customFieldConditions !== undefined) {
				queryParameters['customFieldConditions'] = params.customFieldConditions;
			}

			let fetchParams = {
				method: 'GET',
				headers: headerParams,

			};

			if (extraFetchParams) {
				fetchParams = assign(fetchParams, extraFetchParams);
			}

			let localVarPathWithQueryParameters = localVarPath + (localVarPath.indexOf('?') !== -1 ? '&' : '?') + querystring.stringify(queryParameters);

			return fetch(localVarPathWithQueryParameters, fetchParams).then((response) => {
				if (response.status >= 200 && response.status < 300) {
					return response.json();
				} else {
					let error = new Error(response.statusText);
					(error as any).response = response;
					throw error;
				}
			});
		}
		/**
		 *
		 * Get Projects
		 * @param conditions
		 * @param orderBy
		 * @param childconditions
		 * @param customfieldconditions
		 * @param page
		 * @param pageSize
		 */
		public projectProjectsGet (params: {  conditions?: string; orderBy?: string; childconditions?: string; customfieldconditions?: string; page?: number; pageSize?: number; }, extraQueryParams?: any, extraFetchParams?: any ) : Promise<Array<Project>> {
			const localVarPath = this.basePath + '/project/projects';

			let queryParameters: any = assign({}, extraQueryParams);
			let headerParams: any = assign({}, this.defaultHeaders);
			if (params.conditions !== undefined) {
				queryParameters['conditions'] = params.conditions;
			}

			if (params.orderBy !== undefined) {
				queryParameters['orderBy'] = params.orderBy;
			}

			if (params.childconditions !== undefined) {
				queryParameters['childconditions'] = params.childconditions;
			}

			if (params.customfieldconditions !== undefined) {
				queryParameters['customfieldconditions'] = params.customfieldconditions;
			}

			if (params.page !== undefined) {
				queryParameters['page'] = params.page;
			}

			if (params.pageSize !== undefined) {
				queryParameters['pageSize'] = params.pageSize;
			}

			let fetchParams = {
				method: 'GET',
				headers: headerParams,

			};

			if (extraFetchParams) {
				fetchParams = assign(fetchParams, extraFetchParams);
			}

			let localVarPathWithQueryParameters = localVarPath + (localVarPath.indexOf('?') !== -1 ? '&' : '?') + querystring.stringify(queryParameters);

			return fetch(localVarPathWithQueryParameters, fetchParams).then((response) => {
				if (response.status >= 200 && response.status < 300) {
					return response.json();
				} else {
					let error = new Error(response.statusText);
					(error as any).response = response;
					throw error;
				}
			});
		}
		/**
		 *
		 * Delete Project By Id
		 * @param id
		 */
		public projectProjectsIdDelete (params: {  id: number; }, extraQueryParams?: any, extraFetchParams?: any ) : Promise<{}> {
			const localVarPath = this.basePath + '/project/projects/{id}'
				.replace('{' + 'id' + '}', String(params.id));

			let queryParameters: any = assign({}, extraQueryParams);
			let headerParams: any = assign({}, this.defaultHeaders);
			// verify required parameter 'id' is set
			if (params.id == null) {
				throw new Error('Missing required parameter id when calling projectProjectsIdDelete');
			}
			let fetchParams = {
				method: 'DELETE',
				headers: headerParams,

			};

			if (extraFetchParams) {
				fetchParams = assign(fetchParams, extraFetchParams);
			}

			let localVarPathWithQueryParameters = localVarPath + (localVarPath.indexOf('?') !== -1 ? '&' : '?') + querystring.stringify(queryParameters);

			return fetch(localVarPathWithQueryParameters, fetchParams).then((response) => {
				if (response.status >= 200 && response.status < 300) {
					return response.json();
				} else {
					let error = new Error(response.statusText);
					(error as any).response = response;
					throw error;
				}
			});
		}
		/**
		 *
		 * Get Project By Id
		 * @param id
		 */
		public projectProjectsIdGet (params: {  id: number; }, extraQueryParams?: any, extraFetchParams?: any ) : Promise<Project> {
			const localVarPath = this.basePath + '/project/projects/{id}'
				.replace('{' + 'id' + '}', String(params.id));

			let queryParameters: any = assign({}, extraQueryParams);
			let headerParams: any = assign({}, this.defaultHeaders);
			// verify required parameter 'id' is set
			if (params.id == null) {
				throw new Error('Missing required parameter id when calling projectProjectsIdGet');
			}
			let fetchParams = {
				method: 'GET',
				headers: headerParams,

			};

			if (extraFetchParams) {
				fetchParams = assign(fetchParams, extraFetchParams);
			}

			let localVarPathWithQueryParameters = localVarPath + (localVarPath.indexOf('?') !== -1 ? '&' : '?') + querystring.stringify(queryParameters);

			return fetch(localVarPathWithQueryParameters, fetchParams).then((response) => {
				if (response.status >= 200 && response.status < 300) {
					return response.json();
				} else {
					let error = new Error(response.statusText);
					(error as any).response = response;
					throw error;
				}
			});
		}
		/**
		 *
		 * Update Project
		 * @param id
		 * @param operations
		 */
		public projectProjectsIdPatch (params: {  id: number; operations: Array<PatchOperation>; }, extraQueryParams?: any, extraFetchParams?: any ) : Promise<Project> {
			const localVarPath = this.basePath + '/project/projects/{id}'
				.replace('{' + 'id' + '}', String(params.id));

			let queryParameters: any = assign({}, extraQueryParams);
			let headerParams: any = assign({}, this.defaultHeaders);
			headerParams['Content-Type'] = 'application/json';

			// verify required parameter 'id' is set
			if (params.id == null) {
				throw new Error('Missing required parameter id when calling projectProjectsIdPatch');
			}
			// verify required parameter 'operations' is set
			if (params.operations == null) {
				throw new Error('Missing required parameter operations when calling projectProjectsIdPatch');
			}
			let fetchParams = {
				method: 'PATCH',
				headers: headerParams,
				body: JSON.stringify(params.operations),

			};

			if (extraFetchParams) {
				fetchParams = assign(fetchParams, extraFetchParams);
			}

			let localVarPathWithQueryParameters = localVarPath + (localVarPath.indexOf('?') !== -1 ? '&' : '?') + querystring.stringify(queryParameters);

			return fetch(localVarPathWithQueryParameters, fetchParams).then((response) => {
				if (response.status >= 200 && response.status < 300) {
					return response.json();
				} else {
					let error = new Error(response.statusText);
					(error as any).response = response;
					throw error;
				}
			});
		}
		/**
		 *
		 * Replace Project
		 * @param id
		 * @param project
		 */
		public projectProjectsIdPut (params: {  id: number; project: Project; }, extraQueryParams?: any, extraFetchParams?: any ) : Promise<Project> {
			const localVarPath = this.basePath + '/project/projects/{id}'
				.replace('{' + 'id' + '}', String(params.id));

			let queryParameters: any = assign({}, extraQueryParams);
			let headerParams: any = assign({}, this.defaultHeaders);
			headerParams['Content-Type'] = 'application/json';

			// verify required parameter 'id' is set
			if (params.id == null) {
				throw new Error('Missing required parameter id when calling projectProjectsIdPut');
			}
			// verify required parameter 'project' is set
			if (params.project == null) {
				throw new Error('Missing required parameter project when calling projectProjectsIdPut');
			}
			let fetchParams = {
				method: 'PUT',
				headers: headerParams,
				body: JSON.stringify(params.project),

			};

			if (extraFetchParams) {
				fetchParams = assign(fetchParams, extraFetchParams);
			}

			let localVarPathWithQueryParameters = localVarPath + (localVarPath.indexOf('?') !== -1 ? '&' : '?') + querystring.stringify(queryParameters);

			return fetch(localVarPathWithQueryParameters, fetchParams).then((response) => {
				if (response.status >= 200 && response.status < 300) {
					return response.json();
				} else {
					let error = new Error(response.statusText);
					(error as any).response = response;
					throw error;
				}
			});
		}
		/**
		 *
		 * Create Project
		 * @param project
		 */
		public projectProjectsPost (params: {  project: Project; }, extraQueryParams?: any, extraFetchParams?: any ) : Promise<Project> {
			const localVarPath = this.basePath + '/project/projects';

			let queryParameters: any = assign({}, extraQueryParams);
			let headerParams: any = assign({}, this.defaultHeaders);
			headerParams['Content-Type'] = 'application/json';

			// verify required parameter 'project' is set
			if (params.project == null) {
				throw new Error('Missing required parameter project when calling projectProjectsPost');
			}
			let fetchParams = {
				method: 'POST',
				headers: headerParams,
				body: JSON.stringify(params.project),

			};

			if (extraFetchParams) {
				fetchParams = assign(fetchParams, extraFetchParams);
			}

			let localVarPathWithQueryParameters = localVarPath + (localVarPath.indexOf('?') !== -1 ? '&' : '?') + querystring.stringify(queryParameters);

			return fetch(localVarPathWithQueryParameters, fetchParams).then((response) => {
				if (response.status >= 200 && response.status < 300) {
					return response.json();
				} else {
					let error = new Error(response.statusText);
					(error as any).response = response;
					throw error;
				}
			});
		}
	}
//}
//export namespace  {
	'use strict';

	export class ProjectsTeammembersApi {
		protected basePath = 'https://api-na.myconnectwise.net/v4_6_release/apis/3.0';
		public defaultHeaders : any = {};

		constructor(basePath?: string) {
			if (basePath) {
				this.basePath = basePath;
			}
		}

		/**
		 *
		 * Get Team Members Count
		 * @param id
		 * @param conditions
		 */
		public projectProjectsIdTeamMembersCountGet (params: {  id: number; conditions?: string; }, extraQueryParams?: any, extraFetchParams?: any ) : Promise<Count> {
			const localVarPath = this.basePath + '/project/projects/{id}/teamMembers/count'
				.replace('{' + 'id' + '}', String(params.id));

			let queryParameters: any = assign({}, extraQueryParams);
			let headerParams: any = assign({}, this.defaultHeaders);
			// verify required parameter 'id' is set
			if (params.id == null) {
				throw new Error('Missing required parameter id when calling projectProjectsIdTeamMembersCountGet');
			}
			if (params.conditions !== undefined) {
				queryParameters['conditions'] = params.conditions;
			}

			let fetchParams = {
				method: 'GET',
				headers: headerParams,

			};

			if (extraFetchParams) {
				fetchParams = assign(fetchParams, extraFetchParams);
			}

			let localVarPathWithQueryParameters = localVarPath + (localVarPath.indexOf('?') !== -1 ? '&' : '?') + querystring.stringify(queryParameters);

			return fetch(localVarPathWithQueryParameters, fetchParams).then((response) => {
				if (response.status >= 200 && response.status < 300) {
					return response.json();
				} else {
					let error = new Error(response.statusText);
					(error as any).response = response;
					throw error;
				}
			});
		}
		/**
		 *
		 * Get Team Members
		 * @param id
		 * @param conditions
		 * @param orderBy
		 * @param childconditions
		 * @param customfieldconditions
		 * @param page
		 * @param pageSize
		 */
		public projectProjectsIdTeamMembersGet (params: {  id: number; conditions?: string; orderBy?: string; childconditions?: string; customfieldconditions?: string; page?: number; pageSize?: number; }, extraQueryParams?: any, extraFetchParams?: any ) : Promise<Array<ProjectTeammember>> {
			const localVarPath = this.basePath + '/project/projects/{id}/teamMembers'
				.replace('{' + 'id' + '}', String(params.id));

			let queryParameters: any = assign({}, extraQueryParams);
			let headerParams: any = assign({}, this.defaultHeaders);
			// verify required parameter 'id' is set
			if (params.id == null) {
				throw new Error('Missing required parameter id when calling projectProjectsIdTeamMembersGet');
			}
			if (params.conditions !== undefined) {
				queryParameters['conditions'] = params.conditions;
			}

			if (params.orderBy !== undefined) {
				queryParameters['orderBy'] = params.orderBy;
			}

			if (params.childconditions !== undefined) {
				queryParameters['childconditions'] = params.childconditions;
			}

			if (params.customfieldconditions !== undefined) {
				queryParameters['customfieldconditions'] = params.customfieldconditions;
			}

			if (params.page !== undefined) {
				queryParameters['page'] = params.page;
			}

			if (params.pageSize !== undefined) {
				queryParameters['pageSize'] = params.pageSize;
			}

			let fetchParams = {
				method: 'GET',
				headers: headerParams,

			};

			if (extraFetchParams) {
				fetchParams = assign(fetchParams, extraFetchParams);
			}

			let localVarPathWithQueryParameters = localVarPath + (localVarPath.indexOf('?') !== -1 ? '&' : '?') + querystring.stringify(queryParameters);

			return fetch(localVarPathWithQueryParameters, fetchParams).then((response) => {
				if (response.status >= 200 && response.status < 300) {
					return response.json();
				} else {
					let error = new Error(response.statusText);
					(error as any).response = response;
					throw error;
				}
			});
		}
		/**
		 *
		 * Create Team Member
		 * @param id
		 * @param teamMember
		 */
		public projectProjectsIdTeamMembersPost (params: {  id: number; teamMember: ProjectTeammember; }, extraQueryParams?: any, extraFetchParams?: any ) : Promise<ProjectTeammember> {
			const localVarPath = this.basePath + '/project/projects/{id}/teamMembers'
				.replace('{' + 'id' + '}', String(params.id));

			let queryParameters: any = assign({}, extraQueryParams);
			let headerParams: any = assign({}, this.defaultHeaders);
			headerParams['Content-Type'] = 'application/json';

			// verify required parameter 'id' is set
			if (params.id == null) {
				throw new Error('Missing required parameter id when calling projectProjectsIdTeamMembersPost');
			}
			// verify required parameter 'teamMember' is set
			if (params.teamMember == null) {
				throw new Error('Missing required parameter teamMember when calling projectProjectsIdTeamMembersPost');
			}
			let fetchParams = {
				method: 'POST',
				headers: headerParams,
				body: JSON.stringify(params.teamMember),

			};

			if (extraFetchParams) {
				fetchParams = assign(fetchParams, extraFetchParams);
			}

			let localVarPathWithQueryParameters = localVarPath + (localVarPath.indexOf('?') !== -1 ? '&' : '?') + querystring.stringify(queryParameters);

			return fetch(localVarPathWithQueryParameters, fetchParams).then((response) => {
				if (response.status >= 200 && response.status < 300) {
					return response.json();
				} else {
					let error = new Error(response.statusText);
					(error as any).response = response;
					throw error;
				}
			});
		}
		/**
		 *
		 * Delete Team Member By Id
		 * @param id
		 * @param teamMemberId
		 */
		public projectProjectsIdTeamMembersTeamMemberIdDelete (params: {  id: number; teamMemberId: number; }, extraQueryParams?: any, extraFetchParams?: any ) : Promise<{}> {
			const localVarPath = this.basePath + '/project/projects/{id}/teamMembers/{teamMemberId}'
				.replace('{' + 'id' + '}', String(params.id))
				.replace('{' + 'teamMemberId' + '}', String(params.teamMemberId));

			let queryParameters: any = assign({}, extraQueryParams);
			let headerParams: any = assign({}, this.defaultHeaders);
			// verify required parameter 'id' is set
			if (params.id == null) {
				throw new Error('Missing required parameter id when calling projectProjectsIdTeamMembersTeamMemberIdDelete');
			}
			// verify required parameter 'teamMemberId' is set
			if (params.teamMemberId == null) {
				throw new Error('Missing required parameter teamMemberId when calling projectProjectsIdTeamMembersTeamMemberIdDelete');
			}
			let fetchParams = {
				method: 'DELETE',
				headers: headerParams,

			};

			if (extraFetchParams) {
				fetchParams = assign(fetchParams, extraFetchParams);
			}

			let localVarPathWithQueryParameters = localVarPath + (localVarPath.indexOf('?') !== -1 ? '&' : '?') + querystring.stringify(queryParameters);

			return fetch(localVarPathWithQueryParameters, fetchParams).then((response) => {
				if (response.status >= 200 && response.status < 300) {
					return response.json();
				} else {
					let error = new Error(response.statusText);
					(error as any).response = response;
					throw error;
				}
			});
		}
		/**
		 *
		 * Get Team Member By Id
		 * @param id
		 * @param teamMemberId
		 */
		public projectProjectsIdTeamMembersTeamMemberIdGet (params: {  id: number; teamMemberId: number; }, extraQueryParams?: any, extraFetchParams?: any ) : Promise<ProjectTeammember> {
			const localVarPath = this.basePath + '/project/projects/{id}/teamMembers/{teamMemberId}'
				.replace('{' + 'id' + '}', String(params.id))
				.replace('{' + 'teamMemberId' + '}', String(params.teamMemberId));

			let queryParameters: any = assign({}, extraQueryParams);
			let headerParams: any = assign({}, this.defaultHeaders);
			// verify required parameter 'id' is set
			if (params.id == null) {
				throw new Error('Missing required parameter id when calling projectProjectsIdTeamMembersTeamMemberIdGet');
			}
			// verify required parameter 'teamMemberId' is set
			if (params.teamMemberId == null) {
				throw new Error('Missing required parameter teamMemberId when calling projectProjectsIdTeamMembersTeamMemberIdGet');
			}
			let fetchParams = {
				method: 'GET',
				headers: headerParams,

			};

			if (extraFetchParams) {
				fetchParams = assign(fetchParams, extraFetchParams);
			}

			let localVarPathWithQueryParameters = localVarPath + (localVarPath.indexOf('?') !== -1 ? '&' : '?') + querystring.stringify(queryParameters);

			return fetch(localVarPathWithQueryParameters, fetchParams).then((response) => {
				if (response.status >= 200 && response.status < 300) {
					return response.json();
				} else {
					let error = new Error(response.statusText);
					(error as any).response = response;
					throw error;
				}
			});
		}
		/**
		 *
		 * Update Team Member
		 * @param id
		 * @param teamMemberId
		 * @param operations
		 */
		public projectProjectsIdTeamMembersTeamMemberIdPatch (params: {  id: number; teamMemberId: number; operations: Array<PatchOperation>; }, extraQueryParams?: any, extraFetchParams?: any ) : Promise<ProjectTeammember> {
			const localVarPath = this.basePath + '/project/projects/{id}/teamMembers/{teamMemberId}'
				.replace('{' + 'id' + '}', String(params.id))
				.replace('{' + 'teamMemberId' + '}', String(params.teamMemberId));

			let queryParameters: any = assign({}, extraQueryParams);
			let headerParams: any = assign({}, this.defaultHeaders);
			headerParams['Content-Type'] = 'application/json';

			// verify required parameter 'id' is set
			if (params.id == null) {
				throw new Error('Missing required parameter id when calling projectProjectsIdTeamMembersTeamMemberIdPatch');
			}
			// verify required parameter 'teamMemberId' is set
			if (params.teamMemberId == null) {
				throw new Error('Missing required parameter teamMemberId when calling projectProjectsIdTeamMembersTeamMemberIdPatch');
			}
			// verify required parameter 'operations' is set
			if (params.operations == null) {
				throw new Error('Missing required parameter operations when calling projectProjectsIdTeamMembersTeamMemberIdPatch');
			}
			let fetchParams = {
				method: 'PATCH',
				headers: headerParams,
				body: JSON.stringify(params.operations),

			};

			if (extraFetchParams) {
				fetchParams = assign(fetchParams, extraFetchParams);
			}

			let localVarPathWithQueryParameters = localVarPath + (localVarPath.indexOf('?') !== -1 ? '&' : '?') + querystring.stringify(queryParameters);

			return fetch(localVarPathWithQueryParameters, fetchParams).then((response) => {
				if (response.status >= 200 && response.status < 300) {
					return response.json();
				} else {
					let error = new Error(response.statusText);
					(error as any).response = response;
					throw error;
				}
			});
		}
		/**
		 *
		 * Replace Team Member
		 * @param id
		 * @param teamMemberId
		 * @param teamMember
		 */
		public projectProjectsIdTeamMembersTeamMemberIdPut (params: {  id: number; teamMemberId: number; teamMember: ProjectTeammember; }, extraQueryParams?: any, extraFetchParams?: any ) : Promise<ProjectTeammember> {
			const localVarPath = this.basePath + '/project/projects/{id}/teamMembers/{teamMemberId}'
				.replace('{' + 'id' + '}', String(params.id))
				.replace('{' + 'teamMemberId' + '}', String(params.teamMemberId));

			let queryParameters: any = assign({}, extraQueryParams);
			let headerParams: any = assign({}, this.defaultHeaders);
			headerParams['Content-Type'] = 'application/json';

			// verify required parameter 'id' is set
			if (params.id == null) {
				throw new Error('Missing required parameter id when calling projectProjectsIdTeamMembersTeamMemberIdPut');
			}
			// verify required parameter 'teamMemberId' is set
			if (params.teamMemberId == null) {
				throw new Error('Missing required parameter teamMemberId when calling projectProjectsIdTeamMembersTeamMemberIdPut');
			}
			// verify required parameter 'teamMember' is set
			if (params.teamMember == null) {
				throw new Error('Missing required parameter teamMember when calling projectProjectsIdTeamMembersTeamMemberIdPut');
			}
			let fetchParams = {
				method: 'PUT',
				headers: headerParams,
				body: JSON.stringify(params.teamMember),

			};

			if (extraFetchParams) {
				fetchParams = assign(fetchParams, extraFetchParams);
			}

			let localVarPathWithQueryParameters = localVarPath + (localVarPath.indexOf('?') !== -1 ? '&' : '?') + querystring.stringify(queryParameters);

			return fetch(localVarPathWithQueryParameters, fetchParams).then((response) => {
				if (response.status >= 200 && response.status < 300) {
					return response.json();
				} else {
					let error = new Error(response.statusText);
					(error as any).response = response;
					throw error;
				}
			});
		}
	}
//}
//export namespace  {
	'use strict';

	export class PurchaseOrderLineItemsApi {
		protected basePath = 'https://api-na.myconnectwise.net/v4_6_release/apis/3.0';
		public defaultHeaders : any = {};

		constructor(basePath?: string) {
			if (basePath) {
				this.basePath = basePath;
			}
		}

		/**
		 *
		 * Get Purchase Order Line Items Count
		 * @param id
		 * @param conditions
		 */
		public procurementPurchaseordersIdLineitemsCountGet (params: {  id: number; conditions?: string; }, extraQueryParams?: any, extraFetchParams?: any ) : Promise<Count> {
			const localVarPath = this.basePath + '/procurement/purchaseorders/{id}/lineitems/count'
				.replace('{' + 'id' + '}', String(params.id));

			let queryParameters: any = assign({}, extraQueryParams);
			let headerParams: any = assign({}, this.defaultHeaders);
			// verify required parameter 'id' is set
			if (params.id == null) {
				throw new Error('Missing required parameter id when calling procurementPurchaseordersIdLineitemsCountGet');
			}
			if (params.conditions !== undefined) {
				queryParameters['conditions'] = params.conditions;
			}

			let fetchParams = {
				method: 'GET',
				headers: headerParams,

			};

			if (extraFetchParams) {
				fetchParams = assign(fetchParams, extraFetchParams);
			}

			let localVarPathWithQueryParameters = localVarPath + (localVarPath.indexOf('?') !== -1 ? '&' : '?') + querystring.stringify(queryParameters);

			return fetch(localVarPathWithQueryParameters, fetchParams).then((response) => {
				if (response.status >= 200 && response.status < 300) {
					return response.json();
				} else {
					let error = new Error(response.statusText);
					(error as any).response = response;
					throw error;
				}
			});
		}
		/**
		 *
		 * Get Purchase Order Line Items
		 * @param id
		 * @param conditions
		 * @param orderBy
		 * @param childconditions
		 * @param customfieldconditions
		 * @param page
		 * @param pageSize
		 */
		public procurementPurchaseordersIdLineitemsGet (params: {  id: number; conditions?: string; orderBy?: string; childconditions?: string; customfieldconditions?: string; page?: number; pageSize?: number; }, extraQueryParams?: any, extraFetchParams?: any ) : Promise<Array<PurchaseOrderLineItem>> {
			const localVarPath = this.basePath + '/procurement/purchaseorders/{id}/lineitems'
				.replace('{' + 'id' + '}', String(params.id));

			let queryParameters: any = assign({}, extraQueryParams);
			let headerParams: any = assign({}, this.defaultHeaders);
			// verify required parameter 'id' is set
			if (params.id == null) {
				throw new Error('Missing required parameter id when calling procurementPurchaseordersIdLineitemsGet');
			}
			if (params.conditions !== undefined) {
				queryParameters['conditions'] = params.conditions;
			}

			if (params.orderBy !== undefined) {
				queryParameters['orderBy'] = params.orderBy;
			}

			if (params.childconditions !== undefined) {
				queryParameters['childconditions'] = params.childconditions;
			}

			if (params.customfieldconditions !== undefined) {
				queryParameters['customfieldconditions'] = params.customfieldconditions;
			}

			if (params.page !== undefined) {
				queryParameters['page'] = params.page;
			}

			if (params.pageSize !== undefined) {
				queryParameters['pageSize'] = params.pageSize;
			}

			let fetchParams = {
				method: 'GET',
				headers: headerParams,

			};

			if (extraFetchParams) {
				fetchParams = assign(fetchParams, extraFetchParams);
			}

			let localVarPathWithQueryParameters = localVarPath + (localVarPath.indexOf('?') !== -1 ? '&' : '?') + querystring.stringify(queryParameters);

			return fetch(localVarPathWithQueryParameters, fetchParams).then((response) => {
				if (response.status >= 200 && response.status < 300) {
					return response.json();
				} else {
					let error = new Error(response.statusText);
					(error as any).response = response;
					throw error;
				}
			});
		}
		/**
		 *
		 * Delete Purchase Order Line Item By Id
		 * @param id
		 * @param lineItemId
		 */
		public procurementPurchaseordersIdLineitemsLineItemIdDelete (params: {  id: number; lineItemId: number; }, extraQueryParams?: any, extraFetchParams?: any ) : Promise<{}> {
			const localVarPath = this.basePath + '/procurement/purchaseorders/{id}/lineitems/{lineItemId}'
				.replace('{' + 'id' + '}', String(params.id))
				.replace('{' + 'lineItemId' + '}', String(params.lineItemId));

			let queryParameters: any = assign({}, extraQueryParams);
			let headerParams: any = assign({}, this.defaultHeaders);
			// verify required parameter 'id' is set
			if (params.id == null) {
				throw new Error('Missing required parameter id when calling procurementPurchaseordersIdLineitemsLineItemIdDelete');
			}
			// verify required parameter 'lineItemId' is set
			if (params.lineItemId == null) {
				throw new Error('Missing required parameter lineItemId when calling procurementPurchaseordersIdLineitemsLineItemIdDelete');
			}
			let fetchParams = {
				method: 'DELETE',
				headers: headerParams,

			};

			if (extraFetchParams) {
				fetchParams = assign(fetchParams, extraFetchParams);
			}

			let localVarPathWithQueryParameters = localVarPath + (localVarPath.indexOf('?') !== -1 ? '&' : '?') + querystring.stringify(queryParameters);

			return fetch(localVarPathWithQueryParameters, fetchParams).then((response) => {
				if (response.status >= 200 && response.status < 300) {
					return response.json();
				} else {
					let error = new Error(response.statusText);
					(error as any).response = response;
					throw error;
				}
			});
		}
		/**
		 *
		 * Get Purchase Order Line Item By Id
		 * @param id
		 * @param lineItemId
		 */
		public procurementPurchaseordersIdLineitemsLineItemIdGet (params: {  id: number; lineItemId: number; }, extraQueryParams?: any, extraFetchParams?: any ) : Promise<PurchaseOrderLineItem> {
			const localVarPath = this.basePath + '/procurement/purchaseorders/{id}/lineitems/{lineItemId}'
				.replace('{' + 'id' + '}', String(params.id))
				.replace('{' + 'lineItemId' + '}', String(params.lineItemId));

			let queryParameters: any = assign({}, extraQueryParams);
			let headerParams: any = assign({}, this.defaultHeaders);
			// verify required parameter 'id' is set
			if (params.id == null) {
				throw new Error('Missing required parameter id when calling procurementPurchaseordersIdLineitemsLineItemIdGet');
			}
			// verify required parameter 'lineItemId' is set
			if (params.lineItemId == null) {
				throw new Error('Missing required parameter lineItemId when calling procurementPurchaseordersIdLineitemsLineItemIdGet');
			}
			let fetchParams = {
				method: 'GET',
				headers: headerParams,

			};

			if (extraFetchParams) {
				fetchParams = assign(fetchParams, extraFetchParams);
			}

			let localVarPathWithQueryParameters = localVarPath + (localVarPath.indexOf('?') !== -1 ? '&' : '?') + querystring.stringify(queryParameters);

			return fetch(localVarPathWithQueryParameters, fetchParams).then((response) => {
				if (response.status >= 200 && response.status < 300) {
					return response.json();
				} else {
					let error = new Error(response.statusText);
					(error as any).response = response;
					throw error;
				}
			});
		}
		/**
		 *
		 * Update Purchase Order Line Item
		 * @param id
		 * @param lineItemId
		 * @param operations
		 */
		public procurementPurchaseordersIdLineitemsLineItemIdPatch (params: {  id: number; lineItemId: number; operations: Array<PatchOperation>; }, extraQueryParams?: any, extraFetchParams?: any ) : Promise<PurchaseOrderLineItem> {
			const localVarPath = this.basePath + '/procurement/purchaseorders/{id}/lineitems/{lineItemId}'
				.replace('{' + 'id' + '}', String(params.id))
				.replace('{' + 'lineItemId' + '}', String(params.lineItemId));

			let queryParameters: any = assign({}, extraQueryParams);
			let headerParams: any = assign({}, this.defaultHeaders);
			headerParams['Content-Type'] = 'application/json';

			// verify required parameter 'id' is set
			if (params.id == null) {
				throw new Error('Missing required parameter id when calling procurementPurchaseordersIdLineitemsLineItemIdPatch');
			}
			// verify required parameter 'lineItemId' is set
			if (params.lineItemId == null) {
				throw new Error('Missing required parameter lineItemId when calling procurementPurchaseordersIdLineitemsLineItemIdPatch');
			}
			// verify required parameter 'operations' is set
			if (params.operations == null) {
				throw new Error('Missing required parameter operations when calling procurementPurchaseordersIdLineitemsLineItemIdPatch');
			}
			let fetchParams = {
				method: 'PATCH',
				headers: headerParams,
				body: JSON.stringify(params.operations),

			};

			if (extraFetchParams) {
				fetchParams = assign(fetchParams, extraFetchParams);
			}

			let localVarPathWithQueryParameters = localVarPath + (localVarPath.indexOf('?') !== -1 ? '&' : '?') + querystring.stringify(queryParameters);

			return fetch(localVarPathWithQueryParameters, fetchParams).then((response) => {
				if (response.status >= 200 && response.status < 300) {
					return response.json();
				} else {
					let error = new Error(response.statusText);
					(error as any).response = response;
					throw error;
				}
			});
		}
		/**
		 *
		 * Replace Purchase Order Line Item
		 * @param id
		 * @param lineItemId
		 * @param purchaseOrderLineItem
		 */
		public procurementPurchaseordersIdLineitemsLineItemIdPut (params: {  id: number; lineItemId: number; purchaseOrderLineItem: PurchaseOrderLineItem; }, extraQueryParams?: any, extraFetchParams?: any ) : Promise<PurchaseOrderLineItem> {
			const localVarPath = this.basePath + '/procurement/purchaseorders/{id}/lineitems/{lineItemId}'
				.replace('{' + 'id' + '}', String(params.id))
				.replace('{' + 'lineItemId' + '}', String(params.lineItemId));

			let queryParameters: any = assign({}, extraQueryParams);
			let headerParams: any = assign({}, this.defaultHeaders);
			headerParams['Content-Type'] = 'application/json';

			// verify required parameter 'id' is set
			if (params.id == null) {
				throw new Error('Missing required parameter id when calling procurementPurchaseordersIdLineitemsLineItemIdPut');
			}
			// verify required parameter 'lineItemId' is set
			if (params.lineItemId == null) {
				throw new Error('Missing required parameter lineItemId when calling procurementPurchaseordersIdLineitemsLineItemIdPut');
			}
			// verify required parameter 'purchaseOrderLineItem' is set
			if (params.purchaseOrderLineItem == null) {
				throw new Error('Missing required parameter purchaseOrderLineItem when calling procurementPurchaseordersIdLineitemsLineItemIdPut');
			}
			let fetchParams = {
				method: 'PUT',
				headers: headerParams,
				body: JSON.stringify(params.purchaseOrderLineItem),

			};

			if (extraFetchParams) {
				fetchParams = assign(fetchParams, extraFetchParams);
			}

			let localVarPathWithQueryParameters = localVarPath + (localVarPath.indexOf('?') !== -1 ? '&' : '?') + querystring.stringify(queryParameters);

			return fetch(localVarPathWithQueryParameters, fetchParams).then((response) => {
				if (response.status >= 200 && response.status < 300) {
					return response.json();
				} else {
					let error = new Error(response.statusText);
					(error as any).response = response;
					throw error;
				}
			});
		}
		/**
		 *
		 * Create Purchase Order Line Item
		 * @param id
		 * @param purchaseOrderLineItem
		 */
		public procurementPurchaseordersIdLineitemsPost (params: {  id: number; purchaseOrderLineItem: PurchaseOrderLineItem; }, extraQueryParams?: any, extraFetchParams?: any ) : Promise<PurchaseOrderLineItem> {
			const localVarPath = this.basePath + '/procurement/purchaseorders/{id}/lineitems'
				.replace('{' + 'id' + '}', String(params.id));

			let queryParameters: any = assign({}, extraQueryParams);
			let headerParams: any = assign({}, this.defaultHeaders);
			headerParams['Content-Type'] = 'application/json';

			// verify required parameter 'id' is set
			if (params.id == null) {
				throw new Error('Missing required parameter id when calling procurementPurchaseordersIdLineitemsPost');
			}
			// verify required parameter 'purchaseOrderLineItem' is set
			if (params.purchaseOrderLineItem == null) {
				throw new Error('Missing required parameter purchaseOrderLineItem when calling procurementPurchaseordersIdLineitemsPost');
			}
			let fetchParams = {
				method: 'POST',
				headers: headerParams,
				body: JSON.stringify(params.purchaseOrderLineItem),

			};

			if (extraFetchParams) {
				fetchParams = assign(fetchParams, extraFetchParams);
			}

			let localVarPathWithQueryParameters = localVarPath + (localVarPath.indexOf('?') !== -1 ? '&' : '?') + querystring.stringify(queryParameters);

			return fetch(localVarPathWithQueryParameters, fetchParams).then((response) => {
				if (response.status >= 200 && response.status < 300) {
					return response.json();
				} else {
					let error = new Error(response.statusText);
					(error as any).response = response;
					throw error;
				}
			});
		}
	}
//}
//export namespace  {
	'use strict';

	export class PurchaseOrdersApi {
		protected basePath = 'https://api-na.myconnectwise.net/v4_6_release/apis/3.0';
		public defaultHeaders : any = {};

		constructor(basePath?: string) {
			if (basePath) {
				this.basePath = basePath;
			}
		}

		/**
		 *
		 * Get Purchase Orders Count
		 * @param conditions
		 */
		public procurementPurchaseordersCountGet (params: {  conditions?: string; }, extraQueryParams?: any, extraFetchParams?: any ) : Promise<Count> {
			const localVarPath = this.basePath + '/procurement/purchaseorders/count';

			let queryParameters: any = assign({}, extraQueryParams);
			let headerParams: any = assign({}, this.defaultHeaders);
			if (params.conditions !== undefined) {
				queryParameters['conditions'] = params.conditions;
			}

			let fetchParams = {
				method: 'GET',
				headers: headerParams,

			};

			if (extraFetchParams) {
				fetchParams = assign(fetchParams, extraFetchParams);
			}

			let localVarPathWithQueryParameters = localVarPath + (localVarPath.indexOf('?') !== -1 ? '&' : '?') + querystring.stringify(queryParameters);

			return fetch(localVarPathWithQueryParameters, fetchParams).then((response) => {
				if (response.status >= 200 && response.status < 300) {
					return response.json();
				} else {
					let error = new Error(response.statusText);
					(error as any).response = response;
					throw error;
				}
			});
		}
		/**
		 *
		 * Get Purchase Orders
		 * @param conditions
		 * @param orderBy
		 * @param childconditions
		 * @param customfieldconditions
		 * @param page
		 * @param pageSize
		 */
		public procurementPurchaseordersGet (params: {  conditions?: string; orderBy?: string; childconditions?: string; customfieldconditions?: string; page?: number; pageSize?: number; }, extraQueryParams?: any, extraFetchParams?: any ) : Promise<Array<PurchaseOrder>> {
			const localVarPath = this.basePath + '/procurement/purchaseorders';

			let queryParameters: any = assign({}, extraQueryParams);
			let headerParams: any = assign({}, this.defaultHeaders);
			if (params.conditions !== undefined) {
				queryParameters['conditions'] = params.conditions;
			}

			if (params.orderBy !== undefined) {
				queryParameters['orderBy'] = params.orderBy;
			}

			if (params.childconditions !== undefined) {
				queryParameters['childconditions'] = params.childconditions;
			}

			if (params.customfieldconditions !== undefined) {
				queryParameters['customfieldconditions'] = params.customfieldconditions;
			}

			if (params.page !== undefined) {
				queryParameters['page'] = params.page;
			}

			if (params.pageSize !== undefined) {
				queryParameters['pageSize'] = params.pageSize;
			}

			let fetchParams = {
				method: 'GET',
				headers: headerParams,

			};

			if (extraFetchParams) {
				fetchParams = assign(fetchParams, extraFetchParams);
			}

			let localVarPathWithQueryParameters = localVarPath + (localVarPath.indexOf('?') !== -1 ? '&' : '?') + querystring.stringify(queryParameters);

			return fetch(localVarPathWithQueryParameters, fetchParams).then((response) => {
				if (response.status >= 200 && response.status < 300) {
					return response.json();
				} else {
					let error = new Error(response.statusText);
					(error as any).response = response;
					throw error;
				}
			});
		}
		/**
		 *
		 * Delete Purchase Order By Id
		 * @param id
		 */
		public procurementPurchaseordersIdDelete (params: {  id: number; }, extraQueryParams?: any, extraFetchParams?: any ) : Promise<{}> {
			const localVarPath = this.basePath + '/procurement/purchaseorders/{id}'
				.replace('{' + 'id' + '}', String(params.id));

			let queryParameters: any = assign({}, extraQueryParams);
			let headerParams: any = assign({}, this.defaultHeaders);
			// verify required parameter 'id' is set
			if (params.id == null) {
				throw new Error('Missing required parameter id when calling procurementPurchaseordersIdDelete');
			}
			let fetchParams = {
				method: 'DELETE',
				headers: headerParams,

			};

			if (extraFetchParams) {
				fetchParams = assign(fetchParams, extraFetchParams);
			}

			let localVarPathWithQueryParameters = localVarPath + (localVarPath.indexOf('?') !== -1 ? '&' : '?') + querystring.stringify(queryParameters);

			return fetch(localVarPathWithQueryParameters, fetchParams).then((response) => {
				if (response.status >= 200 && response.status < 300) {
					return response.json();
				} else {
					let error = new Error(response.statusText);
					(error as any).response = response;
					throw error;
				}
			});
		}
		/**
		 *
		 * Get Purchase Order By Id
		 * @param id
		 */
		public procurementPurchaseordersIdGet (params: {  id: number; }, extraQueryParams?: any, extraFetchParams?: any ) : Promise<PurchaseOrder> {
			const localVarPath = this.basePath + '/procurement/purchaseorders/{id}'
				.replace('{' + 'id' + '}', String(params.id));

			let queryParameters: any = assign({}, extraQueryParams);
			let headerParams: any = assign({}, this.defaultHeaders);
			// verify required parameter 'id' is set
			if (params.id == null) {
				throw new Error('Missing required parameter id when calling procurementPurchaseordersIdGet');
			}
			let fetchParams = {
				method: 'GET',
				headers: headerParams,

			};

			if (extraFetchParams) {
				fetchParams = assign(fetchParams, extraFetchParams);
			}

			let localVarPathWithQueryParameters = localVarPath + (localVarPath.indexOf('?') !== -1 ? '&' : '?') + querystring.stringify(queryParameters);

			return fetch(localVarPathWithQueryParameters, fetchParams).then((response) => {
				if (response.status >= 200 && response.status < 300) {
					return response.json();
				} else {
					let error = new Error(response.statusText);
					(error as any).response = response;
					throw error;
				}
			});
		}
		/**
		 *
		 * Update Purchase Order
		 * @param id
		 * @param operations
		 */
		public procurementPurchaseordersIdPatch (params: {  id: number; operations: Array<PatchOperation>; }, extraQueryParams?: any, extraFetchParams?: any ) : Promise<PurchaseOrder> {
			const localVarPath = this.basePath + '/procurement/purchaseorders/{id}'
				.replace('{' + 'id' + '}', String(params.id));

			let queryParameters: any = assign({}, extraQueryParams);
			let headerParams: any = assign({}, this.defaultHeaders);
			headerParams['Content-Type'] = 'application/json';

			// verify required parameter 'id' is set
			if (params.id == null) {
				throw new Error('Missing required parameter id when calling procurementPurchaseordersIdPatch');
			}
			// verify required parameter 'operations' is set
			if (params.operations == null) {
				throw new Error('Missing required parameter operations when calling procurementPurchaseordersIdPatch');
			}
			let fetchParams = {
				method: 'PATCH',
				headers: headerParams,
				body: JSON.stringify(params.operations),

			};

			if (extraFetchParams) {
				fetchParams = assign(fetchParams, extraFetchParams);
			}

			let localVarPathWithQueryParameters = localVarPath + (localVarPath.indexOf('?') !== -1 ? '&' : '?') + querystring.stringify(queryParameters);

			return fetch(localVarPathWithQueryParameters, fetchParams).then((response) => {
				if (response.status >= 200 && response.status < 300) {
					return response.json();
				} else {
					let error = new Error(response.statusText);
					(error as any).response = response;
					throw error;
				}
			});
		}
		/**
		 *
		 * Replace Purchase Order
		 * @param id
		 * @param purchaseOrder
		 */
		public procurementPurchaseordersIdPut (params: {  id: number; purchaseOrder: PurchaseOrder; }, extraQueryParams?: any, extraFetchParams?: any ) : Promise<PurchaseOrder> {
			const localVarPath = this.basePath + '/procurement/purchaseorders/{id}'
				.replace('{' + 'id' + '}', String(params.id));

			let queryParameters: any = assign({}, extraQueryParams);
			let headerParams: any = assign({}, this.defaultHeaders);
			headerParams['Content-Type'] = 'application/json';

			// verify required parameter 'id' is set
			if (params.id == null) {
				throw new Error('Missing required parameter id when calling procurementPurchaseordersIdPut');
			}
			// verify required parameter 'purchaseOrder' is set
			if (params.purchaseOrder == null) {
				throw new Error('Missing required parameter purchaseOrder when calling procurementPurchaseordersIdPut');
			}
			let fetchParams = {
				method: 'PUT',
				headers: headerParams,
				body: JSON.stringify(params.purchaseOrder),

			};

			if (extraFetchParams) {
				fetchParams = assign(fetchParams, extraFetchParams);
			}

			let localVarPathWithQueryParameters = localVarPath + (localVarPath.indexOf('?') !== -1 ? '&' : '?') + querystring.stringify(queryParameters);

			return fetch(localVarPathWithQueryParameters, fetchParams).then((response) => {
				if (response.status >= 200 && response.status < 300) {
					return response.json();
				} else {
					let error = new Error(response.statusText);
					(error as any).response = response;
					throw error;
				}
			});
		}
		/**
		 *
		 * Create Purchase Order
		 * @param purchaseOrder
		 */
		public procurementPurchaseordersPost (params: {  purchaseOrder: PurchaseOrder; }, extraQueryParams?: any, extraFetchParams?: any ) : Promise<PurchaseOrder> {
			const localVarPath = this.basePath + '/procurement/purchaseorders';

			let queryParameters: any = assign({}, extraQueryParams);
			let headerParams: any = assign({}, this.defaultHeaders);
			headerParams['Content-Type'] = 'application/json';

			// verify required parameter 'purchaseOrder' is set
			if (params.purchaseOrder == null) {
				throw new Error('Missing required parameter purchaseOrder when calling procurementPurchaseordersPost');
			}
			let fetchParams = {
				method: 'POST',
				headers: headerParams,
				body: JSON.stringify(params.purchaseOrder),

			};

			if (extraFetchParams) {
				fetchParams = assign(fetchParams, extraFetchParams);
			}

			let localVarPathWithQueryParameters = localVarPath + (localVarPath.indexOf('?') !== -1 ? '&' : '?') + querystring.stringify(queryParameters);

			return fetch(localVarPathWithQueryParameters, fetchParams).then((response) => {
				if (response.status >= 200 && response.status < 300) {
					return response.json();
				} else {
					let error = new Error(response.statusText);
					(error as any).response = response;
					throw error;
				}
			});
		}
	}
//}
//export namespace  {
	'use strict';

	export class RMAActionsApi {
		protected basePath = 'https://api-na.myconnectwise.net/v4_6_release/apis/3.0';
		public defaultHeaders : any = {};

		constructor(basePath?: string) {
			if (basePath) {
				this.basePath = basePath;
			}
		}

		/**
		 *
		 * Get R M A Action Count
		 * @param conditions
		 */
		public procurementRmaActionsCountGet (params: {  conditions?: string; }, extraQueryParams?: any, extraFetchParams?: any ) : Promise<Count> {
			const localVarPath = this.basePath + '/procurement/rmaActions/count';

			let queryParameters: any = assign({}, extraQueryParams);
			let headerParams: any = assign({}, this.defaultHeaders);
			if (params.conditions !== undefined) {
				queryParameters['conditions'] = params.conditions;
			}

			let fetchParams = {
				method: 'GET',
				headers: headerParams,

			};

			if (extraFetchParams) {
				fetchParams = assign(fetchParams, extraFetchParams);
			}

			let localVarPathWithQueryParameters = localVarPath + (localVarPath.indexOf('?') !== -1 ? '&' : '?') + querystring.stringify(queryParameters);

			return fetch(localVarPathWithQueryParameters, fetchParams).then((response) => {
				if (response.status >= 200 && response.status < 300) {
					return response.json();
				} else {
					let error = new Error(response.statusText);
					(error as any).response = response;
					throw error;
				}
			});
		}
		/**
		 *
		 * Get R M A Action
		 * @param conditions
		 * @param orderBy
		 * @param childconditions
		 * @param customfieldconditions
		 * @param page
		 * @param pageSize
		 */
		public procurementRmaActionsGet (params: {  conditions?: string; orderBy?: string; childconditions?: string; customfieldconditions?: string; page?: number; pageSize?: number; }, extraQueryParams?: any, extraFetchParams?: any ) : Promise<Array<RMAAction>> {
			const localVarPath = this.basePath + '/procurement/rmaActions';

			let queryParameters: any = assign({}, extraQueryParams);
			let headerParams: any = assign({}, this.defaultHeaders);
			if (params.conditions !== undefined) {
				queryParameters['conditions'] = params.conditions;
			}

			if (params.orderBy !== undefined) {
				queryParameters['orderBy'] = params.orderBy;
			}

			if (params.childconditions !== undefined) {
				queryParameters['childconditions'] = params.childconditions;
			}

			if (params.customfieldconditions !== undefined) {
				queryParameters['customfieldconditions'] = params.customfieldconditions;
			}

			if (params.page !== undefined) {
				queryParameters['page'] = params.page;
			}

			if (params.pageSize !== undefined) {
				queryParameters['pageSize'] = params.pageSize;
			}

			let fetchParams = {
				method: 'GET',
				headers: headerParams,

			};

			if (extraFetchParams) {
				fetchParams = assign(fetchParams, extraFetchParams);
			}

			let localVarPathWithQueryParameters = localVarPath + (localVarPath.indexOf('?') !== -1 ? '&' : '?') + querystring.stringify(queryParameters);

			return fetch(localVarPathWithQueryParameters, fetchParams).then((response) => {
				if (response.status >= 200 && response.status < 300) {
					return response.json();
				} else {
					let error = new Error(response.statusText);
					(error as any).response = response;
					throw error;
				}
			});
		}
		/**
		 *
		 * Delete R M A Action By Id
		 * @param id
		 */
		public procurementRmaActionsIdDelete (params: {  id: number; }, extraQueryParams?: any, extraFetchParams?: any ) : Promise<{}> {
			const localVarPath = this.basePath + '/procurement/rmaActions/{id}'
				.replace('{' + 'id' + '}', String(params.id));

			let queryParameters: any = assign({}, extraQueryParams);
			let headerParams: any = assign({}, this.defaultHeaders);
			// verify required parameter 'id' is set
			if (params.id == null) {
				throw new Error('Missing required parameter id when calling procurementRmaActionsIdDelete');
			}
			let fetchParams = {
				method: 'DELETE',
				headers: headerParams,

			};

			if (extraFetchParams) {
				fetchParams = assign(fetchParams, extraFetchParams);
			}

			let localVarPathWithQueryParameters = localVarPath + (localVarPath.indexOf('?') !== -1 ? '&' : '?') + querystring.stringify(queryParameters);

			return fetch(localVarPathWithQueryParameters, fetchParams).then((response) => {
				if (response.status >= 200 && response.status < 300) {
					return response.json();
				} else {
					let error = new Error(response.statusText);
					(error as any).response = response;
					throw error;
				}
			});
		}
		/**
		 *
		 * Get R M A Action By Id
		 * @param id
		 */
		public procurementRmaActionsIdGet (params: {  id: number; }, extraQueryParams?: any, extraFetchParams?: any ) : Promise<RMAAction> {
			const localVarPath = this.basePath + '/procurement/rmaActions/{id}'
				.replace('{' + 'id' + '}', String(params.id));

			let queryParameters: any = assign({}, extraQueryParams);
			let headerParams: any = assign({}, this.defaultHeaders);
			// verify required parameter 'id' is set
			if (params.id == null) {
				throw new Error('Missing required parameter id when calling procurementRmaActionsIdGet');
			}
			let fetchParams = {
				method: 'GET',
				headers: headerParams,

			};

			if (extraFetchParams) {
				fetchParams = assign(fetchParams, extraFetchParams);
			}

			let localVarPathWithQueryParameters = localVarPath + (localVarPath.indexOf('?') !== -1 ? '&' : '?') + querystring.stringify(queryParameters);

			return fetch(localVarPathWithQueryParameters, fetchParams).then((response) => {
				if (response.status >= 200 && response.status < 300) {
					return response.json();
				} else {
					let error = new Error(response.statusText);
					(error as any).response = response;
					throw error;
				}
			});
		}
		/**
		 *
		 * Update R M A Action
		 * @param id
		 * @param operations
		 */
		public procurementRmaActionsIdPatch (params: {  id: number; operations: Array<PatchOperation>; }, extraQueryParams?: any, extraFetchParams?: any ) : Promise<RMAAction> {
			const localVarPath = this.basePath + '/procurement/rmaActions/{id}'
				.replace('{' + 'id' + '}', String(params.id));

			let queryParameters: any = assign({}, extraQueryParams);
			let headerParams: any = assign({}, this.defaultHeaders);
			headerParams['Content-Type'] = 'application/json';

			// verify required parameter 'id' is set
			if (params.id == null) {
				throw new Error('Missing required parameter id when calling procurementRmaActionsIdPatch');
			}
			// verify required parameter 'operations' is set
			if (params.operations == null) {
				throw new Error('Missing required parameter operations when calling procurementRmaActionsIdPatch');
			}
			let fetchParams = {
				method: 'PATCH',
				headers: headerParams,
				body: JSON.stringify(params.operations),

			};

			if (extraFetchParams) {
				fetchParams = assign(fetchParams, extraFetchParams);
			}

			let localVarPathWithQueryParameters = localVarPath + (localVarPath.indexOf('?') !== -1 ? '&' : '?') + querystring.stringify(queryParameters);

			return fetch(localVarPathWithQueryParameters, fetchParams).then((response) => {
				if (response.status >= 200 && response.status < 300) {
					return response.json();
				} else {
					let error = new Error(response.statusText);
					(error as any).response = response;
					throw error;
				}
			});
		}
		/**
		 *
		 * Replace R M A Action
		 * @param id
		 * @param rmaAction
		 */
		public procurementRmaActionsIdPut (params: {  id: number; rmaAction: RMAAction; }, extraQueryParams?: any, extraFetchParams?: any ) : Promise<RMAAction> {
			const localVarPath = this.basePath + '/procurement/rmaActions/{id}'
				.replace('{' + 'id' + '}', String(params.id));

			let queryParameters: any = assign({}, extraQueryParams);
			let headerParams: any = assign({}, this.defaultHeaders);
			headerParams['Content-Type'] = 'application/json';

			// verify required parameter 'id' is set
			if (params.id == null) {
				throw new Error('Missing required parameter id when calling procurementRmaActionsIdPut');
			}
			// verify required parameter 'rmaAction' is set
			if (params.rmaAction == null) {
				throw new Error('Missing required parameter rmaAction when calling procurementRmaActionsIdPut');
			}
			let fetchParams = {
				method: 'PUT',
				headers: headerParams,
				body: JSON.stringify(params.rmaAction),

			};

			if (extraFetchParams) {
				fetchParams = assign(fetchParams, extraFetchParams);
			}

			let localVarPathWithQueryParameters = localVarPath + (localVarPath.indexOf('?') !== -1 ? '&' : '?') + querystring.stringify(queryParameters);

			return fetch(localVarPathWithQueryParameters, fetchParams).then((response) => {
				if (response.status >= 200 && response.status < 300) {
					return response.json();
				} else {
					let error = new Error(response.statusText);
					(error as any).response = response;
					throw error;
				}
			});
		}
		/**
		 *
		 * Create R M A Action
		 * @param rmaAction
		 */
		public procurementRmaActionsPost (params: {  rmaAction: RMAAction; }, extraQueryParams?: any, extraFetchParams?: any ) : Promise<RMAAction> {
			const localVarPath = this.basePath + '/procurement/rmaActions';

			let queryParameters: any = assign({}, extraQueryParams);
			let headerParams: any = assign({}, this.defaultHeaders);
			headerParams['Content-Type'] = 'application/json';

			// verify required parameter 'rmaAction' is set
			if (params.rmaAction == null) {
				throw new Error('Missing required parameter rmaAction when calling procurementRmaActionsPost');
			}
			let fetchParams = {
				method: 'POST',
				headers: headerParams,
				body: JSON.stringify(params.rmaAction),

			};

			if (extraFetchParams) {
				fetchParams = assign(fetchParams, extraFetchParams);
			}

			let localVarPathWithQueryParameters = localVarPath + (localVarPath.indexOf('?') !== -1 ? '&' : '?') + querystring.stringify(queryParameters);

			return fetch(localVarPathWithQueryParameters, fetchParams).then((response) => {
				if (response.status >= 200 && response.status < 300) {
					return response.json();
				} else {
					let error = new Error(response.statusText);
					(error as any).response = response;
					throw error;
				}
			});
		}
	}
//}
//export namespace  {
	'use strict';

	export class RMADispositionsApi {
		protected basePath = 'https://api-na.myconnectwise.net/v4_6_release/apis/3.0';
		public defaultHeaders : any = {};

		constructor(basePath?: string) {
			if (basePath) {
				this.basePath = basePath;
			}
		}

		/**
		 *
		 * Get R M A Disposition Count
		 * @param conditions
		 */
		public procurementRMADispositionsCountGet (params: {  conditions?: string; }, extraQueryParams?: any, extraFetchParams?: any ) : Promise<Count> {
			const localVarPath = this.basePath + '/procurement/RMADispositions/count';

			let queryParameters: any = assign({}, extraQueryParams);
			let headerParams: any = assign({}, this.defaultHeaders);
			if (params.conditions !== undefined) {
				queryParameters['conditions'] = params.conditions;
			}

			let fetchParams = {
				method: 'GET',
				headers: headerParams,

			};

			if (extraFetchParams) {
				fetchParams = assign(fetchParams, extraFetchParams);
			}

			let localVarPathWithQueryParameters = localVarPath + (localVarPath.indexOf('?') !== -1 ? '&' : '?') + querystring.stringify(queryParameters);

			return fetch(localVarPathWithQueryParameters, fetchParams).then((response) => {
				if (response.status >= 200 && response.status < 300) {
					return response.json();
				} else {
					let error = new Error(response.statusText);
					(error as any).response = response;
					throw error;
				}
			});
		}
		/**
		 *
		 * Get R M A Disposition
		 * @param conditions
		 * @param orderBy
		 * @param childconditions
		 * @param customfieldconditions
		 * @param page
		 * @param pageSize
		 */
		public procurementRMADispositionsGet (params: {  conditions?: string; orderBy?: string; childconditions?: string; customfieldconditions?: string; page?: number; pageSize?: number; }, extraQueryParams?: any, extraFetchParams?: any ) : Promise<Array<RMADisposition>> {
			const localVarPath = this.basePath + '/procurement/RMADispositions';

			let queryParameters: any = assign({}, extraQueryParams);
			let headerParams: any = assign({}, this.defaultHeaders);
			if (params.conditions !== undefined) {
				queryParameters['conditions'] = params.conditions;
			}

			if (params.orderBy !== undefined) {
				queryParameters['orderBy'] = params.orderBy;
			}

			if (params.childconditions !== undefined) {
				queryParameters['childconditions'] = params.childconditions;
			}

			if (params.customfieldconditions !== undefined) {
				queryParameters['customfieldconditions'] = params.customfieldconditions;
			}

			if (params.page !== undefined) {
				queryParameters['page'] = params.page;
			}

			if (params.pageSize !== undefined) {
				queryParameters['pageSize'] = params.pageSize;
			}

			let fetchParams = {
				method: 'GET',
				headers: headerParams,

			};

			if (extraFetchParams) {
				fetchParams = assign(fetchParams, extraFetchParams);
			}

			let localVarPathWithQueryParameters = localVarPath + (localVarPath.indexOf('?') !== -1 ? '&' : '?') + querystring.stringify(queryParameters);

			return fetch(localVarPathWithQueryParameters, fetchParams).then((response) => {
				if (response.status >= 200 && response.status < 300) {
					return response.json();
				} else {
					let error = new Error(response.statusText);
					(error as any).response = response;
					throw error;
				}
			});
		}
		/**
		 *
		 * Delete R M A Disposition By Id
		 * @param id
		 */
		public procurementRMADispositionsIdDelete (params: {  id: number; }, extraQueryParams?: any, extraFetchParams?: any ) : Promise<{}> {
			const localVarPath = this.basePath + '/procurement/RMADispositions/{id}'
				.replace('{' + 'id' + '}', String(params.id));

			let queryParameters: any = assign({}, extraQueryParams);
			let headerParams: any = assign({}, this.defaultHeaders);
			// verify required parameter 'id' is set
			if (params.id == null) {
				throw new Error('Missing required parameter id when calling procurementRMADispositionsIdDelete');
			}
			let fetchParams = {
				method: 'DELETE',
				headers: headerParams,

			};

			if (extraFetchParams) {
				fetchParams = assign(fetchParams, extraFetchParams);
			}

			let localVarPathWithQueryParameters = localVarPath + (localVarPath.indexOf('?') !== -1 ? '&' : '?') + querystring.stringify(queryParameters);

			return fetch(localVarPathWithQueryParameters, fetchParams).then((response) => {
				if (response.status >= 200 && response.status < 300) {
					return response.json();
				} else {
					let error = new Error(response.statusText);
					(error as any).response = response;
					throw error;
				}
			});
		}
		/**
		 *
		 * Get R M A Disposition By Id
		 * @param id
		 */
		public procurementRMADispositionsIdGet (params: {  id: number; }, extraQueryParams?: any, extraFetchParams?: any ) : Promise<RMADisposition> {
			const localVarPath = this.basePath + '/procurement/RMADispositions/{id}'
				.replace('{' + 'id' + '}', String(params.id));

			let queryParameters: any = assign({}, extraQueryParams);
			let headerParams: any = assign({}, this.defaultHeaders);
			// verify required parameter 'id' is set
			if (params.id == null) {
				throw new Error('Missing required parameter id when calling procurementRMADispositionsIdGet');
			}
			let fetchParams = {
				method: 'GET',
				headers: headerParams,

			};

			if (extraFetchParams) {
				fetchParams = assign(fetchParams, extraFetchParams);
			}

			let localVarPathWithQueryParameters = localVarPath + (localVarPath.indexOf('?') !== -1 ? '&' : '?') + querystring.stringify(queryParameters);

			return fetch(localVarPathWithQueryParameters, fetchParams).then((response) => {
				if (response.status >= 200 && response.status < 300) {
					return response.json();
				} else {
					let error = new Error(response.statusText);
					(error as any).response = response;
					throw error;
				}
			});
		}
		/**
		 *
		 * Update R M A Disposition
		 * @param id
		 * @param operations
		 */
		public procurementRMADispositionsIdPatch (params: {  id: number; operations: Array<PatchOperation>; }, extraQueryParams?: any, extraFetchParams?: any ) : Promise<RMADisposition> {
			const localVarPath = this.basePath + '/procurement/RMADispositions/{id}'
				.replace('{' + 'id' + '}', String(params.id));

			let queryParameters: any = assign({}, extraQueryParams);
			let headerParams: any = assign({}, this.defaultHeaders);
			headerParams['Content-Type'] = 'application/json';

			// verify required parameter 'id' is set
			if (params.id == null) {
				throw new Error('Missing required parameter id when calling procurementRMADispositionsIdPatch');
			}
			// verify required parameter 'operations' is set
			if (params.operations == null) {
				throw new Error('Missing required parameter operations when calling procurementRMADispositionsIdPatch');
			}
			let fetchParams = {
				method: 'PATCH',
				headers: headerParams,
				body: JSON.stringify(params.operations),

			};

			if (extraFetchParams) {
				fetchParams = assign(fetchParams, extraFetchParams);
			}

			let localVarPathWithQueryParameters = localVarPath + (localVarPath.indexOf('?') !== -1 ? '&' : '?') + querystring.stringify(queryParameters);

			return fetch(localVarPathWithQueryParameters, fetchParams).then((response) => {
				if (response.status >= 200 && response.status < 300) {
					return response.json();
				} else {
					let error = new Error(response.statusText);
					(error as any).response = response;
					throw error;
				}
			});
		}
		/**
		 *
		 * Replace R M A Disposition
		 * @param id
		 * @param rMADisposition
		 */
		public procurementRMADispositionsIdPut (params: {  id: number; rMADisposition: RMADisposition; }, extraQueryParams?: any, extraFetchParams?: any ) : Promise<RMADisposition> {
			const localVarPath = this.basePath + '/procurement/RMADispositions/{id}'
				.replace('{' + 'id' + '}', String(params.id));

			let queryParameters: any = assign({}, extraQueryParams);
			let headerParams: any = assign({}, this.defaultHeaders);
			headerParams['Content-Type'] = 'application/json';

			// verify required parameter 'id' is set
			if (params.id == null) {
				throw new Error('Missing required parameter id when calling procurementRMADispositionsIdPut');
			}
			// verify required parameter 'rMADisposition' is set
			if (params.rMADisposition == null) {
				throw new Error('Missing required parameter rMADisposition when calling procurementRMADispositionsIdPut');
			}
			let fetchParams = {
				method: 'PUT',
				headers: headerParams,
				body: JSON.stringify(params.rMADisposition),

			};

			if (extraFetchParams) {
				fetchParams = assign(fetchParams, extraFetchParams);
			}

			let localVarPathWithQueryParameters = localVarPath + (localVarPath.indexOf('?') !== -1 ? '&' : '?') + querystring.stringify(queryParameters);

			return fetch(localVarPathWithQueryParameters, fetchParams).then((response) => {
				if (response.status >= 200 && response.status < 300) {
					return response.json();
				} else {
					let error = new Error(response.statusText);
					(error as any).response = response;
					throw error;
				}
			});
		}
		/**
		 *
		 * Create R M A Disposition
		 * @param rMADisposition
		 */
		public procurementRMADispositionsPost (params: {  rMADisposition: RMADisposition; }, extraQueryParams?: any, extraFetchParams?: any ) : Promise<RMADisposition> {
			const localVarPath = this.basePath + '/procurement/RMADispositions';

			let queryParameters: any = assign({}, extraQueryParams);
			let headerParams: any = assign({}, this.defaultHeaders);
			headerParams['Content-Type'] = 'application/json';

			// verify required parameter 'rMADisposition' is set
			if (params.rMADisposition == null) {
				throw new Error('Missing required parameter rMADisposition when calling procurementRMADispositionsPost');
			}
			let fetchParams = {
				method: 'POST',
				headers: headerParams,
				body: JSON.stringify(params.rMADisposition),

			};

			if (extraFetchParams) {
				fetchParams = assign(fetchParams, extraFetchParams);
			}

			let localVarPathWithQueryParameters = localVarPath + (localVarPath.indexOf('?') !== -1 ? '&' : '?') + querystring.stringify(queryParameters);

			return fetch(localVarPathWithQueryParameters, fetchParams).then((response) => {
				if (response.status >= 200 && response.status < 300) {
					return response.json();
				} else {
					let error = new Error(response.statusText);
					(error as any).response = response;
					throw error;
				}
			});
		}
	}
//}
//export namespace  {
	'use strict';

	export class ReportsApi {
		protected basePath = 'https://api-na.myconnectwise.net/v4_6_release/apis/3.0';
		public defaultHeaders : any = {};

		constructor(basePath?: string) {
			if (basePath) {
				this.basePath = basePath;
			}
		}

		/**
		 *
		 * Get Reports
		 * @param conditions
		 * @param orderBy
		 * @param childconditions
		 * @param customfieldconditions
		 */
		public systemReportsGet (params: {  conditions?: string; orderBy?: string; childconditions?: string; customfieldconditions?: string; }, extraQueryParams?: any, extraFetchParams?: any ) : Promise<Array<Report>> {
			const localVarPath = this.basePath + '/system/reports';

			let queryParameters: any = assign({}, extraQueryParams);
			let headerParams: any = assign({}, this.defaultHeaders);
			if (params.conditions !== undefined) {
				queryParameters['conditions'] = params.conditions;
			}

			if (params.orderBy !== undefined) {
				queryParameters['orderBy'] = params.orderBy;
			}

			if (params.childconditions !== undefined) {
				queryParameters['childconditions'] = params.childconditions;
			}

			if (params.customfieldconditions !== undefined) {
				queryParameters['customfieldconditions'] = params.customfieldconditions;
			}

			let fetchParams = {
				method: 'GET',
				headers: headerParams,

			};

			if (extraFetchParams) {
				fetchParams = assign(fetchParams, extraFetchParams);
			}

			let localVarPathWithQueryParameters = localVarPath + (localVarPath.indexOf('?') !== -1 ? '&' : '?') + querystring.stringify(queryParameters);

			return fetch(localVarPathWithQueryParameters, fetchParams).then((response) => {
				if (response.status >= 200 && response.status < 300) {
					return response.json();
				} else {
					let error = new Error(response.statusText);
					(error as any).response = response;
					throw error;
				}
			});
		}
		/**
		 *
		 * Get Column Definitions
		 * @param reportName
		 */
		public systemReportsReportNameColumnsGet (params: {  reportName: string; }, extraQueryParams?: any, extraFetchParams?: any ) : Promise<Array<JObject>> {
			const localVarPath = this.basePath + '/system/reports/{reportName}/columns'
				.replace('{' + 'reportName' + '}', String(params.reportName));

			let queryParameters: any = assign({}, extraQueryParams);
			let headerParams: any = assign({}, this.defaultHeaders);
			// verify required parameter 'reportName' is set
			if (params.reportName == null) {
				throw new Error('Missing required parameter reportName when calling systemReportsReportNameColumnsGet');
			}
			let fetchParams = {
				method: 'GET',
				headers: headerParams,

			};

			if (extraFetchParams) {
				fetchParams = assign(fetchParams, extraFetchParams);
			}

			let localVarPathWithQueryParameters = localVarPath + (localVarPath.indexOf('?') !== -1 ? '&' : '?') + querystring.stringify(queryParameters);

			return fetch(localVarPathWithQueryParameters, fetchParams).then((response) => {
				if (response.status >= 200 && response.status < 300) {
					return response.json();
				} else {
					let error = new Error(response.statusText);
					(error as any).response = response;
					throw error;
				}
			});
		}
		/**
		 *
		 * Get Report Results Count
		 * @param reportName
		 * @param conditions
		 */
		public systemReportsReportNameCountGet (params: {  reportName: string; conditions?: string; }, extraQueryParams?: any, extraFetchParams?: any ) : Promise<Count> {
			const localVarPath = this.basePath + '/system/reports/{reportName}/count'
				.replace('{' + 'reportName' + '}', String(params.reportName));

			let queryParameters: any = assign({}, extraQueryParams);
			let headerParams: any = assign({}, this.defaultHeaders);
			// verify required parameter 'reportName' is set
			if (params.reportName == null) {
				throw new Error('Missing required parameter reportName when calling systemReportsReportNameCountGet');
			}
			if (params.conditions !== undefined) {
				queryParameters['conditions'] = params.conditions;
			}

			let fetchParams = {
				method: 'GET',
				headers: headerParams,

			};

			if (extraFetchParams) {
				fetchParams = assign(fetchParams, extraFetchParams);
			}

			let localVarPathWithQueryParameters = localVarPath + (localVarPath.indexOf('?') !== -1 ? '&' : '?') + querystring.stringify(queryParameters);

			return fetch(localVarPathWithQueryParameters, fetchParams).then((response) => {
				if (response.status >= 200 && response.status < 300) {
					return response.json();
				} else {
					let error = new Error(response.statusText);
					(error as any).response = response;
					throw error;
				}
			});
		}
		/**
		 *
		 * Get Report Results
		 * @param reportName
		 * @param conditions
		 * @param orderBy
		 * @param childconditions
		 * @param customfieldconditions
		 * @param page
		 * @param pageSize
		 * @param columns
		 */
		public systemReportsReportNameGet (params: {  reportName: string; conditions?: string; orderBy?: string; childconditions?: string; customfieldconditions?: string; page?: number; pageSize?: number; columns?: string; }, extraQueryParams?: any, extraFetchParams?: any ) : Promise<ReportDataResponse> {
			const localVarPath = this.basePath + '/system/reports/{reportName}'
				.replace('{' + 'reportName' + '}', String(params.reportName));

			let queryParameters: any = assign({}, extraQueryParams);
			let headerParams: any = assign({}, this.defaultHeaders);
			// verify required parameter 'reportName' is set
			if (params.reportName == null) {
				throw new Error('Missing required parameter reportName when calling systemReportsReportNameGet');
			}
			if (params.conditions !== undefined) {
				queryParameters['conditions'] = params.conditions;
			}

			if (params.orderBy !== undefined) {
				queryParameters['orderBy'] = params.orderBy;
			}

			if (params.childconditions !== undefined) {
				queryParameters['childconditions'] = params.childconditions;
			}

			if (params.customfieldconditions !== undefined) {
				queryParameters['customfieldconditions'] = params.customfieldconditions;
			}

			if (params.page !== undefined) {
				queryParameters['page'] = params.page;
			}

			if (params.pageSize !== undefined) {
				queryParameters['pageSize'] = params.pageSize;
			}

			if (params.columns !== undefined) {
				queryParameters['columns'] = params.columns;
			}

			let fetchParams = {
				method: 'GET',
				headers: headerParams,

			};

			if (extraFetchParams) {
				fetchParams = assign(fetchParams, extraFetchParams);
			}

			let localVarPathWithQueryParameters = localVarPath + (localVarPath.indexOf('?') !== -1 ? '&' : '?') + querystring.stringify(queryParameters);

			return fetch(localVarPathWithQueryParameters, fetchParams).then((response) => {
				if (response.status >= 200 && response.status < 300) {
					return response.json();
				} else {
					let error = new Error(response.statusText);
					(error as any).response = response;
					throw error;
				}
			});
		}
	}
//}
//export namespace  {
	'use strict';

	export class RolesApi {
		protected basePath = 'https://api-na.myconnectwise.net/v4_6_release/apis/3.0';
		public defaultHeaders : any = {};

		constructor(basePath?: string) {
			if (basePath) {
				this.basePath = basePath;
			}
		}

		/**
		 *
		 * Get Role Count
		 * @param conditions
		 */
		public salesRolesCountGet (params: {  conditions?: string; }, extraQueryParams?: any, extraFetchParams?: any ) : Promise<Count> {
			const localVarPath = this.basePath + '/sales/roles/count';

			let queryParameters: any = assign({}, extraQueryParams);
			let headerParams: any = assign({}, this.defaultHeaders);
			if (params.conditions !== undefined) {
				queryParameters['conditions'] = params.conditions;
			}

			let fetchParams = {
				method: 'GET',
				headers: headerParams,

			};

			if (extraFetchParams) {
				fetchParams = assign(fetchParams, extraFetchParams);
			}

			let localVarPathWithQueryParameters = localVarPath + (localVarPath.indexOf('?') !== -1 ? '&' : '?') + querystring.stringify(queryParameters);

			return fetch(localVarPathWithQueryParameters, fetchParams).then((response) => {
				if (response.status >= 200 && response.status < 300) {
					return response.json();
				} else {
					let error = new Error(response.statusText);
					(error as any).response = response;
					throw error;
				}
			});
		}
		/**
		 *
		 * Get Role
		 * @param conditions
		 * @param orderBy
		 * @param childconditions
		 * @param customfieldconditions
		 * @param page
		 * @param pageSize
		 */
		public salesRolesGet (params: {  conditions?: string; orderBy?: string; childconditions?: string; customfieldconditions?: string; page?: number; pageSize?: number; }, extraQueryParams?: any, extraFetchParams?: any ) : Promise<Array<Role>> {
			const localVarPath = this.basePath + '/sales/roles';

			let queryParameters: any = assign({}, extraQueryParams);
			let headerParams: any = assign({}, this.defaultHeaders);
			if (params.conditions !== undefined) {
				queryParameters['conditions'] = params.conditions;
			}

			if (params.orderBy !== undefined) {
				queryParameters['orderBy'] = params.orderBy;
			}

			if (params.childconditions !== undefined) {
				queryParameters['childconditions'] = params.childconditions;
			}

			if (params.customfieldconditions !== undefined) {
				queryParameters['customfieldconditions'] = params.customfieldconditions;
			}

			if (params.page !== undefined) {
				queryParameters['page'] = params.page;
			}

			if (params.pageSize !== undefined) {
				queryParameters['pageSize'] = params.pageSize;
			}

			let fetchParams = {
				method: 'GET',
				headers: headerParams,

			};

			if (extraFetchParams) {
				fetchParams = assign(fetchParams, extraFetchParams);
			}

			let localVarPathWithQueryParameters = localVarPath + (localVarPath.indexOf('?') !== -1 ? '&' : '?') + querystring.stringify(queryParameters);

			return fetch(localVarPathWithQueryParameters, fetchParams).then((response) => {
				if (response.status >= 200 && response.status < 300) {
					return response.json();
				} else {
					let error = new Error(response.statusText);
					(error as any).response = response;
					throw error;
				}
			});
		}
		/**
		 *
		 * Delete Role By Id
		 * @param id
		 */
		public salesRolesIdDelete (params: {  id: number; }, extraQueryParams?: any, extraFetchParams?: any ) : Promise<{}> {
			const localVarPath = this.basePath + '/sales/roles/{id}'
				.replace('{' + 'id' + '}', String(params.id));

			let queryParameters: any = assign({}, extraQueryParams);
			let headerParams: any = assign({}, this.defaultHeaders);
			// verify required parameter 'id' is set
			if (params.id == null) {
				throw new Error('Missing required parameter id when calling salesRolesIdDelete');
			}
			let fetchParams = {
				method: 'DELETE',
				headers: headerParams,

			};

			if (extraFetchParams) {
				fetchParams = assign(fetchParams, extraFetchParams);
			}

			let localVarPathWithQueryParameters = localVarPath + (localVarPath.indexOf('?') !== -1 ? '&' : '?') + querystring.stringify(queryParameters);

			return fetch(localVarPathWithQueryParameters, fetchParams).then((response) => {
				if (response.status >= 200 && response.status < 300) {
					return response.json();
				} else {
					let error = new Error(response.statusText);
					(error as any).response = response;
					throw error;
				}
			});
		}
		/**
		 *
		 * Get Role By Id
		 * @param id
		 */
		public salesRolesIdGet (params: {  id: number; }, extraQueryParams?: any, extraFetchParams?: any ) : Promise<Role> {
			const localVarPath = this.basePath + '/sales/roles/{id}'
				.replace('{' + 'id' + '}', String(params.id));

			let queryParameters: any = assign({}, extraQueryParams);
			let headerParams: any = assign({}, this.defaultHeaders);
			// verify required parameter 'id' is set
			if (params.id == null) {
				throw new Error('Missing required parameter id when calling salesRolesIdGet');
			}
			let fetchParams = {
				method: 'GET',
				headers: headerParams,

			};

			if (extraFetchParams) {
				fetchParams = assign(fetchParams, extraFetchParams);
			}

			let localVarPathWithQueryParameters = localVarPath + (localVarPath.indexOf('?') !== -1 ? '&' : '?') + querystring.stringify(queryParameters);

			return fetch(localVarPathWithQueryParameters, fetchParams).then((response) => {
				if (response.status >= 200 && response.status < 300) {
					return response.json();
				} else {
					let error = new Error(response.statusText);
					(error as any).response = response;
					throw error;
				}
			});
		}
		/**
		 *
		 * Update Role
		 * @param id
		 * @param operations
		 */
		public salesRolesIdPatch (params: {  id: number; operations: Array<PatchOperation>; }, extraQueryParams?: any, extraFetchParams?: any ) : Promise<Role> {
			const localVarPath = this.basePath + '/sales/roles/{id}'
				.replace('{' + 'id' + '}', String(params.id));

			let queryParameters: any = assign({}, extraQueryParams);
			let headerParams: any = assign({}, this.defaultHeaders);
			headerParams['Content-Type'] = 'application/json';

			// verify required parameter 'id' is set
			if (params.id == null) {
				throw new Error('Missing required parameter id when calling salesRolesIdPatch');
			}
			// verify required parameter 'operations' is set
			if (params.operations == null) {
				throw new Error('Missing required parameter operations when calling salesRolesIdPatch');
			}
			let fetchParams = {
				method: 'PATCH',
				headers: headerParams,
				body: JSON.stringify(params.operations),

			};

			if (extraFetchParams) {
				fetchParams = assign(fetchParams, extraFetchParams);
			}

			let localVarPathWithQueryParameters = localVarPath + (localVarPath.indexOf('?') !== -1 ? '&' : '?') + querystring.stringify(queryParameters);

			return fetch(localVarPathWithQueryParameters, fetchParams).then((response) => {
				if (response.status >= 200 && response.status < 300) {
					return response.json();
				} else {
					let error = new Error(response.statusText);
					(error as any).response = response;
					throw error;
				}
			});
		}
		/**
		 *
		 * Replace Role
		 * @param id
		 * @param role
		 */
		public salesRolesIdPut (params: {  id: number; role: Role; }, extraQueryParams?: any, extraFetchParams?: any ) : Promise<Role> {
			const localVarPath = this.basePath + '/sales/roles/{id}'
				.replace('{' + 'id' + '}', String(params.id));

			let queryParameters: any = assign({}, extraQueryParams);
			let headerParams: any = assign({}, this.defaultHeaders);
			headerParams['Content-Type'] = 'application/json';

			// verify required parameter 'id' is set
			if (params.id == null) {
				throw new Error('Missing required parameter id when calling salesRolesIdPut');
			}
			// verify required parameter 'role' is set
			if (params.role == null) {
				throw new Error('Missing required parameter role when calling salesRolesIdPut');
			}
			let fetchParams = {
				method: 'PUT',
				headers: headerParams,
				body: JSON.stringify(params.role),

			};

			if (extraFetchParams) {
				fetchParams = assign(fetchParams, extraFetchParams);
			}

			let localVarPathWithQueryParameters = localVarPath + (localVarPath.indexOf('?') !== -1 ? '&' : '?') + querystring.stringify(queryParameters);

			return fetch(localVarPathWithQueryParameters, fetchParams).then((response) => {
				if (response.status >= 200 && response.status < 300) {
					return response.json();
				} else {
					let error = new Error(response.statusText);
					(error as any).response = response;
					throw error;
				}
			});
		}
		/**
		 *
		 * Create Role
		 * @param role
		 */
		public salesRolesPost (params: {  role: Role; }, extraQueryParams?: any, extraFetchParams?: any ) : Promise<Role> {
			const localVarPath = this.basePath + '/sales/roles';

			let queryParameters: any = assign({}, extraQueryParams);
			let headerParams: any = assign({}, this.defaultHeaders);
			headerParams['Content-Type'] = 'application/json';

			// verify required parameter 'role' is set
			if (params.role == null) {
				throw new Error('Missing required parameter role when calling salesRolesPost');
			}
			let fetchParams = {
				method: 'POST',
				headers: headerParams,
				body: JSON.stringify(params.role),

			};

			if (extraFetchParams) {
				fetchParams = assign(fetchParams, extraFetchParams);
			}

			let localVarPathWithQueryParameters = localVarPath + (localVarPath.indexOf('?') !== -1 ? '&' : '?') + querystring.stringify(queryParameters);

			return fetch(localVarPathWithQueryParameters, fetchParams).then((response) => {
				if (response.status >= 200 && response.status < 300) {
					return response.json();
				} else {
					let error = new Error(response.statusText);
					(error as any).response = response;
					throw error;
				}
			});
		}
	}
//}
//export namespace  {
	'use strict';

	export class SalesProbabilitiesApi {
		protected basePath = 'https://api-na.myconnectwise.net/v4_6_release/apis/3.0';
		public defaultHeaders : any = {};

		constructor(basePath?: string) {
			if (basePath) {
				this.basePath = basePath;
			}
		}

		/**
		 *
		 * Get Probabilities Count
		 * @param conditions
		 */
		public salesProbabilitiesCountGet (params: {  conditions?: string; }, extraQueryParams?: any, extraFetchParams?: any ) : Promise<Count> {
			const localVarPath = this.basePath + '/sales/probabilities/count';

			let queryParameters: any = assign({}, extraQueryParams);
			let headerParams: any = assign({}, this.defaultHeaders);
			if (params.conditions !== undefined) {
				queryParameters['conditions'] = params.conditions;
			}

			let fetchParams = {
				method: 'GET',
				headers: headerParams,

			};

			if (extraFetchParams) {
				fetchParams = assign(fetchParams, extraFetchParams);
			}

			let localVarPathWithQueryParameters = localVarPath + (localVarPath.indexOf('?') !== -1 ? '&' : '?') + querystring.stringify(queryParameters);

			return fetch(localVarPathWithQueryParameters, fetchParams).then((response) => {
				if (response.status >= 200 && response.status < 300) {
					return response.json();
				} else {
					let error = new Error(response.statusText);
					(error as any).response = response;
					throw error;
				}
			});
		}
		/**
		 *
		 * Get Probabilities
		 * @param conditions
		 * @param orderBy
		 * @param childconditions
		 * @param customfieldconditions
		 * @param page
		 * @param pageSize
		 */
		public salesProbabilitiesGet (params: {  conditions?: string; orderBy?: string; childconditions?: string; customfieldconditions?: string; page?: number; pageSize?: number; }, extraQueryParams?: any, extraFetchParams?: any ) : Promise<Array<SalesProbability>> {
			const localVarPath = this.basePath + '/sales/probabilities';

			let queryParameters: any = assign({}, extraQueryParams);
			let headerParams: any = assign({}, this.defaultHeaders);
			if (params.conditions !== undefined) {
				queryParameters['conditions'] = params.conditions;
			}

			if (params.orderBy !== undefined) {
				queryParameters['orderBy'] = params.orderBy;
			}

			if (params.childconditions !== undefined) {
				queryParameters['childconditions'] = params.childconditions;
			}

			if (params.customfieldconditions !== undefined) {
				queryParameters['customfieldconditions'] = params.customfieldconditions;
			}

			if (params.page !== undefined) {
				queryParameters['page'] = params.page;
			}

			if (params.pageSize !== undefined) {
				queryParameters['pageSize'] = params.pageSize;
			}

			let fetchParams = {
				method: 'GET',
				headers: headerParams,

			};

			if (extraFetchParams) {
				fetchParams = assign(fetchParams, extraFetchParams);
			}

			let localVarPathWithQueryParameters = localVarPath + (localVarPath.indexOf('?') !== -1 ? '&' : '?') + querystring.stringify(queryParameters);

			return fetch(localVarPathWithQueryParameters, fetchParams).then((response) => {
				if (response.status >= 200 && response.status < 300) {
					return response.json();
				} else {
					let error = new Error(response.statusText);
					(error as any).response = response;
					throw error;
				}
			});
		}
		/**
		 *
		 * Delete Probability By Id
		 * @param id
		 */
		public salesProbabilitiesIdDelete (params: {  id: number; }, extraQueryParams?: any, extraFetchParams?: any ) : Promise<{}> {
			const localVarPath = this.basePath + '/sales/probabilities/{id}'
				.replace('{' + 'id' + '}', String(params.id));

			let queryParameters: any = assign({}, extraQueryParams);
			let headerParams: any = assign({}, this.defaultHeaders);
			// verify required parameter 'id' is set
			if (params.id == null) {
				throw new Error('Missing required parameter id when calling salesProbabilitiesIdDelete');
			}
			let fetchParams = {
				method: 'DELETE',
				headers: headerParams,

			};

			if (extraFetchParams) {
				fetchParams = assign(fetchParams, extraFetchParams);
			}

			let localVarPathWithQueryParameters = localVarPath + (localVarPath.indexOf('?') !== -1 ? '&' : '?') + querystring.stringify(queryParameters);

			return fetch(localVarPathWithQueryParameters, fetchParams).then((response) => {
				if (response.status >= 200 && response.status < 300) {
					return response.json();
				} else {
					let error = new Error(response.statusText);
					(error as any).response = response;
					throw error;
				}
			});
		}
		/**
		 *
		 * Get Probability By Id
		 * @param id
		 */
		public salesProbabilitiesIdGet (params: {  id: number; }, extraQueryParams?: any, extraFetchParams?: any ) : Promise<SalesProbability> {
			const localVarPath = this.basePath + '/sales/probabilities/{id}'
				.replace('{' + 'id' + '}', String(params.id));

			let queryParameters: any = assign({}, extraQueryParams);
			let headerParams: any = assign({}, this.defaultHeaders);
			// verify required parameter 'id' is set
			if (params.id == null) {
				throw new Error('Missing required parameter id when calling salesProbabilitiesIdGet');
			}
			let fetchParams = {
				method: 'GET',
				headers: headerParams,

			};

			if (extraFetchParams) {
				fetchParams = assign(fetchParams, extraFetchParams);
			}

			let localVarPathWithQueryParameters = localVarPath + (localVarPath.indexOf('?') !== -1 ? '&' : '?') + querystring.stringify(queryParameters);

			return fetch(localVarPathWithQueryParameters, fetchParams).then((response) => {
				if (response.status >= 200 && response.status < 300) {
					return response.json();
				} else {
					let error = new Error(response.statusText);
					(error as any).response = response;
					throw error;
				}
			});
		}
		/**
		 *
		 * Update Probability
		 * @param id
		 * @param operations
		 */
		public salesProbabilitiesIdPatch (params: {  id: number; operations: Array<PatchOperation>; }, extraQueryParams?: any, extraFetchParams?: any ) : Promise<SalesProbability> {
			const localVarPath = this.basePath + '/sales/probabilities/{id}'
				.replace('{' + 'id' + '}', String(params.id));

			let queryParameters: any = assign({}, extraQueryParams);
			let headerParams: any = assign({}, this.defaultHeaders);
			headerParams['Content-Type'] = 'application/json';

			// verify required parameter 'id' is set
			if (params.id == null) {
				throw new Error('Missing required parameter id when calling salesProbabilitiesIdPatch');
			}
			// verify required parameter 'operations' is set
			if (params.operations == null) {
				throw new Error('Missing required parameter operations when calling salesProbabilitiesIdPatch');
			}
			let fetchParams = {
				method: 'PATCH',
				headers: headerParams,
				body: JSON.stringify(params.operations),

			};

			if (extraFetchParams) {
				fetchParams = assign(fetchParams, extraFetchParams);
			}

			let localVarPathWithQueryParameters = localVarPath + (localVarPath.indexOf('?') !== -1 ? '&' : '?') + querystring.stringify(queryParameters);

			return fetch(localVarPathWithQueryParameters, fetchParams).then((response) => {
				if (response.status >= 200 && response.status < 300) {
					return response.json();
				} else {
					let error = new Error(response.statusText);
					(error as any).response = response;
					throw error;
				}
			});
		}
		/**
		 *
		 * Replace Probability
		 * @param id
		 * @param probability
		 */
		public salesProbabilitiesIdPut (params: {  id: number; probability: SalesProbability; }, extraQueryParams?: any, extraFetchParams?: any ) : Promise<SalesProbability> {
			const localVarPath = this.basePath + '/sales/probabilities/{id}'
				.replace('{' + 'id' + '}', String(params.id));

			let queryParameters: any = assign({}, extraQueryParams);
			let headerParams: any = assign({}, this.defaultHeaders);
			headerParams['Content-Type'] = 'application/json';

			// verify required parameter 'id' is set
			if (params.id == null) {
				throw new Error('Missing required parameter id when calling salesProbabilitiesIdPut');
			}
			// verify required parameter 'probability' is set
			if (params.probability == null) {
				throw new Error('Missing required parameter probability when calling salesProbabilitiesIdPut');
			}
			let fetchParams = {
				method: 'PUT',
				headers: headerParams,
				body: JSON.stringify(params.probability),

			};

			if (extraFetchParams) {
				fetchParams = assign(fetchParams, extraFetchParams);
			}

			let localVarPathWithQueryParameters = localVarPath + (localVarPath.indexOf('?') !== -1 ? '&' : '?') + querystring.stringify(queryParameters);

			return fetch(localVarPathWithQueryParameters, fetchParams).then((response) => {
				if (response.status >= 200 && response.status < 300) {
					return response.json();
				} else {
					let error = new Error(response.statusText);
					(error as any).response = response;
					throw error;
				}
			});
		}
		/**
		 *
		 * Create Probability
		 * @param probability
		 */
		public salesProbabilitiesPost (params: {  probability: SalesProbability; }, extraQueryParams?: any, extraFetchParams?: any ) : Promise<SalesProbability> {
			const localVarPath = this.basePath + '/sales/probabilities';

			let queryParameters: any = assign({}, extraQueryParams);
			let headerParams: any = assign({}, this.defaultHeaders);
			headerParams['Content-Type'] = 'application/json';

			// verify required parameter 'probability' is set
			if (params.probability == null) {
				throw new Error('Missing required parameter probability when calling salesProbabilitiesPost');
			}
			let fetchParams = {
				method: 'POST',
				headers: headerParams,
				body: JSON.stringify(params.probability),

			};

			if (extraFetchParams) {
				fetchParams = assign(fetchParams, extraFetchParams);
			}

			let localVarPathWithQueryParameters = localVarPath + (localVarPath.indexOf('?') !== -1 ? '&' : '?') + querystring.stringify(queryParameters);

			return fetch(localVarPathWithQueryParameters, fetchParams).then((response) => {
				if (response.status >= 200 && response.status < 300) {
					return response.json();
				} else {
					let error = new Error(response.statusText);
					(error as any).response = response;
					throw error;
				}
			});
		}
	}
//}
//export namespace  {
	'use strict';

	export class ScheduleEntriesApi {
		protected basePath = 'https://api-na.myconnectwise.net/v4_6_release/apis/3.0';
		public defaultHeaders : any = {};

		constructor(basePath?: string) {
			if (basePath) {
				this.basePath = basePath;
			}
		}

		/**
		 *
		 * Get Schedules Count
		 * @param conditions
		 */
		public scheduleEntriesCountGet (params: {  conditions?: string; }, extraQueryParams?: any, extraFetchParams?: any ) : Promise<Count> {
			const localVarPath = this.basePath + '/schedule/entries/count';

			let queryParameters: any = assign({}, extraQueryParams);
			let headerParams: any = assign({}, this.defaultHeaders);
			if (params.conditions !== undefined) {
				queryParameters['conditions'] = params.conditions;
			}

			let fetchParams = {
				method: 'GET',
				headers: headerParams,

			};

			if (extraFetchParams) {
				fetchParams = assign(fetchParams, extraFetchParams);
			}

			let localVarPathWithQueryParameters = localVarPath + (localVarPath.indexOf('?') !== -1 ? '&' : '?') + querystring.stringify(queryParameters);

			return fetch(localVarPathWithQueryParameters, fetchParams).then((response) => {
				if (response.status >= 200 && response.status < 300) {
					return response.json();
				} else {
					let error = new Error(response.statusText);
					(error as any).response = response;
					throw error;
				}
			});
		}
		/**
		 *
		 * Get Schedules
		 * @param conditions
		 * @param orderBy
		 * @param childconditions
		 * @param customfieldconditions
		 * @param page
		 * @param pageSize
		 */
		public scheduleEntriesGet (params: {  conditions?: string; orderBy?: string; childconditions?: string; customfieldconditions?: string; page?: number; pageSize?: number; }, extraQueryParams?: any, extraFetchParams?: any ) : Promise<Array<ScheduleEntry>> {
			const localVarPath = this.basePath + '/schedule/entries';

			let queryParameters: any = assign({}, extraQueryParams);
			let headerParams: any = assign({}, this.defaultHeaders);
			if (params.conditions !== undefined) {
				queryParameters['conditions'] = params.conditions;
			}

			if (params.orderBy !== undefined) {
				queryParameters['orderBy'] = params.orderBy;
			}

			if (params.childconditions !== undefined) {
				queryParameters['childconditions'] = params.childconditions;
			}

			if (params.customfieldconditions !== undefined) {
				queryParameters['customfieldconditions'] = params.customfieldconditions;
			}

			if (params.page !== undefined) {
				queryParameters['page'] = params.page;
			}

			if (params.pageSize !== undefined) {
				queryParameters['pageSize'] = params.pageSize;
			}

			let fetchParams = {
				method: 'GET',
				headers: headerParams,

			};

			if (extraFetchParams) {
				fetchParams = assign(fetchParams, extraFetchParams);
			}

			let localVarPathWithQueryParameters = localVarPath + (localVarPath.indexOf('?') !== -1 ? '&' : '?') + querystring.stringify(queryParameters);

			return fetch(localVarPathWithQueryParameters, fetchParams).then((response) => {
				if (response.status >= 200 && response.status < 300) {
					return response.json();
				} else {
					let error = new Error(response.statusText);
					(error as any).response = response;
					throw error;
				}
			});
		}
		/**
		 *
		 * Delete Schedule By Id
		 * @param id
		 */
		public scheduleEntriesIdDelete (params: {  id: number; }, extraQueryParams?: any, extraFetchParams?: any ) : Promise<{}> {
			const localVarPath = this.basePath + '/schedule/entries/{id}'
				.replace('{' + 'id' + '}', String(params.id));

			let queryParameters: any = assign({}, extraQueryParams);
			let headerParams: any = assign({}, this.defaultHeaders);
			// verify required parameter 'id' is set
			if (params.id == null) {
				throw new Error('Missing required parameter id when calling scheduleEntriesIdDelete');
			}
			let fetchParams = {
				method: 'DELETE',
				headers: headerParams,

			};

			if (extraFetchParams) {
				fetchParams = assign(fetchParams, extraFetchParams);
			}

			let localVarPathWithQueryParameters = localVarPath + (localVarPath.indexOf('?') !== -1 ? '&' : '?') + querystring.stringify(queryParameters);

			return fetch(localVarPathWithQueryParameters, fetchParams).then((response) => {
				if (response.status >= 200 && response.status < 300) {
					return response.json();
				} else {
					let error = new Error(response.statusText);
					(error as any).response = response;
					throw error;
				}
			});
		}
		/**
		 *
		 * Get Schedule By Id
		 * @param id
		 */
		public scheduleEntriesIdGet (params: {  id: number; }, extraQueryParams?: any, extraFetchParams?: any ) : Promise<ScheduleEntry> {
			const localVarPath = this.basePath + '/schedule/entries/{id}'
				.replace('{' + 'id' + '}', String(params.id));

			let queryParameters: any = assign({}, extraQueryParams);
			let headerParams: any = assign({}, this.defaultHeaders);
			// verify required parameter 'id' is set
			if (params.id == null) {
				throw new Error('Missing required parameter id when calling scheduleEntriesIdGet');
			}
			let fetchParams = {
				method: 'GET',
				headers: headerParams,

			};

			if (extraFetchParams) {
				fetchParams = assign(fetchParams, extraFetchParams);
			}

			let localVarPathWithQueryParameters = localVarPath + (localVarPath.indexOf('?') !== -1 ? '&' : '?') + querystring.stringify(queryParameters);

			return fetch(localVarPathWithQueryParameters, fetchParams).then((response) => {
				if (response.status >= 200 && response.status < 300) {
					return response.json();
				} else {
					let error = new Error(response.statusText);
					(error as any).response = response;
					throw error;
				}
			});
		}
		/**
		 *
		 * Update Schedule
		 * @param id
		 * @param operations
		 */
		public scheduleEntriesIdPatch (params: {  id: number; operations: Array<PatchOperation>; }, extraQueryParams?: any, extraFetchParams?: any ) : Promise<ScheduleEntry> {
			const localVarPath = this.basePath + '/schedule/entries/{id}'
				.replace('{' + 'id' + '}', String(params.id));

			let queryParameters: any = assign({}, extraQueryParams);
			let headerParams: any = assign({}, this.defaultHeaders);
			headerParams['Content-Type'] = 'application/json';

			// verify required parameter 'id' is set
			if (params.id == null) {
				throw new Error('Missing required parameter id when calling scheduleEntriesIdPatch');
			}
			// verify required parameter 'operations' is set
			if (params.operations == null) {
				throw new Error('Missing required parameter operations when calling scheduleEntriesIdPatch');
			}
			let fetchParams = {
				method: 'PATCH',
				headers: headerParams,
				body: JSON.stringify(params.operations),

			};

			if (extraFetchParams) {
				fetchParams = assign(fetchParams, extraFetchParams);
			}

			let localVarPathWithQueryParameters = localVarPath + (localVarPath.indexOf('?') !== -1 ? '&' : '?') + querystring.stringify(queryParameters);

			return fetch(localVarPathWithQueryParameters, fetchParams).then((response) => {
				if (response.status >= 200 && response.status < 300) {
					return response.json();
				} else {
					let error = new Error(response.statusText);
					(error as any).response = response;
					throw error;
				}
			});
		}
		/**
		 *
		 * Replace Schedule
		 * @param id
		 * @param scheduleEntry
		 */
		public scheduleEntriesIdPut (params: {  id: number; scheduleEntry: ScheduleEntry; }, extraQueryParams?: any, extraFetchParams?: any ) : Promise<ScheduleEntry> {
			const localVarPath = this.basePath + '/schedule/entries/{id}'
				.replace('{' + 'id' + '}', String(params.id));

			let queryParameters: any = assign({}, extraQueryParams);
			let headerParams: any = assign({}, this.defaultHeaders);
			headerParams['Content-Type'] = 'application/json';

			// verify required parameter 'id' is set
			if (params.id == null) {
				throw new Error('Missing required parameter id when calling scheduleEntriesIdPut');
			}
			// verify required parameter 'scheduleEntry' is set
			if (params.scheduleEntry == null) {
				throw new Error('Missing required parameter scheduleEntry when calling scheduleEntriesIdPut');
			}
			let fetchParams = {
				method: 'PUT',
				headers: headerParams,
				body: JSON.stringify(params.scheduleEntry),

			};

			if (extraFetchParams) {
				fetchParams = assign(fetchParams, extraFetchParams);
			}

			let localVarPathWithQueryParameters = localVarPath + (localVarPath.indexOf('?') !== -1 ? '&' : '?') + querystring.stringify(queryParameters);

			return fetch(localVarPathWithQueryParameters, fetchParams).then((response) => {
				if (response.status >= 200 && response.status < 300) {
					return response.json();
				} else {
					let error = new Error(response.statusText);
					(error as any).response = response;
					throw error;
				}
			});
		}
		/**
		 *
		 * Create Schedule
		 * @param scheduleEntry
		 */
		public scheduleEntriesPost (params: {  scheduleEntry: ScheduleEntry; }, extraQueryParams?: any, extraFetchParams?: any ) : Promise<ScheduleEntry> {
			const localVarPath = this.basePath + '/schedule/entries';

			let queryParameters: any = assign({}, extraQueryParams);
			let headerParams: any = assign({}, this.defaultHeaders);
			headerParams['Content-Type'] = 'application/json';

			// verify required parameter 'scheduleEntry' is set
			if (params.scheduleEntry == null) {
				throw new Error('Missing required parameter scheduleEntry when calling scheduleEntriesPost');
			}
			let fetchParams = {
				method: 'POST',
				headers: headerParams,
				body: JSON.stringify(params.scheduleEntry),

			};

			if (extraFetchParams) {
				fetchParams = assign(fetchParams, extraFetchParams);
			}

			let localVarPathWithQueryParameters = localVarPath + (localVarPath.indexOf('?') !== -1 ? '&' : '?') + querystring.stringify(queryParameters);

			return fetch(localVarPathWithQueryParameters, fetchParams).then((response) => {
				if (response.status >= 200 && response.status < 300) {
					return response.json();
				} else {
					let error = new Error(response.statusText);
					(error as any).response = response;
					throw error;
				}
			});
		}
	}
//}
//export namespace  {
	'use strict';

	export class ScheduleReminderTimesApi {
		protected basePath = 'https://api-na.myconnectwise.net/v4_6_release/apis/3.0';
		public defaultHeaders : any = {};

		constructor(basePath?: string) {
			if (basePath) {
				this.basePath = basePath;
			}
		}

		/**
		 *
		 * Get Reminder Time Count
		 * @param conditions
		 */
		public scheduleReminderTimesCountGet (params: {  conditions?: string; }, extraQueryParams?: any, extraFetchParams?: any ) : Promise<Count> {
			const localVarPath = this.basePath + '/schedule/reminderTimes/count';

			let queryParameters: any = assign({}, extraQueryParams);
			let headerParams: any = assign({}, this.defaultHeaders);
			if (params.conditions !== undefined) {
				queryParameters['conditions'] = params.conditions;
			}

			let fetchParams = {
				method: 'GET',
				headers: headerParams,

			};

			if (extraFetchParams) {
				fetchParams = assign(fetchParams, extraFetchParams);
			}

			let localVarPathWithQueryParameters = localVarPath + (localVarPath.indexOf('?') !== -1 ? '&' : '?') + querystring.stringify(queryParameters);

			return fetch(localVarPathWithQueryParameters, fetchParams).then((response) => {
				if (response.status >= 200 && response.status < 300) {
					return response.json();
				} else {
					let error = new Error(response.statusText);
					(error as any).response = response;
					throw error;
				}
			});
		}
		/**
		 *
		 * Get Reminder Time
		 * @param conditions
		 * @param orderBy
		 * @param childconditions
		 * @param customfieldconditions
		 * @param page
		 * @param pageSize
		 */
		public scheduleReminderTimesGet (params: {  conditions?: string; orderBy?: string; childconditions?: string; customfieldconditions?: string; page?: number; pageSize?: number; }, extraQueryParams?: any, extraFetchParams?: any ) : Promise<Array<ScheduleReminderTime>> {
			const localVarPath = this.basePath + '/schedule/reminderTimes';

			let queryParameters: any = assign({}, extraQueryParams);
			let headerParams: any = assign({}, this.defaultHeaders);
			if (params.conditions !== undefined) {
				queryParameters['conditions'] = params.conditions;
			}

			if (params.orderBy !== undefined) {
				queryParameters['orderBy'] = params.orderBy;
			}

			if (params.childconditions !== undefined) {
				queryParameters['childconditions'] = params.childconditions;
			}

			if (params.customfieldconditions !== undefined) {
				queryParameters['customfieldconditions'] = params.customfieldconditions;
			}

			if (params.page !== undefined) {
				queryParameters['page'] = params.page;
			}

			if (params.pageSize !== undefined) {
				queryParameters['pageSize'] = params.pageSize;
			}

			let fetchParams = {
				method: 'GET',
				headers: headerParams,

			};

			if (extraFetchParams) {
				fetchParams = assign(fetchParams, extraFetchParams);
			}

			let localVarPathWithQueryParameters = localVarPath + (localVarPath.indexOf('?') !== -1 ? '&' : '?') + querystring.stringify(queryParameters);

			return fetch(localVarPathWithQueryParameters, fetchParams).then((response) => {
				if (response.status >= 200 && response.status < 300) {
					return response.json();
				} else {
					let error = new Error(response.statusText);
					(error as any).response = response;
					throw error;
				}
			});
		}
		/**
		 *
		 * Get Reminder Time By Id
		 * @param id
		 */
		public scheduleReminderTimesIdGet (params: {  id: number; }, extraQueryParams?: any, extraFetchParams?: any ) : Promise<ScheduleReminderTime> {
			const localVarPath = this.basePath + '/schedule/reminderTimes/{id}'
				.replace('{' + 'id' + '}', String(params.id));

			let queryParameters: any = assign({}, extraQueryParams);
			let headerParams: any = assign({}, this.defaultHeaders);
			// verify required parameter 'id' is set
			if (params.id == null) {
				throw new Error('Missing required parameter id when calling scheduleReminderTimesIdGet');
			}
			let fetchParams = {
				method: 'GET',
				headers: headerParams,

			};

			if (extraFetchParams) {
				fetchParams = assign(fetchParams, extraFetchParams);
			}

			let localVarPathWithQueryParameters = localVarPath + (localVarPath.indexOf('?') !== -1 ? '&' : '?') + querystring.stringify(queryParameters);

			return fetch(localVarPathWithQueryParameters, fetchParams).then((response) => {
				if (response.status >= 200 && response.status < 300) {
					return response.json();
				} else {
					let error = new Error(response.statusText);
					(error as any).response = response;
					throw error;
				}
			});
		}
		/**
		 *
		 * Update Reminder Time
		 * @param id
		 * @param operations
		 */
		public scheduleReminderTimesIdPatch (params: {  id: number; operations: Array<PatchOperation>; }, extraQueryParams?: any, extraFetchParams?: any ) : Promise<ScheduleReminderTime> {
			const localVarPath = this.basePath + '/schedule/reminderTimes/{id}'
				.replace('{' + 'id' + '}', String(params.id));

			let queryParameters: any = assign({}, extraQueryParams);
			let headerParams: any = assign({}, this.defaultHeaders);
			headerParams['Content-Type'] = 'application/json';

			// verify required parameter 'id' is set
			if (params.id == null) {
				throw new Error('Missing required parameter id when calling scheduleReminderTimesIdPatch');
			}
			// verify required parameter 'operations' is set
			if (params.operations == null) {
				throw new Error('Missing required parameter operations when calling scheduleReminderTimesIdPatch');
			}
			let fetchParams = {
				method: 'PATCH',
				headers: headerParams,
				body: JSON.stringify(params.operations),

			};

			if (extraFetchParams) {
				fetchParams = assign(fetchParams, extraFetchParams);
			}

			let localVarPathWithQueryParameters = localVarPath + (localVarPath.indexOf('?') !== -1 ? '&' : '?') + querystring.stringify(queryParameters);

			return fetch(localVarPathWithQueryParameters, fetchParams).then((response) => {
				if (response.status >= 200 && response.status < 300) {
					return response.json();
				} else {
					let error = new Error(response.statusText);
					(error as any).response = response;
					throw error;
				}
			});
		}
		/**
		 *
		 * Replace Reminder Time
		 * @param id
		 * @param reminderTime
		 */
		public scheduleReminderTimesIdPut (params: {  id: number; reminderTime: ScheduleReminderTime; }, extraQueryParams?: any, extraFetchParams?: any ) : Promise<ScheduleReminderTime> {
			const localVarPath = this.basePath + '/schedule/reminderTimes/{id}'
				.replace('{' + 'id' + '}', String(params.id));

			let queryParameters: any = assign({}, extraQueryParams);
			let headerParams: any = assign({}, this.defaultHeaders);
			headerParams['Content-Type'] = 'application/json';

			// verify required parameter 'id' is set
			if (params.id == null) {
				throw new Error('Missing required parameter id when calling scheduleReminderTimesIdPut');
			}
			// verify required parameter 'reminderTime' is set
			if (params.reminderTime == null) {
				throw new Error('Missing required parameter reminderTime when calling scheduleReminderTimesIdPut');
			}
			let fetchParams = {
				method: 'PUT',
				headers: headerParams,
				body: JSON.stringify(params.reminderTime),

			};

			if (extraFetchParams) {
				fetchParams = assign(fetchParams, extraFetchParams);
			}

			let localVarPathWithQueryParameters = localVarPath + (localVarPath.indexOf('?') !== -1 ? '&' : '?') + querystring.stringify(queryParameters);

			return fetch(localVarPathWithQueryParameters, fetchParams).then((response) => {
				if (response.status >= 200 && response.status < 300) {
					return response.json();
				} else {
					let error = new Error(response.statusText);
					(error as any).response = response;
					throw error;
				}
			});
		}
	}
//}
//export namespace  {
	'use strict';

	export class ScheduleStatusesApi {
		protected basePath = 'https://api-na.myconnectwise.net/v4_6_release/apis/3.0';
		public defaultHeaders : any = {};

		constructor(basePath?: string) {
			if (basePath) {
				this.basePath = basePath;
			}
		}

		/**
		 *
		 * Get Schedule Statuses Count
		 * @param conditions
		 */
		public scheduleStatusesCountGet (params: {  conditions?: string; }, extraQueryParams?: any, extraFetchParams?: any ) : Promise<Count> {
			const localVarPath = this.basePath + '/schedule/statuses/count';

			let queryParameters: any = assign({}, extraQueryParams);
			let headerParams: any = assign({}, this.defaultHeaders);
			if (params.conditions !== undefined) {
				queryParameters['conditions'] = params.conditions;
			}

			let fetchParams = {
				method: 'GET',
				headers: headerParams,

			};

			if (extraFetchParams) {
				fetchParams = assign(fetchParams, extraFetchParams);
			}

			let localVarPathWithQueryParameters = localVarPath + (localVarPath.indexOf('?') !== -1 ? '&' : '?') + querystring.stringify(queryParameters);

			return fetch(localVarPathWithQueryParameters, fetchParams).then((response) => {
				if (response.status >= 200 && response.status < 300) {
					return response.json();
				} else {
					let error = new Error(response.statusText);
					(error as any).response = response;
					throw error;
				}
			});
		}
		/**
		 *
		 * Get Schedule Statuses
		 * @param conditions
		 * @param orderBy
		 * @param childconditions
		 * @param customfieldconditions
		 * @param page
		 * @param pageSize
		 */
		public scheduleStatusesGet (params: {  conditions?: string; orderBy?: string; childconditions?: string; customfieldconditions?: string; page?: number; pageSize?: number; }, extraQueryParams?: any, extraFetchParams?: any ) : Promise<Array<ScheduleStatus>> {
			const localVarPath = this.basePath + '/schedule/statuses';

			let queryParameters: any = assign({}, extraQueryParams);
			let headerParams: any = assign({}, this.defaultHeaders);
			if (params.conditions !== undefined) {
				queryParameters['conditions'] = params.conditions;
			}

			if (params.orderBy !== undefined) {
				queryParameters['orderBy'] = params.orderBy;
			}

			if (params.childconditions !== undefined) {
				queryParameters['childconditions'] = params.childconditions;
			}

			if (params.customfieldconditions !== undefined) {
				queryParameters['customfieldconditions'] = params.customfieldconditions;
			}

			if (params.page !== undefined) {
				queryParameters['page'] = params.page;
			}

			if (params.pageSize !== undefined) {
				queryParameters['pageSize'] = params.pageSize;
			}

			let fetchParams = {
				method: 'GET',
				headers: headerParams,

			};

			if (extraFetchParams) {
				fetchParams = assign(fetchParams, extraFetchParams);
			}

			let localVarPathWithQueryParameters = localVarPath + (localVarPath.indexOf('?') !== -1 ? '&' : '?') + querystring.stringify(queryParameters);

			return fetch(localVarPathWithQueryParameters, fetchParams).then((response) => {
				if (response.status >= 200 && response.status < 300) {
					return response.json();
				} else {
					let error = new Error(response.statusText);
					(error as any).response = response;
					throw error;
				}
			});
		}
		/**
		 *
		 * Delete Schedule Status By Id
		 * @param id
		 */
		public scheduleStatusesIdDelete (params: {  id: number; }, extraQueryParams?: any, extraFetchParams?: any ) : Promise<{}> {
			const localVarPath = this.basePath + '/schedule/statuses/{id}'
				.replace('{' + 'id' + '}', String(params.id));

			let queryParameters: any = assign({}, extraQueryParams);
			let headerParams: any = assign({}, this.defaultHeaders);
			// verify required parameter 'id' is set
			if (params.id == null) {
				throw new Error('Missing required parameter id when calling scheduleStatusesIdDelete');
			}
			let fetchParams = {
				method: 'DELETE',
				headers: headerParams,

			};

			if (extraFetchParams) {
				fetchParams = assign(fetchParams, extraFetchParams);
			}

			let localVarPathWithQueryParameters = localVarPath + (localVarPath.indexOf('?') !== -1 ? '&' : '?') + querystring.stringify(queryParameters);

			return fetch(localVarPathWithQueryParameters, fetchParams).then((response) => {
				if (response.status >= 200 && response.status < 300) {
					return response.json();
				} else {
					let error = new Error(response.statusText);
					(error as any).response = response;
					throw error;
				}
			});
		}
		/**
		 *
		 * Get Schedule Status By Id
		 * @param id
		 */
		public scheduleStatusesIdGet (params: {  id: number; }, extraQueryParams?: any, extraFetchParams?: any ) : Promise<ScheduleStatus> {
			const localVarPath = this.basePath + '/schedule/statuses/{id}'
				.replace('{' + 'id' + '}', String(params.id));

			let queryParameters: any = assign({}, extraQueryParams);
			let headerParams: any = assign({}, this.defaultHeaders);
			// verify required parameter 'id' is set
			if (params.id == null) {
				throw new Error('Missing required parameter id when calling scheduleStatusesIdGet');
			}
			let fetchParams = {
				method: 'GET',
				headers: headerParams,

			};

			if (extraFetchParams) {
				fetchParams = assign(fetchParams, extraFetchParams);
			}

			let localVarPathWithQueryParameters = localVarPath + (localVarPath.indexOf('?') !== -1 ? '&' : '?') + querystring.stringify(queryParameters);

			return fetch(localVarPathWithQueryParameters, fetchParams).then((response) => {
				if (response.status >= 200 && response.status < 300) {
					return response.json();
				} else {
					let error = new Error(response.statusText);
					(error as any).response = response;
					throw error;
				}
			});
		}
		/**
		 *
		 * Update Schedule Status
		 * @param id
		 * @param operations
		 */
		public scheduleStatusesIdPatch (params: {  id: number; operations: Array<PatchOperation>; }, extraQueryParams?: any, extraFetchParams?: any ) : Promise<ScheduleStatus> {
			const localVarPath = this.basePath + '/schedule/statuses/{id}'
				.replace('{' + 'id' + '}', String(params.id));

			let queryParameters: any = assign({}, extraQueryParams);
			let headerParams: any = assign({}, this.defaultHeaders);
			headerParams['Content-Type'] = 'application/json';

			// verify required parameter 'id' is set
			if (params.id == null) {
				throw new Error('Missing required parameter id when calling scheduleStatusesIdPatch');
			}
			// verify required parameter 'operations' is set
			if (params.operations == null) {
				throw new Error('Missing required parameter operations when calling scheduleStatusesIdPatch');
			}
			let fetchParams = {
				method: 'PATCH',
				headers: headerParams,
				body: JSON.stringify(params.operations),

			};

			if (extraFetchParams) {
				fetchParams = assign(fetchParams, extraFetchParams);
			}

			let localVarPathWithQueryParameters = localVarPath + (localVarPath.indexOf('?') !== -1 ? '&' : '?') + querystring.stringify(queryParameters);

			return fetch(localVarPathWithQueryParameters, fetchParams).then((response) => {
				if (response.status >= 200 && response.status < 300) {
					return response.json();
				} else {
					let error = new Error(response.statusText);
					(error as any).response = response;
					throw error;
				}
			});
		}
		/**
		 *
		 * Replace Schedule Status
		 * @param id
		 * @param scheduleStatus
		 */
		public scheduleStatusesIdPut (params: {  id: number; scheduleStatus: ScheduleStatus; }, extraQueryParams?: any, extraFetchParams?: any ) : Promise<ScheduleStatus> {
			const localVarPath = this.basePath + '/schedule/statuses/{id}'
				.replace('{' + 'id' + '}', String(params.id));

			let queryParameters: any = assign({}, extraQueryParams);
			let headerParams: any = assign({}, this.defaultHeaders);
			headerParams['Content-Type'] = 'application/json';

			// verify required parameter 'id' is set
			if (params.id == null) {
				throw new Error('Missing required parameter id when calling scheduleStatusesIdPut');
			}
			// verify required parameter 'scheduleStatus' is set
			if (params.scheduleStatus == null) {
				throw new Error('Missing required parameter scheduleStatus when calling scheduleStatusesIdPut');
			}
			let fetchParams = {
				method: 'PUT',
				headers: headerParams,
				body: JSON.stringify(params.scheduleStatus),

			};

			if (extraFetchParams) {
				fetchParams = assign(fetchParams, extraFetchParams);
			}

			let localVarPathWithQueryParameters = localVarPath + (localVarPath.indexOf('?') !== -1 ? '&' : '?') + querystring.stringify(queryParameters);

			return fetch(localVarPathWithQueryParameters, fetchParams).then((response) => {
				if (response.status >= 200 && response.status < 300) {
					return response.json();
				} else {
					let error = new Error(response.statusText);
					(error as any).response = response;
					throw error;
				}
			});
		}
		/**
		 *
		 * Create Schedule Status
		 * @param scheduleStatus
		 */
		public scheduleStatusesPost (params: {  scheduleStatus: ScheduleStatus; }, extraQueryParams?: any, extraFetchParams?: any ) : Promise<ScheduleStatus> {
			const localVarPath = this.basePath + '/schedule/statuses';

			let queryParameters: any = assign({}, extraQueryParams);
			let headerParams: any = assign({}, this.defaultHeaders);
			headerParams['Content-Type'] = 'application/json';

			// verify required parameter 'scheduleStatus' is set
			if (params.scheduleStatus == null) {
				throw new Error('Missing required parameter scheduleStatus when calling scheduleStatusesPost');
			}
			let fetchParams = {
				method: 'POST',
				headers: headerParams,
				body: JSON.stringify(params.scheduleStatus),

			};

			if (extraFetchParams) {
				fetchParams = assign(fetchParams, extraFetchParams);
			}

			let localVarPathWithQueryParameters = localVarPath + (localVarPath.indexOf('?') !== -1 ? '&' : '?') + querystring.stringify(queryParameters);

			return fetch(localVarPathWithQueryParameters, fetchParams).then((response) => {
				if (response.status >= 200 && response.status < 300) {
					return response.json();
				} else {
					let error = new Error(response.statusText);
					(error as any).response = response;
					throw error;
				}
			});
		}
	}
//}
//export namespace  {
	'use strict';

	export class ScheduleStopwatchesApi {
		protected basePath = 'https://api-na.myconnectwise.net/v4_6_release/apis/3.0';
		public defaultHeaders : any = {};

		constructor(basePath?: string) {
			if (basePath) {
				this.basePath = basePath;
			}
		}

		/**
		 *
		 * Get Schedule Stopwatches Count
		 * @param conditions
		 */
		public timeSchedulestopwatchesCountGet (params: {  conditions?: string; }, extraQueryParams?: any, extraFetchParams?: any ) : Promise<Count> {
			const localVarPath = this.basePath + '/time/schedulestopwatches/count';

			let queryParameters: any = assign({}, extraQueryParams);
			let headerParams: any = assign({}, this.defaultHeaders);
			if (params.conditions !== undefined) {
				queryParameters['conditions'] = params.conditions;
			}

			let fetchParams = {
				method: 'GET',
				headers: headerParams,

			};

			if (extraFetchParams) {
				fetchParams = assign(fetchParams, extraFetchParams);
			}

			let localVarPathWithQueryParameters = localVarPath + (localVarPath.indexOf('?') !== -1 ? '&' : '?') + querystring.stringify(queryParameters);

			return fetch(localVarPathWithQueryParameters, fetchParams).then((response) => {
				if (response.status >= 200 && response.status < 300) {
					return response.json();
				} else {
					let error = new Error(response.statusText);
					(error as any).response = response;
					throw error;
				}
			});
		}
		/**
		 *
		 * Get Schedule Stopwatches
		 * @param conditions
		 * @param orderBy
		 * @param childconditions
		 * @param customfieldconditions
		 * @param page
		 * @param pageSize
		 */
		public timeSchedulestopwatchesGet (params: {  conditions?: string; orderBy?: string; childconditions?: string; customfieldconditions?: string; page?: number; pageSize?: number; }, extraQueryParams?: any, extraFetchParams?: any ) : Promise<Array<ScheduleStopwatch>> {
			const localVarPath = this.basePath + '/time/schedulestopwatches';

			let queryParameters: any = assign({}, extraQueryParams);
			let headerParams: any = assign({}, this.defaultHeaders);
			if (params.conditions !== undefined) {
				queryParameters['conditions'] = params.conditions;
			}

			if (params.orderBy !== undefined) {
				queryParameters['orderBy'] = params.orderBy;
			}

			if (params.childconditions !== undefined) {
				queryParameters['childconditions'] = params.childconditions;
			}

			if (params.customfieldconditions !== undefined) {
				queryParameters['customfieldconditions'] = params.customfieldconditions;
			}

			if (params.page !== undefined) {
				queryParameters['page'] = params.page;
			}

			if (params.pageSize !== undefined) {
				queryParameters['pageSize'] = params.pageSize;
			}

			let fetchParams = {
				method: 'GET',
				headers: headerParams,

			};

			if (extraFetchParams) {
				fetchParams = assign(fetchParams, extraFetchParams);
			}

			let localVarPathWithQueryParameters = localVarPath + (localVarPath.indexOf('?') !== -1 ? '&' : '?') + querystring.stringify(queryParameters);

			return fetch(localVarPathWithQueryParameters, fetchParams).then((response) => {
				if (response.status >= 200 && response.status < 300) {
					return response.json();
				} else {
					let error = new Error(response.statusText);
					(error as any).response = response;
					throw error;
				}
			});
		}
		/**
		 *
		 * Delete Schedule Stopwatch By Id
		 * @param id
		 */
		public timeSchedulestopwatchesIdDelete (params: {  id: number; }, extraQueryParams?: any, extraFetchParams?: any ) : Promise<{}> {
			const localVarPath = this.basePath + '/time/schedulestopwatches/{id}'
				.replace('{' + 'id' + '}', String(params.id));

			let queryParameters: any = assign({}, extraQueryParams);
			let headerParams: any = assign({}, this.defaultHeaders);
			// verify required parameter 'id' is set
			if (params.id == null) {
				throw new Error('Missing required parameter id when calling timeSchedulestopwatchesIdDelete');
			}
			let fetchParams = {
				method: 'DELETE',
				headers: headerParams,

			};

			if (extraFetchParams) {
				fetchParams = assign(fetchParams, extraFetchParams);
			}

			let localVarPathWithQueryParameters = localVarPath + (localVarPath.indexOf('?') !== -1 ? '&' : '?') + querystring.stringify(queryParameters);

			return fetch(localVarPathWithQueryParameters, fetchParams).then((response) => {
				if (response.status >= 200 && response.status < 300) {
					return response.json();
				} else {
					let error = new Error(response.statusText);
					(error as any).response = response;
					throw error;
				}
			});
		}
		/**
		 *
		 * Get Schedule Stopwatch By Id
		 * @param id
		 */
		public timeSchedulestopwatchesIdGet (params: {  id: number; }, extraQueryParams?: any, extraFetchParams?: any ) : Promise<ScheduleStopwatch> {
			const localVarPath = this.basePath + '/time/schedulestopwatches/{id}'
				.replace('{' + 'id' + '}', String(params.id));

			let queryParameters: any = assign({}, extraQueryParams);
			let headerParams: any = assign({}, this.defaultHeaders);
			// verify required parameter 'id' is set
			if (params.id == null) {
				throw new Error('Missing required parameter id when calling timeSchedulestopwatchesIdGet');
			}
			let fetchParams = {
				method: 'GET',
				headers: headerParams,

			};

			if (extraFetchParams) {
				fetchParams = assign(fetchParams, extraFetchParams);
			}

			let localVarPathWithQueryParameters = localVarPath + (localVarPath.indexOf('?') !== -1 ? '&' : '?') + querystring.stringify(queryParameters);

			return fetch(localVarPathWithQueryParameters, fetchParams).then((response) => {
				if (response.status >= 200 && response.status < 300) {
					return response.json();
				} else {
					let error = new Error(response.statusText);
					(error as any).response = response;
					throw error;
				}
			});
		}
		/**
		 *
		 * Update Schedule Stopwatch
		 * @param id
		 * @param operations
		 */
		public timeSchedulestopwatchesIdPatch (params: {  id: number; operations: Array<PatchOperation>; }, extraQueryParams?: any, extraFetchParams?: any ) : Promise<ScheduleStopwatch> {
			const localVarPath = this.basePath + '/time/schedulestopwatches/{id}'
				.replace('{' + 'id' + '}', String(params.id));

			let queryParameters: any = assign({}, extraQueryParams);
			let headerParams: any = assign({}, this.defaultHeaders);
			headerParams['Content-Type'] = 'application/json';

			// verify required parameter 'id' is set
			if (params.id == null) {
				throw new Error('Missing required parameter id when calling timeSchedulestopwatchesIdPatch');
			}
			// verify required parameter 'operations' is set
			if (params.operations == null) {
				throw new Error('Missing required parameter operations when calling timeSchedulestopwatchesIdPatch');
			}
			let fetchParams = {
				method: 'PATCH',
				headers: headerParams,
				body: JSON.stringify(params.operations),

			};

			if (extraFetchParams) {
				fetchParams = assign(fetchParams, extraFetchParams);
			}

			let localVarPathWithQueryParameters = localVarPath + (localVarPath.indexOf('?') !== -1 ? '&' : '?') + querystring.stringify(queryParameters);

			return fetch(localVarPathWithQueryParameters, fetchParams).then((response) => {
				if (response.status >= 200 && response.status < 300) {
					return response.json();
				} else {
					let error = new Error(response.statusText);
					(error as any).response = response;
					throw error;
				}
			});
		}
		/**
		 *
		 * Replace Schedule Stopwatch
		 * @param id
		 * @param scheduleStopwatch
		 */
		public timeSchedulestopwatchesIdPut (params: {  id: number; scheduleStopwatch: ScheduleStopwatch; }, extraQueryParams?: any, extraFetchParams?: any ) : Promise<ScheduleStopwatch> {
			const localVarPath = this.basePath + '/time/schedulestopwatches/{id}'
				.replace('{' + 'id' + '}', String(params.id));

			let queryParameters: any = assign({}, extraQueryParams);
			let headerParams: any = assign({}, this.defaultHeaders);
			headerParams['Content-Type'] = 'application/json';

			// verify required parameter 'id' is set
			if (params.id == null) {
				throw new Error('Missing required parameter id when calling timeSchedulestopwatchesIdPut');
			}
			// verify required parameter 'scheduleStopwatch' is set
			if (params.scheduleStopwatch == null) {
				throw new Error('Missing required parameter scheduleStopwatch when calling timeSchedulestopwatchesIdPut');
			}
			let fetchParams = {
				method: 'PUT',
				headers: headerParams,
				body: JSON.stringify(params.scheduleStopwatch),

			};

			if (extraFetchParams) {
				fetchParams = assign(fetchParams, extraFetchParams);
			}

			let localVarPathWithQueryParameters = localVarPath + (localVarPath.indexOf('?') !== -1 ? '&' : '?') + querystring.stringify(queryParameters);

			return fetch(localVarPathWithQueryParameters, fetchParams).then((response) => {
				if (response.status >= 200 && response.status < 300) {
					return response.json();
				} else {
					let error = new Error(response.statusText);
					(error as any).response = response;
					throw error;
				}
			});
		}
		/**
		 *
		 * Create Schedule Stopwatch
		 * @param scheduleStopwatch
		 */
		public timeSchedulestopwatchesPost (params: {  scheduleStopwatch: ScheduleStopwatch; }, extraQueryParams?: any, extraFetchParams?: any ) : Promise<ScheduleStopwatch> {
			const localVarPath = this.basePath + '/time/schedulestopwatches';

			let queryParameters: any = assign({}, extraQueryParams);
			let headerParams: any = assign({}, this.defaultHeaders);
			headerParams['Content-Type'] = 'application/json';

			// verify required parameter 'scheduleStopwatch' is set
			if (params.scheduleStopwatch == null) {
				throw new Error('Missing required parameter scheduleStopwatch when calling timeSchedulestopwatchesPost');
			}
			let fetchParams = {
				method: 'POST',
				headers: headerParams,
				body: JSON.stringify(params.scheduleStopwatch),

			};

			if (extraFetchParams) {
				fetchParams = assign(fetchParams, extraFetchParams);
			}

			let localVarPathWithQueryParameters = localVarPath + (localVarPath.indexOf('?') !== -1 ? '&' : '?') + querystring.stringify(queryParameters);

			return fetch(localVarPathWithQueryParameters, fetchParams).then((response) => {
				if (response.status >= 200 && response.status < 300) {
					return response.json();
				} else {
					let error = new Error(response.statusText);
					(error as any).response = response;
					throw error;
				}
			});
		}
	}
//}
//export namespace  {
	'use strict';

	export class ScheduleTypesApi {
		protected basePath = 'https://api-na.myconnectwise.net/v4_6_release/apis/3.0';
		public defaultHeaders : any = {};

		constructor(basePath?: string) {
			if (basePath) {
				this.basePath = basePath;
			}
		}

		/**
		 *
		 * Get Schedule Types Count
		 * @param conditions
		 */
		public scheduleTypesCountGet (params: {  conditions?: string; }, extraQueryParams?: any, extraFetchParams?: any ) : Promise<Count> {
			const localVarPath = this.basePath + '/schedule/types/count';

			let queryParameters: any = assign({}, extraQueryParams);
			let headerParams: any = assign({}, this.defaultHeaders);
			if (params.conditions !== undefined) {
				queryParameters['conditions'] = params.conditions;
			}

			let fetchParams = {
				method: 'GET',
				headers: headerParams,

			};

			if (extraFetchParams) {
				fetchParams = assign(fetchParams, extraFetchParams);
			}

			let localVarPathWithQueryParameters = localVarPath + (localVarPath.indexOf('?') !== -1 ? '&' : '?') + querystring.stringify(queryParameters);

			return fetch(localVarPathWithQueryParameters, fetchParams).then((response) => {
				if (response.status >= 200 && response.status < 300) {
					return response.json();
				} else {
					let error = new Error(response.statusText);
					(error as any).response = response;
					throw error;
				}
			});
		}
		/**
		 *
		 * Get Schedule Types
		 * @param conditions
		 * @param orderBy
		 * @param childconditions
		 * @param customfieldconditions
		 * @param page
		 * @param pageSize
		 */
		public scheduleTypesGet (params: {  conditions?: string; orderBy?: string; childconditions?: string; customfieldconditions?: string; page?: number; pageSize?: number; }, extraQueryParams?: any, extraFetchParams?: any ) : Promise<Array<ScheduleType>> {
			const localVarPath = this.basePath + '/schedule/types';

			let queryParameters: any = assign({}, extraQueryParams);
			let headerParams: any = assign({}, this.defaultHeaders);
			if (params.conditions !== undefined) {
				queryParameters['conditions'] = params.conditions;
			}

			if (params.orderBy !== undefined) {
				queryParameters['orderBy'] = params.orderBy;
			}

			if (params.childconditions !== undefined) {
				queryParameters['childconditions'] = params.childconditions;
			}

			if (params.customfieldconditions !== undefined) {
				queryParameters['customfieldconditions'] = params.customfieldconditions;
			}

			if (params.page !== undefined) {
				queryParameters['page'] = params.page;
			}

			if (params.pageSize !== undefined) {
				queryParameters['pageSize'] = params.pageSize;
			}

			let fetchParams = {
				method: 'GET',
				headers: headerParams,

			};

			if (extraFetchParams) {
				fetchParams = assign(fetchParams, extraFetchParams);
			}

			let localVarPathWithQueryParameters = localVarPath + (localVarPath.indexOf('?') !== -1 ? '&' : '?') + querystring.stringify(queryParameters);

			return fetch(localVarPathWithQueryParameters, fetchParams).then((response) => {
				if (response.status >= 200 && response.status < 300) {
					return response.json();
				} else {
					let error = new Error(response.statusText);
					(error as any).response = response;
					throw error;
				}
			});
		}
		/**
		 *
		 * Delete Schedule Type By Id
		 * @param id
		 */
		public scheduleTypesIdDelete (params: {  id: number; }, extraQueryParams?: any, extraFetchParams?: any ) : Promise<{}> {
			const localVarPath = this.basePath + '/schedule/types/{id}'
				.replace('{' + 'id' + '}', String(params.id));

			let queryParameters: any = assign({}, extraQueryParams);
			let headerParams: any = assign({}, this.defaultHeaders);
			// verify required parameter 'id' is set
			if (params.id == null) {
				throw new Error('Missing required parameter id when calling scheduleTypesIdDelete');
			}
			let fetchParams = {
				method: 'DELETE',
				headers: headerParams,

			};

			if (extraFetchParams) {
				fetchParams = assign(fetchParams, extraFetchParams);
			}

			let localVarPathWithQueryParameters = localVarPath + (localVarPath.indexOf('?') !== -1 ? '&' : '?') + querystring.stringify(queryParameters);

			return fetch(localVarPathWithQueryParameters, fetchParams).then((response) => {
				if (response.status >= 200 && response.status < 300) {
					return response.json();
				} else {
					let error = new Error(response.statusText);
					(error as any).response = response;
					throw error;
				}
			});
		}
		/**
		 *
		 * Get Schedule Type By Id
		 * @param id
		 */
		public scheduleTypesIdGet (params: {  id: number; }, extraQueryParams?: any, extraFetchParams?: any ) : Promise<ScheduleType> {
			const localVarPath = this.basePath + '/schedule/types/{id}'
				.replace('{' + 'id' + '}', String(params.id));

			let queryParameters: any = assign({}, extraQueryParams);
			let headerParams: any = assign({}, this.defaultHeaders);
			// verify required parameter 'id' is set
			if (params.id == null) {
				throw new Error('Missing required parameter id when calling scheduleTypesIdGet');
			}
			let fetchParams = {
				method: 'GET',
				headers: headerParams,

			};

			if (extraFetchParams) {
				fetchParams = assign(fetchParams, extraFetchParams);
			}

			let localVarPathWithQueryParameters = localVarPath + (localVarPath.indexOf('?') !== -1 ? '&' : '?') + querystring.stringify(queryParameters);

			return fetch(localVarPathWithQueryParameters, fetchParams).then((response) => {
				if (response.status >= 200 && response.status < 300) {
					return response.json();
				} else {
					let error = new Error(response.statusText);
					(error as any).response = response;
					throw error;
				}
			});
		}
		/**
		 *
		 * Update Schedule Type
		 * @param id
		 * @param operations
		 */
		public scheduleTypesIdPatch (params: {  id: number; operations: Array<PatchOperation>; }, extraQueryParams?: any, extraFetchParams?: any ) : Promise<ScheduleType> {
			const localVarPath = this.basePath + '/schedule/types/{id}'
				.replace('{' + 'id' + '}', String(params.id));

			let queryParameters: any = assign({}, extraQueryParams);
			let headerParams: any = assign({}, this.defaultHeaders);
			headerParams['Content-Type'] = 'application/json';

			// verify required parameter 'id' is set
			if (params.id == null) {
				throw new Error('Missing required parameter id when calling scheduleTypesIdPatch');
			}
			// verify required parameter 'operations' is set
			if (params.operations == null) {
				throw new Error('Missing required parameter operations when calling scheduleTypesIdPatch');
			}
			let fetchParams = {
				method: 'PATCH',
				headers: headerParams,
				body: JSON.stringify(params.operations),

			};

			if (extraFetchParams) {
				fetchParams = assign(fetchParams, extraFetchParams);
			}

			let localVarPathWithQueryParameters = localVarPath + (localVarPath.indexOf('?') !== -1 ? '&' : '?') + querystring.stringify(queryParameters);

			return fetch(localVarPathWithQueryParameters, fetchParams).then((response) => {
				if (response.status >= 200 && response.status < 300) {
					return response.json();
				} else {
					let error = new Error(response.statusText);
					(error as any).response = response;
					throw error;
				}
			});
		}
		/**
		 *
		 * Replace Schedule Type
		 * @param id
		 * @param scheduleType
		 */
		public scheduleTypesIdPut (params: {  id: number; scheduleType: ScheduleType; }, extraQueryParams?: any, extraFetchParams?: any ) : Promise<ScheduleType> {
			const localVarPath = this.basePath + '/schedule/types/{id}'
				.replace('{' + 'id' + '}', String(params.id));

			let queryParameters: any = assign({}, extraQueryParams);
			let headerParams: any = assign({}, this.defaultHeaders);
			headerParams['Content-Type'] = 'application/json';

			// verify required parameter 'id' is set
			if (params.id == null) {
				throw new Error('Missing required parameter id when calling scheduleTypesIdPut');
			}
			// verify required parameter 'scheduleType' is set
			if (params.scheduleType == null) {
				throw new Error('Missing required parameter scheduleType when calling scheduleTypesIdPut');
			}
			let fetchParams = {
				method: 'PUT',
				headers: headerParams,
				body: JSON.stringify(params.scheduleType),

			};

			if (extraFetchParams) {
				fetchParams = assign(fetchParams, extraFetchParams);
			}

			let localVarPathWithQueryParameters = localVarPath + (localVarPath.indexOf('?') !== -1 ? '&' : '?') + querystring.stringify(queryParameters);

			return fetch(localVarPathWithQueryParameters, fetchParams).then((response) => {
				if (response.status >= 200 && response.status < 300) {
					return response.json();
				} else {
					let error = new Error(response.statusText);
					(error as any).response = response;
					throw error;
				}
			});
		}
		/**
		 *
		 * Create Schedule Type
		 * @param scheduleType
		 */
		public scheduleTypesPost (params: {  scheduleType: ScheduleType; }, extraQueryParams?: any, extraFetchParams?: any ) : Promise<ScheduleType> {
			const localVarPath = this.basePath + '/schedule/types';

			let queryParameters: any = assign({}, extraQueryParams);
			let headerParams: any = assign({}, this.defaultHeaders);
			headerParams['Content-Type'] = 'application/json';

			// verify required parameter 'scheduleType' is set
			if (params.scheduleType == null) {
				throw new Error('Missing required parameter scheduleType when calling scheduleTypesPost');
			}
			let fetchParams = {
				method: 'POST',
				headers: headerParams,
				body: JSON.stringify(params.scheduleType),

			};

			if (extraFetchParams) {
				fetchParams = assign(fetchParams, extraFetchParams);
			}

			let localVarPathWithQueryParameters = localVarPath + (localVarPath.indexOf('?') !== -1 ? '&' : '?') + querystring.stringify(queryParameters);

			return fetch(localVarPathWithQueryParameters, fetchParams).then((response) => {
				if (response.status >= 200 && response.status < 300) {
					return response.json();
				} else {
					let error = new Error(response.statusText);
					(error as any).response = response;
					throw error;
				}
			});
		}
	}
//}
//export namespace  {
	'use strict';

	export class ShipmentMethodsApi {
		protected basePath = 'https://api-na.myconnectwise.net/v4_6_release/apis/3.0';
		public defaultHeaders : any = {};

		constructor(basePath?: string) {
			if (basePath) {
				this.basePath = basePath;
			}
		}

		/**
		 *
		 * Get Shipment Methods Count
		 * @param conditions
		 */
		public procurementShipmentmethodsCountGet (params: {  conditions?: string; }, extraQueryParams?: any, extraFetchParams?: any ) : Promise<Count> {
			const localVarPath = this.basePath + '/procurement/shipmentmethods/count';

			let queryParameters: any = assign({}, extraQueryParams);
			let headerParams: any = assign({}, this.defaultHeaders);
			if (params.conditions !== undefined) {
				queryParameters['conditions'] = params.conditions;
			}

			let fetchParams = {
				method: 'GET',
				headers: headerParams,

			};

			if (extraFetchParams) {
				fetchParams = assign(fetchParams, extraFetchParams);
			}

			let localVarPathWithQueryParameters = localVarPath + (localVarPath.indexOf('?') !== -1 ? '&' : '?') + querystring.stringify(queryParameters);

			return fetch(localVarPathWithQueryParameters, fetchParams).then((response) => {
				if (response.status >= 200 && response.status < 300) {
					return response.json();
				} else {
					let error = new Error(response.statusText);
					(error as any).response = response;
					throw error;
				}
			});
		}
		/**
		 *
		 * Get Shipment Methods
		 * @param conditions
		 * @param orderBy
		 * @param childconditions
		 * @param customfieldconditions
		 * @param page
		 * @param pageSize
		 */
		public procurementShipmentmethodsGet (params: {  conditions?: string; orderBy?: string; childconditions?: string; customfieldconditions?: string; page?: number; pageSize?: number; }, extraQueryParams?: any, extraFetchParams?: any ) : Promise<Array<ShipmentMethod>> {
			const localVarPath = this.basePath + '/procurement/shipmentmethods';

			let queryParameters: any = assign({}, extraQueryParams);
			let headerParams: any = assign({}, this.defaultHeaders);
			if (params.conditions !== undefined) {
				queryParameters['conditions'] = params.conditions;
			}

			if (params.orderBy !== undefined) {
				queryParameters['orderBy'] = params.orderBy;
			}

			if (params.childconditions !== undefined) {
				queryParameters['childconditions'] = params.childconditions;
			}

			if (params.customfieldconditions !== undefined) {
				queryParameters['customfieldconditions'] = params.customfieldconditions;
			}

			if (params.page !== undefined) {
				queryParameters['page'] = params.page;
			}

			if (params.pageSize !== undefined) {
				queryParameters['pageSize'] = params.pageSize;
			}

			let fetchParams = {
				method: 'GET',
				headers: headerParams,

			};

			if (extraFetchParams) {
				fetchParams = assign(fetchParams, extraFetchParams);
			}

			let localVarPathWithQueryParameters = localVarPath + (localVarPath.indexOf('?') !== -1 ? '&' : '?') + querystring.stringify(queryParameters);

			return fetch(localVarPathWithQueryParameters, fetchParams).then((response) => {
				if (response.status >= 200 && response.status < 300) {
					return response.json();
				} else {
					let error = new Error(response.statusText);
					(error as any).response = response;
					throw error;
				}
			});
		}
		/**
		 *
		 * Delete Shipment Method By Id
		 * @param id
		 */
		public procurementShipmentmethodsIdDelete (params: {  id: number; }, extraQueryParams?: any, extraFetchParams?: any ) : Promise<{}> {
			const localVarPath = this.basePath + '/procurement/shipmentmethods/{id}'
				.replace('{' + 'id' + '}', String(params.id));

			let queryParameters: any = assign({}, extraQueryParams);
			let headerParams: any = assign({}, this.defaultHeaders);
			// verify required parameter 'id' is set
			if (params.id == null) {
				throw new Error('Missing required parameter id when calling procurementShipmentmethodsIdDelete');
			}
			let fetchParams = {
				method: 'DELETE',
				headers: headerParams,

			};

			if (extraFetchParams) {
				fetchParams = assign(fetchParams, extraFetchParams);
			}

			let localVarPathWithQueryParameters = localVarPath + (localVarPath.indexOf('?') !== -1 ? '&' : '?') + querystring.stringify(queryParameters);

			return fetch(localVarPathWithQueryParameters, fetchParams).then((response) => {
				if (response.status >= 200 && response.status < 300) {
					return response.json();
				} else {
					let error = new Error(response.statusText);
					(error as any).response = response;
					throw error;
				}
			});
		}
		/**
		 *
		 * Get Shipment Method By Id
		 * @param id
		 */
		public procurementShipmentmethodsIdGet (params: {  id: number; }, extraQueryParams?: any, extraFetchParams?: any ) : Promise<ShipmentMethod> {
			const localVarPath = this.basePath + '/procurement/shipmentmethods/{id}'
				.replace('{' + 'id' + '}', String(params.id));

			let queryParameters: any = assign({}, extraQueryParams);
			let headerParams: any = assign({}, this.defaultHeaders);
			// verify required parameter 'id' is set
			if (params.id == null) {
				throw new Error('Missing required parameter id when calling procurementShipmentmethodsIdGet');
			}
			let fetchParams = {
				method: 'GET',
				headers: headerParams,

			};

			if (extraFetchParams) {
				fetchParams = assign(fetchParams, extraFetchParams);
			}

			let localVarPathWithQueryParameters = localVarPath + (localVarPath.indexOf('?') !== -1 ? '&' : '?') + querystring.stringify(queryParameters);

			return fetch(localVarPathWithQueryParameters, fetchParams).then((response) => {
				if (response.status >= 200 && response.status < 300) {
					return response.json();
				} else {
					let error = new Error(response.statusText);
					(error as any).response = response;
					throw error;
				}
			});
		}
		/**
		 *
		 * Update Shipment Method
		 * @param id
		 * @param operations
		 */
		public procurementShipmentmethodsIdPatch (params: {  id: number; operations: Array<PatchOperation>; }, extraQueryParams?: any, extraFetchParams?: any ) : Promise<ShipmentMethod> {
			const localVarPath = this.basePath + '/procurement/shipmentmethods/{id}'
				.replace('{' + 'id' + '}', String(params.id));

			let queryParameters: any = assign({}, extraQueryParams);
			let headerParams: any = assign({}, this.defaultHeaders);
			headerParams['Content-Type'] = 'application/json';

			// verify required parameter 'id' is set
			if (params.id == null) {
				throw new Error('Missing required parameter id when calling procurementShipmentmethodsIdPatch');
			}
			// verify required parameter 'operations' is set
			if (params.operations == null) {
				throw new Error('Missing required parameter operations when calling procurementShipmentmethodsIdPatch');
			}
			let fetchParams = {
				method: 'PATCH',
				headers: headerParams,
				body: JSON.stringify(params.operations),

			};

			if (extraFetchParams) {
				fetchParams = assign(fetchParams, extraFetchParams);
			}

			let localVarPathWithQueryParameters = localVarPath + (localVarPath.indexOf('?') !== -1 ? '&' : '?') + querystring.stringify(queryParameters);

			return fetch(localVarPathWithQueryParameters, fetchParams).then((response) => {
				if (response.status >= 200 && response.status < 300) {
					return response.json();
				} else {
					let error = new Error(response.statusText);
					(error as any).response = response;
					throw error;
				}
			});
		}
		/**
		 *
		 * Replace Shipment Method
		 * @param id
		 * @param shipmentMethod
		 */
		public procurementShipmentmethodsIdPut (params: {  id: number; shipmentMethod: ShipmentMethod; }, extraQueryParams?: any, extraFetchParams?: any ) : Promise<ShipmentMethod> {
			const localVarPath = this.basePath + '/procurement/shipmentmethods/{id}'
				.replace('{' + 'id' + '}', String(params.id));

			let queryParameters: any = assign({}, extraQueryParams);
			let headerParams: any = assign({}, this.defaultHeaders);
			headerParams['Content-Type'] = 'application/json';

			// verify required parameter 'id' is set
			if (params.id == null) {
				throw new Error('Missing required parameter id when calling procurementShipmentmethodsIdPut');
			}
			// verify required parameter 'shipmentMethod' is set
			if (params.shipmentMethod == null) {
				throw new Error('Missing required parameter shipmentMethod when calling procurementShipmentmethodsIdPut');
			}
			let fetchParams = {
				method: 'PUT',
				headers: headerParams,
				body: JSON.stringify(params.shipmentMethod),

			};

			if (extraFetchParams) {
				fetchParams = assign(fetchParams, extraFetchParams);
			}

			let localVarPathWithQueryParameters = localVarPath + (localVarPath.indexOf('?') !== -1 ? '&' : '?') + querystring.stringify(queryParameters);

			return fetch(localVarPathWithQueryParameters, fetchParams).then((response) => {
				if (response.status >= 200 && response.status < 300) {
					return response.json();
				} else {
					let error = new Error(response.statusText);
					(error as any).response = response;
					throw error;
				}
			});
		}
		/**
		 *
		 * Create Shipment Method
		 * @param shipmentMethod
		 */
		public procurementShipmentmethodsPost (params: {  shipmentMethod: ShipmentMethod; }, extraQueryParams?: any, extraFetchParams?: any ) : Promise<ShipmentMethod> {
			const localVarPath = this.basePath + '/procurement/shipmentmethods';

			let queryParameters: any = assign({}, extraQueryParams);
			let headerParams: any = assign({}, this.defaultHeaders);
			headerParams['Content-Type'] = 'application/json';

			// verify required parameter 'shipmentMethod' is set
			if (params.shipmentMethod == null) {
				throw new Error('Missing required parameter shipmentMethod when calling procurementShipmentmethodsPost');
			}
			let fetchParams = {
				method: 'POST',
				headers: headerParams,
				body: JSON.stringify(params.shipmentMethod),

			};

			if (extraFetchParams) {
				fetchParams = assign(fetchParams, extraFetchParams);
			}

			let localVarPathWithQueryParameters = localVarPath + (localVarPath.indexOf('?') !== -1 ? '&' : '?') + querystring.stringify(queryParameters);

			return fetch(localVarPathWithQueryParameters, fetchParams).then((response) => {
				if (response.status >= 200 && response.status < 300) {
					return response.json();
				} else {
					let error = new Error(response.statusText);
					(error as any).response = response;
					throw error;
				}
			});
		}
	}
//}
//export namespace  {
	'use strict';

	export class SkillCategoriesApi {
		protected basePath = 'https://api-na.myconnectwise.net/v4_6_release/apis/3.0';
		public defaultHeaders : any = {};

		constructor(basePath?: string) {
			if (basePath) {
				this.basePath = basePath;
			}
		}

		/**
		 *
		 * Get Skill Categories Count
		 * @param conditions
		 */
		public systemSkillCategoriesCountGet (params: {  conditions?: string; }, extraQueryParams?: any, extraFetchParams?: any ) : Promise<Count> {
			const localVarPath = this.basePath + '/system/skillCategories/count';

			let queryParameters: any = assign({}, extraQueryParams);
			let headerParams: any = assign({}, this.defaultHeaders);
			if (params.conditions !== undefined) {
				queryParameters['conditions'] = params.conditions;
			}

			let fetchParams = {
				method: 'GET',
				headers: headerParams,

			};

			if (extraFetchParams) {
				fetchParams = assign(fetchParams, extraFetchParams);
			}

			let localVarPathWithQueryParameters = localVarPath + (localVarPath.indexOf('?') !== -1 ? '&' : '?') + querystring.stringify(queryParameters);

			return fetch(localVarPathWithQueryParameters, fetchParams).then((response) => {
				if (response.status >= 200 && response.status < 300) {
					return response.json();
				} else {
					let error = new Error(response.statusText);
					(error as any).response = response;
					throw error;
				}
			});
		}
		/**
		 *
		 * Get Skill Categories
		 * @param conditions
		 * @param orderBy
		 * @param childconditions
		 * @param customfieldconditions
		 * @param page
		 * @param pageSize
		 */
		public systemSkillCategoriesGet (params: {  conditions?: string; orderBy?: string; childconditions?: string; customfieldconditions?: string; page?: number; pageSize?: number; }, extraQueryParams?: any, extraFetchParams?: any ) : Promise<Array<SkillCategory>> {
			const localVarPath = this.basePath + '/system/skillCategories';

			let queryParameters: any = assign({}, extraQueryParams);
			let headerParams: any = assign({}, this.defaultHeaders);
			if (params.conditions !== undefined) {
				queryParameters['conditions'] = params.conditions;
			}

			if (params.orderBy !== undefined) {
				queryParameters['orderBy'] = params.orderBy;
			}

			if (params.childconditions !== undefined) {
				queryParameters['childconditions'] = params.childconditions;
			}

			if (params.customfieldconditions !== undefined) {
				queryParameters['customfieldconditions'] = params.customfieldconditions;
			}

			if (params.page !== undefined) {
				queryParameters['page'] = params.page;
			}

			if (params.pageSize !== undefined) {
				queryParameters['pageSize'] = params.pageSize;
			}

			let fetchParams = {
				method: 'GET',
				headers: headerParams,

			};

			if (extraFetchParams) {
				fetchParams = assign(fetchParams, extraFetchParams);
			}

			let localVarPathWithQueryParameters = localVarPath + (localVarPath.indexOf('?') !== -1 ? '&' : '?') + querystring.stringify(queryParameters);

			return fetch(localVarPathWithQueryParameters, fetchParams).then((response) => {
				if (response.status >= 200 && response.status < 300) {
					return response.json();
				} else {
					let error = new Error(response.statusText);
					(error as any).response = response;
					throw error;
				}
			});
		}
		/**
		 *
		 * Delete Skill Category By Id
		 * @param id
		 */
		public systemSkillCategoriesIdDelete (params: {  id: number; }, extraQueryParams?: any, extraFetchParams?: any ) : Promise<{}> {
			const localVarPath = this.basePath + '/system/skillCategories/{id}'
				.replace('{' + 'id' + '}', String(params.id));

			let queryParameters: any = assign({}, extraQueryParams);
			let headerParams: any = assign({}, this.defaultHeaders);
			// verify required parameter 'id' is set
			if (params.id == null) {
				throw new Error('Missing required parameter id when calling systemSkillCategoriesIdDelete');
			}
			let fetchParams = {
				method: 'DELETE',
				headers: headerParams,

			};

			if (extraFetchParams) {
				fetchParams = assign(fetchParams, extraFetchParams);
			}

			let localVarPathWithQueryParameters = localVarPath + (localVarPath.indexOf('?') !== -1 ? '&' : '?') + querystring.stringify(queryParameters);

			return fetch(localVarPathWithQueryParameters, fetchParams).then((response) => {
				if (response.status >= 200 && response.status < 300) {
					return response.json();
				} else {
					let error = new Error(response.statusText);
					(error as any).response = response;
					throw error;
				}
			});
		}
		/**
		 *
		 * Get Skill Category By Id
		 * @param id
		 */
		public systemSkillCategoriesIdGet (params: {  id: number; }, extraQueryParams?: any, extraFetchParams?: any ) : Promise<SkillCategory> {
			const localVarPath = this.basePath + '/system/skillCategories/{id}'
				.replace('{' + 'id' + '}', String(params.id));

			let queryParameters: any = assign({}, extraQueryParams);
			let headerParams: any = assign({}, this.defaultHeaders);
			// verify required parameter 'id' is set
			if (params.id == null) {
				throw new Error('Missing required parameter id when calling systemSkillCategoriesIdGet');
			}
			let fetchParams = {
				method: 'GET',
				headers: headerParams,

			};

			if (extraFetchParams) {
				fetchParams = assign(fetchParams, extraFetchParams);
			}

			let localVarPathWithQueryParameters = localVarPath + (localVarPath.indexOf('?') !== -1 ? '&' : '?') + querystring.stringify(queryParameters);

			return fetch(localVarPathWithQueryParameters, fetchParams).then((response) => {
				if (response.status >= 200 && response.status < 300) {
					return response.json();
				} else {
					let error = new Error(response.statusText);
					(error as any).response = response;
					throw error;
				}
			});
		}
		/**
		 *
		 * Update Skill Category
		 * @param id
		 * @param operations
		 */
		public systemSkillCategoriesIdPatch (params: {  id: number; operations: Array<PatchOperation>; }, extraQueryParams?: any, extraFetchParams?: any ) : Promise<SkillCategory> {
			const localVarPath = this.basePath + '/system/skillCategories/{id}'
				.replace('{' + 'id' + '}', String(params.id));

			let queryParameters: any = assign({}, extraQueryParams);
			let headerParams: any = assign({}, this.defaultHeaders);
			headerParams['Content-Type'] = 'application/json';

			// verify required parameter 'id' is set
			if (params.id == null) {
				throw new Error('Missing required parameter id when calling systemSkillCategoriesIdPatch');
			}
			// verify required parameter 'operations' is set
			if (params.operations == null) {
				throw new Error('Missing required parameter operations when calling systemSkillCategoriesIdPatch');
			}
			let fetchParams = {
				method: 'PATCH',
				headers: headerParams,
				body: JSON.stringify(params.operations),

			};

			if (extraFetchParams) {
				fetchParams = assign(fetchParams, extraFetchParams);
			}

			let localVarPathWithQueryParameters = localVarPath + (localVarPath.indexOf('?') !== -1 ? '&' : '?') + querystring.stringify(queryParameters);

			return fetch(localVarPathWithQueryParameters, fetchParams).then((response) => {
				if (response.status >= 200 && response.status < 300) {
					return response.json();
				} else {
					let error = new Error(response.statusText);
					(error as any).response = response;
					throw error;
				}
			});
		}
		/**
		 *
		 * Replace Skill Category
		 * @param id
		 * @param skillCategory
		 */
		public systemSkillCategoriesIdPut (params: {  id: number; skillCategory: SkillCategory; }, extraQueryParams?: any, extraFetchParams?: any ) : Promise<SkillCategory> {
			const localVarPath = this.basePath + '/system/skillCategories/{id}'
				.replace('{' + 'id' + '}', String(params.id));

			let queryParameters: any = assign({}, extraQueryParams);
			let headerParams: any = assign({}, this.defaultHeaders);
			headerParams['Content-Type'] = 'application/json';

			// verify required parameter 'id' is set
			if (params.id == null) {
				throw new Error('Missing required parameter id when calling systemSkillCategoriesIdPut');
			}
			// verify required parameter 'skillCategory' is set
			if (params.skillCategory == null) {
				throw new Error('Missing required parameter skillCategory when calling systemSkillCategoriesIdPut');
			}
			let fetchParams = {
				method: 'PUT',
				headers: headerParams,
				body: JSON.stringify(params.skillCategory),

			};

			if (extraFetchParams) {
				fetchParams = assign(fetchParams, extraFetchParams);
			}

			let localVarPathWithQueryParameters = localVarPath + (localVarPath.indexOf('?') !== -1 ? '&' : '?') + querystring.stringify(queryParameters);

			return fetch(localVarPathWithQueryParameters, fetchParams).then((response) => {
				if (response.status >= 200 && response.status < 300) {
					return response.json();
				} else {
					let error = new Error(response.statusText);
					(error as any).response = response;
					throw error;
				}
			});
		}
		/**
		 *
		 * Create Skill Category
		 * @param skillCategory
		 */
		public systemSkillCategoriesPost (params: {  skillCategory: SkillCategory; }, extraQueryParams?: any, extraFetchParams?: any ) : Promise<SkillCategory> {
			const localVarPath = this.basePath + '/system/skillCategories';

			let queryParameters: any = assign({}, extraQueryParams);
			let headerParams: any = assign({}, this.defaultHeaders);
			headerParams['Content-Type'] = 'application/json';

			// verify required parameter 'skillCategory' is set
			if (params.skillCategory == null) {
				throw new Error('Missing required parameter skillCategory when calling systemSkillCategoriesPost');
			}
			let fetchParams = {
				method: 'POST',
				headers: headerParams,
				body: JSON.stringify(params.skillCategory),

			};

			if (extraFetchParams) {
				fetchParams = assign(fetchParams, extraFetchParams);
			}

			let localVarPathWithQueryParameters = localVarPath + (localVarPath.indexOf('?') !== -1 ? '&' : '?') + querystring.stringify(queryParameters);

			return fetch(localVarPathWithQueryParameters, fetchParams).then((response) => {
				if (response.status >= 200 && response.status < 300) {
					return response.json();
				} else {
					let error = new Error(response.statusText);
					(error as any).response = response;
					throw error;
				}
			});
		}
	}
//}
//export namespace  {
	'use strict';

	export class SkillsApi {
		protected basePath = 'https://api-na.myconnectwise.net/v4_6_release/apis/3.0';
		public defaultHeaders : any = {};

		constructor(basePath?: string) {
			if (basePath) {
				this.basePath = basePath;
			}
		}

		/**
		 *
		 * Get Skill Count
		 * @param conditions
		 */
		public systemSkillsCountGet (params: {  conditions?: string; }, extraQueryParams?: any, extraFetchParams?: any ) : Promise<Count> {
			const localVarPath = this.basePath + '/system/skills/count';

			let queryParameters: any = assign({}, extraQueryParams);
			let headerParams: any = assign({}, this.defaultHeaders);
			if (params.conditions !== undefined) {
				queryParameters['conditions'] = params.conditions;
			}

			let fetchParams = {
				method: 'GET',
				headers: headerParams,

			};

			if (extraFetchParams) {
				fetchParams = assign(fetchParams, extraFetchParams);
			}

			let localVarPathWithQueryParameters = localVarPath + (localVarPath.indexOf('?') !== -1 ? '&' : '?') + querystring.stringify(queryParameters);

			return fetch(localVarPathWithQueryParameters, fetchParams).then((response) => {
				if (response.status >= 200 && response.status < 300) {
					return response.json();
				} else {
					let error = new Error(response.statusText);
					(error as any).response = response;
					throw error;
				}
			});
		}
		/**
		 *
		 * Get Skill
		 * @param conditions
		 * @param orderBy
		 * @param childconditions
		 * @param customfieldconditions
		 * @param page
		 * @param pageSize
		 */
		public systemSkillsGet (params: {  conditions?: string; orderBy?: string; childconditions?: string; customfieldconditions?: string; page?: number; pageSize?: number; }, extraQueryParams?: any, extraFetchParams?: any ) : Promise<Array<Skill>> {
			const localVarPath = this.basePath + '/system/skills';

			let queryParameters: any = assign({}, extraQueryParams);
			let headerParams: any = assign({}, this.defaultHeaders);
			if (params.conditions !== undefined) {
				queryParameters['conditions'] = params.conditions;
			}

			if (params.orderBy !== undefined) {
				queryParameters['orderBy'] = params.orderBy;
			}

			if (params.childconditions !== undefined) {
				queryParameters['childconditions'] = params.childconditions;
			}

			if (params.customfieldconditions !== undefined) {
				queryParameters['customfieldconditions'] = params.customfieldconditions;
			}

			if (params.page !== undefined) {
				queryParameters['page'] = params.page;
			}

			if (params.pageSize !== undefined) {
				queryParameters['pageSize'] = params.pageSize;
			}

			let fetchParams = {
				method: 'GET',
				headers: headerParams,

			};

			if (extraFetchParams) {
				fetchParams = assign(fetchParams, extraFetchParams);
			}

			let localVarPathWithQueryParameters = localVarPath + (localVarPath.indexOf('?') !== -1 ? '&' : '?') + querystring.stringify(queryParameters);

			return fetch(localVarPathWithQueryParameters, fetchParams).then((response) => {
				if (response.status >= 200 && response.status < 300) {
					return response.json();
				} else {
					let error = new Error(response.statusText);
					(error as any).response = response;
					throw error;
				}
			});
		}
		/**
		 *
		 * Delete Skill By Id
		 * @param id
		 */
		public systemSkillsIdDelete (params: {  id: number; }, extraQueryParams?: any, extraFetchParams?: any ) : Promise<{}> {
			const localVarPath = this.basePath + '/system/skills/{id}'
				.replace('{' + 'id' + '}', String(params.id));

			let queryParameters: any = assign({}, extraQueryParams);
			let headerParams: any = assign({}, this.defaultHeaders);
			// verify required parameter 'id' is set
			if (params.id == null) {
				throw new Error('Missing required parameter id when calling systemSkillsIdDelete');
			}
			let fetchParams = {
				method: 'DELETE',
				headers: headerParams,

			};

			if (extraFetchParams) {
				fetchParams = assign(fetchParams, extraFetchParams);
			}

			let localVarPathWithQueryParameters = localVarPath + (localVarPath.indexOf('?') !== -1 ? '&' : '?') + querystring.stringify(queryParameters);

			return fetch(localVarPathWithQueryParameters, fetchParams).then((response) => {
				if (response.status >= 200 && response.status < 300) {
					return response.json();
				} else {
					let error = new Error(response.statusText);
					(error as any).response = response;
					throw error;
				}
			});
		}
		/**
		 *
		 * Get Skill By Id
		 * @param id
		 */
		public systemSkillsIdGet (params: {  id: number; }, extraQueryParams?: any, extraFetchParams?: any ) : Promise<Skill> {
			const localVarPath = this.basePath + '/system/skills/{id}'
				.replace('{' + 'id' + '}', String(params.id));

			let queryParameters: any = assign({}, extraQueryParams);
			let headerParams: any = assign({}, this.defaultHeaders);
			// verify required parameter 'id' is set
			if (params.id == null) {
				throw new Error('Missing required parameter id when calling systemSkillsIdGet');
			}
			let fetchParams = {
				method: 'GET',
				headers: headerParams,

			};

			if (extraFetchParams) {
				fetchParams = assign(fetchParams, extraFetchParams);
			}

			let localVarPathWithQueryParameters = localVarPath + (localVarPath.indexOf('?') !== -1 ? '&' : '?') + querystring.stringify(queryParameters);

			return fetch(localVarPathWithQueryParameters, fetchParams).then((response) => {
				if (response.status >= 200 && response.status < 300) {
					return response.json();
				} else {
					let error = new Error(response.statusText);
					(error as any).response = response;
					throw error;
				}
			});
		}
		/**
		 *
		 * Update Skill
		 * @param id
		 * @param operations
		 */
		public systemSkillsIdPatch (params: {  id: number; operations: Array<PatchOperation>; }, extraQueryParams?: any, extraFetchParams?: any ) : Promise<Skill> {
			const localVarPath = this.basePath + '/system/skills/{id}'
				.replace('{' + 'id' + '}', String(params.id));

			let queryParameters: any = assign({}, extraQueryParams);
			let headerParams: any = assign({}, this.defaultHeaders);
			headerParams['Content-Type'] = 'application/json';

			// verify required parameter 'id' is set
			if (params.id == null) {
				throw new Error('Missing required parameter id when calling systemSkillsIdPatch');
			}
			// verify required parameter 'operations' is set
			if (params.operations == null) {
				throw new Error('Missing required parameter operations when calling systemSkillsIdPatch');
			}
			let fetchParams = {
				method: 'PATCH',
				headers: headerParams,
				body: JSON.stringify(params.operations),

			};

			if (extraFetchParams) {
				fetchParams = assign(fetchParams, extraFetchParams);
			}

			let localVarPathWithQueryParameters = localVarPath + (localVarPath.indexOf('?') !== -1 ? '&' : '?') + querystring.stringify(queryParameters);

			return fetch(localVarPathWithQueryParameters, fetchParams).then((response) => {
				if (response.status >= 200 && response.status < 300) {
					return response.json();
				} else {
					let error = new Error(response.statusText);
					(error as any).response = response;
					throw error;
				}
			});
		}
		/**
		 *
		 * Replace Skill
		 * @param id
		 * @param skill
		 */
		public systemSkillsIdPut (params: {  id: number; skill: Skill; }, extraQueryParams?: any, extraFetchParams?: any ) : Promise<Skill> {
			const localVarPath = this.basePath + '/system/skills/{id}'
				.replace('{' + 'id' + '}', String(params.id));

			let queryParameters: any = assign({}, extraQueryParams);
			let headerParams: any = assign({}, this.defaultHeaders);
			headerParams['Content-Type'] = 'application/json';

			// verify required parameter 'id' is set
			if (params.id == null) {
				throw new Error('Missing required parameter id when calling systemSkillsIdPut');
			}
			// verify required parameter 'skill' is set
			if (params.skill == null) {
				throw new Error('Missing required parameter skill when calling systemSkillsIdPut');
			}
			let fetchParams = {
				method: 'PUT',
				headers: headerParams,
				body: JSON.stringify(params.skill),

			};

			if (extraFetchParams) {
				fetchParams = assign(fetchParams, extraFetchParams);
			}

			let localVarPathWithQueryParameters = localVarPath + (localVarPath.indexOf('?') !== -1 ? '&' : '?') + querystring.stringify(queryParameters);

			return fetch(localVarPathWithQueryParameters, fetchParams).then((response) => {
				if (response.status >= 200 && response.status < 300) {
					return response.json();
				} else {
					let error = new Error(response.statusText);
					(error as any).response = response;
					throw error;
				}
			});
		}
		/**
		 *
		 * Create Skill
		 * @param skill
		 */
		public systemSkillsPost (params: {  skill: Skill; }, extraQueryParams?: any, extraFetchParams?: any ) : Promise<Skill> {
			const localVarPath = this.basePath + '/system/skills';

			let queryParameters: any = assign({}, extraQueryParams);
			let headerParams: any = assign({}, this.defaultHeaders);
			headerParams['Content-Type'] = 'application/json';

			// verify required parameter 'skill' is set
			if (params.skill == null) {
				throw new Error('Missing required parameter skill when calling systemSkillsPost');
			}
			let fetchParams = {
				method: 'POST',
				headers: headerParams,
				body: JSON.stringify(params.skill),

			};

			if (extraFetchParams) {
				fetchParams = assign(fetchParams, extraFetchParams);
			}

			let localVarPathWithQueryParameters = localVarPath + (localVarPath.indexOf('?') !== -1 ? '&' : '?') + querystring.stringify(queryParameters);

			return fetch(localVarPathWithQueryParameters, fetchParams).then((response) => {
				if (response.status >= 200 && response.status < 300) {
					return response.json();
				} else {
					let error = new Error(response.statusText);
					(error as any).response = response;
					throw error;
				}
			});
		}
	}
//}
//export namespace  {
	'use strict';

	export class SourcesApi {
		protected basePath = 'https://api-na.myconnectwise.net/v4_6_release/apis/3.0';
		public defaultHeaders : any = {};

		constructor(basePath?: string) {
			if (basePath) {
				this.basePath = basePath;
			}
		}

		/**
		 *
		 * Create Sources Count
		 * @param conditions
		 */
		public serviceSourcesCountGet (params: {  conditions?: string; }, extraQueryParams?: any, extraFetchParams?: any ) : Promise<Count> {
			const localVarPath = this.basePath + '/service/sources/count';

			let queryParameters: any = assign({}, extraQueryParams);
			let headerParams: any = assign({}, this.defaultHeaders);
			if (params.conditions !== undefined) {
				queryParameters['conditions'] = params.conditions;
			}

			let fetchParams = {
				method: 'GET',
				headers: headerParams,

			};

			if (extraFetchParams) {
				fetchParams = assign(fetchParams, extraFetchParams);
			}

			let localVarPathWithQueryParameters = localVarPath + (localVarPath.indexOf('?') !== -1 ? '&' : '?') + querystring.stringify(queryParameters);

			return fetch(localVarPathWithQueryParameters, fetchParams).then((response) => {
				if (response.status >= 200 && response.status < 300) {
					return response.json();
				} else {
					let error = new Error(response.statusText);
					(error as any).response = response;
					throw error;
				}
			});
		}
		/**
		 *
		 * Get Sources
		 * @param conditions
		 * @param orderBy
		 * @param childconditions
		 * @param customfieldconditions
		 * @param page
		 * @param pageSize
		 */
		public serviceSourcesGet (params: {  conditions?: string; orderBy?: string; childconditions?: string; customfieldconditions?: string; page?: number; pageSize?: number; }, extraQueryParams?: any, extraFetchParams?: any ) : Promise<Array<Source>> {
			const localVarPath = this.basePath + '/service/sources';

			let queryParameters: any = assign({}, extraQueryParams);
			let headerParams: any = assign({}, this.defaultHeaders);
			if (params.conditions !== undefined) {
				queryParameters['conditions'] = params.conditions;
			}

			if (params.orderBy !== undefined) {
				queryParameters['orderBy'] = params.orderBy;
			}

			if (params.childconditions !== undefined) {
				queryParameters['childconditions'] = params.childconditions;
			}

			if (params.customfieldconditions !== undefined) {
				queryParameters['customfieldconditions'] = params.customfieldconditions;
			}

			if (params.page !== undefined) {
				queryParameters['page'] = params.page;
			}

			if (params.pageSize !== undefined) {
				queryParameters['pageSize'] = params.pageSize;
			}

			let fetchParams = {
				method: 'GET',
				headers: headerParams,

			};

			if (extraFetchParams) {
				fetchParams = assign(fetchParams, extraFetchParams);
			}

			let localVarPathWithQueryParameters = localVarPath + (localVarPath.indexOf('?') !== -1 ? '&' : '?') + querystring.stringify(queryParameters);

			return fetch(localVarPathWithQueryParameters, fetchParams).then((response) => {
				if (response.status >= 200 && response.status < 300) {
					return response.json();
				} else {
					let error = new Error(response.statusText);
					(error as any).response = response;
					throw error;
				}
			});
		}
		/**
		 *
		 * Delete Source By Id
		 * @param id
		 */
		public serviceSourcesIdDelete (params: {  id: number; }, extraQueryParams?: any, extraFetchParams?: any ) : Promise<{}> {
			const localVarPath = this.basePath + '/service/sources/{id}'
				.replace('{' + 'id' + '}', String(params.id));

			let queryParameters: any = assign({}, extraQueryParams);
			let headerParams: any = assign({}, this.defaultHeaders);
			// verify required parameter 'id' is set
			if (params.id == null) {
				throw new Error('Missing required parameter id when calling serviceSourcesIdDelete');
			}
			let fetchParams = {
				method: 'DELETE',
				headers: headerParams,

			};

			if (extraFetchParams) {
				fetchParams = assign(fetchParams, extraFetchParams);
			}

			let localVarPathWithQueryParameters = localVarPath + (localVarPath.indexOf('?') !== -1 ? '&' : '?') + querystring.stringify(queryParameters);

			return fetch(localVarPathWithQueryParameters, fetchParams).then((response) => {
				if (response.status >= 200 && response.status < 300) {
					return response.json();
				} else {
					let error = new Error(response.statusText);
					(error as any).response = response;
					throw error;
				}
			});
		}
		/**
		 *
		 * Get Source By Id
		 * @param id
		 */
		public serviceSourcesIdGet (params: {  id: number; }, extraQueryParams?: any, extraFetchParams?: any ) : Promise<Source> {
			const localVarPath = this.basePath + '/service/sources/{id}'
				.replace('{' + 'id' + '}', String(params.id));

			let queryParameters: any = assign({}, extraQueryParams);
			let headerParams: any = assign({}, this.defaultHeaders);
			// verify required parameter 'id' is set
			if (params.id == null) {
				throw new Error('Missing required parameter id when calling serviceSourcesIdGet');
			}
			let fetchParams = {
				method: 'GET',
				headers: headerParams,

			};

			if (extraFetchParams) {
				fetchParams = assign(fetchParams, extraFetchParams);
			}

			let localVarPathWithQueryParameters = localVarPath + (localVarPath.indexOf('?') !== -1 ? '&' : '?') + querystring.stringify(queryParameters);

			return fetch(localVarPathWithQueryParameters, fetchParams).then((response) => {
				if (response.status >= 200 && response.status < 300) {
					return response.json();
				} else {
					let error = new Error(response.statusText);
					(error as any).response = response;
					throw error;
				}
			});
		}
		/**
		 *
		 * Update Source
		 * @param id
		 * @param operations
		 */
		public serviceSourcesIdPatch (params: {  id: number; operations: Array<PatchOperation>; }, extraQueryParams?: any, extraFetchParams?: any ) : Promise<Source> {
			const localVarPath = this.basePath + '/service/sources/{id}'
				.replace('{' + 'id' + '}', String(params.id));

			let queryParameters: any = assign({}, extraQueryParams);
			let headerParams: any = assign({}, this.defaultHeaders);
			headerParams['Content-Type'] = 'application/json';

			// verify required parameter 'id' is set
			if (params.id == null) {
				throw new Error('Missing required parameter id when calling serviceSourcesIdPatch');
			}
			// verify required parameter 'operations' is set
			if (params.operations == null) {
				throw new Error('Missing required parameter operations when calling serviceSourcesIdPatch');
			}
			let fetchParams = {
				method: 'PATCH',
				headers: headerParams,
				body: JSON.stringify(params.operations),

			};

			if (extraFetchParams) {
				fetchParams = assign(fetchParams, extraFetchParams);
			}

			let localVarPathWithQueryParameters = localVarPath + (localVarPath.indexOf('?') !== -1 ? '&' : '?') + querystring.stringify(queryParameters);

			return fetch(localVarPathWithQueryParameters, fetchParams).then((response) => {
				if (response.status >= 200 && response.status < 300) {
					return response.json();
				} else {
					let error = new Error(response.statusText);
					(error as any).response = response;
					throw error;
				}
			});
		}
		/**
		 *
		 * Replace Source
		 * @param id
		 * @param source
		 */
		public serviceSourcesIdPut (params: {  id: number; source: Source; }, extraQueryParams?: any, extraFetchParams?: any ) : Promise<Source> {
			const localVarPath = this.basePath + '/service/sources/{id}'
				.replace('{' + 'id' + '}', String(params.id));

			let queryParameters: any = assign({}, extraQueryParams);
			let headerParams: any = assign({}, this.defaultHeaders);
			headerParams['Content-Type'] = 'application/json';

			// verify required parameter 'id' is set
			if (params.id == null) {
				throw new Error('Missing required parameter id when calling serviceSourcesIdPut');
			}
			// verify required parameter 'source' is set
			if (params.source == null) {
				throw new Error('Missing required parameter source when calling serviceSourcesIdPut');
			}
			let fetchParams = {
				method: 'PUT',
				headers: headerParams,
				body: JSON.stringify(params.source),

			};

			if (extraFetchParams) {
				fetchParams = assign(fetchParams, extraFetchParams);
			}

			let localVarPathWithQueryParameters = localVarPath + (localVarPath.indexOf('?') !== -1 ? '&' : '?') + querystring.stringify(queryParameters);

			return fetch(localVarPathWithQueryParameters, fetchParams).then((response) => {
				if (response.status >= 200 && response.status < 300) {
					return response.json();
				} else {
					let error = new Error(response.statusText);
					(error as any).response = response;
					throw error;
				}
			});
		}
		/**
		 *
		 * Create Source
		 * @param source
		 */
		public serviceSourcesPost (params: {  source: Source; }, extraQueryParams?: any, extraFetchParams?: any ) : Promise<Source> {
			const localVarPath = this.basePath + '/service/sources';

			let queryParameters: any = assign({}, extraQueryParams);
			let headerParams: any = assign({}, this.defaultHeaders);
			headerParams['Content-Type'] = 'application/json';

			// verify required parameter 'source' is set
			if (params.source == null) {
				throw new Error('Missing required parameter source when calling serviceSourcesPost');
			}
			let fetchParams = {
				method: 'POST',
				headers: headerParams,
				body: JSON.stringify(params.source),

			};

			if (extraFetchParams) {
				fetchParams = assign(fetchParams, extraFetchParams);
			}

			let localVarPathWithQueryParameters = localVarPath + (localVarPath.indexOf('?') !== -1 ? '&' : '?') + querystring.stringify(queryParameters);

			return fetch(localVarPathWithQueryParameters, fetchParams).then((response) => {
				if (response.status >= 200 && response.status < 300) {
					return response.json();
				} else {
					let error = new Error(response.statusText);
					(error as any).response = response;
					throw error;
				}
			});
		}
	}
//}
//export namespace  {
	'use strict';

	export class SubCategoriesApi {
		protected basePath = 'https://api-na.myconnectwise.net/v4_6_release/apis/3.0';
		public defaultHeaders : any = {};

		constructor(basePath?: string) {
			if (basePath) {
				this.basePath = basePath;
			}
		}

		/**
		 *
		 * Get Sub Categories Count
		 * @param id
		 * @param conditions
		 */
		public procurementCategoriesIdSubcategoriesCountGet (params: {  id: number; conditions?: string; }, extraQueryParams?: any, extraFetchParams?: any ) : Promise<Count> {
			const localVarPath = this.basePath + '/procurement/categories/{id}/subcategories/count'
				.replace('{' + 'id' + '}', String(params.id));

			let queryParameters: any = assign({}, extraQueryParams);
			let headerParams: any = assign({}, this.defaultHeaders);
			// verify required parameter 'id' is set
			if (params.id == null) {
				throw new Error('Missing required parameter id when calling procurementCategoriesIdSubcategoriesCountGet');
			}
			if (params.conditions !== undefined) {
				queryParameters['conditions'] = params.conditions;
			}

			let fetchParams = {
				method: 'GET',
				headers: headerParams,

			};

			if (extraFetchParams) {
				fetchParams = assign(fetchParams, extraFetchParams);
			}

			let localVarPathWithQueryParameters = localVarPath + (localVarPath.indexOf('?') !== -1 ? '&' : '?') + querystring.stringify(queryParameters);

			return fetch(localVarPathWithQueryParameters, fetchParams).then((response) => {
				if (response.status >= 200 && response.status < 300) {
					return response.json();
				} else {
					let error = new Error(response.statusText);
					(error as any).response = response;
					throw error;
				}
			});
		}
		/**
		 *
		 * Get Sub Categories
		 * @param id
		 * @param conditions
		 * @param orderBy
		 * @param childconditions
		 * @param customfieldconditions
		 * @param page
		 * @param pageSize
		 */
		public procurementCategoriesIdSubcategoriesGet (params: {  id: number; conditions?: string; orderBy?: string; childconditions?: string; customfieldconditions?: string; page?: number; pageSize?: number; }, extraQueryParams?: any, extraFetchParams?: any ) : Promise<Array<SubCategory>> {
			const localVarPath = this.basePath + '/procurement/categories/{id}/subcategories'
				.replace('{' + 'id' + '}', String(params.id));

			let queryParameters: any = assign({}, extraQueryParams);
			let headerParams: any = assign({}, this.defaultHeaders);
			// verify required parameter 'id' is set
			if (params.id == null) {
				throw new Error('Missing required parameter id when calling procurementCategoriesIdSubcategoriesGet');
			}
			if (params.conditions !== undefined) {
				queryParameters['conditions'] = params.conditions;
			}

			if (params.orderBy !== undefined) {
				queryParameters['orderBy'] = params.orderBy;
			}

			if (params.childconditions !== undefined) {
				queryParameters['childconditions'] = params.childconditions;
			}

			if (params.customfieldconditions !== undefined) {
				queryParameters['customfieldconditions'] = params.customfieldconditions;
			}

			if (params.page !== undefined) {
				queryParameters['page'] = params.page;
			}

			if (params.pageSize !== undefined) {
				queryParameters['pageSize'] = params.pageSize;
			}

			let fetchParams = {
				method: 'GET',
				headers: headerParams,

			};

			if (extraFetchParams) {
				fetchParams = assign(fetchParams, extraFetchParams);
			}

			let localVarPathWithQueryParameters = localVarPath + (localVarPath.indexOf('?') !== -1 ? '&' : '?') + querystring.stringify(queryParameters);

			return fetch(localVarPathWithQueryParameters, fetchParams).then((response) => {
				if (response.status >= 200 && response.status < 300) {
					return response.json();
				} else {
					let error = new Error(response.statusText);
					(error as any).response = response;
					throw error;
				}
			});
		}
		/**
		 *
		 * Create Sub Category
		 * @param id
		 * @param subCategory
		 */
		public procurementCategoriesIdSubcategoriesPost (params: {  id: number; subCategory: SubCategory; }, extraQueryParams?: any, extraFetchParams?: any ) : Promise<SubCategory> {
			const localVarPath = this.basePath + '/procurement/categories/{id}/subcategories'
				.replace('{' + 'id' + '}', String(params.id));

			let queryParameters: any = assign({}, extraQueryParams);
			let headerParams: any = assign({}, this.defaultHeaders);
			headerParams['Content-Type'] = 'application/json';

			// verify required parameter 'id' is set
			if (params.id == null) {
				throw new Error('Missing required parameter id when calling procurementCategoriesIdSubcategoriesPost');
			}
			// verify required parameter 'subCategory' is set
			if (params.subCategory == null) {
				throw new Error('Missing required parameter subCategory when calling procurementCategoriesIdSubcategoriesPost');
			}
			let fetchParams = {
				method: 'POST',
				headers: headerParams,
				body: JSON.stringify(params.subCategory),

			};

			if (extraFetchParams) {
				fetchParams = assign(fetchParams, extraFetchParams);
			}

			let localVarPathWithQueryParameters = localVarPath + (localVarPath.indexOf('?') !== -1 ? '&' : '?') + querystring.stringify(queryParameters);

			return fetch(localVarPathWithQueryParameters, fetchParams).then((response) => {
				if (response.status >= 200 && response.status < 300) {
					return response.json();
				} else {
					let error = new Error(response.statusText);
					(error as any).response = response;
					throw error;
				}
			});
		}
		/**
		 *
		 * Delete Sub Category By Id
		 * @param id
		 * @param subcategoryID
		 */
		public procurementCategoriesIdSubcategoriesSubcategoryIDDelete (params: {  id: number; subcategoryID: number; }, extraQueryParams?: any, extraFetchParams?: any ) : Promise<{}> {
			const localVarPath = this.basePath + '/procurement/categories/{id}/subcategories/{subcategoryID}'
				.replace('{' + 'id' + '}', String(params.id))
				.replace('{' + 'subcategoryID' + '}', String(params.subcategoryID));

			let queryParameters: any = assign({}, extraQueryParams);
			let headerParams: any = assign({}, this.defaultHeaders);
			// verify required parameter 'id' is set
			if (params.id == null) {
				throw new Error('Missing required parameter id when calling procurementCategoriesIdSubcategoriesSubcategoryIDDelete');
			}
			// verify required parameter 'subcategoryID' is set
			if (params.subcategoryID == null) {
				throw new Error('Missing required parameter subcategoryID when calling procurementCategoriesIdSubcategoriesSubcategoryIDDelete');
			}
			let fetchParams = {
				method: 'DELETE',
				headers: headerParams,

			};

			if (extraFetchParams) {
				fetchParams = assign(fetchParams, extraFetchParams);
			}

			let localVarPathWithQueryParameters = localVarPath + (localVarPath.indexOf('?') !== -1 ? '&' : '?') + querystring.stringify(queryParameters);

			return fetch(localVarPathWithQueryParameters, fetchParams).then((response) => {
				if (response.status >= 200 && response.status < 300) {
					return response.json();
				} else {
					let error = new Error(response.statusText);
					(error as any).response = response;
					throw error;
				}
			});
		}
		/**
		 *
		 * Get Sub Category By Id
		 * @param id
		 * @param subcategoryID
		 */
		public procurementCategoriesIdSubcategoriesSubcategoryIDGet (params: {  id: number; subcategoryID: number; }, extraQueryParams?: any, extraFetchParams?: any ) : Promise<SubCategory> {
			const localVarPath = this.basePath + '/procurement/categories/{id}/subcategories/{subcategoryID}'
				.replace('{' + 'id' + '}', String(params.id))
				.replace('{' + 'subcategoryID' + '}', String(params.subcategoryID));

			let queryParameters: any = assign({}, extraQueryParams);
			let headerParams: any = assign({}, this.defaultHeaders);
			// verify required parameter 'id' is set
			if (params.id == null) {
				throw new Error('Missing required parameter id when calling procurementCategoriesIdSubcategoriesSubcategoryIDGet');
			}
			// verify required parameter 'subcategoryID' is set
			if (params.subcategoryID == null) {
				throw new Error('Missing required parameter subcategoryID when calling procurementCategoriesIdSubcategoriesSubcategoryIDGet');
			}
			let fetchParams = {
				method: 'GET',
				headers: headerParams,

			};

			if (extraFetchParams) {
				fetchParams = assign(fetchParams, extraFetchParams);
			}

			let localVarPathWithQueryParameters = localVarPath + (localVarPath.indexOf('?') !== -1 ? '&' : '?') + querystring.stringify(queryParameters);

			return fetch(localVarPathWithQueryParameters, fetchParams).then((response) => {
				if (response.status >= 200 && response.status < 300) {
					return response.json();
				} else {
					let error = new Error(response.statusText);
					(error as any).response = response;
					throw error;
				}
			});
		}
		/**
		 *
		 * Update Sub Category
		 * @param id
		 * @param subcategoryID
		 * @param operations
		 */
		public procurementCategoriesIdSubcategoriesSubcategoryIDPatch (params: {  id: number; subcategoryID: number; operations: Array<PatchOperation>; }, extraQueryParams?: any, extraFetchParams?: any ) : Promise<SubCategory> {
			const localVarPath = this.basePath + '/procurement/categories/{id}/subcategories/{subcategoryID}'
				.replace('{' + 'id' + '}', String(params.id))
				.replace('{' + 'subcategoryID' + '}', String(params.subcategoryID));

			let queryParameters: any = assign({}, extraQueryParams);
			let headerParams: any = assign({}, this.defaultHeaders);
			headerParams['Content-Type'] = 'application/json';

			// verify required parameter 'id' is set
			if (params.id == null) {
				throw new Error('Missing required parameter id when calling procurementCategoriesIdSubcategoriesSubcategoryIDPatch');
			}
			// verify required parameter 'subcategoryID' is set
			if (params.subcategoryID == null) {
				throw new Error('Missing required parameter subcategoryID when calling procurementCategoriesIdSubcategoriesSubcategoryIDPatch');
			}
			// verify required parameter 'operations' is set
			if (params.operations == null) {
				throw new Error('Missing required parameter operations when calling procurementCategoriesIdSubcategoriesSubcategoryIDPatch');
			}
			let fetchParams = {
				method: 'PATCH',
				headers: headerParams,
				body: JSON.stringify(params.operations),

			};

			if (extraFetchParams) {
				fetchParams = assign(fetchParams, extraFetchParams);
			}

			let localVarPathWithQueryParameters = localVarPath + (localVarPath.indexOf('?') !== -1 ? '&' : '?') + querystring.stringify(queryParameters);

			return fetch(localVarPathWithQueryParameters, fetchParams).then((response) => {
				if (response.status >= 200 && response.status < 300) {
					return response.json();
				} else {
					let error = new Error(response.statusText);
					(error as any).response = response;
					throw error;
				}
			});
		}
		/**
		 *
		 * Replace Sub Category
		 * @param id
		 * @param subcategoryID
		 * @param subCategory
		 */
		public procurementCategoriesIdSubcategoriesSubcategoryIDPut (params: {  id: number; subcategoryID: number; subCategory: SubCategory; }, extraQueryParams?: any, extraFetchParams?: any ) : Promise<SubCategory> {
			const localVarPath = this.basePath + '/procurement/categories/{id}/subcategories/{subcategoryID}'
				.replace('{' + 'id' + '}', String(params.id))
				.replace('{' + 'subcategoryID' + '}', String(params.subcategoryID));

			let queryParameters: any = assign({}, extraQueryParams);
			let headerParams: any = assign({}, this.defaultHeaders);
			headerParams['Content-Type'] = 'application/json';

			// verify required parameter 'id' is set
			if (params.id == null) {
				throw new Error('Missing required parameter id when calling procurementCategoriesIdSubcategoriesSubcategoryIDPut');
			}
			// verify required parameter 'subcategoryID' is set
			if (params.subcategoryID == null) {
				throw new Error('Missing required parameter subcategoryID when calling procurementCategoriesIdSubcategoriesSubcategoryIDPut');
			}
			// verify required parameter 'subCategory' is set
			if (params.subCategory == null) {
				throw new Error('Missing required parameter subCategory when calling procurementCategoriesIdSubcategoriesSubcategoryIDPut');
			}
			let fetchParams = {
				method: 'PUT',
				headers: headerParams,
				body: JSON.stringify(params.subCategory),

			};

			if (extraFetchParams) {
				fetchParams = assign(fetchParams, extraFetchParams);
			}

			let localVarPathWithQueryParameters = localVarPath + (localVarPath.indexOf('?') !== -1 ? '&' : '?') + querystring.stringify(queryParameters);

			return fetch(localVarPathWithQueryParameters, fetchParams).then((response) => {
				if (response.status >= 200 && response.status < 300) {
					return response.json();
				} else {
					let error = new Error(response.statusText);
					(error as any).response = response;
					throw error;
				}
			});
		}
	}
//}
//export namespace  {
	'use strict';

	export class SurveyQuestionsApi {
		protected basePath = 'https://api-na.myconnectwise.net/v4_6_release/apis/3.0';
		public defaultHeaders : any = {};

		constructor(basePath?: string) {
			if (basePath) {
				this.basePath = basePath;
			}
		}

		/**
		 *
		 * Get Survey Questions Count
		 * @param id
		 * @param conditions
		 */
		public serviceSurveysIdQuestionsCountGet (params: {  id: number; conditions?: string; }, extraQueryParams?: any, extraFetchParams?: any ) : Promise<Count> {
			const localVarPath = this.basePath + '/service/surveys/{id}/questions/count'
				.replace('{' + 'id' + '}', String(params.id));

			let queryParameters: any = assign({}, extraQueryParams);
			let headerParams: any = assign({}, this.defaultHeaders);
			// verify required parameter 'id' is set
			if (params.id == null) {
				throw new Error('Missing required parameter id when calling serviceSurveysIdQuestionsCountGet');
			}
			if (params.conditions !== undefined) {
				queryParameters['conditions'] = params.conditions;
			}

			let fetchParams = {
				method: 'GET',
				headers: headerParams,

			};

			if (extraFetchParams) {
				fetchParams = assign(fetchParams, extraFetchParams);
			}

			let localVarPathWithQueryParameters = localVarPath + (localVarPath.indexOf('?') !== -1 ? '&' : '?') + querystring.stringify(queryParameters);

			return fetch(localVarPathWithQueryParameters, fetchParams).then((response) => {
				if (response.status >= 200 && response.status < 300) {
					return response.json();
				} else {
					let error = new Error(response.statusText);
					(error as any).response = response;
					throw error;
				}
			});
		}
		/**
		 *
		 * Get Survey Questions
		 * @param id
		 * @param conditions
		 * @param orderBy
		 * @param childconditions
		 * @param customfieldconditions
		 * @param page
		 * @param pageSize
		 */
		public serviceSurveysIdQuestionsGet (params: {  id: number; conditions?: string; orderBy?: string; childconditions?: string; customfieldconditions?: string; page?: number; pageSize?: number; }, extraQueryParams?: any, extraFetchParams?: any ) : Promise<Array<SurveyQuestion>> {
			const localVarPath = this.basePath + '/service/surveys/{id}/questions'
				.replace('{' + 'id' + '}', String(params.id));

			let queryParameters: any = assign({}, extraQueryParams);
			let headerParams: any = assign({}, this.defaultHeaders);
			// verify required parameter 'id' is set
			if (params.id == null) {
				throw new Error('Missing required parameter id when calling serviceSurveysIdQuestionsGet');
			}
			if (params.conditions !== undefined) {
				queryParameters['conditions'] = params.conditions;
			}

			if (params.orderBy !== undefined) {
				queryParameters['orderBy'] = params.orderBy;
			}

			if (params.childconditions !== undefined) {
				queryParameters['childconditions'] = params.childconditions;
			}

			if (params.customfieldconditions !== undefined) {
				queryParameters['customfieldconditions'] = params.customfieldconditions;
			}

			if (params.page !== undefined) {
				queryParameters['page'] = params.page;
			}

			if (params.pageSize !== undefined) {
				queryParameters['pageSize'] = params.pageSize;
			}

			let fetchParams = {
				method: 'GET',
				headers: headerParams,

			};

			if (extraFetchParams) {
				fetchParams = assign(fetchParams, extraFetchParams);
			}

			let localVarPathWithQueryParameters = localVarPath + (localVarPath.indexOf('?') !== -1 ? '&' : '?') + querystring.stringify(queryParameters);

			return fetch(localVarPathWithQueryParameters, fetchParams).then((response) => {
				if (response.status >= 200 && response.status < 300) {
					return response.json();
				} else {
					let error = new Error(response.statusText);
					(error as any).response = response;
					throw error;
				}
			});
		}
		/**
		 *
		 * Create Survey Question
		 * @param id
		 * @param surveyQuestion
		 */
		public serviceSurveysIdQuestionsPost (params: {  id: number; surveyQuestion: SurveyQuestion; }, extraQueryParams?: any, extraFetchParams?: any ) : Promise<SurveyQuestion> {
			const localVarPath = this.basePath + '/service/surveys/{id}/questions'
				.replace('{' + 'id' + '}', String(params.id));

			let queryParameters: any = assign({}, extraQueryParams);
			let headerParams: any = assign({}, this.defaultHeaders);
			headerParams['Content-Type'] = 'application/json';

			// verify required parameter 'id' is set
			if (params.id == null) {
				throw new Error('Missing required parameter id when calling serviceSurveysIdQuestionsPost');
			}
			// verify required parameter 'surveyQuestion' is set
			if (params.surveyQuestion == null) {
				throw new Error('Missing required parameter surveyQuestion when calling serviceSurveysIdQuestionsPost');
			}
			let fetchParams = {
				method: 'POST',
				headers: headerParams,
				body: JSON.stringify(params.surveyQuestion),

			};

			if (extraFetchParams) {
				fetchParams = assign(fetchParams, extraFetchParams);
			}

			let localVarPathWithQueryParameters = localVarPath + (localVarPath.indexOf('?') !== -1 ? '&' : '?') + querystring.stringify(queryParameters);

			return fetch(localVarPathWithQueryParameters, fetchParams).then((response) => {
				if (response.status >= 200 && response.status < 300) {
					return response.json();
				} else {
					let error = new Error(response.statusText);
					(error as any).response = response;
					throw error;
				}
			});
		}
		/**
		 *
		 * Delete Survey Question By Id
		 * @param id
		 * @param questionId
		 */
		public serviceSurveysIdQuestionsQuestionIdDelete (params: {  id: number; questionId: number; }, extraQueryParams?: any, extraFetchParams?: any ) : Promise<{}> {
			const localVarPath = this.basePath + '/service/surveys/{id}/questions/{questionId}'
				.replace('{' + 'id' + '}', String(params.id))
				.replace('{' + 'questionId' + '}', String(params.questionId));

			let queryParameters: any = assign({}, extraQueryParams);
			let headerParams: any = assign({}, this.defaultHeaders);
			// verify required parameter 'id' is set
			if (params.id == null) {
				throw new Error('Missing required parameter id when calling serviceSurveysIdQuestionsQuestionIdDelete');
			}
			// verify required parameter 'questionId' is set
			if (params.questionId == null) {
				throw new Error('Missing required parameter questionId when calling serviceSurveysIdQuestionsQuestionIdDelete');
			}
			let fetchParams = {
				method: 'DELETE',
				headers: headerParams,

			};

			if (extraFetchParams) {
				fetchParams = assign(fetchParams, extraFetchParams);
			}

			let localVarPathWithQueryParameters = localVarPath + (localVarPath.indexOf('?') !== -1 ? '&' : '?') + querystring.stringify(queryParameters);

			return fetch(localVarPathWithQueryParameters, fetchParams).then((response) => {
				if (response.status >= 200 && response.status < 300) {
					return response.json();
				} else {
					let error = new Error(response.statusText);
					(error as any).response = response;
					throw error;
				}
			});
		}
		/**
		 *
		 * Get Survey Question By Id
		 * @param id
		 * @param questionId
		 */
		public serviceSurveysIdQuestionsQuestionIdGet (params: {  id: number; questionId: number; }, extraQueryParams?: any, extraFetchParams?: any ) : Promise<SurveyQuestion> {
			const localVarPath = this.basePath + '/service/surveys/{id}/questions/{questionId}'
				.replace('{' + 'id' + '}', String(params.id))
				.replace('{' + 'questionId' + '}', String(params.questionId));

			let queryParameters: any = assign({}, extraQueryParams);
			let headerParams: any = assign({}, this.defaultHeaders);
			// verify required parameter 'id' is set
			if (params.id == null) {
				throw new Error('Missing required parameter id when calling serviceSurveysIdQuestionsQuestionIdGet');
			}
			// verify required parameter 'questionId' is set
			if (params.questionId == null) {
				throw new Error('Missing required parameter questionId when calling serviceSurveysIdQuestionsQuestionIdGet');
			}
			let fetchParams = {
				method: 'GET',
				headers: headerParams,

			};

			if (extraFetchParams) {
				fetchParams = assign(fetchParams, extraFetchParams);
			}

			let localVarPathWithQueryParameters = localVarPath + (localVarPath.indexOf('?') !== -1 ? '&' : '?') + querystring.stringify(queryParameters);

			return fetch(localVarPathWithQueryParameters, fetchParams).then((response) => {
				if (response.status >= 200 && response.status < 300) {
					return response.json();
				} else {
					let error = new Error(response.statusText);
					(error as any).response = response;
					throw error;
				}
			});
		}
		/**
		 *
		 * Update Survey Question
		 * @param id
		 * @param questionId
		 * @param operations
		 */
		public serviceSurveysIdQuestionsQuestionIdPatch (params: {  id: number; questionId: number; operations: Array<PatchOperation>; }, extraQueryParams?: any, extraFetchParams?: any ) : Promise<SurveyQuestion> {
			const localVarPath = this.basePath + '/service/surveys/{id}/questions/{questionId}'
				.replace('{' + 'id' + '}', String(params.id))
				.replace('{' + 'questionId' + '}', String(params.questionId));

			let queryParameters: any = assign({}, extraQueryParams);
			let headerParams: any = assign({}, this.defaultHeaders);
			headerParams['Content-Type'] = 'application/json';

			// verify required parameter 'id' is set
			if (params.id == null) {
				throw new Error('Missing required parameter id when calling serviceSurveysIdQuestionsQuestionIdPatch');
			}
			// verify required parameter 'questionId' is set
			if (params.questionId == null) {
				throw new Error('Missing required parameter questionId when calling serviceSurveysIdQuestionsQuestionIdPatch');
			}
			// verify required parameter 'operations' is set
			if (params.operations == null) {
				throw new Error('Missing required parameter operations when calling serviceSurveysIdQuestionsQuestionIdPatch');
			}
			let fetchParams = {
				method: 'PATCH',
				headers: headerParams,
				body: JSON.stringify(params.operations),

			};

			if (extraFetchParams) {
				fetchParams = assign(fetchParams, extraFetchParams);
			}

			let localVarPathWithQueryParameters = localVarPath + (localVarPath.indexOf('?') !== -1 ? '&' : '?') + querystring.stringify(queryParameters);

			return fetch(localVarPathWithQueryParameters, fetchParams).then((response) => {
				if (response.status >= 200 && response.status < 300) {
					return response.json();
				} else {
					let error = new Error(response.statusText);
					(error as any).response = response;
					throw error;
				}
			});
		}
		/**
		 *
		 * Replace Survey Question
		 * @param id
		 * @param questionId
		 * @param surveyQuestion
		 */
		public serviceSurveysIdQuestionsQuestionIdPut (params: {  id: number; questionId: number; surveyQuestion: SurveyQuestion; }, extraQueryParams?: any, extraFetchParams?: any ) : Promise<SurveyQuestion> {
			const localVarPath = this.basePath + '/service/surveys/{id}/questions/{questionId}'
				.replace('{' + 'id' + '}', String(params.id))
				.replace('{' + 'questionId' + '}', String(params.questionId));

			let queryParameters: any = assign({}, extraQueryParams);
			let headerParams: any = assign({}, this.defaultHeaders);
			headerParams['Content-Type'] = 'application/json';

			// verify required parameter 'id' is set
			if (params.id == null) {
				throw new Error('Missing required parameter id when calling serviceSurveysIdQuestionsQuestionIdPut');
			}
			// verify required parameter 'questionId' is set
			if (params.questionId == null) {
				throw new Error('Missing required parameter questionId when calling serviceSurveysIdQuestionsQuestionIdPut');
			}
			// verify required parameter 'surveyQuestion' is set
			if (params.surveyQuestion == null) {
				throw new Error('Missing required parameter surveyQuestion when calling serviceSurveysIdQuestionsQuestionIdPut');
			}
			let fetchParams = {
				method: 'PUT',
				headers: headerParams,
				body: JSON.stringify(params.surveyQuestion),

			};

			if (extraFetchParams) {
				fetchParams = assign(fetchParams, extraFetchParams);
			}

			let localVarPathWithQueryParameters = localVarPath + (localVarPath.indexOf('?') !== -1 ? '&' : '?') + querystring.stringify(queryParameters);

			return fetch(localVarPathWithQueryParameters, fetchParams).then((response) => {
				if (response.status >= 200 && response.status < 300) {
					return response.json();
				} else {
					let error = new Error(response.statusText);
					(error as any).response = response;
					throw error;
				}
			});
		}
	}
//}
//export namespace  {
	'use strict';

	export class SurveyResultsApi {
		protected basePath = 'https://api-na.myconnectwise.net/v4_6_release/apis/3.0';
		public defaultHeaders : any = {};

		constructor(basePath?: string) {
			if (basePath) {
				this.basePath = basePath;
			}
		}

		/**
		 *
		 * Get Survey Results Count
		 * @param id
		 * @param conditions
		 */
		public serviceSurveysIdResultsCountGet (params: {  id: number; conditions?: string; }, extraQueryParams?: any, extraFetchParams?: any ) : Promise<Count> {
			const localVarPath = this.basePath + '/service/surveys/{id}/results/count'
				.replace('{' + 'id' + '}', String(params.id));

			let queryParameters: any = assign({}, extraQueryParams);
			let headerParams: any = assign({}, this.defaultHeaders);
			// verify required parameter 'id' is set
			if (params.id == null) {
				throw new Error('Missing required parameter id when calling serviceSurveysIdResultsCountGet');
			}
			if (params.conditions !== undefined) {
				queryParameters['conditions'] = params.conditions;
			}

			let fetchParams = {
				method: 'GET',
				headers: headerParams,

			};

			if (extraFetchParams) {
				fetchParams = assign(fetchParams, extraFetchParams);
			}

			let localVarPathWithQueryParameters = localVarPath + (localVarPath.indexOf('?') !== -1 ? '&' : '?') + querystring.stringify(queryParameters);

			return fetch(localVarPathWithQueryParameters, fetchParams).then((response) => {
				if (response.status >= 200 && response.status < 300) {
					return response.json();
				} else {
					let error = new Error(response.statusText);
					(error as any).response = response;
					throw error;
				}
			});
		}
		/**
		 *
		 * Get Survey Results
		 * @param id
		 * @param conditions
		 * @param orderBy
		 * @param childconditions
		 * @param customfieldconditions
		 * @param page
		 * @param pageSize
		 */
		public serviceSurveysIdResultsGet (params: {  id: number; conditions?: string; orderBy?: string; childconditions?: string; customfieldconditions?: string; page?: number; pageSize?: number; }, extraQueryParams?: any, extraFetchParams?: any ) : Promise<Array<SurveyResult>> {
			const localVarPath = this.basePath + '/service/surveys/{id}/results'
				.replace('{' + 'id' + '}', String(params.id));

			let queryParameters: any = assign({}, extraQueryParams);
			let headerParams: any = assign({}, this.defaultHeaders);
			// verify required parameter 'id' is set
			if (params.id == null) {
				throw new Error('Missing required parameter id when calling serviceSurveysIdResultsGet');
			}
			if (params.conditions !== undefined) {
				queryParameters['conditions'] = params.conditions;
			}

			if (params.orderBy !== undefined) {
				queryParameters['orderBy'] = params.orderBy;
			}

			if (params.childconditions !== undefined) {
				queryParameters['childconditions'] = params.childconditions;
			}

			if (params.customfieldconditions !== undefined) {
				queryParameters['customfieldconditions'] = params.customfieldconditions;
			}

			if (params.page !== undefined) {
				queryParameters['page'] = params.page;
			}

			if (params.pageSize !== undefined) {
				queryParameters['pageSize'] = params.pageSize;
			}

			let fetchParams = {
				method: 'GET',
				headers: headerParams,

			};

			if (extraFetchParams) {
				fetchParams = assign(fetchParams, extraFetchParams);
			}

			let localVarPathWithQueryParameters = localVarPath + (localVarPath.indexOf('?') !== -1 ? '&' : '?') + querystring.stringify(queryParameters);

			return fetch(localVarPathWithQueryParameters, fetchParams).then((response) => {
				if (response.status >= 200 && response.status < 300) {
					return response.json();
				} else {
					let error = new Error(response.statusText);
					(error as any).response = response;
					throw error;
				}
			});
		}
		/**
		 *
		 * Create Survey Result
		 * @param id
		 * @param surveyResult
		 */
		public serviceSurveysIdResultsPost (params: {  id: number; surveyResult: SurveyResult; }, extraQueryParams?: any, extraFetchParams?: any ) : Promise<SurveyResult> {
			const localVarPath = this.basePath + '/service/surveys/{id}/results'
				.replace('{' + 'id' + '}', String(params.id));

			let queryParameters: any = assign({}, extraQueryParams);
			let headerParams: any = assign({}, this.defaultHeaders);
			headerParams['Content-Type'] = 'application/json';

			// verify required parameter 'id' is set
			if (params.id == null) {
				throw new Error('Missing required parameter id when calling serviceSurveysIdResultsPost');
			}
			// verify required parameter 'surveyResult' is set
			if (params.surveyResult == null) {
				throw new Error('Missing required parameter surveyResult when calling serviceSurveysIdResultsPost');
			}
			let fetchParams = {
				method: 'POST',
				headers: headerParams,
				body: JSON.stringify(params.surveyResult),

			};

			if (extraFetchParams) {
				fetchParams = assign(fetchParams, extraFetchParams);
			}

			let localVarPathWithQueryParameters = localVarPath + (localVarPath.indexOf('?') !== -1 ? '&' : '?') + querystring.stringify(queryParameters);

			return fetch(localVarPathWithQueryParameters, fetchParams).then((response) => {
				if (response.status >= 200 && response.status < 300) {
					return response.json();
				} else {
					let error = new Error(response.statusText);
					(error as any).response = response;
					throw error;
				}
			});
		}
		/**
		 *
		 * Delete Survey Result By Id
		 * @param id
		 * @param resultId
		 */
		public serviceSurveysIdResultsResultIdDelete (params: {  id: number; resultId: number; }, extraQueryParams?: any, extraFetchParams?: any ) : Promise<{}> {
			const localVarPath = this.basePath + '/service/surveys/{id}/results/{resultId}'
				.replace('{' + 'id' + '}', String(params.id))
				.replace('{' + 'resultId' + '}', String(params.resultId));

			let queryParameters: any = assign({}, extraQueryParams);
			let headerParams: any = assign({}, this.defaultHeaders);
			// verify required parameter 'id' is set
			if (params.id == null) {
				throw new Error('Missing required parameter id when calling serviceSurveysIdResultsResultIdDelete');
			}
			// verify required parameter 'resultId' is set
			if (params.resultId == null) {
				throw new Error('Missing required parameter resultId when calling serviceSurveysIdResultsResultIdDelete');
			}
			let fetchParams = {
				method: 'DELETE',
				headers: headerParams,

			};

			if (extraFetchParams) {
				fetchParams = assign(fetchParams, extraFetchParams);
			}

			let localVarPathWithQueryParameters = localVarPath + (localVarPath.indexOf('?') !== -1 ? '&' : '?') + querystring.stringify(queryParameters);

			return fetch(localVarPathWithQueryParameters, fetchParams).then((response) => {
				if (response.status >= 200 && response.status < 300) {
					return response.json();
				} else {
					let error = new Error(response.statusText);
					(error as any).response = response;
					throw error;
				}
			});
		}
		/**
		 *
		 * Get Survey Result By Id
		 * @param id
		 * @param resultId
		 */
		public serviceSurveysIdResultsResultIdGet (params: {  id: number; resultId: number; }, extraQueryParams?: any, extraFetchParams?: any ) : Promise<SurveyResult> {
			const localVarPath = this.basePath + '/service/surveys/{id}/results/{resultId}'
				.replace('{' + 'id' + '}', String(params.id))
				.replace('{' + 'resultId' + '}', String(params.resultId));

			let queryParameters: any = assign({}, extraQueryParams);
			let headerParams: any = assign({}, this.defaultHeaders);
			// verify required parameter 'id' is set
			if (params.id == null) {
				throw new Error('Missing required parameter id when calling serviceSurveysIdResultsResultIdGet');
			}
			// verify required parameter 'resultId' is set
			if (params.resultId == null) {
				throw new Error('Missing required parameter resultId when calling serviceSurveysIdResultsResultIdGet');
			}
			let fetchParams = {
				method: 'GET',
				headers: headerParams,

			};

			if (extraFetchParams) {
				fetchParams = assign(fetchParams, extraFetchParams);
			}

			let localVarPathWithQueryParameters = localVarPath + (localVarPath.indexOf('?') !== -1 ? '&' : '?') + querystring.stringify(queryParameters);

			return fetch(localVarPathWithQueryParameters, fetchParams).then((response) => {
				if (response.status >= 200 && response.status < 300) {
					return response.json();
				} else {
					let error = new Error(response.statusText);
					(error as any).response = response;
					throw error;
				}
			});
		}
		/**
		 *
		 * Update Survey Result
		 * @param id
		 * @param resultId
		 * @param operations
		 */
		public serviceSurveysIdResultsResultIdPatch (params: {  id: number; resultId: number; operations: Array<PatchOperation>; }, extraQueryParams?: any, extraFetchParams?: any ) : Promise<SurveyResult> {
			const localVarPath = this.basePath + '/service/surveys/{id}/results/{resultId}'
				.replace('{' + 'id' + '}', String(params.id))
				.replace('{' + 'resultId' + '}', String(params.resultId));

			let queryParameters: any = assign({}, extraQueryParams);
			let headerParams: any = assign({}, this.defaultHeaders);
			headerParams['Content-Type'] = 'application/json';

			// verify required parameter 'id' is set
			if (params.id == null) {
				throw new Error('Missing required parameter id when calling serviceSurveysIdResultsResultIdPatch');
			}
			// verify required parameter 'resultId' is set
			if (params.resultId == null) {
				throw new Error('Missing required parameter resultId when calling serviceSurveysIdResultsResultIdPatch');
			}
			// verify required parameter 'operations' is set
			if (params.operations == null) {
				throw new Error('Missing required parameter operations when calling serviceSurveysIdResultsResultIdPatch');
			}
			let fetchParams = {
				method: 'PATCH',
				headers: headerParams,
				body: JSON.stringify(params.operations),

			};

			if (extraFetchParams) {
				fetchParams = assign(fetchParams, extraFetchParams);
			}

			let localVarPathWithQueryParameters = localVarPath + (localVarPath.indexOf('?') !== -1 ? '&' : '?') + querystring.stringify(queryParameters);

			return fetch(localVarPathWithQueryParameters, fetchParams).then((response) => {
				if (response.status >= 200 && response.status < 300) {
					return response.json();
				} else {
					let error = new Error(response.statusText);
					(error as any).response = response;
					throw error;
				}
			});
		}
		/**
		 *
		 * Replace Survey Result
		 * @param id
		 * @param resultId
		 * @param surveyResult
		 */
		public serviceSurveysIdResultsResultIdPut (params: {  id: number; resultId: number; surveyResult: SurveyResult; }, extraQueryParams?: any, extraFetchParams?: any ) : Promise<SurveyResult> {
			const localVarPath = this.basePath + '/service/surveys/{id}/results/{resultId}'
				.replace('{' + 'id' + '}', String(params.id))
				.replace('{' + 'resultId' + '}', String(params.resultId));

			let queryParameters: any = assign({}, extraQueryParams);
			let headerParams: any = assign({}, this.defaultHeaders);
			headerParams['Content-Type'] = 'application/json';

			// verify required parameter 'id' is set
			if (params.id == null) {
				throw new Error('Missing required parameter id when calling serviceSurveysIdResultsResultIdPut');
			}
			// verify required parameter 'resultId' is set
			if (params.resultId == null) {
				throw new Error('Missing required parameter resultId when calling serviceSurveysIdResultsResultIdPut');
			}
			// verify required parameter 'surveyResult' is set
			if (params.surveyResult == null) {
				throw new Error('Missing required parameter surveyResult when calling serviceSurveysIdResultsResultIdPut');
			}
			let fetchParams = {
				method: 'PUT',
				headers: headerParams,
				body: JSON.stringify(params.surveyResult),

			};

			if (extraFetchParams) {
				fetchParams = assign(fetchParams, extraFetchParams);
			}

			let localVarPathWithQueryParameters = localVarPath + (localVarPath.indexOf('?') !== -1 ? '&' : '?') + querystring.stringify(queryParameters);

			return fetch(localVarPathWithQueryParameters, fetchParams).then((response) => {
				if (response.status >= 200 && response.status < 300) {
					return response.json();
				} else {
					let error = new Error(response.statusText);
					(error as any).response = response;
					throw error;
				}
			});
		}
	}
//}
//export namespace  {
	'use strict';

	export class SurveysApi {
		protected basePath = 'https://api-na.myconnectwise.net/v4_6_release/apis/3.0';
		public defaultHeaders : any = {};

		constructor(basePath?: string) {
			if (basePath) {
				this.basePath = basePath;
			}
		}

		/**
		 *
		 * Get Surveys Count
		 * @param conditions
		 */
		public serviceSurveysCountGet (params: {  conditions?: string; }, extraQueryParams?: any, extraFetchParams?: any ) : Promise<Count> {
			const localVarPath = this.basePath + '/service/surveys/count';

			let queryParameters: any = assign({}, extraQueryParams);
			let headerParams: any = assign({}, this.defaultHeaders);
			if (params.conditions !== undefined) {
				queryParameters['conditions'] = params.conditions;
			}

			let fetchParams = {
				method: 'GET',
				headers: headerParams,

			};

			if (extraFetchParams) {
				fetchParams = assign(fetchParams, extraFetchParams);
			}

			let localVarPathWithQueryParameters = localVarPath + (localVarPath.indexOf('?') !== -1 ? '&' : '?') + querystring.stringify(queryParameters);

			return fetch(localVarPathWithQueryParameters, fetchParams).then((response) => {
				if (response.status >= 200 && response.status < 300) {
					return response.json();
				} else {
					let error = new Error(response.statusText);
					(error as any).response = response;
					throw error;
				}
			});
		}
		/**
		 *
		 * Get Surveys
		 * @param conditions
		 * @param orderBy
		 * @param childconditions
		 * @param customfieldconditions
		 * @param page
		 * @param pageSize
		 */
		public serviceSurveysGet (params: {  conditions?: string; orderBy?: string; childconditions?: string; customfieldconditions?: string; page?: number; pageSize?: number; }, extraQueryParams?: any, extraFetchParams?: any ) : Promise<Array<Survey>> {
			const localVarPath = this.basePath + '/service/surveys';

			let queryParameters: any = assign({}, extraQueryParams);
			let headerParams: any = assign({}, this.defaultHeaders);
			if (params.conditions !== undefined) {
				queryParameters['conditions'] = params.conditions;
			}

			if (params.orderBy !== undefined) {
				queryParameters['orderBy'] = params.orderBy;
			}

			if (params.childconditions !== undefined) {
				queryParameters['childconditions'] = params.childconditions;
			}

			if (params.customfieldconditions !== undefined) {
				queryParameters['customfieldconditions'] = params.customfieldconditions;
			}

			if (params.page !== undefined) {
				queryParameters['page'] = params.page;
			}

			if (params.pageSize !== undefined) {
				queryParameters['pageSize'] = params.pageSize;
			}

			let fetchParams = {
				method: 'GET',
				headers: headerParams,

			};

			if (extraFetchParams) {
				fetchParams = assign(fetchParams, extraFetchParams);
			}

			let localVarPathWithQueryParameters = localVarPath + (localVarPath.indexOf('?') !== -1 ? '&' : '?') + querystring.stringify(queryParameters);

			return fetch(localVarPathWithQueryParameters, fetchParams).then((response) => {
				if (response.status >= 200 && response.status < 300) {
					return response.json();
				} else {
					let error = new Error(response.statusText);
					(error as any).response = response;
					throw error;
				}
			});
		}
		/**
		 *
		 * Delete Survey By Id
		 * @param id
		 */
		public serviceSurveysIdDelete (params: {  id: number; }, extraQueryParams?: any, extraFetchParams?: any ) : Promise<{}> {
			const localVarPath = this.basePath + '/service/surveys/{id}'
				.replace('{' + 'id' + '}', String(params.id));

			let queryParameters: any = assign({}, extraQueryParams);
			let headerParams: any = assign({}, this.defaultHeaders);
			// verify required parameter 'id' is set
			if (params.id == null) {
				throw new Error('Missing required parameter id when calling serviceSurveysIdDelete');
			}
			let fetchParams = {
				method: 'DELETE',
				headers: headerParams,

			};

			if (extraFetchParams) {
				fetchParams = assign(fetchParams, extraFetchParams);
			}

			let localVarPathWithQueryParameters = localVarPath + (localVarPath.indexOf('?') !== -1 ? '&' : '?') + querystring.stringify(queryParameters);

			return fetch(localVarPathWithQueryParameters, fetchParams).then((response) => {
				if (response.status >= 200 && response.status < 300) {
					return response.json();
				} else {
					let error = new Error(response.statusText);
					(error as any).response = response;
					throw error;
				}
			});
		}
		/**
		 *
		 * Get Survey By Id
		 * @param id
		 */
		public serviceSurveysIdGet (params: {  id: number; }, extraQueryParams?: any, extraFetchParams?: any ) : Promise<Survey> {
			const localVarPath = this.basePath + '/service/surveys/{id}'
				.replace('{' + 'id' + '}', String(params.id));

			let queryParameters: any = assign({}, extraQueryParams);
			let headerParams: any = assign({}, this.defaultHeaders);
			// verify required parameter 'id' is set
			if (params.id == null) {
				throw new Error('Missing required parameter id when calling serviceSurveysIdGet');
			}
			let fetchParams = {
				method: 'GET',
				headers: headerParams,

			};

			if (extraFetchParams) {
				fetchParams = assign(fetchParams, extraFetchParams);
			}

			let localVarPathWithQueryParameters = localVarPath + (localVarPath.indexOf('?') !== -1 ? '&' : '?') + querystring.stringify(queryParameters);

			return fetch(localVarPathWithQueryParameters, fetchParams).then((response) => {
				if (response.status >= 200 && response.status < 300) {
					return response.json();
				} else {
					let error = new Error(response.statusText);
					(error as any).response = response;
					throw error;
				}
			});
		}
		/**
		 *
		 * Update Survey
		 * @param id
		 * @param operations
		 */
		public serviceSurveysIdPatch (params: {  id: number; operations: Array<PatchOperation>; }, extraQueryParams?: any, extraFetchParams?: any ) : Promise<Survey> {
			const localVarPath = this.basePath + '/service/surveys/{id}'
				.replace('{' + 'id' + '}', String(params.id));

			let queryParameters: any = assign({}, extraQueryParams);
			let headerParams: any = assign({}, this.defaultHeaders);
			headerParams['Content-Type'] = 'application/json';

			// verify required parameter 'id' is set
			if (params.id == null) {
				throw new Error('Missing required parameter id when calling serviceSurveysIdPatch');
			}
			// verify required parameter 'operations' is set
			if (params.operations == null) {
				throw new Error('Missing required parameter operations when calling serviceSurveysIdPatch');
			}
			let fetchParams = {
				method: 'PATCH',
				headers: headerParams,
				body: JSON.stringify(params.operations),

			};

			if (extraFetchParams) {
				fetchParams = assign(fetchParams, extraFetchParams);
			}

			let localVarPathWithQueryParameters = localVarPath + (localVarPath.indexOf('?') !== -1 ? '&' : '?') + querystring.stringify(queryParameters);

			return fetch(localVarPathWithQueryParameters, fetchParams).then((response) => {
				if (response.status >= 200 && response.status < 300) {
					return response.json();
				} else {
					let error = new Error(response.statusText);
					(error as any).response = response;
					throw error;
				}
			});
		}
		/**
		 *
		 * Replace Survey
		 * @param id
		 * @param survey
		 */
		public serviceSurveysIdPut (params: {  id: number; survey: Survey; }, extraQueryParams?: any, extraFetchParams?: any ) : Promise<Survey> {
			const localVarPath = this.basePath + '/service/surveys/{id}'
				.replace('{' + 'id' + '}', String(params.id));

			let queryParameters: any = assign({}, extraQueryParams);
			let headerParams: any = assign({}, this.defaultHeaders);
			headerParams['Content-Type'] = 'application/json';

			// verify required parameter 'id' is set
			if (params.id == null) {
				throw new Error('Missing required parameter id when calling serviceSurveysIdPut');
			}
			// verify required parameter 'survey' is set
			if (params.survey == null) {
				throw new Error('Missing required parameter survey when calling serviceSurveysIdPut');
			}
			let fetchParams = {
				method: 'PUT',
				headers: headerParams,
				body: JSON.stringify(params.survey),

			};

			if (extraFetchParams) {
				fetchParams = assign(fetchParams, extraFetchParams);
			}

			let localVarPathWithQueryParameters = localVarPath + (localVarPath.indexOf('?') !== -1 ? '&' : '?') + querystring.stringify(queryParameters);

			return fetch(localVarPathWithQueryParameters, fetchParams).then((response) => {
				if (response.status >= 200 && response.status < 300) {
					return response.json();
				} else {
					let error = new Error(response.statusText);
					(error as any).response = response;
					throw error;
				}
			});
		}
		/**
		 *
		 * Create Survey
		 * @param survey
		 */
		public serviceSurveysPost (params: {  survey: Survey; }, extraQueryParams?: any, extraFetchParams?: any ) : Promise<Survey> {
			const localVarPath = this.basePath + '/service/surveys';

			let queryParameters: any = assign({}, extraQueryParams);
			let headerParams: any = assign({}, this.defaultHeaders);
			headerParams['Content-Type'] = 'application/json';

			// verify required parameter 'survey' is set
			if (params.survey == null) {
				throw new Error('Missing required parameter survey when calling serviceSurveysPost');
			}
			let fetchParams = {
				method: 'POST',
				headers: headerParams,
				body: JSON.stringify(params.survey),

			};

			if (extraFetchParams) {
				fetchParams = assign(fetchParams, extraFetchParams);
			}

			let localVarPathWithQueryParameters = localVarPath + (localVarPath.indexOf('?') !== -1 ? '&' : '?') + querystring.stringify(queryParameters);

			return fetch(localVarPathWithQueryParameters, fetchParams).then((response) => {
				if (response.status >= 200 && response.status < 300) {
					return response.json();
				} else {
					let error = new Error(response.statusText);
					(error as any).response = response;
					throw error;
				}
			});
		}
	}
//}
//export namespace  {
	'use strict';

	export class TaxCodeXRefsApi {
		protected basePath = 'https://api-na.myconnectwise.net/v4_6_release/apis/3.0';
		public defaultHeaders : any = {};

		constructor(basePath?: string) {
			if (basePath) {
				this.basePath = basePath;
			}
		}

		/**
		 *
		 * Get Tax Code X Ref Count
		 * @param id
		 * @param conditions
		 */
		public financeTaxCodesIdTaxCodeXRefsCountGet (params: {  id: number; conditions?: string; }, extraQueryParams?: any, extraFetchParams?: any ) : Promise<Count> {
			const localVarPath = this.basePath + '/finance/taxCodes/{id}/taxCodeXRefs/count'
				.replace('{' + 'id' + '}', String(params.id));

			let queryParameters: any = assign({}, extraQueryParams);
			let headerParams: any = assign({}, this.defaultHeaders);
			// verify required parameter 'id' is set
			if (params.id == null) {
				throw new Error('Missing required parameter id when calling financeTaxCodesIdTaxCodeXRefsCountGet');
			}
			if (params.conditions !== undefined) {
				queryParameters['conditions'] = params.conditions;
			}

			let fetchParams = {
				method: 'GET',
				headers: headerParams,

			};

			if (extraFetchParams) {
				fetchParams = assign(fetchParams, extraFetchParams);
			}

			let localVarPathWithQueryParameters = localVarPath + (localVarPath.indexOf('?') !== -1 ? '&' : '?') + querystring.stringify(queryParameters);

			return fetch(localVarPathWithQueryParameters, fetchParams).then((response) => {
				if (response.status >= 200 && response.status < 300) {
					return response.json();
				} else {
					let error = new Error(response.statusText);
					(error as any).response = response;
					throw error;
				}
			});
		}
		/**
		 *
		 * Get Tax Code X Ref
		 * @param id
		 * @param conditions
		 * @param orderBy
		 * @param childconditions
		 * @param customfieldconditions
		 * @param page
		 * @param pageSize
		 */
		public financeTaxCodesIdTaxCodeXRefsGet (params: {  id: number; conditions?: string; orderBy?: string; childconditions?: string; customfieldconditions?: string; page?: number; pageSize?: number; }, extraQueryParams?: any, extraFetchParams?: any ) : Promise<Array<TaxCodeXRef>> {
			const localVarPath = this.basePath + '/finance/taxCodes/{id}/taxCodeXRefs'
				.replace('{' + 'id' + '}', String(params.id));

			let queryParameters: any = assign({}, extraQueryParams);
			let headerParams: any = assign({}, this.defaultHeaders);
			// verify required parameter 'id' is set
			if (params.id == null) {
				throw new Error('Missing required parameter id when calling financeTaxCodesIdTaxCodeXRefsGet');
			}
			if (params.conditions !== undefined) {
				queryParameters['conditions'] = params.conditions;
			}

			if (params.orderBy !== undefined) {
				queryParameters['orderBy'] = params.orderBy;
			}

			if (params.childconditions !== undefined) {
				queryParameters['childconditions'] = params.childconditions;
			}

			if (params.customfieldconditions !== undefined) {
				queryParameters['customfieldconditions'] = params.customfieldconditions;
			}

			if (params.page !== undefined) {
				queryParameters['page'] = params.page;
			}

			if (params.pageSize !== undefined) {
				queryParameters['pageSize'] = params.pageSize;
			}

			let fetchParams = {
				method: 'GET',
				headers: headerParams,

			};

			if (extraFetchParams) {
				fetchParams = assign(fetchParams, extraFetchParams);
			}

			let localVarPathWithQueryParameters = localVarPath + (localVarPath.indexOf('?') !== -1 ? '&' : '?') + querystring.stringify(queryParameters);

			return fetch(localVarPathWithQueryParameters, fetchParams).then((response) => {
				if (response.status >= 200 && response.status < 300) {
					return response.json();
				} else {
					let error = new Error(response.statusText);
					(error as any).response = response;
					throw error;
				}
			});
		}
		/**
		 *
		 * Create Tax Code X Ref
		 * @param id
		 * @param taxCodeXRef
		 */
		public financeTaxCodesIdTaxCodeXRefsPost (params: {  id: number; taxCodeXRef: TaxCodeXRef; }, extraQueryParams?: any, extraFetchParams?: any ) : Promise<TaxCodeXRef> {
			const localVarPath = this.basePath + '/finance/taxCodes/{id}/taxCodeXRefs'
				.replace('{' + 'id' + '}', String(params.id));

			let queryParameters: any = assign({}, extraQueryParams);
			let headerParams: any = assign({}, this.defaultHeaders);
			headerParams['Content-Type'] = 'application/json';

			// verify required parameter 'id' is set
			if (params.id == null) {
				throw new Error('Missing required parameter id when calling financeTaxCodesIdTaxCodeXRefsPost');
			}
			// verify required parameter 'taxCodeXRef' is set
			if (params.taxCodeXRef == null) {
				throw new Error('Missing required parameter taxCodeXRef when calling financeTaxCodesIdTaxCodeXRefsPost');
			}
			let fetchParams = {
				method: 'POST',
				headers: headerParams,
				body: JSON.stringify(params.taxCodeXRef),

			};

			if (extraFetchParams) {
				fetchParams = assign(fetchParams, extraFetchParams);
			}

			let localVarPathWithQueryParameters = localVarPath + (localVarPath.indexOf('?') !== -1 ? '&' : '?') + querystring.stringify(queryParameters);

			return fetch(localVarPathWithQueryParameters, fetchParams).then((response) => {
				if (response.status >= 200 && response.status < 300) {
					return response.json();
				} else {
					let error = new Error(response.statusText);
					(error as any).response = response;
					throw error;
				}
			});
		}
		/**
		 *
		 * Delete Tax Code X Ref By Id
		 * @param id
		 * @param taxCodeXRefId
		 */
		public financeTaxCodesIdTaxCodeXRefsTaxCodeXRefIdDelete (params: {  id: number; taxCodeXRefId: number; }, extraQueryParams?: any, extraFetchParams?: any ) : Promise<{}> {
			const localVarPath = this.basePath + '/finance/taxCodes/{id}/taxCodeXRefs/{taxCodeXRefId}'
				.replace('{' + 'id' + '}', String(params.id))
				.replace('{' + 'taxCodeXRefId' + '}', String(params.taxCodeXRefId));

			let queryParameters: any = assign({}, extraQueryParams);
			let headerParams: any = assign({}, this.defaultHeaders);
			// verify required parameter 'id' is set
			if (params.id == null) {
				throw new Error('Missing required parameter id when calling financeTaxCodesIdTaxCodeXRefsTaxCodeXRefIdDelete');
			}
			// verify required parameter 'taxCodeXRefId' is set
			if (params.taxCodeXRefId == null) {
				throw new Error('Missing required parameter taxCodeXRefId when calling financeTaxCodesIdTaxCodeXRefsTaxCodeXRefIdDelete');
			}
			let fetchParams = {
				method: 'DELETE',
				headers: headerParams,

			};

			if (extraFetchParams) {
				fetchParams = assign(fetchParams, extraFetchParams);
			}

			let localVarPathWithQueryParameters = localVarPath + (localVarPath.indexOf('?') !== -1 ? '&' : '?') + querystring.stringify(queryParameters);

			return fetch(localVarPathWithQueryParameters, fetchParams).then((response) => {
				if (response.status >= 200 && response.status < 300) {
					return response.json();
				} else {
					let error = new Error(response.statusText);
					(error as any).response = response;
					throw error;
				}
			});
		}
		/**
		 *
		 * Get Tax Code X Ref By Id
		 * @param id
		 * @param taxCodeXRefId
		 */
		public financeTaxCodesIdTaxCodeXRefsTaxCodeXRefIdGet (params: {  id: number; taxCodeXRefId: number; }, extraQueryParams?: any, extraFetchParams?: any ) : Promise<TaxCodeXRef> {
			const localVarPath = this.basePath + '/finance/taxCodes/{id}/taxCodeXRefs/{taxCodeXRefId}'
				.replace('{' + 'id' + '}', String(params.id))
				.replace('{' + 'taxCodeXRefId' + '}', String(params.taxCodeXRefId));

			let queryParameters: any = assign({}, extraQueryParams);
			let headerParams: any = assign({}, this.defaultHeaders);
			// verify required parameter 'id' is set
			if (params.id == null) {
				throw new Error('Missing required parameter id when calling financeTaxCodesIdTaxCodeXRefsTaxCodeXRefIdGet');
			}
			// verify required parameter 'taxCodeXRefId' is set
			if (params.taxCodeXRefId == null) {
				throw new Error('Missing required parameter taxCodeXRefId when calling financeTaxCodesIdTaxCodeXRefsTaxCodeXRefIdGet');
			}
			let fetchParams = {
				method: 'GET',
				headers: headerParams,

			};

			if (extraFetchParams) {
				fetchParams = assign(fetchParams, extraFetchParams);
			}

			let localVarPathWithQueryParameters = localVarPath + (localVarPath.indexOf('?') !== -1 ? '&' : '?') + querystring.stringify(queryParameters);

			return fetch(localVarPathWithQueryParameters, fetchParams).then((response) => {
				if (response.status >= 200 && response.status < 300) {
					return response.json();
				} else {
					let error = new Error(response.statusText);
					(error as any).response = response;
					throw error;
				}
			});
		}
		/**
		 *
		 * Update Tax Code X Ref
		 * @param id
		 * @param taxCodeXRefId
		 * @param operations
		 */
		public financeTaxCodesIdTaxCodeXRefsTaxCodeXRefIdPatch (params: {  id: number; taxCodeXRefId: number; operations: Array<PatchOperation>; }, extraQueryParams?: any, extraFetchParams?: any ) : Promise<TaxCodeXRef> {
			const localVarPath = this.basePath + '/finance/taxCodes/{id}/taxCodeXRefs/{taxCodeXRefId}'
				.replace('{' + 'id' + '}', String(params.id))
				.replace('{' + 'taxCodeXRefId' + '}', String(params.taxCodeXRefId));

			let queryParameters: any = assign({}, extraQueryParams);
			let headerParams: any = assign({}, this.defaultHeaders);
			headerParams['Content-Type'] = 'application/json';

			// verify required parameter 'id' is set
			if (params.id == null) {
				throw new Error('Missing required parameter id when calling financeTaxCodesIdTaxCodeXRefsTaxCodeXRefIdPatch');
			}
			// verify required parameter 'taxCodeXRefId' is set
			if (params.taxCodeXRefId == null) {
				throw new Error('Missing required parameter taxCodeXRefId when calling financeTaxCodesIdTaxCodeXRefsTaxCodeXRefIdPatch');
			}
			// verify required parameter 'operations' is set
			if (params.operations == null) {
				throw new Error('Missing required parameter operations when calling financeTaxCodesIdTaxCodeXRefsTaxCodeXRefIdPatch');
			}
			let fetchParams = {
				method: 'PATCH',
				headers: headerParams,
				body: JSON.stringify(params.operations),

			};

			if (extraFetchParams) {
				fetchParams = assign(fetchParams, extraFetchParams);
			}

			let localVarPathWithQueryParameters = localVarPath + (localVarPath.indexOf('?') !== -1 ? '&' : '?') + querystring.stringify(queryParameters);

			return fetch(localVarPathWithQueryParameters, fetchParams).then((response) => {
				if (response.status >= 200 && response.status < 300) {
					return response.json();
				} else {
					let error = new Error(response.statusText);
					(error as any).response = response;
					throw error;
				}
			});
		}
		/**
		 *
		 * Replace Tax Code X Ref
		 * @param id
		 * @param taxCodeXRefId
		 * @param taxCodeXRef
		 */
		public financeTaxCodesIdTaxCodeXRefsTaxCodeXRefIdPut (params: {  id: number; taxCodeXRefId: number; taxCodeXRef: TaxCodeXRef; }, extraQueryParams?: any, extraFetchParams?: any ) : Promise<TaxCodeXRef> {
			const localVarPath = this.basePath + '/finance/taxCodes/{id}/taxCodeXRefs/{taxCodeXRefId}'
				.replace('{' + 'id' + '}', String(params.id))
				.replace('{' + 'taxCodeXRefId' + '}', String(params.taxCodeXRefId));

			let queryParameters: any = assign({}, extraQueryParams);
			let headerParams: any = assign({}, this.defaultHeaders);
			headerParams['Content-Type'] = 'application/json';

			// verify required parameter 'id' is set
			if (params.id == null) {
				throw new Error('Missing required parameter id when calling financeTaxCodesIdTaxCodeXRefsTaxCodeXRefIdPut');
			}
			// verify required parameter 'taxCodeXRefId' is set
			if (params.taxCodeXRefId == null) {
				throw new Error('Missing required parameter taxCodeXRefId when calling financeTaxCodesIdTaxCodeXRefsTaxCodeXRefIdPut');
			}
			// verify required parameter 'taxCodeXRef' is set
			if (params.taxCodeXRef == null) {
				throw new Error('Missing required parameter taxCodeXRef when calling financeTaxCodesIdTaxCodeXRefsTaxCodeXRefIdPut');
			}
			let fetchParams = {
				method: 'PUT',
				headers: headerParams,
				body: JSON.stringify(params.taxCodeXRef),

			};

			if (extraFetchParams) {
				fetchParams = assign(fetchParams, extraFetchParams);
			}

			let localVarPathWithQueryParameters = localVarPath + (localVarPath.indexOf('?') !== -1 ? '&' : '?') + querystring.stringify(queryParameters);

			return fetch(localVarPathWithQueryParameters, fetchParams).then((response) => {
				if (response.status >= 200 && response.status < 300) {
					return response.json();
				} else {
					let error = new Error(response.statusText);
					(error as any).response = response;
					throw error;
				}
			});
		}
	}
//}
//export namespace  {
	'use strict';

	export class TaxCodesApi {
		protected basePath = 'https://api-na.myconnectwise.net/v4_6_release/apis/3.0';
		public defaultHeaders : any = {};

		constructor(basePath?: string) {
			if (basePath) {
				this.basePath = basePath;
			}
		}

		/**
		 *
		 * Get Tax Code Count
		 * @param conditions
		 */
		public financeTaxCodesCountGet (params: {  conditions?: string; }, extraQueryParams?: any, extraFetchParams?: any ) : Promise<Count> {
			const localVarPath = this.basePath + '/finance/taxCodes/count';

			let queryParameters: any = assign({}, extraQueryParams);
			let headerParams: any = assign({}, this.defaultHeaders);
			if (params.conditions !== undefined) {
				queryParameters['conditions'] = params.conditions;
			}

			let fetchParams = {
				method: 'GET',
				headers: headerParams,

			};

			if (extraFetchParams) {
				fetchParams = assign(fetchParams, extraFetchParams);
			}

			let localVarPathWithQueryParameters = localVarPath + (localVarPath.indexOf('?') !== -1 ? '&' : '?') + querystring.stringify(queryParameters);

			return fetch(localVarPathWithQueryParameters, fetchParams).then((response) => {
				if (response.status >= 200 && response.status < 300) {
					return response.json();
				} else {
					let error = new Error(response.statusText);
					(error as any).response = response;
					throw error;
				}
			});
		}
		/**
		 *
		 * Get Tax Code
		 * @param conditions
		 * @param orderBy
		 * @param childconditions
		 * @param customfieldconditions
		 * @param page
		 * @param pageSize
		 */
		public financeTaxCodesGet (params: {  conditions?: string; orderBy?: string; childconditions?: string; customfieldconditions?: string; page?: number; pageSize?: number; }, extraQueryParams?: any, extraFetchParams?: any ) : Promise<Array<TaxCode>> {
			const localVarPath = this.basePath + '/finance/taxCodes';

			let queryParameters: any = assign({}, extraQueryParams);
			let headerParams: any = assign({}, this.defaultHeaders);
			if (params.conditions !== undefined) {
				queryParameters['conditions'] = params.conditions;
			}

			if (params.orderBy !== undefined) {
				queryParameters['orderBy'] = params.orderBy;
			}

			if (params.childconditions !== undefined) {
				queryParameters['childconditions'] = params.childconditions;
			}

			if (params.customfieldconditions !== undefined) {
				queryParameters['customfieldconditions'] = params.customfieldconditions;
			}

			if (params.page !== undefined) {
				queryParameters['page'] = params.page;
			}

			if (params.pageSize !== undefined) {
				queryParameters['pageSize'] = params.pageSize;
			}

			let fetchParams = {
				method: 'GET',
				headers: headerParams,

			};

			if (extraFetchParams) {
				fetchParams = assign(fetchParams, extraFetchParams);
			}

			let localVarPathWithQueryParameters = localVarPath + (localVarPath.indexOf('?') !== -1 ? '&' : '?') + querystring.stringify(queryParameters);

			return fetch(localVarPathWithQueryParameters, fetchParams).then((response) => {
				if (response.status >= 200 && response.status < 300) {
					return response.json();
				} else {
					let error = new Error(response.statusText);
					(error as any).response = response;
					throw error;
				}
			});
		}
		/**
		 *
		 * Delete Tax Code By Id
		 * @param id
		 */
		public financeTaxCodesIdDelete (params: {  id: number; }, extraQueryParams?: any, extraFetchParams?: any ) : Promise<{}> {
			const localVarPath = this.basePath + '/finance/taxCodes/{id}'
				.replace('{' + 'id' + '}', String(params.id));

			let queryParameters: any = assign({}, extraQueryParams);
			let headerParams: any = assign({}, this.defaultHeaders);
			// verify required parameter 'id' is set
			if (params.id == null) {
				throw new Error('Missing required parameter id when calling financeTaxCodesIdDelete');
			}
			let fetchParams = {
				method: 'DELETE',
				headers: headerParams,

			};

			if (extraFetchParams) {
				fetchParams = assign(fetchParams, extraFetchParams);
			}

			let localVarPathWithQueryParameters = localVarPath + (localVarPath.indexOf('?') !== -1 ? '&' : '?') + querystring.stringify(queryParameters);

			return fetch(localVarPathWithQueryParameters, fetchParams).then((response) => {
				if (response.status >= 200 && response.status < 300) {
					return response.json();
				} else {
					let error = new Error(response.statusText);
					(error as any).response = response;
					throw error;
				}
			});
		}
		/**
		 *
		 * Get Tax Code By Id
		 * @param id
		 */
		public financeTaxCodesIdGet (params: {  id: number; }, extraQueryParams?: any, extraFetchParams?: any ) : Promise<TaxCode> {
			const localVarPath = this.basePath + '/finance/taxCodes/{id}'
				.replace('{' + 'id' + '}', String(params.id));

			let queryParameters: any = assign({}, extraQueryParams);
			let headerParams: any = assign({}, this.defaultHeaders);
			// verify required parameter 'id' is set
			if (params.id == null) {
				throw new Error('Missing required parameter id when calling financeTaxCodesIdGet');
			}
			let fetchParams = {
				method: 'GET',
				headers: headerParams,

			};

			if (extraFetchParams) {
				fetchParams = assign(fetchParams, extraFetchParams);
			}

			let localVarPathWithQueryParameters = localVarPath + (localVarPath.indexOf('?') !== -1 ? '&' : '?') + querystring.stringify(queryParameters);

			return fetch(localVarPathWithQueryParameters, fetchParams).then((response) => {
				if (response.status >= 200 && response.status < 300) {
					return response.json();
				} else {
					let error = new Error(response.statusText);
					(error as any).response = response;
					throw error;
				}
			});
		}
		/**
		 *
		 * Update Tax Code
		 * @param id
		 * @param operations
		 */
		public financeTaxCodesIdPatch (params: {  id: number; operations: Array<PatchOperation>; }, extraQueryParams?: any, extraFetchParams?: any ) : Promise<TaxCode> {
			const localVarPath = this.basePath + '/finance/taxCodes/{id}'
				.replace('{' + 'id' + '}', String(params.id));

			let queryParameters: any = assign({}, extraQueryParams);
			let headerParams: any = assign({}, this.defaultHeaders);
			headerParams['Content-Type'] = 'application/json';

			// verify required parameter 'id' is set
			if (params.id == null) {
				throw new Error('Missing required parameter id when calling financeTaxCodesIdPatch');
			}
			// verify required parameter 'operations' is set
			if (params.operations == null) {
				throw new Error('Missing required parameter operations when calling financeTaxCodesIdPatch');
			}
			let fetchParams = {
				method: 'PATCH',
				headers: headerParams,
				body: JSON.stringify(params.operations),

			};

			if (extraFetchParams) {
				fetchParams = assign(fetchParams, extraFetchParams);
			}

			let localVarPathWithQueryParameters = localVarPath + (localVarPath.indexOf('?') !== -1 ? '&' : '?') + querystring.stringify(queryParameters);

			return fetch(localVarPathWithQueryParameters, fetchParams).then((response) => {
				if (response.status >= 200 && response.status < 300) {
					return response.json();
				} else {
					let error = new Error(response.statusText);
					(error as any).response = response;
					throw error;
				}
			});
		}
		/**
		 *
		 * Replace Tax Code
		 * @param id
		 * @param taxCode
		 */
		public financeTaxCodesIdPut (params: {  id: number; taxCode: TaxCode; }, extraQueryParams?: any, extraFetchParams?: any ) : Promise<TaxCode> {
			const localVarPath = this.basePath + '/finance/taxCodes/{id}'
				.replace('{' + 'id' + '}', String(params.id));

			let queryParameters: any = assign({}, extraQueryParams);
			let headerParams: any = assign({}, this.defaultHeaders);
			headerParams['Content-Type'] = 'application/json';

			// verify required parameter 'id' is set
			if (params.id == null) {
				throw new Error('Missing required parameter id when calling financeTaxCodesIdPut');
			}
			// verify required parameter 'taxCode' is set
			if (params.taxCode == null) {
				throw new Error('Missing required parameter taxCode when calling financeTaxCodesIdPut');
			}
			let fetchParams = {
				method: 'PUT',
				headers: headerParams,
				body: JSON.stringify(params.taxCode),

			};

			if (extraFetchParams) {
				fetchParams = assign(fetchParams, extraFetchParams);
			}

			let localVarPathWithQueryParameters = localVarPath + (localVarPath.indexOf('?') !== -1 ? '&' : '?') + querystring.stringify(queryParameters);

			return fetch(localVarPathWithQueryParameters, fetchParams).then((response) => {
				if (response.status >= 200 && response.status < 300) {
					return response.json();
				} else {
					let error = new Error(response.statusText);
					(error as any).response = response;
					throw error;
				}
			});
		}
		/**
		 *
		 * Create Tax Code
		 * @param taxCode
		 */
		public financeTaxCodesPost (params: {  taxCode: TaxCode; }, extraQueryParams?: any, extraFetchParams?: any ) : Promise<TaxCode> {
			const localVarPath = this.basePath + '/finance/taxCodes';

			let queryParameters: any = assign({}, extraQueryParams);
			let headerParams: any = assign({}, this.defaultHeaders);
			headerParams['Content-Type'] = 'application/json';

			// verify required parameter 'taxCode' is set
			if (params.taxCode == null) {
				throw new Error('Missing required parameter taxCode when calling financeTaxCodesPost');
			}
			let fetchParams = {
				method: 'POST',
				headers: headerParams,
				body: JSON.stringify(params.taxCode),

			};

			if (extraFetchParams) {
				fetchParams = assign(fetchParams, extraFetchParams);
			}

			let localVarPathWithQueryParameters = localVarPath + (localVarPath.indexOf('?') !== -1 ? '&' : '?') + querystring.stringify(queryParameters);

			return fetch(localVarPathWithQueryParameters, fetchParams).then((response) => {
				if (response.status >= 200 && response.status < 300) {
					return response.json();
				} else {
					let error = new Error(response.statusText);
					(error as any).response = response;
					throw error;
				}
			});
		}
	}
//}
//export namespace  {
	'use strict';

	export class TeamRolesApi {
		protected basePath = 'https://api-na.myconnectwise.net/v4_6_release/apis/3.0';
		public defaultHeaders : any = {};

		constructor(basePath?: string) {
			if (basePath) {
				this.basePath = basePath;
			}
		}

		/**
		 *
		 * Get Team Role Count
		 * @param conditions
		 */
		public companyTeamRolesCountGet (params: {  conditions?: string; }, extraQueryParams?: any, extraFetchParams?: any ) : Promise<Count> {
			const localVarPath = this.basePath + '/company/teamRoles/count';

			let queryParameters: any = assign({}, extraQueryParams);
			let headerParams: any = assign({}, this.defaultHeaders);
			if (params.conditions !== undefined) {
				queryParameters['conditions'] = params.conditions;
			}

			let fetchParams = {
				method: 'GET',
				headers: headerParams,

			};

			if (extraFetchParams) {
				fetchParams = assign(fetchParams, extraFetchParams);
			}

			let localVarPathWithQueryParameters = localVarPath + (localVarPath.indexOf('?') !== -1 ? '&' : '?') + querystring.stringify(queryParameters);

			return fetch(localVarPathWithQueryParameters, fetchParams).then((response) => {
				if (response.status >= 200 && response.status < 300) {
					return response.json();
				} else {
					let error = new Error(response.statusText);
					(error as any).response = response;
					throw error;
				}
			});
		}
		/**
		 *
		 * Get Team Role
		 * @param conditions
		 * @param orderBy
		 * @param childconditions
		 * @param customfieldconditions
		 * @param page
		 * @param pageSize
		 */
		public companyTeamRolesGet (params: {  conditions?: string; orderBy?: string; childconditions?: string; customfieldconditions?: string; page?: number; pageSize?: number; }, extraQueryParams?: any, extraFetchParams?: any ) : Promise<Array<TeamRole>> {
			const localVarPath = this.basePath + '/company/teamRoles';

			let queryParameters: any = assign({}, extraQueryParams);
			let headerParams: any = assign({}, this.defaultHeaders);
			if (params.conditions !== undefined) {
				queryParameters['conditions'] = params.conditions;
			}

			if (params.orderBy !== undefined) {
				queryParameters['orderBy'] = params.orderBy;
			}

			if (params.childconditions !== undefined) {
				queryParameters['childconditions'] = params.childconditions;
			}

			if (params.customfieldconditions !== undefined) {
				queryParameters['customfieldconditions'] = params.customfieldconditions;
			}

			if (params.page !== undefined) {
				queryParameters['page'] = params.page;
			}

			if (params.pageSize !== undefined) {
				queryParameters['pageSize'] = params.pageSize;
			}

			let fetchParams = {
				method: 'GET',
				headers: headerParams,

			};

			if (extraFetchParams) {
				fetchParams = assign(fetchParams, extraFetchParams);
			}

			let localVarPathWithQueryParameters = localVarPath + (localVarPath.indexOf('?') !== -1 ? '&' : '?') + querystring.stringify(queryParameters);

			return fetch(localVarPathWithQueryParameters, fetchParams).then((response) => {
				if (response.status >= 200 && response.status < 300) {
					return response.json();
				} else {
					let error = new Error(response.statusText);
					(error as any).response = response;
					throw error;
				}
			});
		}
		/**
		 *
		 * Delete Team Role By Id
		 * @param id
		 */
		public companyTeamRolesIdDelete (params: {  id: number; }, extraQueryParams?: any, extraFetchParams?: any ) : Promise<{}> {
			const localVarPath = this.basePath + '/company/teamRoles/{id}'
				.replace('{' + 'id' + '}', String(params.id));

			let queryParameters: any = assign({}, extraQueryParams);
			let headerParams: any = assign({}, this.defaultHeaders);
			// verify required parameter 'id' is set
			if (params.id == null) {
				throw new Error('Missing required parameter id when calling companyTeamRolesIdDelete');
			}
			let fetchParams = {
				method: 'DELETE',
				headers: headerParams,

			};

			if (extraFetchParams) {
				fetchParams = assign(fetchParams, extraFetchParams);
			}

			let localVarPathWithQueryParameters = localVarPath + (localVarPath.indexOf('?') !== -1 ? '&' : '?') + querystring.stringify(queryParameters);

			return fetch(localVarPathWithQueryParameters, fetchParams).then((response) => {
				if (response.status >= 200 && response.status < 300) {
					return response.json();
				} else {
					let error = new Error(response.statusText);
					(error as any).response = response;
					throw error;
				}
			});
		}
		/**
		 *
		 * Get Team Role By Id
		 * @param id
		 */
		public companyTeamRolesIdGet (params: {  id: number; }, extraQueryParams?: any, extraFetchParams?: any ) : Promise<TeamRole> {
			const localVarPath = this.basePath + '/company/teamRoles/{id}'
				.replace('{' + 'id' + '}', String(params.id));

			let queryParameters: any = assign({}, extraQueryParams);
			let headerParams: any = assign({}, this.defaultHeaders);
			// verify required parameter 'id' is set
			if (params.id == null) {
				throw new Error('Missing required parameter id when calling companyTeamRolesIdGet');
			}
			let fetchParams = {
				method: 'GET',
				headers: headerParams,

			};

			if (extraFetchParams) {
				fetchParams = assign(fetchParams, extraFetchParams);
			}

			let localVarPathWithQueryParameters = localVarPath + (localVarPath.indexOf('?') !== -1 ? '&' : '?') + querystring.stringify(queryParameters);

			return fetch(localVarPathWithQueryParameters, fetchParams).then((response) => {
				if (response.status >= 200 && response.status < 300) {
					return response.json();
				} else {
					let error = new Error(response.statusText);
					(error as any).response = response;
					throw error;
				}
			});
		}
		/**
		 *
		 * Update Team Role
		 * @param id
		 * @param operations
		 */
		public companyTeamRolesIdPatch (params: {  id: number; operations: Array<PatchOperation>; }, extraQueryParams?: any, extraFetchParams?: any ) : Promise<TeamRole> {
			const localVarPath = this.basePath + '/company/teamRoles/{id}'
				.replace('{' + 'id' + '}', String(params.id));

			let queryParameters: any = assign({}, extraQueryParams);
			let headerParams: any = assign({}, this.defaultHeaders);
			headerParams['Content-Type'] = 'application/json';

			// verify required parameter 'id' is set
			if (params.id == null) {
				throw new Error('Missing required parameter id when calling companyTeamRolesIdPatch');
			}
			// verify required parameter 'operations' is set
			if (params.operations == null) {
				throw new Error('Missing required parameter operations when calling companyTeamRolesIdPatch');
			}
			let fetchParams = {
				method: 'PATCH',
				headers: headerParams,
				body: JSON.stringify(params.operations),

			};

			if (extraFetchParams) {
				fetchParams = assign(fetchParams, extraFetchParams);
			}

			let localVarPathWithQueryParameters = localVarPath + (localVarPath.indexOf('?') !== -1 ? '&' : '?') + querystring.stringify(queryParameters);

			return fetch(localVarPathWithQueryParameters, fetchParams).then((response) => {
				if (response.status >= 200 && response.status < 300) {
					return response.json();
				} else {
					let error = new Error(response.statusText);
					(error as any).response = response;
					throw error;
				}
			});
		}
		/**
		 *
		 * Replace Team Role
		 * @param id
		 * @param teamRole
		 */
		public companyTeamRolesIdPut (params: {  id: number; teamRole: TeamRole; }, extraQueryParams?: any, extraFetchParams?: any ) : Promise<TeamRole> {
			const localVarPath = this.basePath + '/company/teamRoles/{id}'
				.replace('{' + 'id' + '}', String(params.id));

			let queryParameters: any = assign({}, extraQueryParams);
			let headerParams: any = assign({}, this.defaultHeaders);
			headerParams['Content-Type'] = 'application/json';

			// verify required parameter 'id' is set
			if (params.id == null) {
				throw new Error('Missing required parameter id when calling companyTeamRolesIdPut');
			}
			// verify required parameter 'teamRole' is set
			if (params.teamRole == null) {
				throw new Error('Missing required parameter teamRole when calling companyTeamRolesIdPut');
			}
			let fetchParams = {
				method: 'PUT',
				headers: headerParams,
				body: JSON.stringify(params.teamRole),

			};

			if (extraFetchParams) {
				fetchParams = assign(fetchParams, extraFetchParams);
			}

			let localVarPathWithQueryParameters = localVarPath + (localVarPath.indexOf('?') !== -1 ? '&' : '?') + querystring.stringify(queryParameters);

			return fetch(localVarPathWithQueryParameters, fetchParams).then((response) => {
				if (response.status >= 200 && response.status < 300) {
					return response.json();
				} else {
					let error = new Error(response.statusText);
					(error as any).response = response;
					throw error;
				}
			});
		}
		/**
		 *
		 * Create Team Role
		 * @param teamRole
		 */
		public companyTeamRolesPost (params: {  teamRole: TeamRole; }, extraQueryParams?: any, extraFetchParams?: any ) : Promise<TeamRole> {
			const localVarPath = this.basePath + '/company/teamRoles';

			let queryParameters: any = assign({}, extraQueryParams);
			let headerParams: any = assign({}, this.defaultHeaders);
			headerParams['Content-Type'] = 'application/json';

			// verify required parameter 'teamRole' is set
			if (params.teamRole == null) {
				throw new Error('Missing required parameter teamRole when calling companyTeamRolesPost');
			}
			let fetchParams = {
				method: 'POST',
				headers: headerParams,
				body: JSON.stringify(params.teamRole),

			};

			if (extraFetchParams) {
				fetchParams = assign(fetchParams, extraFetchParams);
			}

			let localVarPathWithQueryParameters = localVarPath + (localVarPath.indexOf('?') !== -1 ? '&' : '?') + querystring.stringify(queryParameters);

			return fetch(localVarPathWithQueryParameters, fetchParams).then((response) => {
				if (response.status >= 200 && response.status < 300) {
					return response.json();
				} else {
					let error = new Error(response.statusText);
					(error as any).response = response;
					throw error;
				}
			});
		}
	}
//}
//export namespace  {
	'use strict';

	export class TicketNotesApi {
		protected basePath = 'https://api-na.myconnectwise.net/v4_6_release/apis/3.0';
		public defaultHeaders : any = {};

		constructor(basePath?: string) {
			if (basePath) {
				this.basePath = basePath;
			}
		}

		/**
		 *
		 * Get Service Notes Count
		 * @param id
		 * @param conditions
		 */
		public serviceTicketsIdNotesCountGet (params: {  id: number; conditions?: string; }, extraQueryParams?: any, extraFetchParams?: any ) : Promise<Count> {
			const localVarPath = this.basePath + '/service/tickets/{id}/notes/count'
				.replace('{' + 'id' + '}', String(params.id));

			let queryParameters: any = assign({}, extraQueryParams);
			let headerParams: any = assign({}, this.defaultHeaders);
			// verify required parameter 'id' is set
			if (params.id == null) {
				throw new Error('Missing required parameter id when calling serviceTicketsIdNotesCountGet');
			}
			if (params.conditions !== undefined) {
				queryParameters['conditions'] = params.conditions;
			}

			let fetchParams = {
				method: 'GET',
				headers: headerParams,

			};

			if (extraFetchParams) {
				fetchParams = assign(fetchParams, extraFetchParams);
			}

			let localVarPathWithQueryParameters = localVarPath + (localVarPath.indexOf('?') !== -1 ? '&' : '?') + querystring.stringify(queryParameters);

			return fetch(localVarPathWithQueryParameters, fetchParams).then((response) => {
				if (response.status >= 200 && response.status < 300) {
					return response.json();
				} else {
					let error = new Error(response.statusText);
					(error as any).response = response;
					throw error;
				}
			});
		}
		/**
		 *
		 * Get Service Notes
		 * @param id
		 * @param conditions
		 * @param orderBy
		 * @param childconditions
		 * @param customfieldconditions
		 * @param page
		 * @param pageSize
		 */
		public serviceTicketsIdNotesGet (params: {  id: number; conditions?: string; orderBy?: string; childconditions?: string; customfieldconditions?: string; page?: number; pageSize?: number; }, extraQueryParams?: any, extraFetchParams?: any ) : Promise<Array<ServiceNote>> {
			const localVarPath = this.basePath + '/service/tickets/{id}/notes'
				.replace('{' + 'id' + '}', String(params.id));

			let queryParameters: any = assign({}, extraQueryParams);
			let headerParams: any = assign({}, this.defaultHeaders);
			// verify required parameter 'id' is set
			if (params.id == null) {
				throw new Error('Missing required parameter id when calling serviceTicketsIdNotesGet');
			}
			if (params.conditions !== undefined) {
				queryParameters['conditions'] = params.conditions;
			}

			if (params.orderBy !== undefined) {
				queryParameters['orderBy'] = params.orderBy;
			}

			if (params.childconditions !== undefined) {
				queryParameters['childconditions'] = params.childconditions;
			}

			if (params.customfieldconditions !== undefined) {
				queryParameters['customfieldconditions'] = params.customfieldconditions;
			}

			if (params.page !== undefined) {
				queryParameters['page'] = params.page;
			}

			if (params.pageSize !== undefined) {
				queryParameters['pageSize'] = params.pageSize;
			}

			let fetchParams = {
				method: 'GET',
				headers: headerParams,

			};

			if (extraFetchParams) {
				fetchParams = assign(fetchParams, extraFetchParams);
			}

			let localVarPathWithQueryParameters = localVarPath + (localVarPath.indexOf('?') !== -1 ? '&' : '?') + querystring.stringify(queryParameters);

			return fetch(localVarPathWithQueryParameters, fetchParams).then((response) => {
				if (response.status >= 200 && response.status < 300) {
					return response.json();
				} else {
					let error = new Error(response.statusText);
					(error as any).response = response;
					throw error;
				}
			});
		}
		/**
		 *
		 * Delete Service Note By Id
		 * @param id
		 * @param noteId
		 */
		public serviceTicketsIdNotesNoteIdDelete (params: {  id: number; noteId: number; }, extraQueryParams?: any, extraFetchParams?: any ) : Promise<{}> {
			const localVarPath = this.basePath + '/service/tickets/{id}/notes/{noteId}'
				.replace('{' + 'id' + '}', String(params.id))
				.replace('{' + 'noteId' + '}', String(params.noteId));

			let queryParameters: any = assign({}, extraQueryParams);
			let headerParams: any = assign({}, this.defaultHeaders);
			// verify required parameter 'id' is set
			if (params.id == null) {
				throw new Error('Missing required parameter id when calling serviceTicketsIdNotesNoteIdDelete');
			}
			// verify required parameter 'noteId' is set
			if (params.noteId == null) {
				throw new Error('Missing required parameter noteId when calling serviceTicketsIdNotesNoteIdDelete');
			}
			let fetchParams = {
				method: 'DELETE',
				headers: headerParams,

			};

			if (extraFetchParams) {
				fetchParams = assign(fetchParams, extraFetchParams);
			}

			let localVarPathWithQueryParameters = localVarPath + (localVarPath.indexOf('?') !== -1 ? '&' : '?') + querystring.stringify(queryParameters);

			return fetch(localVarPathWithQueryParameters, fetchParams).then((response) => {
				if (response.status >= 200 && response.status < 300) {
					return response.json();
				} else {
					let error = new Error(response.statusText);
					(error as any).response = response;
					throw error;
				}
			});
		}
		/**
		 *
		 * Get Service Note By Id
		 * @param id
		 * @param noteId
		 */
		public serviceTicketsIdNotesNoteIdGet (params: {  id: number; noteId: number; }, extraQueryParams?: any, extraFetchParams?: any ) : Promise<ServiceNote> {
			const localVarPath = this.basePath + '/service/tickets/{id}/notes/{noteId}'
				.replace('{' + 'id' + '}', String(params.id))
				.replace('{' + 'noteId' + '}', String(params.noteId));

			let queryParameters: any = assign({}, extraQueryParams);
			let headerParams: any = assign({}, this.defaultHeaders);
			// verify required parameter 'id' is set
			if (params.id == null) {
				throw new Error('Missing required parameter id when calling serviceTicketsIdNotesNoteIdGet');
			}
			// verify required parameter 'noteId' is set
			if (params.noteId == null) {
				throw new Error('Missing required parameter noteId when calling serviceTicketsIdNotesNoteIdGet');
			}
			let fetchParams = {
				method: 'GET',
				headers: headerParams,

			};

			if (extraFetchParams) {
				fetchParams = assign(fetchParams, extraFetchParams);
			}

			let localVarPathWithQueryParameters = localVarPath + (localVarPath.indexOf('?') !== -1 ? '&' : '?') + querystring.stringify(queryParameters);

			return fetch(localVarPathWithQueryParameters, fetchParams).then((response) => {
				if (response.status >= 200 && response.status < 300) {
					return response.json();
				} else {
					let error = new Error(response.statusText);
					(error as any).response = response;
					throw error;
				}
			});
		}
		/**
		 *
		 * Update Service Note
		 * @param id
		 * @param noteId
		 * @param operations
		 */
		public serviceTicketsIdNotesNoteIdPatch (params: {  id: number; noteId: number; operations: Array<PatchOperation>; }, extraQueryParams?: any, extraFetchParams?: any ) : Promise<ServiceNote> {
			const localVarPath = this.basePath + '/service/tickets/{id}/notes/{noteId}'
				.replace('{' + 'id' + '}', String(params.id))
				.replace('{' + 'noteId' + '}', String(params.noteId));

			let queryParameters: any = assign({}, extraQueryParams);
			let headerParams: any = assign({}, this.defaultHeaders);
			headerParams['Content-Type'] = 'application/json';

			// verify required parameter 'id' is set
			if (params.id == null) {
				throw new Error('Missing required parameter id when calling serviceTicketsIdNotesNoteIdPatch');
			}
			// verify required parameter 'noteId' is set
			if (params.noteId == null) {
				throw new Error('Missing required parameter noteId when calling serviceTicketsIdNotesNoteIdPatch');
			}
			// verify required parameter 'operations' is set
			if (params.operations == null) {
				throw new Error('Missing required parameter operations when calling serviceTicketsIdNotesNoteIdPatch');
			}
			let fetchParams = {
				method: 'PATCH',
				headers: headerParams,
				body: JSON.stringify(params.operations),

			};

			if (extraFetchParams) {
				fetchParams = assign(fetchParams, extraFetchParams);
			}

			let localVarPathWithQueryParameters = localVarPath + (localVarPath.indexOf('?') !== -1 ? '&' : '?') + querystring.stringify(queryParameters);

			return fetch(localVarPathWithQueryParameters, fetchParams).then((response) => {
				if (response.status >= 200 && response.status < 300) {
					return response.json();
				} else {
					let error = new Error(response.statusText);
					(error as any).response = response;
					throw error;
				}
			});
		}
		/**
		 *
		 * Replace Service Note
		 * @param id
		 * @param noteId
		 * @param serviceNote
		 */
		public serviceTicketsIdNotesNoteIdPut (params: {  id: number; noteId: number; serviceNote: ServiceNote; }, extraQueryParams?: any, extraFetchParams?: any ) : Promise<ServiceNote> {
			const localVarPath = this.basePath + '/service/tickets/{id}/notes/{noteId}'
				.replace('{' + 'id' + '}', String(params.id))
				.replace('{' + 'noteId' + '}', String(params.noteId));

			let queryParameters: any = assign({}, extraQueryParams);
			let headerParams: any = assign({}, this.defaultHeaders);
			headerParams['Content-Type'] = 'application/json';

			// verify required parameter 'id' is set
			if (params.id == null) {
				throw new Error('Missing required parameter id when calling serviceTicketsIdNotesNoteIdPut');
			}
			// verify required parameter 'noteId' is set
			if (params.noteId == null) {
				throw new Error('Missing required parameter noteId when calling serviceTicketsIdNotesNoteIdPut');
			}
			// verify required parameter 'serviceNote' is set
			if (params.serviceNote == null) {
				throw new Error('Missing required parameter serviceNote when calling serviceTicketsIdNotesNoteIdPut');
			}
			let fetchParams = {
				method: 'PUT',
				headers: headerParams,
				body: JSON.stringify(params.serviceNote),

			};

			if (extraFetchParams) {
				fetchParams = assign(fetchParams, extraFetchParams);
			}

			let localVarPathWithQueryParameters = localVarPath + (localVarPath.indexOf('?') !== -1 ? '&' : '?') + querystring.stringify(queryParameters);

			return fetch(localVarPathWithQueryParameters, fetchParams).then((response) => {
				if (response.status >= 200 && response.status < 300) {
					return response.json();
				} else {
					let error = new Error(response.statusText);
					(error as any).response = response;
					throw error;
				}
			});
		}
		/**
		 *
		 * Create Service Note
		 * @param id
		 * @param serviceNote
		 */
		public serviceTicketsIdNotesPost (params: {  id: number; serviceNote: ServiceNote; }, extraQueryParams?: any, extraFetchParams?: any ) : Promise<ServiceNote> {
			const localVarPath = this.basePath + '/service/tickets/{id}/notes'
				.replace('{' + 'id' + '}', String(params.id));

			let queryParameters: any = assign({}, extraQueryParams);
			let headerParams: any = assign({}, this.defaultHeaders);
			headerParams['Content-Type'] = 'application/json';

			// verify required parameter 'id' is set
			if (params.id == null) {
				throw new Error('Missing required parameter id when calling serviceTicketsIdNotesPost');
			}
			// verify required parameter 'serviceNote' is set
			if (params.serviceNote == null) {
				throw new Error('Missing required parameter serviceNote when calling serviceTicketsIdNotesPost');
			}
			let fetchParams = {
				method: 'POST',
				headers: headerParams,
				body: JSON.stringify(params.serviceNote),

			};

			if (extraFetchParams) {
				fetchParams = assign(fetchParams, extraFetchParams);
			}

			let localVarPathWithQueryParameters = localVarPath + (localVarPath.indexOf('?') !== -1 ? '&' : '?') + querystring.stringify(queryParameters);

			return fetch(localVarPathWithQueryParameters, fetchParams).then((response) => {
				if (response.status >= 200 && response.status < 300) {
					return response.json();
				} else {
					let error = new Error(response.statusText);
					(error as any).response = response;
					throw error;
				}
			});
		}
	}
//}
//export namespace  {
	'use strict';

	export class TicketStopwatchesApi {
		protected basePath = 'https://api-na.myconnectwise.net/v4_6_release/apis/3.0';
		public defaultHeaders : any = {};

		constructor(basePath?: string) {
			if (basePath) {
				this.basePath = basePath;
			}
		}

		/**
		 *
		 * Get Ticket Stopwatches Count
		 * @param conditions
		 */
		public timeTicketstopwatchesCountGet (params: {  conditions?: string; }, extraQueryParams?: any, extraFetchParams?: any ) : Promise<Count> {
			const localVarPath = this.basePath + '/time/ticketstopwatches/count';

			let queryParameters: any = assign({}, extraQueryParams);
			let headerParams: any = assign({}, this.defaultHeaders);
			if (params.conditions !== undefined) {
				queryParameters['conditions'] = params.conditions;
			}

			let fetchParams = {
				method: 'GET',
				headers: headerParams,

			};

			if (extraFetchParams) {
				fetchParams = assign(fetchParams, extraFetchParams);
			}

			let localVarPathWithQueryParameters = localVarPath + (localVarPath.indexOf('?') !== -1 ? '&' : '?') + querystring.stringify(queryParameters);

			return fetch(localVarPathWithQueryParameters, fetchParams).then((response) => {
				if (response.status >= 200 && response.status < 300) {
					return response.json();
				} else {
					let error = new Error(response.statusText);
					(error as any).response = response;
					throw error;
				}
			});
		}
		/**
		 *
		 * Get Ticket Stopwatches
		 * @param conditions
		 * @param orderBy
		 * @param childconditions
		 * @param customfieldconditions
		 * @param page
		 * @param pageSize
		 */
		public timeTicketstopwatchesGet (params: {  conditions?: string; orderBy?: string; childconditions?: string; customfieldconditions?: string; page?: number; pageSize?: number; }, extraQueryParams?: any, extraFetchParams?: any ) : Promise<Array<TicketStopwatch>> {
			const localVarPath = this.basePath + '/time/ticketstopwatches';

			let queryParameters: any = assign({}, extraQueryParams);
			let headerParams: any = assign({}, this.defaultHeaders);
			if (params.conditions !== undefined) {
				queryParameters['conditions'] = params.conditions;
			}

			if (params.orderBy !== undefined) {
				queryParameters['orderBy'] = params.orderBy;
			}

			if (params.childconditions !== undefined) {
				queryParameters['childconditions'] = params.childconditions;
			}

			if (params.customfieldconditions !== undefined) {
				queryParameters['customfieldconditions'] = params.customfieldconditions;
			}

			if (params.page !== undefined) {
				queryParameters['page'] = params.page;
			}

			if (params.pageSize !== undefined) {
				queryParameters['pageSize'] = params.pageSize;
			}

			let fetchParams = {
				method: 'GET',
				headers: headerParams,

			};

			if (extraFetchParams) {
				fetchParams = assign(fetchParams, extraFetchParams);
			}

			let localVarPathWithQueryParameters = localVarPath + (localVarPath.indexOf('?') !== -1 ? '&' : '?') + querystring.stringify(queryParameters);

			return fetch(localVarPathWithQueryParameters, fetchParams).then((response) => {
				if (response.status >= 200 && response.status < 300) {
					return response.json();
				} else {
					let error = new Error(response.statusText);
					(error as any).response = response;
					throw error;
				}
			});
		}
		/**
		 *
		 * Delete Ticket Stopwatch By Id
		 * @param id
		 */
		public timeTicketstopwatchesIdDelete (params: {  id: number; }, extraQueryParams?: any, extraFetchParams?: any ) : Promise<{}> {
			const localVarPath = this.basePath + '/time/ticketstopwatches/{id}'
				.replace('{' + 'id' + '}', String(params.id));

			let queryParameters: any = assign({}, extraQueryParams);
			let headerParams: any = assign({}, this.defaultHeaders);
			// verify required parameter 'id' is set
			if (params.id == null) {
				throw new Error('Missing required parameter id when calling timeTicketstopwatchesIdDelete');
			}
			let fetchParams = {
				method: 'DELETE',
				headers: headerParams,

			};

			if (extraFetchParams) {
				fetchParams = assign(fetchParams, extraFetchParams);
			}

			let localVarPathWithQueryParameters = localVarPath + (localVarPath.indexOf('?') !== -1 ? '&' : '?') + querystring.stringify(queryParameters);

			return fetch(localVarPathWithQueryParameters, fetchParams).then((response) => {
				if (response.status >= 200 && response.status < 300) {
					return response.json();
				} else {
					let error = new Error(response.statusText);
					(error as any).response = response;
					throw error;
				}
			});
		}
		/**
		 *
		 * Get Ticket Stopwatch By Id
		 * @param id
		 */
		public timeTicketstopwatchesIdGet (params: {  id: number; }, extraQueryParams?: any, extraFetchParams?: any ) : Promise<TicketStopwatch> {
			const localVarPath = this.basePath + '/time/ticketstopwatches/{id}'
				.replace('{' + 'id' + '}', String(params.id));

			let queryParameters: any = assign({}, extraQueryParams);
			let headerParams: any = assign({}, this.defaultHeaders);
			// verify required parameter 'id' is set
			if (params.id == null) {
				throw new Error('Missing required parameter id when calling timeTicketstopwatchesIdGet');
			}
			let fetchParams = {
				method: 'GET',
				headers: headerParams,

			};

			if (extraFetchParams) {
				fetchParams = assign(fetchParams, extraFetchParams);
			}

			let localVarPathWithQueryParameters = localVarPath + (localVarPath.indexOf('?') !== -1 ? '&' : '?') + querystring.stringify(queryParameters);

			return fetch(localVarPathWithQueryParameters, fetchParams).then((response) => {
				if (response.status >= 200 && response.status < 300) {
					return response.json();
				} else {
					let error = new Error(response.statusText);
					(error as any).response = response;
					throw error;
				}
			});
		}
		/**
		 *
		 * Update Ticket Stopwatch
		 * @param id
		 * @param operations
		 */
		public timeTicketstopwatchesIdPatch (params: {  id: number; operations: Array<PatchOperation>; }, extraQueryParams?: any, extraFetchParams?: any ) : Promise<TicketStopwatch> {
			const localVarPath = this.basePath + '/time/ticketstopwatches/{id}'
				.replace('{' + 'id' + '}', String(params.id));

			let queryParameters: any = assign({}, extraQueryParams);
			let headerParams: any = assign({}, this.defaultHeaders);
			headerParams['Content-Type'] = 'application/json';

			// verify required parameter 'id' is set
			if (params.id == null) {
				throw new Error('Missing required parameter id when calling timeTicketstopwatchesIdPatch');
			}
			// verify required parameter 'operations' is set
			if (params.operations == null) {
				throw new Error('Missing required parameter operations when calling timeTicketstopwatchesIdPatch');
			}
			let fetchParams = {
				method: 'PATCH',
				headers: headerParams,
				body: JSON.stringify(params.operations),

			};

			if (extraFetchParams) {
				fetchParams = assign(fetchParams, extraFetchParams);
			}

			let localVarPathWithQueryParameters = localVarPath + (localVarPath.indexOf('?') !== -1 ? '&' : '?') + querystring.stringify(queryParameters);

			return fetch(localVarPathWithQueryParameters, fetchParams).then((response) => {
				if (response.status >= 200 && response.status < 300) {
					return response.json();
				} else {
					let error = new Error(response.statusText);
					(error as any).response = response;
					throw error;
				}
			});
		}
		/**
		 *
		 * Replace Ticket Stopwatch
		 * @param id
		 * @param ticketStopwatch
		 */
		public timeTicketstopwatchesIdPut (params: {  id: number; ticketStopwatch: TicketStopwatch; }, extraQueryParams?: any, extraFetchParams?: any ) : Promise<TicketStopwatch> {
			const localVarPath = this.basePath + '/time/ticketstopwatches/{id}'
				.replace('{' + 'id' + '}', String(params.id));

			let queryParameters: any = assign({}, extraQueryParams);
			let headerParams: any = assign({}, this.defaultHeaders);
			headerParams['Content-Type'] = 'application/json';

			// verify required parameter 'id' is set
			if (params.id == null) {
				throw new Error('Missing required parameter id when calling timeTicketstopwatchesIdPut');
			}
			// verify required parameter 'ticketStopwatch' is set
			if (params.ticketStopwatch == null) {
				throw new Error('Missing required parameter ticketStopwatch when calling timeTicketstopwatchesIdPut');
			}
			let fetchParams = {
				method: 'PUT',
				headers: headerParams,
				body: JSON.stringify(params.ticketStopwatch),

			};

			if (extraFetchParams) {
				fetchParams = assign(fetchParams, extraFetchParams);
			}

			let localVarPathWithQueryParameters = localVarPath + (localVarPath.indexOf('?') !== -1 ? '&' : '?') + querystring.stringify(queryParameters);

			return fetch(localVarPathWithQueryParameters, fetchParams).then((response) => {
				if (response.status >= 200 && response.status < 300) {
					return response.json();
				} else {
					let error = new Error(response.statusText);
					(error as any).response = response;
					throw error;
				}
			});
		}
		/**
		 *
		 * Create Ticket Stopwatch
		 * @param ticketStopwatch
		 */
		public timeTicketstopwatchesPost (params: {  ticketStopwatch: TicketStopwatch; }, extraQueryParams?: any, extraFetchParams?: any ) : Promise<TicketStopwatch> {
			const localVarPath = this.basePath + '/time/ticketstopwatches';

			let queryParameters: any = assign({}, extraQueryParams);
			let headerParams: any = assign({}, this.defaultHeaders);
			headerParams['Content-Type'] = 'application/json';

			// verify required parameter 'ticketStopwatch' is set
			if (params.ticketStopwatch == null) {
				throw new Error('Missing required parameter ticketStopwatch when calling timeTicketstopwatchesPost');
			}
			let fetchParams = {
				method: 'POST',
				headers: headerParams,
				body: JSON.stringify(params.ticketStopwatch),

			};

			if (extraFetchParams) {
				fetchParams = assign(fetchParams, extraFetchParams);
			}

			let localVarPathWithQueryParameters = localVarPath + (localVarPath.indexOf('?') !== -1 ? '&' : '?') + querystring.stringify(queryParameters);

			return fetch(localVarPathWithQueryParameters, fetchParams).then((response) => {
				if (response.status >= 200 && response.status < 300) {
					return response.json();
				} else {
					let error = new Error(response.statusText);
					(error as any).response = response;
					throw error;
				}
			});
		}
	}
//}
//export namespace  {
	'use strict';

	export class TicketTasksApi {
		protected basePath = 'https://api-na.myconnectwise.net/v4_6_release/apis/3.0';
		public defaultHeaders : any = {};

		constructor(basePath?: string) {
			if (basePath) {
				this.basePath = basePath;
			}
		}

		/**
		 *
		 * Get Tasks Count
		 * @param id
		 * @param conditions
		 */
		public serviceTicketsIdTasksCountGet (params: {  id: number; conditions?: string; }, extraQueryParams?: any, extraFetchParams?: any ) : Promise<Count> {
			const localVarPath = this.basePath + '/service/tickets/{id}/tasks/count'
				.replace('{' + 'id' + '}', String(params.id));

			let queryParameters: any = assign({}, extraQueryParams);
			let headerParams: any = assign({}, this.defaultHeaders);
			// verify required parameter 'id' is set
			if (params.id == null) {
				throw new Error('Missing required parameter id when calling serviceTicketsIdTasksCountGet');
			}
			if (params.conditions !== undefined) {
				queryParameters['conditions'] = params.conditions;
			}

			let fetchParams = {
				method: 'GET',
				headers: headerParams,

			};

			if (extraFetchParams) {
				fetchParams = assign(fetchParams, extraFetchParams);
			}

			let localVarPathWithQueryParameters = localVarPath + (localVarPath.indexOf('?') !== -1 ? '&' : '?') + querystring.stringify(queryParameters);

			return fetch(localVarPathWithQueryParameters, fetchParams).then((response) => {
				if (response.status >= 200 && response.status < 300) {
					return response.json();
				} else {
					let error = new Error(response.statusText);
					(error as any).response = response;
					throw error;
				}
			});
		}
		/**
		 *
		 * Get Tasks
		 * @param id
		 * @param conditions
		 * @param orderBy
		 * @param childconditions
		 * @param customfieldconditions
		 * @param page
		 * @param pageSize
		 */
		public serviceTicketsIdTasksGet (params: {  id: number; conditions?: string; orderBy?: string; childconditions?: string; customfieldconditions?: string; page?: number; pageSize?: number; }, extraQueryParams?: any, extraFetchParams?: any ) : Promise<Array<Task>> {
			const localVarPath = this.basePath + '/service/tickets/{id}/tasks'
				.replace('{' + 'id' + '}', String(params.id));

			let queryParameters: any = assign({}, extraQueryParams);
			let headerParams: any = assign({}, this.defaultHeaders);
			// verify required parameter 'id' is set
			if (params.id == null) {
				throw new Error('Missing required parameter id when calling serviceTicketsIdTasksGet');
			}
			if (params.conditions !== undefined) {
				queryParameters['conditions'] = params.conditions;
			}

			if (params.orderBy !== undefined) {
				queryParameters['orderBy'] = params.orderBy;
			}

			if (params.childconditions !== undefined) {
				queryParameters['childconditions'] = params.childconditions;
			}

			if (params.customfieldconditions !== undefined) {
				queryParameters['customfieldconditions'] = params.customfieldconditions;
			}

			if (params.page !== undefined) {
				queryParameters['page'] = params.page;
			}

			if (params.pageSize !== undefined) {
				queryParameters['pageSize'] = params.pageSize;
			}

			let fetchParams = {
				method: 'GET',
				headers: headerParams,

			};

			if (extraFetchParams) {
				fetchParams = assign(fetchParams, extraFetchParams);
			}

			let localVarPathWithQueryParameters = localVarPath + (localVarPath.indexOf('?') !== -1 ? '&' : '?') + querystring.stringify(queryParameters);

			return fetch(localVarPathWithQueryParameters, fetchParams).then((response) => {
				if (response.status >= 200 && response.status < 300) {
					return response.json();
				} else {
					let error = new Error(response.statusText);
					(error as any).response = response;
					throw error;
				}
			});
		}
		/**
		 *
		 * Create Task
		 * @param id
		 * @param task
		 */
		public serviceTicketsIdTasksPost (params: {  id: number; task: Task; }, extraQueryParams?: any, extraFetchParams?: any ) : Promise<Task> {
			const localVarPath = this.basePath + '/service/tickets/{id}/tasks'
				.replace('{' + 'id' + '}', String(params.id));

			let queryParameters: any = assign({}, extraQueryParams);
			let headerParams: any = assign({}, this.defaultHeaders);
			headerParams['Content-Type'] = 'application/json';

			// verify required parameter 'id' is set
			if (params.id == null) {
				throw new Error('Missing required parameter id when calling serviceTicketsIdTasksPost');
			}
			// verify required parameter 'task' is set
			if (params.task == null) {
				throw new Error('Missing required parameter task when calling serviceTicketsIdTasksPost');
			}
			let fetchParams = {
				method: 'POST',
				headers: headerParams,
				body: JSON.stringify(params.task),

			};

			if (extraFetchParams) {
				fetchParams = assign(fetchParams, extraFetchParams);
			}

			let localVarPathWithQueryParameters = localVarPath + (localVarPath.indexOf('?') !== -1 ? '&' : '?') + querystring.stringify(queryParameters);

			return fetch(localVarPathWithQueryParameters, fetchParams).then((response) => {
				if (response.status >= 200 && response.status < 300) {
					return response.json();
				} else {
					let error = new Error(response.statusText);
					(error as any).response = response;
					throw error;
				}
			});
		}
		/**
		 *
		 * Delete Task By Id
		 * @param id
		 * @param taskId
		 */
		public serviceTicketsIdTasksTaskIdDelete (params: {  id: number; taskId: number; }, extraQueryParams?: any, extraFetchParams?: any ) : Promise<{}> {
			const localVarPath = this.basePath + '/service/tickets/{id}/tasks/{taskId}'
				.replace('{' + 'id' + '}', String(params.id))
				.replace('{' + 'taskId' + '}', String(params.taskId));

			let queryParameters: any = assign({}, extraQueryParams);
			let headerParams: any = assign({}, this.defaultHeaders);
			// verify required parameter 'id' is set
			if (params.id == null) {
				throw new Error('Missing required parameter id when calling serviceTicketsIdTasksTaskIdDelete');
			}
			// verify required parameter 'taskId' is set
			if (params.taskId == null) {
				throw new Error('Missing required parameter taskId when calling serviceTicketsIdTasksTaskIdDelete');
			}
			let fetchParams = {
				method: 'DELETE',
				headers: headerParams,

			};

			if (extraFetchParams) {
				fetchParams = assign(fetchParams, extraFetchParams);
			}

			let localVarPathWithQueryParameters = localVarPath + (localVarPath.indexOf('?') !== -1 ? '&' : '?') + querystring.stringify(queryParameters);

			return fetch(localVarPathWithQueryParameters, fetchParams).then((response) => {
				if (response.status >= 200 && response.status < 300) {
					return response.json();
				} else {
					let error = new Error(response.statusText);
					(error as any).response = response;
					throw error;
				}
			});
		}
		/**
		 *
		 * Get Task By Id
		 * @param id
		 * @param taskId
		 */
		public serviceTicketsIdTasksTaskIdGet (params: {  id: number; taskId: number; }, extraQueryParams?: any, extraFetchParams?: any ) : Promise<Task> {
			const localVarPath = this.basePath + '/service/tickets/{id}/tasks/{taskId}'
				.replace('{' + 'id' + '}', String(params.id))
				.replace('{' + 'taskId' + '}', String(params.taskId));

			let queryParameters: any = assign({}, extraQueryParams);
			let headerParams: any = assign({}, this.defaultHeaders);
			// verify required parameter 'id' is set
			if (params.id == null) {
				throw new Error('Missing required parameter id when calling serviceTicketsIdTasksTaskIdGet');
			}
			// verify required parameter 'taskId' is set
			if (params.taskId == null) {
				throw new Error('Missing required parameter taskId when calling serviceTicketsIdTasksTaskIdGet');
			}
			let fetchParams = {
				method: 'GET',
				headers: headerParams,

			};

			if (extraFetchParams) {
				fetchParams = assign(fetchParams, extraFetchParams);
			}

			let localVarPathWithQueryParameters = localVarPath + (localVarPath.indexOf('?') !== -1 ? '&' : '?') + querystring.stringify(queryParameters);

			return fetch(localVarPathWithQueryParameters, fetchParams).then((response) => {
				if (response.status >= 200 && response.status < 300) {
					return response.json();
				} else {
					let error = new Error(response.statusText);
					(error as any).response = response;
					throw error;
				}
			});
		}
		/**
		 *
		 * Update Task
		 * @param id
		 * @param taskId
		 * @param operations
		 */
		public serviceTicketsIdTasksTaskIdPatch (params: {  id: number; taskId: number; operations: Array<PatchOperation>; }, extraQueryParams?: any, extraFetchParams?: any ) : Promise<Task> {
			const localVarPath = this.basePath + '/service/tickets/{id}/tasks/{taskId}'
				.replace('{' + 'id' + '}', String(params.id))
				.replace('{' + 'taskId' + '}', String(params.taskId));

			let queryParameters: any = assign({}, extraQueryParams);
			let headerParams: any = assign({}, this.defaultHeaders);
			headerParams['Content-Type'] = 'application/json';

			// verify required parameter 'id' is set
			if (params.id == null) {
				throw new Error('Missing required parameter id when calling serviceTicketsIdTasksTaskIdPatch');
			}
			// verify required parameter 'taskId' is set
			if (params.taskId == null) {
				throw new Error('Missing required parameter taskId when calling serviceTicketsIdTasksTaskIdPatch');
			}
			// verify required parameter 'operations' is set
			if (params.operations == null) {
				throw new Error('Missing required parameter operations when calling serviceTicketsIdTasksTaskIdPatch');
			}
			let fetchParams = {
				method: 'PATCH',
				headers: headerParams,
				body: JSON.stringify(params.operations),

			};

			if (extraFetchParams) {
				fetchParams = assign(fetchParams, extraFetchParams);
			}

			let localVarPathWithQueryParameters = localVarPath + (localVarPath.indexOf('?') !== -1 ? '&' : '?') + querystring.stringify(queryParameters);

			return fetch(localVarPathWithQueryParameters, fetchParams).then((response) => {
				if (response.status >= 200 && response.status < 300) {
					return response.json();
				} else {
					let error = new Error(response.statusText);
					(error as any).response = response;
					throw error;
				}
			});
		}
		/**
		 *
		 * Replace Task
		 * @param id
		 * @param taskId
		 * @param task
		 */
		public serviceTicketsIdTasksTaskIdPut (params: {  id: number; taskId: number; task: Task; }, extraQueryParams?: any, extraFetchParams?: any ) : Promise<Task> {
			const localVarPath = this.basePath + '/service/tickets/{id}/tasks/{taskId}'
				.replace('{' + 'id' + '}', String(params.id))
				.replace('{' + 'taskId' + '}', String(params.taskId));

			let queryParameters: any = assign({}, extraQueryParams);
			let headerParams: any = assign({}, this.defaultHeaders);
			headerParams['Content-Type'] = 'application/json';

			// verify required parameter 'id' is set
			if (params.id == null) {
				throw new Error('Missing required parameter id when calling serviceTicketsIdTasksTaskIdPut');
			}
			// verify required parameter 'taskId' is set
			if (params.taskId == null) {
				throw new Error('Missing required parameter taskId when calling serviceTicketsIdTasksTaskIdPut');
			}
			// verify required parameter 'task' is set
			if (params.task == null) {
				throw new Error('Missing required parameter task when calling serviceTicketsIdTasksTaskIdPut');
			}
			let fetchParams = {
				method: 'PUT',
				headers: headerParams,
				body: JSON.stringify(params.task),

			};

			if (extraFetchParams) {
				fetchParams = assign(fetchParams, extraFetchParams);
			}

			let localVarPathWithQueryParameters = localVarPath + (localVarPath.indexOf('?') !== -1 ? '&' : '?') + querystring.stringify(queryParameters);

			return fetch(localVarPathWithQueryParameters, fetchParams).then((response) => {
				if (response.status >= 200 && response.status < 300) {
					return response.json();
				} else {
					let error = new Error(response.statusText);
					(error as any).response = response;
					throw error;
				}
			});
		}
	}
//}
//export namespace  {
	'use strict';

	export class TicketsApi {
		protected basePath = 'https://api-na.myconnectwise.net/v4_6_release/apis/3.0';
		public defaultHeaders : any = {};

		constructor(basePath?: string) {
			if (basePath) {
				this.basePath = basePath;
			}
		}

		/**
		 *
		 * Get Tickets Count
		 * @param conditions
		 * @param customFieldConditions
		 */
		public serviceTicketsCountGet (params: {  conditions?: string; customFieldConditions?: string; }, extraQueryParams?: any, extraFetchParams?: any ) : Promise<Count> {
			const localVarPath = this.basePath + '/service/tickets/count';

			let queryParameters: any = assign({}, extraQueryParams);
			let headerParams: any = assign({}, this.defaultHeaders);
			if (params.conditions !== undefined) {
				queryParameters['conditions'] = params.conditions;
			}

			if (params.customFieldConditions !== undefined) {
				queryParameters['customFieldConditions'] = params.customFieldConditions;
			}

			let fetchParams = {
				method: 'GET',
				headers: headerParams,

			};

			if (extraFetchParams) {
				fetchParams = assign(fetchParams, extraFetchParams);
			}

			let localVarPathWithQueryParameters = localVarPath + (localVarPath.indexOf('?') !== -1 ? '&' : '?') + querystring.stringify(queryParameters);

			return fetch(localVarPathWithQueryParameters, fetchParams).then((response) => {
				if (response.status >= 200 && response.status < 300) {
					return response.json();
				} else {
					let error = new Error(response.statusText);
					(error as any).response = response;
					throw error;
				}
			});
		}
		/**
		 *
		 * Get Tickets
		 * @param conditions
		 * @param orderBy
		 * @param childconditions
		 * @param customfieldconditions
		 * @param page
		 * @param pageSize
		 */
		public serviceTicketsGet (params: {  conditions?: string; orderBy?: string; childconditions?: string; customfieldconditions?: string; page?: number; pageSize?: number; }, extraQueryParams?: any, extraFetchParams?: any ) : Promise<Array<Ticket>> {
			const localVarPath = this.basePath + '/service/tickets';

			let queryParameters: any = assign({}, extraQueryParams);
			let headerParams: any = assign({}, this.defaultHeaders);
			if (params.conditions !== undefined) {
				queryParameters['conditions'] = params.conditions;
			}

			if (params.orderBy !== undefined) {
				queryParameters['orderBy'] = params.orderBy;
			}

			if (params.childconditions !== undefined) {
				queryParameters['childconditions'] = params.childconditions;
			}

			if (params.customfieldconditions !== undefined) {
				queryParameters['customfieldconditions'] = params.customfieldconditions;
			}

			if (params.page !== undefined) {
				queryParameters['page'] = params.page;
			}

			if (params.pageSize !== undefined) {
				queryParameters['pageSize'] = params.pageSize;
			}

			let fetchParams = {
				method: 'GET',
				headers: headerParams,

			};

			if (extraFetchParams) {
				fetchParams = assign(fetchParams, extraFetchParams);
			}

			let localVarPathWithQueryParameters = localVarPath + (localVarPath.indexOf('?') !== -1 ? '&' : '?') + querystring.stringify(queryParameters);

			return fetch(localVarPathWithQueryParameters, fetchParams).then((response) => {
				if (response.status >= 200 && response.status < 300) {
					return response.json();
				} else {
					let error = new Error(response.statusText);
					(error as any).response = response;
					throw error;
				}
			});
		}
		/**
		 *
		 * Get Ticket Activities Count
		 * @param id
		 */
		public serviceTicketsIdActivitiesCountGet (params: {  id: number; }, extraQueryParams?: any, extraFetchParams?: any ) : Promise<Count> {
			const localVarPath = this.basePath + '/service/tickets/{id}/activities/count'
				.replace('{' + 'id' + '}', String(params.id));

			let queryParameters: any = assign({}, extraQueryParams);
			let headerParams: any = assign({}, this.defaultHeaders);
			// verify required parameter 'id' is set
			if (params.id == null) {
				throw new Error('Missing required parameter id when calling serviceTicketsIdActivitiesCountGet');
			}
			let fetchParams = {
				method: 'GET',
				headers: headerParams,

			};

			if (extraFetchParams) {
				fetchParams = assign(fetchParams, extraFetchParams);
			}

			let localVarPathWithQueryParameters = localVarPath + (localVarPath.indexOf('?') !== -1 ? '&' : '?') + querystring.stringify(queryParameters);

			return fetch(localVarPathWithQueryParameters, fetchParams).then((response) => {
				if (response.status >= 200 && response.status < 300) {
					return response.json();
				} else {
					let error = new Error(response.statusText);
					(error as any).response = response;
					throw error;
				}
			});
		}
		/**
		 *
		 * Get Ticket Activities
		 * @param id
		 * @param page
		 * @param pageSize
		 */
		public serviceTicketsIdActivitiesGet (params: {  id: number; page?: number; pageSize?: number; }, extraQueryParams?: any, extraFetchParams?: any ) : Promise<Array<ActivityReference>> {
			const localVarPath = this.basePath + '/service/tickets/{id}/activities'
				.replace('{' + 'id' + '}', String(params.id));

			let queryParameters: any = assign({}, extraQueryParams);
			let headerParams: any = assign({}, this.defaultHeaders);
			// verify required parameter 'id' is set
			if (params.id == null) {
				throw new Error('Missing required parameter id when calling serviceTicketsIdActivitiesGet');
			}
			if (params.page !== undefined) {
				queryParameters['page'] = params.page;
			}

			if (params.pageSize !== undefined) {
				queryParameters['pageSize'] = params.pageSize;
			}

			let fetchParams = {
				method: 'GET',
				headers: headerParams,

			};

			if (extraFetchParams) {
				fetchParams = assign(fetchParams, extraFetchParams);
			}

			let localVarPathWithQueryParameters = localVarPath + (localVarPath.indexOf('?') !== -1 ? '&' : '?') + querystring.stringify(queryParameters);

			return fetch(localVarPathWithQueryParameters, fetchParams).then((response) => {
				if (response.status >= 200 && response.status < 300) {
					return response.json();
				} else {
					let error = new Error(response.statusText);
					(error as any).response = response;
					throw error;
				}
			});
		}
		/**
		 *
		 * Delete Configuration Association
		 * @param id
		 * @param configId
		 */
		public serviceTicketsIdConfigurationsConfigIdDelete (params: {  id: number; configId: number; }, extraQueryParams?: any, extraFetchParams?: any ) : Promise<{}> {
			const localVarPath = this.basePath + '/service/tickets/{id}/configurations/{configId}'
				.replace('{' + 'id' + '}', String(params.id))
				.replace('{' + 'configId' + '}', String(params.configId));

			let queryParameters: any = assign({}, extraQueryParams);
			let headerParams: any = assign({}, this.defaultHeaders);
			// verify required parameter 'id' is set
			if (params.id == null) {
				throw new Error('Missing required parameter id when calling serviceTicketsIdConfigurationsConfigIdDelete');
			}
			// verify required parameter 'configId' is set
			if (params.configId == null) {
				throw new Error('Missing required parameter configId when calling serviceTicketsIdConfigurationsConfigIdDelete');
			}
			let fetchParams = {
				method: 'DELETE',
				headers: headerParams,

			};

			if (extraFetchParams) {
				fetchParams = assign(fetchParams, extraFetchParams);
			}

			let localVarPathWithQueryParameters = localVarPath + (localVarPath.indexOf('?') !== -1 ? '&' : '?') + querystring.stringify(queryParameters);

			return fetch(localVarPathWithQueryParameters, fetchParams).then((response) => {
				if (response.status >= 200 && response.status < 300) {
					return response.json();
				} else {
					let error = new Error(response.statusText);
					(error as any).response = response;
					throw error;
				}
			});
		}
		/**
		 *
		 * Get Configuration Association
		 * @param id
		 * @param configId
		 */
		public serviceTicketsIdConfigurationsConfigIdGet (params: {  id: number; configId: number; }, extraQueryParams?: any, extraFetchParams?: any ) : Promise<ConfigurationReference> {
			const localVarPath = this.basePath + '/service/tickets/{id}/configurations/{configId}'
				.replace('{' + 'id' + '}', String(params.id))
				.replace('{' + 'configId' + '}', String(params.configId));

			let queryParameters: any = assign({}, extraQueryParams);
			let headerParams: any = assign({}, this.defaultHeaders);
			// verify required parameter 'id' is set
			if (params.id == null) {
				throw new Error('Missing required parameter id when calling serviceTicketsIdConfigurationsConfigIdGet');
			}
			// verify required parameter 'configId' is set
			if (params.configId == null) {
				throw new Error('Missing required parameter configId when calling serviceTicketsIdConfigurationsConfigIdGet');
			}
			let fetchParams = {
				method: 'GET',
				headers: headerParams,

			};

			if (extraFetchParams) {
				fetchParams = assign(fetchParams, extraFetchParams);
			}

			let localVarPathWithQueryParameters = localVarPath + (localVarPath.indexOf('?') !== -1 ? '&' : '?') + querystring.stringify(queryParameters);

			return fetch(localVarPathWithQueryParameters, fetchParams).then((response) => {
				if (response.status >= 200 && response.status < 300) {
					return response.json();
				} else {
					let error = new Error(response.statusText);
					(error as any).response = response;
					throw error;
				}
			});
		}
		/**
		 *
		 * Get Ticket Configurations Count
		 * @param id
		 */
		public serviceTicketsIdConfigurationsCountGet (params: {  id: number; }, extraQueryParams?: any, extraFetchParams?: any ) : Promise<Count> {
			const localVarPath = this.basePath + '/service/tickets/{id}/configurations/count'
				.replace('{' + 'id' + '}', String(params.id));

			let queryParameters: any = assign({}, extraQueryParams);
			let headerParams: any = assign({}, this.defaultHeaders);
			// verify required parameter 'id' is set
			if (params.id == null) {
				throw new Error('Missing required parameter id when calling serviceTicketsIdConfigurationsCountGet');
			}
			let fetchParams = {
				method: 'GET',
				headers: headerParams,

			};

			if (extraFetchParams) {
				fetchParams = assign(fetchParams, extraFetchParams);
			}

			let localVarPathWithQueryParameters = localVarPath + (localVarPath.indexOf('?') !== -1 ? '&' : '?') + querystring.stringify(queryParameters);

			return fetch(localVarPathWithQueryParameters, fetchParams).then((response) => {
				if (response.status >= 200 && response.status < 300) {
					return response.json();
				} else {
					let error = new Error(response.statusText);
					(error as any).response = response;
					throw error;
				}
			});
		}
		/**
		 *
		 * Get Ticket Configurations
		 * @param id
		 * @param page
		 * @param pageSize
		 */
		public serviceTicketsIdConfigurationsGet (params: {  id: number; page?: number; pageSize?: number; }, extraQueryParams?: any, extraFetchParams?: any ) : Promise<Array<ConfigurationReference>> {
			const localVarPath = this.basePath + '/service/tickets/{id}/configurations'
				.replace('{' + 'id' + '}', String(params.id));

			let queryParameters: any = assign({}, extraQueryParams);
			let headerParams: any = assign({}, this.defaultHeaders);
			// verify required parameter 'id' is set
			if (params.id == null) {
				throw new Error('Missing required parameter id when calling serviceTicketsIdConfigurationsGet');
			}
			if (params.page !== undefined) {
				queryParameters['page'] = params.page;
			}

			if (params.pageSize !== undefined) {
				queryParameters['pageSize'] = params.pageSize;
			}

			let fetchParams = {
				method: 'GET',
				headers: headerParams,

			};

			if (extraFetchParams) {
				fetchParams = assign(fetchParams, extraFetchParams);
			}

			let localVarPathWithQueryParameters = localVarPath + (localVarPath.indexOf('?') !== -1 ? '&' : '?') + querystring.stringify(queryParameters);

			return fetch(localVarPathWithQueryParameters, fetchParams).then((response) => {
				if (response.status >= 200 && response.status < 300) {
					return response.json();
				} else {
					let error = new Error(response.statusText);
					(error as any).response = response;
					throw error;
				}
			});
		}
		/**
		 *
		 * Create Configuration Association
		 * @param id
		 * @param configuration
		 */
		public serviceTicketsIdConfigurationsPost (params: {  id: number; configuration: ConfigurationReference; }, extraQueryParams?: any, extraFetchParams?: any ) : Promise<ConfigurationReference> {
			const localVarPath = this.basePath + '/service/tickets/{id}/configurations'
				.replace('{' + 'id' + '}', String(params.id));

			let queryParameters: any = assign({}, extraQueryParams);
			let headerParams: any = assign({}, this.defaultHeaders);
			headerParams['Content-Type'] = 'application/json';

			// verify required parameter 'id' is set
			if (params.id == null) {
				throw new Error('Missing required parameter id when calling serviceTicketsIdConfigurationsPost');
			}
			// verify required parameter 'configuration' is set
			if (params.configuration == null) {
				throw new Error('Missing required parameter configuration when calling serviceTicketsIdConfigurationsPost');
			}
			let fetchParams = {
				method: 'POST',
				headers: headerParams,
				body: JSON.stringify(params.configuration),

			};

			if (extraFetchParams) {
				fetchParams = assign(fetchParams, extraFetchParams);
			}

			let localVarPathWithQueryParameters = localVarPath + (localVarPath.indexOf('?') !== -1 ? '&' : '?') + querystring.stringify(queryParameters);

			return fetch(localVarPathWithQueryParameters, fetchParams).then((response) => {
				if (response.status >= 200 && response.status < 300) {
					return response.json();
				} else {
					let error = new Error(response.statusText);
					(error as any).response = response;
					throw error;
				}
			});
		}
		/**
		 *
		 * Delete Ticket By Id
		 * @param id
		 */
		public serviceTicketsIdDelete (params: {  id: number; }, extraQueryParams?: any, extraFetchParams?: any ) : Promise<{}> {
			const localVarPath = this.basePath + '/service/tickets/{id}'
				.replace('{' + 'id' + '}', String(params.id));

			let queryParameters: any = assign({}, extraQueryParams);
			let headerParams: any = assign({}, this.defaultHeaders);
			// verify required parameter 'id' is set
			if (params.id == null) {
				throw new Error('Missing required parameter id when calling serviceTicketsIdDelete');
			}
			let fetchParams = {
				method: 'DELETE',
				headers: headerParams,

			};

			if (extraFetchParams) {
				fetchParams = assign(fetchParams, extraFetchParams);
			}

			let localVarPathWithQueryParameters = localVarPath + (localVarPath.indexOf('?') !== -1 ? '&' : '?') + querystring.stringify(queryParameters);

			return fetch(localVarPathWithQueryParameters, fetchParams).then((response) => {
				if (response.status >= 200 && response.status < 300) {
					return response.json();
				} else {
					let error = new Error(response.statusText);
					(error as any).response = response;
					throw error;
				}
			});
		}
		/**
		 *
		 * Get Ticket Documents Count
		 * @param id
		 */
		public serviceTicketsIdDocumentsCountGet (params: {  id: number; }, extraQueryParams?: any, extraFetchParams?: any ) : Promise<Count> {
			const localVarPath = this.basePath + '/service/tickets/{id}/documents/count'
				.replace('{' + 'id' + '}', String(params.id));

			let queryParameters: any = assign({}, extraQueryParams);
			let headerParams: any = assign({}, this.defaultHeaders);
			// verify required parameter 'id' is set
			if (params.id == null) {
				throw new Error('Missing required parameter id when calling serviceTicketsIdDocumentsCountGet');
			}
			let fetchParams = {
				method: 'GET',
				headers: headerParams,

			};

			if (extraFetchParams) {
				fetchParams = assign(fetchParams, extraFetchParams);
			}

			let localVarPathWithQueryParameters = localVarPath + (localVarPath.indexOf('?') !== -1 ? '&' : '?') + querystring.stringify(queryParameters);

			return fetch(localVarPathWithQueryParameters, fetchParams).then((response) => {
				if (response.status >= 200 && response.status < 300) {
					return response.json();
				} else {
					let error = new Error(response.statusText);
					(error as any).response = response;
					throw error;
				}
			});
		}
		/**
		 *
		 * Get Ticket Documents
		 * @param id
		 * @param page
		 * @param pageSize
		 */
		public serviceTicketsIdDocumentsGet (params: {  id: number; page?: number; pageSize?: number; }, extraQueryParams?: any, extraFetchParams?: any ) : Promise<Array<DocumentReference>> {
			const localVarPath = this.basePath + '/service/tickets/{id}/documents'
				.replace('{' + 'id' + '}', String(params.id));

			let queryParameters: any = assign({}, extraQueryParams);
			let headerParams: any = assign({}, this.defaultHeaders);
			// verify required parameter 'id' is set
			if (params.id == null) {
				throw new Error('Missing required parameter id when calling serviceTicketsIdDocumentsGet');
			}
			if (params.page !== undefined) {
				queryParameters['page'] = params.page;
			}

			if (params.pageSize !== undefined) {
				queryParameters['pageSize'] = params.pageSize;
			}

			let fetchParams = {
				method: 'GET',
				headers: headerParams,

			};

			if (extraFetchParams) {
				fetchParams = assign(fetchParams, extraFetchParams);
			}

			let localVarPathWithQueryParameters = localVarPath + (localVarPath.indexOf('?') !== -1 ? '&' : '?') + querystring.stringify(queryParameters);

			return fetch(localVarPathWithQueryParameters, fetchParams).then((response) => {
				if (response.status >= 200 && response.status < 300) {
					return response.json();
				} else {
					let error = new Error(response.statusText);
					(error as any).response = response;
					throw error;
				}
			});
		}
		/**
		 *
		 * Get Ticket By Id
		 * @param id
		 */
		public serviceTicketsIdGet (params: {  id: number; }, extraQueryParams?: any, extraFetchParams?: any ) : Promise<Ticket> {
			const localVarPath = this.basePath + '/service/tickets/{id}'
				.replace('{' + 'id' + '}', String(params.id));

			let queryParameters: any = assign({}, extraQueryParams);
			let headerParams: any = assign({}, this.defaultHeaders);
			// verify required parameter 'id' is set
			if (params.id == null) {
				throw new Error('Missing required parameter id when calling serviceTicketsIdGet');
			}
			let fetchParams = {
				method: 'GET',
				headers: headerParams,

			};

			if (extraFetchParams) {
				fetchParams = assign(fetchParams, extraFetchParams);
			}

			let localVarPathWithQueryParameters = localVarPath + (localVarPath.indexOf('?') !== -1 ? '&' : '?') + querystring.stringify(queryParameters);

			return fetch(localVarPathWithQueryParameters, fetchParams).then((response) => {
				if (response.status >= 200 && response.status < 300) {
					return response.json();
				} else {
					let error = new Error(response.statusText);
					(error as any).response = response;
					throw error;
				}
			});
		}
		/**
		 *
		 * Merge Company
		 * @param id
		 * @param merge
		 */
		public serviceTicketsIdMergePost (params: {  id: number; merge: TicketMerge; }, extraQueryParams?: any, extraFetchParams?: any ) : Promise<SuccessResponse> {
			const localVarPath = this.basePath + '/service/tickets/{id}/merge'
				.replace('{' + 'id' + '}', String(params.id));

			let queryParameters: any = assign({}, extraQueryParams);
			let headerParams: any = assign({}, this.defaultHeaders);
			headerParams['Content-Type'] = 'application/json';

			// verify required parameter 'id' is set
			if (params.id == null) {
				throw new Error('Missing required parameter id when calling serviceTicketsIdMergePost');
			}
			// verify required parameter 'merge' is set
			if (params.merge == null) {
				throw new Error('Missing required parameter merge when calling serviceTicketsIdMergePost');
			}
			let fetchParams = {
				method: 'POST',
				headers: headerParams,
				body: JSON.stringify(params.merge),

			};

			if (extraFetchParams) {
				fetchParams = assign(fetchParams, extraFetchParams);
			}

			let localVarPathWithQueryParameters = localVarPath + (localVarPath.indexOf('?') !== -1 ? '&' : '?') + querystring.stringify(queryParameters);

			return fetch(localVarPathWithQueryParameters, fetchParams).then((response) => {
				if (response.status >= 200 && response.status < 300) {
					return response.json();
				} else {
					let error = new Error(response.statusText);
					(error as any).response = response;
					throw error;
				}
			});
		}
		/**
		 *
		 * Update Ticket
		 * @param id
		 * @param operations
		 */
		public serviceTicketsIdPatch (params: {  id: number; operations: Array<PatchOperation>; }, extraQueryParams?: any, extraFetchParams?: any ) : Promise<Ticket> {
			const localVarPath = this.basePath + '/service/tickets/{id}'
				.replace('{' + 'id' + '}', String(params.id));

			let queryParameters: any = assign({}, extraQueryParams);
			let headerParams: any = assign({}, this.defaultHeaders);
			headerParams['Content-Type'] = 'application/json';

			// verify required parameter 'id' is set
			if (params.id == null) {
				throw new Error('Missing required parameter id when calling serviceTicketsIdPatch');
			}
			// verify required parameter 'operations' is set
			if (params.operations == null) {
				throw new Error('Missing required parameter operations when calling serviceTicketsIdPatch');
			}
			let fetchParams = {
				method: 'PATCH',
				headers: headerParams,
				body: JSON.stringify(params.operations),

			};

			if (extraFetchParams) {
				fetchParams = assign(fetchParams, extraFetchParams);
			}

			let localVarPathWithQueryParameters = localVarPath + (localVarPath.indexOf('?') !== -1 ? '&' : '?') + querystring.stringify(queryParameters);

			return fetch(localVarPathWithQueryParameters, fetchParams).then((response) => {
				if (response.status >= 200 && response.status < 300) {
					return response.json();
				} else {
					let error = new Error(response.statusText);
					(error as any).response = response;
					throw error;
				}
			});
		}
		/**
		 *
		 * Get Ticket Products Count
		 * @param id
		 */
		public serviceTicketsIdProductsCountGet (params: {  id: number; }, extraQueryParams?: any, extraFetchParams?: any ) : Promise<Count> {
			const localVarPath = this.basePath + '/service/tickets/{id}/products/count'
				.replace('{' + 'id' + '}', String(params.id));

			let queryParameters: any = assign({}, extraQueryParams);
			let headerParams: any = assign({}, this.defaultHeaders);
			// verify required parameter 'id' is set
			if (params.id == null) {
				throw new Error('Missing required parameter id when calling serviceTicketsIdProductsCountGet');
			}
			let fetchParams = {
				method: 'GET',
				headers: headerParams,

			};

			if (extraFetchParams) {
				fetchParams = assign(fetchParams, extraFetchParams);
			}

			let localVarPathWithQueryParameters = localVarPath + (localVarPath.indexOf('?') !== -1 ? '&' : '?') + querystring.stringify(queryParameters);

			return fetch(localVarPathWithQueryParameters, fetchParams).then((response) => {
				if (response.status >= 200 && response.status < 300) {
					return response.json();
				} else {
					let error = new Error(response.statusText);
					(error as any).response = response;
					throw error;
				}
			});
		}
		/**
		 *
		 * Get Ticket Products
		 * @param id
		 * @param page
		 * @param pageSize
		 */
		public serviceTicketsIdProductsGet (params: {  id: number; page?: number; pageSize?: number; }, extraQueryParams?: any, extraFetchParams?: any ) : Promise<Array<ProductReference>> {
			const localVarPath = this.basePath + '/service/tickets/{id}/products'
				.replace('{' + 'id' + '}', String(params.id));

			let queryParameters: any = assign({}, extraQueryParams);
			let headerParams: any = assign({}, this.defaultHeaders);
			// verify required parameter 'id' is set
			if (params.id == null) {
				throw new Error('Missing required parameter id when calling serviceTicketsIdProductsGet');
			}
			if (params.page !== undefined) {
				queryParameters['page'] = params.page;
			}

			if (params.pageSize !== undefined) {
				queryParameters['pageSize'] = params.pageSize;
			}

			let fetchParams = {
				method: 'GET',
				headers: headerParams,

			};

			if (extraFetchParams) {
				fetchParams = assign(fetchParams, extraFetchParams);
			}

			let localVarPathWithQueryParameters = localVarPath + (localVarPath.indexOf('?') !== -1 ? '&' : '?') + querystring.stringify(queryParameters);

			return fetch(localVarPathWithQueryParameters, fetchParams).then((response) => {
				if (response.status >= 200 && response.status < 300) {
					return response.json();
				} else {
					let error = new Error(response.statusText);
					(error as any).response = response;
					throw error;
				}
			});
		}
		/**
		 *
		 * Replace Ticket
		 * @param id
		 * @param ticket
		 */
		public serviceTicketsIdPut (params: {  id: number; ticket: Ticket; }, extraQueryParams?: any, extraFetchParams?: any ) : Promise<Ticket> {
			const localVarPath = this.basePath + '/service/tickets/{id}'
				.replace('{' + 'id' + '}', String(params.id));

			let queryParameters: any = assign({}, extraQueryParams);
			let headerParams: any = assign({}, this.defaultHeaders);
			headerParams['Content-Type'] = 'application/json';

			// verify required parameter 'id' is set
			if (params.id == null) {
				throw new Error('Missing required parameter id when calling serviceTicketsIdPut');
			}
			// verify required parameter 'ticket' is set
			if (params.ticket == null) {
				throw new Error('Missing required parameter ticket when calling serviceTicketsIdPut');
			}
			let fetchParams = {
				method: 'PUT',
				headers: headerParams,
				body: JSON.stringify(params.ticket),

			};

			if (extraFetchParams) {
				fetchParams = assign(fetchParams, extraFetchParams);
			}

			let localVarPathWithQueryParameters = localVarPath + (localVarPath.indexOf('?') !== -1 ? '&' : '?') + querystring.stringify(queryParameters);

			return fetch(localVarPathWithQueryParameters, fetchParams).then((response) => {
				if (response.status >= 200 && response.status < 300) {
					return response.json();
				} else {
					let error = new Error(response.statusText);
					(error as any).response = response;
					throw error;
				}
			});
		}
		/**
		 *
		 * Get Ticket Schedule Entries Count
		 * @param id
		 */
		public serviceTicketsIdScheduleentriesCountGet (params: {  id: number; }, extraQueryParams?: any, extraFetchParams?: any ) : Promise<Count> {
			const localVarPath = this.basePath + '/service/tickets/{id}/scheduleentries/count'
				.replace('{' + 'id' + '}', String(params.id));

			let queryParameters: any = assign({}, extraQueryParams);
			let headerParams: any = assign({}, this.defaultHeaders);
			// verify required parameter 'id' is set
			if (params.id == null) {
				throw new Error('Missing required parameter id when calling serviceTicketsIdScheduleentriesCountGet');
			}
			let fetchParams = {
				method: 'GET',
				headers: headerParams,

			};

			if (extraFetchParams) {
				fetchParams = assign(fetchParams, extraFetchParams);
			}

			let localVarPathWithQueryParameters = localVarPath + (localVarPath.indexOf('?') !== -1 ? '&' : '?') + querystring.stringify(queryParameters);

			return fetch(localVarPathWithQueryParameters, fetchParams).then((response) => {
				if (response.status >= 200 && response.status < 300) {
					return response.json();
				} else {
					let error = new Error(response.statusText);
					(error as any).response = response;
					throw error;
				}
			});
		}
		/**
		 *
		 * Get Ticket Schedule Entries
		 * @param id
		 * @param page
		 * @param pageSize
		 */
		public serviceTicketsIdScheduleentriesGet (params: {  id: number; page?: number; pageSize?: number; }, extraQueryParams?: any, extraFetchParams?: any ) : Promise<Array<ScheduleEntryReference>> {
			const localVarPath = this.basePath + '/service/tickets/{id}/scheduleentries'
				.replace('{' + 'id' + '}', String(params.id));

			let queryParameters: any = assign({}, extraQueryParams);
			let headerParams: any = assign({}, this.defaultHeaders);
			// verify required parameter 'id' is set
			if (params.id == null) {
				throw new Error('Missing required parameter id when calling serviceTicketsIdScheduleentriesGet');
			}
			if (params.page !== undefined) {
				queryParameters['page'] = params.page;
			}

			if (params.pageSize !== undefined) {
				queryParameters['pageSize'] = params.pageSize;
			}

			let fetchParams = {
				method: 'GET',
				headers: headerParams,

			};

			if (extraFetchParams) {
				fetchParams = assign(fetchParams, extraFetchParams);
			}

			let localVarPathWithQueryParameters = localVarPath + (localVarPath.indexOf('?') !== -1 ? '&' : '?') + querystring.stringify(queryParameters);

			return fetch(localVarPathWithQueryParameters, fetchParams).then((response) => {
				if (response.status >= 200 && response.status < 300) {
					return response.json();
				} else {
					let error = new Error(response.statusText);
					(error as any).response = response;
					throw error;
				}
			});
		}
		/**
		 *
		 * Get Ticket Time Entries Count
		 * @param id
		 */
		public serviceTicketsIdTimeentriesCountGet (params: {  id: number; }, extraQueryParams?: any, extraFetchParams?: any ) : Promise<Count> {
			const localVarPath = this.basePath + '/service/tickets/{id}/timeentries/count'
				.replace('{' + 'id' + '}', String(params.id));

			let queryParameters: any = assign({}, extraQueryParams);
			let headerParams: any = assign({}, this.defaultHeaders);
			// verify required parameter 'id' is set
			if (params.id == null) {
				throw new Error('Missing required parameter id when calling serviceTicketsIdTimeentriesCountGet');
			}
			let fetchParams = {
				method: 'GET',
				headers: headerParams,

			};

			if (extraFetchParams) {
				fetchParams = assign(fetchParams, extraFetchParams);
			}

			let localVarPathWithQueryParameters = localVarPath + (localVarPath.indexOf('?') !== -1 ? '&' : '?') + querystring.stringify(queryParameters);

			return fetch(localVarPathWithQueryParameters, fetchParams).then((response) => {
				if (response.status >= 200 && response.status < 300) {
					return response.json();
				} else {
					let error = new Error(response.statusText);
					(error as any).response = response;
					throw error;
				}
			});
		}
		/**
		 *
		 * Get Ticket Time Entries
		 * @param id
		 * @param page
		 * @param pageSize
		 */
		public serviceTicketsIdTimeentriesGet (params: {  id: number; page?: number; pageSize?: number; }, extraQueryParams?: any, extraFetchParams?: any ) : Promise<Array<TimeEntryReference>> {
			const localVarPath = this.basePath + '/service/tickets/{id}/timeentries'
				.replace('{' + 'id' + '}', String(params.id));

			let queryParameters: any = assign({}, extraQueryParams);
			let headerParams: any = assign({}, this.defaultHeaders);
			// verify required parameter 'id' is set
			if (params.id == null) {
				throw new Error('Missing required parameter id when calling serviceTicketsIdTimeentriesGet');
			}
			if (params.page !== undefined) {
				queryParameters['page'] = params.page;
			}

			if (params.pageSize !== undefined) {
				queryParameters['pageSize'] = params.pageSize;
			}

			let fetchParams = {
				method: 'GET',
				headers: headerParams,

			};

			if (extraFetchParams) {
				fetchParams = assign(fetchParams, extraFetchParams);
			}

			let localVarPathWithQueryParameters = localVarPath + (localVarPath.indexOf('?') !== -1 ? '&' : '?') + querystring.stringify(queryParameters);

			return fetch(localVarPathWithQueryParameters, fetchParams).then((response) => {
				if (response.status >= 200 && response.status < 300) {
					return response.json();
				} else {
					let error = new Error(response.statusText);
					(error as any).response = response;
					throw error;
				}
			});
		}
		/**
		 *
		 * Create Ticket
		 * @param ticket
		 */
		public serviceTicketsPost (params: {  ticket: Ticket; }, extraQueryParams?: any, extraFetchParams?: any ) : Promise<Ticket> {
			const localVarPath = this.basePath + '/service/tickets';

			let queryParameters: any = assign({}, extraQueryParams);
			let headerParams: any = assign({}, this.defaultHeaders);
			headerParams['Content-Type'] = 'application/json';

			// verify required parameter 'ticket' is set
			if (params.ticket == null) {
				throw new Error('Missing required parameter ticket when calling serviceTicketsPost');
			}
			let fetchParams = {
				method: 'POST',
				headers: headerParams,
				body: JSON.stringify(params.ticket),

			};

			if (extraFetchParams) {
				fetchParams = assign(fetchParams, extraFetchParams);
			}

			let localVarPathWithQueryParameters = localVarPath + (localVarPath.indexOf('?') !== -1 ? '&' : '?') + querystring.stringify(queryParameters);

			return fetch(localVarPathWithQueryParameters, fetchParams).then((response) => {
				if (response.status >= 200 && response.status < 300) {
					return response.json();
				} else {
					let error = new Error(response.statusText);
					(error as any).response = response;
					throw error;
				}
			});
		}
		/**
		 *
		 * Ticket Search
		 * @param filterValues
		 * @param page
		 * @param pageSize
		 */
		public serviceTicketsSearchPost (params: {  filterValues: FilterValues; page?: number; pageSize?: number; }, extraQueryParams?: any, extraFetchParams?: any ) : Promise<Array<Ticket>> {
			const localVarPath = this.basePath + '/service/tickets/search';

			let queryParameters: any = assign({}, extraQueryParams);
			let headerParams: any = assign({}, this.defaultHeaders);
			headerParams['Content-Type'] = 'application/json';

			// verify required parameter 'filterValues' is set
			if (params.filterValues == null) {
				throw new Error('Missing required parameter filterValues when calling serviceTicketsSearchPost');
			}
			if (params.page !== undefined) {
				queryParameters['page'] = params.page;
			}

			if (params.pageSize !== undefined) {
				queryParameters['pageSize'] = params.pageSize;
			}

			let fetchParams = {
				method: 'POST',
				headers: headerParams,
				body: JSON.stringify(params.filterValues),

			};

			if (extraFetchParams) {
				fetchParams = assign(fetchParams, extraFetchParams);
			}

			let localVarPathWithQueryParameters = localVarPath + (localVarPath.indexOf('?') !== -1 ? '&' : '?') + querystring.stringify(queryParameters);

			return fetch(localVarPathWithQueryParameters, fetchParams).then((response) => {
				if (response.status >= 200 && response.status < 300) {
					return response.json();
				} else {
					let error = new Error(response.statusText);
					(error as any).response = response;
					throw error;
				}
			});
		}
	}
//}
//export namespace  {
	'use strict';

	export class TimeEntriesApi {
		protected basePath = 'https://api-na.myconnectwise.net/v4_6_release/apis/3.0';
		public defaultHeaders : any = {};

		constructor(basePath?: string) {
			if (basePath) {
				this.basePath = basePath;
			}
		}

		/**
		 *
		 * Get Time Entries Count
		 * @param conditions
		 * @param customFieldConditions
		 */
		public timeEntriesCountGet (params: {  conditions?: string; customFieldConditions?: string; }, extraQueryParams?: any, extraFetchParams?: any ) : Promise<Count> {
			const localVarPath = this.basePath + '/time/entries/count';

			let queryParameters: any = assign({}, extraQueryParams);
			let headerParams: any = assign({}, this.defaultHeaders);
			if (params.conditions !== undefined) {
				queryParameters['conditions'] = params.conditions;
			}

			if (params.customFieldConditions !== undefined) {
				queryParameters['customFieldConditions'] = params.customFieldConditions;
			}

			let fetchParams = {
				method: 'GET',
				headers: headerParams,

			};

			if (extraFetchParams) {
				fetchParams = assign(fetchParams, extraFetchParams);
			}

			let localVarPathWithQueryParameters = localVarPath + (localVarPath.indexOf('?') !== -1 ? '&' : '?') + querystring.stringify(queryParameters);

			return fetch(localVarPathWithQueryParameters, fetchParams).then((response) => {
				if (response.status >= 200 && response.status < 300) {
					return response.json();
				} else {
					let error = new Error(response.statusText);
					(error as any).response = response;
					throw error;
				}
			});
		}
		/**
		 *
		 * Get Time Entries
		 * @param conditions
		 * @param orderBy
		 * @param childconditions
		 * @param customfieldconditions
		 * @param page
		 * @param pageSize
		 */
		public timeEntriesGet (params: {  conditions?: string; orderBy?: string; childconditions?: string; customfieldconditions?: string; page?: number; pageSize?: number; }, extraQueryParams?: any, extraFetchParams?: any ) : Promise<Array<TimeEntry>> {
			const localVarPath = this.basePath + '/time/entries';

			let queryParameters: any = assign({}, extraQueryParams);
			let headerParams: any = assign({}, this.defaultHeaders);
			if (params.conditions !== undefined) {
				queryParameters['conditions'] = params.conditions;
			}

			if (params.orderBy !== undefined) {
				queryParameters['orderBy'] = params.orderBy;
			}

			if (params.childconditions !== undefined) {
				queryParameters['childconditions'] = params.childconditions;
			}

			if (params.customfieldconditions !== undefined) {
				queryParameters['customfieldconditions'] = params.customfieldconditions;
			}

			if (params.page !== undefined) {
				queryParameters['page'] = params.page;
			}

			if (params.pageSize !== undefined) {
				queryParameters['pageSize'] = params.pageSize;
			}

			let fetchParams = {
				method: 'GET',
				headers: headerParams,

			};

			if (extraFetchParams) {
				fetchParams = assign(fetchParams, extraFetchParams);
			}

			let localVarPathWithQueryParameters = localVarPath + (localVarPath.indexOf('?') !== -1 ? '&' : '?') + querystring.stringify(queryParameters);

			return fetch(localVarPathWithQueryParameters, fetchParams).then((response) => {
				if (response.status >= 200 && response.status < 300) {
					return response.json();
				} else {
					let error = new Error(response.statusText);
					(error as any).response = response;
					throw error;
				}
			});
		}
		/**
		 *
		 * Delete Time Entry By Id
		 * @param id
		 */
		public timeEntriesIdDelete (params: {  id: number; }, extraQueryParams?: any, extraFetchParams?: any ) : Promise<{}> {
			const localVarPath = this.basePath + '/time/entries/{id}'
				.replace('{' + 'id' + '}', String(params.id));

			let queryParameters: any = assign({}, extraQueryParams);
			let headerParams: any = assign({}, this.defaultHeaders);
			// verify required parameter 'id' is set
			if (params.id == null) {
				throw new Error('Missing required parameter id when calling timeEntriesIdDelete');
			}
			let fetchParams = {
				method: 'DELETE',
				headers: headerParams,

			};

			if (extraFetchParams) {
				fetchParams = assign(fetchParams, extraFetchParams);
			}

			let localVarPathWithQueryParameters = localVarPath + (localVarPath.indexOf('?') !== -1 ? '&' : '?') + querystring.stringify(queryParameters);

			return fetch(localVarPathWithQueryParameters, fetchParams).then((response) => {
				if (response.status >= 200 && response.status < 300) {
					return response.json();
				} else {
					let error = new Error(response.statusText);
					(error as any).response = response;
					throw error;
				}
			});
		}
		/**
		 *
		 * Get Time Entry By Id
		 * @param id
		 */
		public timeEntriesIdGet (params: {  id: number; }, extraQueryParams?: any, extraFetchParams?: any ) : Promise<TimeEntry> {
			const localVarPath = this.basePath + '/time/entries/{id}'
				.replace('{' + 'id' + '}', String(params.id));

			let queryParameters: any = assign({}, extraQueryParams);
			let headerParams: any = assign({}, this.defaultHeaders);
			// verify required parameter 'id' is set
			if (params.id == null) {
				throw new Error('Missing required parameter id when calling timeEntriesIdGet');
			}
			let fetchParams = {
				method: 'GET',
				headers: headerParams,

			};

			if (extraFetchParams) {
				fetchParams = assign(fetchParams, extraFetchParams);
			}

			let localVarPathWithQueryParameters = localVarPath + (localVarPath.indexOf('?') !== -1 ? '&' : '?') + querystring.stringify(queryParameters);

			return fetch(localVarPathWithQueryParameters, fetchParams).then((response) => {
				if (response.status >= 200 && response.status < 300) {
					return response.json();
				} else {
					let error = new Error(response.statusText);
					(error as any).response = response;
					throw error;
				}
			});
		}
		/**
		 *
		 * Update Time Entry
		 * @param id
		 * @param operations
		 */
		public timeEntriesIdPatch (params: {  id: number; operations: Array<PatchOperation>; }, extraQueryParams?: any, extraFetchParams?: any ) : Promise<TimeEntry> {
			const localVarPath = this.basePath + '/time/entries/{id}'
				.replace('{' + 'id' + '}', String(params.id));

			let queryParameters: any = assign({}, extraQueryParams);
			let headerParams: any = assign({}, this.defaultHeaders);
			headerParams['Content-Type'] = 'application/json';

			// verify required parameter 'id' is set
			if (params.id == null) {
				throw new Error('Missing required parameter id when calling timeEntriesIdPatch');
			}
			// verify required parameter 'operations' is set
			if (params.operations == null) {
				throw new Error('Missing required parameter operations when calling timeEntriesIdPatch');
			}
			let fetchParams = {
				method: 'PATCH',
				headers: headerParams,
				body: JSON.stringify(params.operations),

			};

			if (extraFetchParams) {
				fetchParams = assign(fetchParams, extraFetchParams);
			}

			let localVarPathWithQueryParameters = localVarPath + (localVarPath.indexOf('?') !== -1 ? '&' : '?') + querystring.stringify(queryParameters);

			return fetch(localVarPathWithQueryParameters, fetchParams).then((response) => {
				if (response.status >= 200 && response.status < 300) {
					return response.json();
				} else {
					let error = new Error(response.statusText);
					(error as any).response = response;
					throw error;
				}
			});
		}
		/**
		 *
		 * Replace Time Entry
		 * @param id
		 * @param timeEntry
		 */
		public timeEntriesIdPut (params: {  id: number; timeEntry: TimeEntry; }, extraQueryParams?: any, extraFetchParams?: any ) : Promise<TimeEntry> {
			const localVarPath = this.basePath + '/time/entries/{id}'
				.replace('{' + 'id' + '}', String(params.id));

			let queryParameters: any = assign({}, extraQueryParams);
			let headerParams: any = assign({}, this.defaultHeaders);
			headerParams['Content-Type'] = 'application/json';

			// verify required parameter 'id' is set
			if (params.id == null) {
				throw new Error('Missing required parameter id when calling timeEntriesIdPut');
			}
			// verify required parameter 'timeEntry' is set
			if (params.timeEntry == null) {
				throw new Error('Missing required parameter timeEntry when calling timeEntriesIdPut');
			}
			let fetchParams = {
				method: 'PUT',
				headers: headerParams,
				body: JSON.stringify(params.timeEntry),

			};

			if (extraFetchParams) {
				fetchParams = assign(fetchParams, extraFetchParams);
			}

			let localVarPathWithQueryParameters = localVarPath + (localVarPath.indexOf('?') !== -1 ? '&' : '?') + querystring.stringify(queryParameters);

			return fetch(localVarPathWithQueryParameters, fetchParams).then((response) => {
				if (response.status >= 200 && response.status < 300) {
					return response.json();
				} else {
					let error = new Error(response.statusText);
					(error as any).response = response;
					throw error;
				}
			});
		}
		/**
		 *
		 * Create Time Entry
		 * @param timeEntry
		 */
		public timeEntriesPost (params: {  timeEntry: TimeEntry; }, extraQueryParams?: any, extraFetchParams?: any ) : Promise<TimeEntry> {
			const localVarPath = this.basePath + '/time/entries';

			let queryParameters: any = assign({}, extraQueryParams);
			let headerParams: any = assign({}, this.defaultHeaders);
			headerParams['Content-Type'] = 'application/json';

			// verify required parameter 'timeEntry' is set
			if (params.timeEntry == null) {
				throw new Error('Missing required parameter timeEntry when calling timeEntriesPost');
			}
			let fetchParams = {
				method: 'POST',
				headers: headerParams,
				body: JSON.stringify(params.timeEntry),

			};

			if (extraFetchParams) {
				fetchParams = assign(fetchParams, extraFetchParams);
			}

			let localVarPathWithQueryParameters = localVarPath + (localVarPath.indexOf('?') !== -1 ? '&' : '?') + querystring.stringify(queryParameters);

			return fetch(localVarPathWithQueryParameters, fetchParams).then((response) => {
				if (response.status >= 200 && response.status < 300) {
					return response.json();
				} else {
					let error = new Error(response.statusText);
					(error as any).response = response;
					throw error;
				}
			});
		}
	}
//}
//export namespace  {
	'use strict';

	export class TodayPageCategoriesApi {
		protected basePath = 'https://api-na.myconnectwise.net/v4_6_release/apis/3.0';
		public defaultHeaders : any = {};

		constructor(basePath?: string) {
			if (basePath) {
				this.basePath = basePath;
			}
		}

		/**
		 *
		 * Get Today Page Categories Count
		 * @param conditions
		 */
		public systemTodayPageCategoriesCountGet (params: {  conditions?: string; }, extraQueryParams?: any, extraFetchParams?: any ) : Promise<Count> {
			const localVarPath = this.basePath + '/system/todayPageCategories/count';

			let queryParameters: any = assign({}, extraQueryParams);
			let headerParams: any = assign({}, this.defaultHeaders);
			if (params.conditions !== undefined) {
				queryParameters['conditions'] = params.conditions;
			}

			let fetchParams = {
				method: 'GET',
				headers: headerParams,

			};

			if (extraFetchParams) {
				fetchParams = assign(fetchParams, extraFetchParams);
			}

			let localVarPathWithQueryParameters = localVarPath + (localVarPath.indexOf('?') !== -1 ? '&' : '?') + querystring.stringify(queryParameters);

			return fetch(localVarPathWithQueryParameters, fetchParams).then((response) => {
				if (response.status >= 200 && response.status < 300) {
					return response.json();
				} else {
					let error = new Error(response.statusText);
					(error as any).response = response;
					throw error;
				}
			});
		}
		/**
		 *
		 * Get Today Page Categories
		 * @param conditions
		 * @param orderBy
		 * @param childconditions
		 * @param customfieldconditions
		 * @param page
		 * @param pageSize
		 */
		public systemTodayPageCategoriesGet (params: {  conditions?: string; orderBy?: string; childconditions?: string; customfieldconditions?: string; page?: number; pageSize?: number; }, extraQueryParams?: any, extraFetchParams?: any ) : Promise<Array<TodayPageCategory>> {
			const localVarPath = this.basePath + '/system/todayPageCategories';

			let queryParameters: any = assign({}, extraQueryParams);
			let headerParams: any = assign({}, this.defaultHeaders);
			if (params.conditions !== undefined) {
				queryParameters['conditions'] = params.conditions;
			}

			if (params.orderBy !== undefined) {
				queryParameters['orderBy'] = params.orderBy;
			}

			if (params.childconditions !== undefined) {
				queryParameters['childconditions'] = params.childconditions;
			}

			if (params.customfieldconditions !== undefined) {
				queryParameters['customfieldconditions'] = params.customfieldconditions;
			}

			if (params.page !== undefined) {
				queryParameters['page'] = params.page;
			}

			if (params.pageSize !== undefined) {
				queryParameters['pageSize'] = params.pageSize;
			}

			let fetchParams = {
				method: 'GET',
				headers: headerParams,

			};

			if (extraFetchParams) {
				fetchParams = assign(fetchParams, extraFetchParams);
			}

			let localVarPathWithQueryParameters = localVarPath + (localVarPath.indexOf('?') !== -1 ? '&' : '?') + querystring.stringify(queryParameters);

			return fetch(localVarPathWithQueryParameters, fetchParams).then((response) => {
				if (response.status >= 200 && response.status < 300) {
					return response.json();
				} else {
					let error = new Error(response.statusText);
					(error as any).response = response;
					throw error;
				}
			});
		}
		/**
		 *
		 * Delete Today Page Category By Id
		 * @param id
		 */
		public systemTodayPageCategoriesIdDelete (params: {  id: number; }, extraQueryParams?: any, extraFetchParams?: any ) : Promise<{}> {
			const localVarPath = this.basePath + '/system/todayPageCategories/{id}'
				.replace('{' + 'id' + '}', String(params.id));

			let queryParameters: any = assign({}, extraQueryParams);
			let headerParams: any = assign({}, this.defaultHeaders);
			// verify required parameter 'id' is set
			if (params.id == null) {
				throw new Error('Missing required parameter id when calling systemTodayPageCategoriesIdDelete');
			}
			let fetchParams = {
				method: 'DELETE',
				headers: headerParams,

			};

			if (extraFetchParams) {
				fetchParams = assign(fetchParams, extraFetchParams);
			}

			let localVarPathWithQueryParameters = localVarPath + (localVarPath.indexOf('?') !== -1 ? '&' : '?') + querystring.stringify(queryParameters);

			return fetch(localVarPathWithQueryParameters, fetchParams).then((response) => {
				if (response.status >= 200 && response.status < 300) {
					return response.json();
				} else {
					let error = new Error(response.statusText);
					(error as any).response = response;
					throw error;
				}
			});
		}
		/**
		 *
		 * Get Today Page Category By Id
		 * @param id
		 */
		public systemTodayPageCategoriesIdGet (params: {  id: number; }, extraQueryParams?: any, extraFetchParams?: any ) : Promise<TodayPageCategory> {
			const localVarPath = this.basePath + '/system/todayPageCategories/{id}'
				.replace('{' + 'id' + '}', String(params.id));

			let queryParameters: any = assign({}, extraQueryParams);
			let headerParams: any = assign({}, this.defaultHeaders);
			// verify required parameter 'id' is set
			if (params.id == null) {
				throw new Error('Missing required parameter id when calling systemTodayPageCategoriesIdGet');
			}
			let fetchParams = {
				method: 'GET',
				headers: headerParams,

			};

			if (extraFetchParams) {
				fetchParams = assign(fetchParams, extraFetchParams);
			}

			let localVarPathWithQueryParameters = localVarPath + (localVarPath.indexOf('?') !== -1 ? '&' : '?') + querystring.stringify(queryParameters);

			return fetch(localVarPathWithQueryParameters, fetchParams).then((response) => {
				if (response.status >= 200 && response.status < 300) {
					return response.json();
				} else {
					let error = new Error(response.statusText);
					(error as any).response = response;
					throw error;
				}
			});
		}
		/**
		 *
		 * Update Today Page Category
		 * @param id
		 * @param operations
		 */
		public systemTodayPageCategoriesIdPatch (params: {  id: number; operations: Array<PatchOperation>; }, extraQueryParams?: any, extraFetchParams?: any ) : Promise<TodayPageCategory> {
			const localVarPath = this.basePath + '/system/todayPageCategories/{id}'
				.replace('{' + 'id' + '}', String(params.id));

			let queryParameters: any = assign({}, extraQueryParams);
			let headerParams: any = assign({}, this.defaultHeaders);
			headerParams['Content-Type'] = 'application/json';

			// verify required parameter 'id' is set
			if (params.id == null) {
				throw new Error('Missing required parameter id when calling systemTodayPageCategoriesIdPatch');
			}
			// verify required parameter 'operations' is set
			if (params.operations == null) {
				throw new Error('Missing required parameter operations when calling systemTodayPageCategoriesIdPatch');
			}
			let fetchParams = {
				method: 'PATCH',
				headers: headerParams,
				body: JSON.stringify(params.operations),

			};

			if (extraFetchParams) {
				fetchParams = assign(fetchParams, extraFetchParams);
			}

			let localVarPathWithQueryParameters = localVarPath + (localVarPath.indexOf('?') !== -1 ? '&' : '?') + querystring.stringify(queryParameters);

			return fetch(localVarPathWithQueryParameters, fetchParams).then((response) => {
				if (response.status >= 200 && response.status < 300) {
					return response.json();
				} else {
					let error = new Error(response.statusText);
					(error as any).response = response;
					throw error;
				}
			});
		}
		/**
		 *
		 * Replace Today Page Category
		 * @param id
		 * @param todayPageCategory
		 */
		public systemTodayPageCategoriesIdPut (params: {  id: number; todayPageCategory: TodayPageCategory; }, extraQueryParams?: any, extraFetchParams?: any ) : Promise<TodayPageCategory> {
			const localVarPath = this.basePath + '/system/todayPageCategories/{id}'
				.replace('{' + 'id' + '}', String(params.id));

			let queryParameters: any = assign({}, extraQueryParams);
			let headerParams: any = assign({}, this.defaultHeaders);
			headerParams['Content-Type'] = 'application/json';

			// verify required parameter 'id' is set
			if (params.id == null) {
				throw new Error('Missing required parameter id when calling systemTodayPageCategoriesIdPut');
			}
			// verify required parameter 'todayPageCategory' is set
			if (params.todayPageCategory == null) {
				throw new Error('Missing required parameter todayPageCategory when calling systemTodayPageCategoriesIdPut');
			}
			let fetchParams = {
				method: 'PUT',
				headers: headerParams,
				body: JSON.stringify(params.todayPageCategory),

			};

			if (extraFetchParams) {
				fetchParams = assign(fetchParams, extraFetchParams);
			}

			let localVarPathWithQueryParameters = localVarPath + (localVarPath.indexOf('?') !== -1 ? '&' : '?') + querystring.stringify(queryParameters);

			return fetch(localVarPathWithQueryParameters, fetchParams).then((response) => {
				if (response.status >= 200 && response.status < 300) {
					return response.json();
				} else {
					let error = new Error(response.statusText);
					(error as any).response = response;
					throw error;
				}
			});
		}
		/**
		 *
		 * Create Today Page Category
		 * @param todayPageCategory
		 */
		public systemTodayPageCategoriesPost (params: {  todayPageCategory: TodayPageCategory; }, extraQueryParams?: any, extraFetchParams?: any ) : Promise<TodayPageCategory> {
			const localVarPath = this.basePath + '/system/todayPageCategories';

			let queryParameters: any = assign({}, extraQueryParams);
			let headerParams: any = assign({}, this.defaultHeaders);
			headerParams['Content-Type'] = 'application/json';

			// verify required parameter 'todayPageCategory' is set
			if (params.todayPageCategory == null) {
				throw new Error('Missing required parameter todayPageCategory when calling systemTodayPageCategoriesPost');
			}
			let fetchParams = {
				method: 'POST',
				headers: headerParams,
				body: JSON.stringify(params.todayPageCategory),

			};

			if (extraFetchParams) {
				fetchParams = assign(fetchParams, extraFetchParams);
			}

			let localVarPathWithQueryParameters = localVarPath + (localVarPath.indexOf('?') !== -1 ? '&' : '?') + querystring.stringify(queryParameters);

			return fetch(localVarPathWithQueryParameters, fetchParams).then((response) => {
				if (response.status >= 200 && response.status < 300) {
					return response.json();
				} else {
					let error = new Error(response.statusText);
					(error as any).response = response;
					throw error;
				}
			});
		}
	}
//}
//export namespace  {
	'use strict';

	export class UnitOfMeasureConversionsApi {
		protected basePath = 'https://api-na.myconnectwise.net/v4_6_release/apis/3.0';
		public defaultHeaders : any = {};

		constructor(basePath?: string) {
			if (basePath) {
				this.basePath = basePath;
			}
		}

		/**
		 *
		 * Delete Conversion By Id
		 * @param id
		 * @param conversionId
		 */
		public procurementUnitOfMeasuresIdConversionsConversionIdDelete (params: {  id: number; conversionId: number; }, extraQueryParams?: any, extraFetchParams?: any ) : Promise<{}> {
			const localVarPath = this.basePath + '/procurement/unitOfMeasures/{id}/conversions/{conversionId}'
				.replace('{' + 'id' + '}', String(params.id))
				.replace('{' + 'conversionId' + '}', String(params.conversionId));

			let queryParameters: any = assign({}, extraQueryParams);
			let headerParams: any = assign({}, this.defaultHeaders);
			// verify required parameter 'id' is set
			if (params.id == null) {
				throw new Error('Missing required parameter id when calling procurementUnitOfMeasuresIdConversionsConversionIdDelete');
			}
			// verify required parameter 'conversionId' is set
			if (params.conversionId == null) {
				throw new Error('Missing required parameter conversionId when calling procurementUnitOfMeasuresIdConversionsConversionIdDelete');
			}
			let fetchParams = {
				method: 'DELETE',
				headers: headerParams,

			};

			if (extraFetchParams) {
				fetchParams = assign(fetchParams, extraFetchParams);
			}

			let localVarPathWithQueryParameters = localVarPath + (localVarPath.indexOf('?') !== -1 ? '&' : '?') + querystring.stringify(queryParameters);

			return fetch(localVarPathWithQueryParameters, fetchParams).then((response) => {
				if (response.status >= 200 && response.status < 300) {
					return response.json();
				} else {
					let error = new Error(response.statusText);
					(error as any).response = response;
					throw error;
				}
			});
		}
		/**
		 *
		 * Get Conversion By Id
		 * @param id
		 * @param conversionId
		 */
		public procurementUnitOfMeasuresIdConversionsConversionIdGet (params: {  id: number; conversionId: number; }, extraQueryParams?: any, extraFetchParams?: any ) : Promise<Conversion> {
			const localVarPath = this.basePath + '/procurement/unitOfMeasures/{id}/conversions/{conversionId}'
				.replace('{' + 'id' + '}', String(params.id))
				.replace('{' + 'conversionId' + '}', String(params.conversionId));

			let queryParameters: any = assign({}, extraQueryParams);
			let headerParams: any = assign({}, this.defaultHeaders);
			// verify required parameter 'id' is set
			if (params.id == null) {
				throw new Error('Missing required parameter id when calling procurementUnitOfMeasuresIdConversionsConversionIdGet');
			}
			// verify required parameter 'conversionId' is set
			if (params.conversionId == null) {
				throw new Error('Missing required parameter conversionId when calling procurementUnitOfMeasuresIdConversionsConversionIdGet');
			}
			let fetchParams = {
				method: 'GET',
				headers: headerParams,

			};

			if (extraFetchParams) {
				fetchParams = assign(fetchParams, extraFetchParams);
			}

			let localVarPathWithQueryParameters = localVarPath + (localVarPath.indexOf('?') !== -1 ? '&' : '?') + querystring.stringify(queryParameters);

			return fetch(localVarPathWithQueryParameters, fetchParams).then((response) => {
				if (response.status >= 200 && response.status < 300) {
					return response.json();
				} else {
					let error = new Error(response.statusText);
					(error as any).response = response;
					throw error;
				}
			});
		}
		/**
		 *
		 * Update Conversion
		 * @param id
		 * @param conversionId
		 * @param operations
		 */
		public procurementUnitOfMeasuresIdConversionsConversionIdPatch (params: {  id: number; conversionId: number; operations: Array<PatchOperation>; }, extraQueryParams?: any, extraFetchParams?: any ) : Promise<Conversion> {
			const localVarPath = this.basePath + '/procurement/unitOfMeasures/{id}/conversions/{conversionId}'
				.replace('{' + 'id' + '}', String(params.id))
				.replace('{' + 'conversionId' + '}', String(params.conversionId));

			let queryParameters: any = assign({}, extraQueryParams);
			let headerParams: any = assign({}, this.defaultHeaders);
			headerParams['Content-Type'] = 'application/json';

			// verify required parameter 'id' is set
			if (params.id == null) {
				throw new Error('Missing required parameter id when calling procurementUnitOfMeasuresIdConversionsConversionIdPatch');
			}
			// verify required parameter 'conversionId' is set
			if (params.conversionId == null) {
				throw new Error('Missing required parameter conversionId when calling procurementUnitOfMeasuresIdConversionsConversionIdPatch');
			}
			// verify required parameter 'operations' is set
			if (params.operations == null) {
				throw new Error('Missing required parameter operations when calling procurementUnitOfMeasuresIdConversionsConversionIdPatch');
			}
			let fetchParams = {
				method: 'PATCH',
				headers: headerParams,
				body: JSON.stringify(params.operations),

			};

			if (extraFetchParams) {
				fetchParams = assign(fetchParams, extraFetchParams);
			}

			let localVarPathWithQueryParameters = localVarPath + (localVarPath.indexOf('?') !== -1 ? '&' : '?') + querystring.stringify(queryParameters);

			return fetch(localVarPathWithQueryParameters, fetchParams).then((response) => {
				if (response.status >= 200 && response.status < 300) {
					return response.json();
				} else {
					let error = new Error(response.statusText);
					(error as any).response = response;
					throw error;
				}
			});
		}
		/**
		 *
		 * Replace Conversion
		 * @param id
		 * @param conversionId
		 * @param conversion
		 */
		public procurementUnitOfMeasuresIdConversionsConversionIdPut (params: {  id: number; conversionId: number; conversion: Conversion; }, extraQueryParams?: any, extraFetchParams?: any ) : Promise<Conversion> {
			const localVarPath = this.basePath + '/procurement/unitOfMeasures/{id}/conversions/{conversionId}'
				.replace('{' + 'id' + '}', String(params.id))
				.replace('{' + 'conversionId' + '}', String(params.conversionId));

			let queryParameters: any = assign({}, extraQueryParams);
			let headerParams: any = assign({}, this.defaultHeaders);
			headerParams['Content-Type'] = 'application/json';

			// verify required parameter 'id' is set
			if (params.id == null) {
				throw new Error('Missing required parameter id when calling procurementUnitOfMeasuresIdConversionsConversionIdPut');
			}
			// verify required parameter 'conversionId' is set
			if (params.conversionId == null) {
				throw new Error('Missing required parameter conversionId when calling procurementUnitOfMeasuresIdConversionsConversionIdPut');
			}
			// verify required parameter 'conversion' is set
			if (params.conversion == null) {
				throw new Error('Missing required parameter conversion when calling procurementUnitOfMeasuresIdConversionsConversionIdPut');
			}
			let fetchParams = {
				method: 'PUT',
				headers: headerParams,
				body: JSON.stringify(params.conversion),

			};

			if (extraFetchParams) {
				fetchParams = assign(fetchParams, extraFetchParams);
			}

			let localVarPathWithQueryParameters = localVarPath + (localVarPath.indexOf('?') !== -1 ? '&' : '?') + querystring.stringify(queryParameters);

			return fetch(localVarPathWithQueryParameters, fetchParams).then((response) => {
				if (response.status >= 200 && response.status < 300) {
					return response.json();
				} else {
					let error = new Error(response.statusText);
					(error as any).response = response;
					throw error;
				}
			});
		}
		/**
		 *
		 * Get Conversion Count
		 * @param id
		 * @param conditions
		 */
		public procurementUnitOfMeasuresIdConversionsCountGet (params: {  id: number; conditions?: string; }, extraQueryParams?: any, extraFetchParams?: any ) : Promise<Count> {
			const localVarPath = this.basePath + '/procurement/unitOfMeasures/{id}/conversions/count'
				.replace('{' + 'id' + '}', String(params.id));

			let queryParameters: any = assign({}, extraQueryParams);
			let headerParams: any = assign({}, this.defaultHeaders);
			// verify required parameter 'id' is set
			if (params.id == null) {
				throw new Error('Missing required parameter id when calling procurementUnitOfMeasuresIdConversionsCountGet');
			}
			if (params.conditions !== undefined) {
				queryParameters['conditions'] = params.conditions;
			}

			let fetchParams = {
				method: 'GET',
				headers: headerParams,

			};

			if (extraFetchParams) {
				fetchParams = assign(fetchParams, extraFetchParams);
			}

			let localVarPathWithQueryParameters = localVarPath + (localVarPath.indexOf('?') !== -1 ? '&' : '?') + querystring.stringify(queryParameters);

			return fetch(localVarPathWithQueryParameters, fetchParams).then((response) => {
				if (response.status >= 200 && response.status < 300) {
					return response.json();
				} else {
					let error = new Error(response.statusText);
					(error as any).response = response;
					throw error;
				}
			});
		}
		/**
		 *
		 * Get Conversion
		 * @param id
		 * @param conditions
		 * @param orderBy
		 * @param childconditions
		 * @param customfieldconditions
		 * @param page
		 * @param pageSize
		 */
		public procurementUnitOfMeasuresIdConversionsGet (params: {  id: number; conditions?: string; orderBy?: string; childconditions?: string; customfieldconditions?: string; page?: number; pageSize?: number; }, extraQueryParams?: any, extraFetchParams?: any ) : Promise<Array<Conversion>> {
			const localVarPath = this.basePath + '/procurement/unitOfMeasures/{id}/conversions'
				.replace('{' + 'id' + '}', String(params.id));

			let queryParameters: any = assign({}, extraQueryParams);
			let headerParams: any = assign({}, this.defaultHeaders);
			// verify required parameter 'id' is set
			if (params.id == null) {
				throw new Error('Missing required parameter id when calling procurementUnitOfMeasuresIdConversionsGet');
			}
			if (params.conditions !== undefined) {
				queryParameters['conditions'] = params.conditions;
			}

			if (params.orderBy !== undefined) {
				queryParameters['orderBy'] = params.orderBy;
			}

			if (params.childconditions !== undefined) {
				queryParameters['childconditions'] = params.childconditions;
			}

			if (params.customfieldconditions !== undefined) {
				queryParameters['customfieldconditions'] = params.customfieldconditions;
			}

			if (params.page !== undefined) {
				queryParameters['page'] = params.page;
			}

			if (params.pageSize !== undefined) {
				queryParameters['pageSize'] = params.pageSize;
			}

			let fetchParams = {
				method: 'GET',
				headers: headerParams,

			};

			if (extraFetchParams) {
				fetchParams = assign(fetchParams, extraFetchParams);
			}

			let localVarPathWithQueryParameters = localVarPath + (localVarPath.indexOf('?') !== -1 ? '&' : '?') + querystring.stringify(queryParameters);

			return fetch(localVarPathWithQueryParameters, fetchParams).then((response) => {
				if (response.status >= 200 && response.status < 300) {
					return response.json();
				} else {
					let error = new Error(response.statusText);
					(error as any).response = response;
					throw error;
				}
			});
		}
		/**
		 *
		 * Create Conversion
		 * @param id
		 * @param conversion
		 */
		public procurementUnitOfMeasuresIdConversionsPost (params: {  id: number; conversion: Conversion; }, extraQueryParams?: any, extraFetchParams?: any ) : Promise<Conversion> {
			const localVarPath = this.basePath + '/procurement/unitOfMeasures/{id}/conversions'
				.replace('{' + 'id' + '}', String(params.id));

			let queryParameters: any = assign({}, extraQueryParams);
			let headerParams: any = assign({}, this.defaultHeaders);
			headerParams['Content-Type'] = 'application/json';

			// verify required parameter 'id' is set
			if (params.id == null) {
				throw new Error('Missing required parameter id when calling procurementUnitOfMeasuresIdConversionsPost');
			}
			// verify required parameter 'conversion' is set
			if (params.conversion == null) {
				throw new Error('Missing required parameter conversion when calling procurementUnitOfMeasuresIdConversionsPost');
			}
			let fetchParams = {
				method: 'POST',
				headers: headerParams,
				body: JSON.stringify(params.conversion),

			};

			if (extraFetchParams) {
				fetchParams = assign(fetchParams, extraFetchParams);
			}

			let localVarPathWithQueryParameters = localVarPath + (localVarPath.indexOf('?') !== -1 ? '&' : '?') + querystring.stringify(queryParameters);

			return fetch(localVarPathWithQueryParameters, fetchParams).then((response) => {
				if (response.status >= 200 && response.status < 300) {
					return response.json();
				} else {
					let error = new Error(response.statusText);
					(error as any).response = response;
					throw error;
				}
			});
		}
	}
//}
//export namespace  {
	'use strict';

	export class UnitOfMeasuresApi {
		protected basePath = 'https://api-na.myconnectwise.net/v4_6_release/apis/3.0';
		public defaultHeaders : any = {};

		constructor(basePath?: string) {
			if (basePath) {
				this.basePath = basePath;
			}
		}

		/**
		 *
		 * Get Unit Of Measure Count
		 * @param conditions
		 */
		public procurementUnitOfMeasuresCountGet (params: {  conditions?: string; }, extraQueryParams?: any, extraFetchParams?: any ) : Promise<Count> {
			const localVarPath = this.basePath + '/procurement/unitOfMeasures/count';

			let queryParameters: any = assign({}, extraQueryParams);
			let headerParams: any = assign({}, this.defaultHeaders);
			if (params.conditions !== undefined) {
				queryParameters['conditions'] = params.conditions;
			}

			let fetchParams = {
				method: 'GET',
				headers: headerParams,

			};

			if (extraFetchParams) {
				fetchParams = assign(fetchParams, extraFetchParams);
			}

			let localVarPathWithQueryParameters = localVarPath + (localVarPath.indexOf('?') !== -1 ? '&' : '?') + querystring.stringify(queryParameters);

			return fetch(localVarPathWithQueryParameters, fetchParams).then((response) => {
				if (response.status >= 200 && response.status < 300) {
					return response.json();
				} else {
					let error = new Error(response.statusText);
					(error as any).response = response;
					throw error;
				}
			});
		}
		/**
		 *
		 * Get Unit Of Measure
		 * @param conditions
		 * @param orderBy
		 * @param childconditions
		 * @param customfieldconditions
		 * @param page
		 * @param pageSize
		 */
		public procurementUnitOfMeasuresGet (params: {  conditions?: string; orderBy?: string; childconditions?: string; customfieldconditions?: string; page?: number; pageSize?: number; }, extraQueryParams?: any, extraFetchParams?: any ) : Promise<Array<UnitOfMeasure>> {
			const localVarPath = this.basePath + '/procurement/unitOfMeasures';

			let queryParameters: any = assign({}, extraQueryParams);
			let headerParams: any = assign({}, this.defaultHeaders);
			if (params.conditions !== undefined) {
				queryParameters['conditions'] = params.conditions;
			}

			if (params.orderBy !== undefined) {
				queryParameters['orderBy'] = params.orderBy;
			}

			if (params.childconditions !== undefined) {
				queryParameters['childconditions'] = params.childconditions;
			}

			if (params.customfieldconditions !== undefined) {
				queryParameters['customfieldconditions'] = params.customfieldconditions;
			}

			if (params.page !== undefined) {
				queryParameters['page'] = params.page;
			}

			if (params.pageSize !== undefined) {
				queryParameters['pageSize'] = params.pageSize;
			}

			let fetchParams = {
				method: 'GET',
				headers: headerParams,

			};

			if (extraFetchParams) {
				fetchParams = assign(fetchParams, extraFetchParams);
			}

			let localVarPathWithQueryParameters = localVarPath + (localVarPath.indexOf('?') !== -1 ? '&' : '?') + querystring.stringify(queryParameters);

			return fetch(localVarPathWithQueryParameters, fetchParams).then((response) => {
				if (response.status >= 200 && response.status < 300) {
					return response.json();
				} else {
					let error = new Error(response.statusText);
					(error as any).response = response;
					throw error;
				}
			});
		}
		/**
		 *
		 * Delete Unit Of Measure By Id
		 * @param id
		 */
		public procurementUnitOfMeasuresIdDelete (params: {  id: number; }, extraQueryParams?: any, extraFetchParams?: any ) : Promise<{}> {
			const localVarPath = this.basePath + '/procurement/unitOfMeasures/{id}'
				.replace('{' + 'id' + '}', String(params.id));

			let queryParameters: any = assign({}, extraQueryParams);
			let headerParams: any = assign({}, this.defaultHeaders);
			// verify required parameter 'id' is set
			if (params.id == null) {
				throw new Error('Missing required parameter id when calling procurementUnitOfMeasuresIdDelete');
			}
			let fetchParams = {
				method: 'DELETE',
				headers: headerParams,

			};

			if (extraFetchParams) {
				fetchParams = assign(fetchParams, extraFetchParams);
			}

			let localVarPathWithQueryParameters = localVarPath + (localVarPath.indexOf('?') !== -1 ? '&' : '?') + querystring.stringify(queryParameters);

			return fetch(localVarPathWithQueryParameters, fetchParams).then((response) => {
				if (response.status >= 200 && response.status < 300) {
					return response.json();
				} else {
					let error = new Error(response.statusText);
					(error as any).response = response;
					throw error;
				}
			});
		}
		/**
		 *
		 * Get Unit Of Measure By Id
		 * @param id
		 */
		public procurementUnitOfMeasuresIdGet (params: {  id: number; }, extraQueryParams?: any, extraFetchParams?: any ) : Promise<UnitOfMeasure> {
			const localVarPath = this.basePath + '/procurement/unitOfMeasures/{id}'
				.replace('{' + 'id' + '}', String(params.id));

			let queryParameters: any = assign({}, extraQueryParams);
			let headerParams: any = assign({}, this.defaultHeaders);
			// verify required parameter 'id' is set
			if (params.id == null) {
				throw new Error('Missing required parameter id when calling procurementUnitOfMeasuresIdGet');
			}
			let fetchParams = {
				method: 'GET',
				headers: headerParams,

			};

			if (extraFetchParams) {
				fetchParams = assign(fetchParams, extraFetchParams);
			}

			let localVarPathWithQueryParameters = localVarPath + (localVarPath.indexOf('?') !== -1 ? '&' : '?') + querystring.stringify(queryParameters);

			return fetch(localVarPathWithQueryParameters, fetchParams).then((response) => {
				if (response.status >= 200 && response.status < 300) {
					return response.json();
				} else {
					let error = new Error(response.statusText);
					(error as any).response = response;
					throw error;
				}
			});
		}
		/**
		 *
		 * Update Unit Of Measure
		 * @param id
		 * @param operations
		 */
		public procurementUnitOfMeasuresIdPatch (params: {  id: number; operations: Array<PatchOperation>; }, extraQueryParams?: any, extraFetchParams?: any ) : Promise<UnitOfMeasure> {
			const localVarPath = this.basePath + '/procurement/unitOfMeasures/{id}'
				.replace('{' + 'id' + '}', String(params.id));

			let queryParameters: any = assign({}, extraQueryParams);
			let headerParams: any = assign({}, this.defaultHeaders);
			headerParams['Content-Type'] = 'application/json';

			// verify required parameter 'id' is set
			if (params.id == null) {
				throw new Error('Missing required parameter id when calling procurementUnitOfMeasuresIdPatch');
			}
			// verify required parameter 'operations' is set
			if (params.operations == null) {
				throw new Error('Missing required parameter operations when calling procurementUnitOfMeasuresIdPatch');
			}
			let fetchParams = {
				method: 'PATCH',
				headers: headerParams,
				body: JSON.stringify(params.operations),

			};

			if (extraFetchParams) {
				fetchParams = assign(fetchParams, extraFetchParams);
			}

			let localVarPathWithQueryParameters = localVarPath + (localVarPath.indexOf('?') !== -1 ? '&' : '?') + querystring.stringify(queryParameters);

			return fetch(localVarPathWithQueryParameters, fetchParams).then((response) => {
				if (response.status >= 200 && response.status < 300) {
					return response.json();
				} else {
					let error = new Error(response.statusText);
					(error as any).response = response;
					throw error;
				}
			});
		}
		/**
		 *
		 * Replace Unit Of Measure
		 * @param id
		 * @param unitOfMeasure
		 */
		public procurementUnitOfMeasuresIdPut (params: {  id: number; unitOfMeasure: UnitOfMeasure; }, extraQueryParams?: any, extraFetchParams?: any ) : Promise<UnitOfMeasure> {
			const localVarPath = this.basePath + '/procurement/unitOfMeasures/{id}'
				.replace('{' + 'id' + '}', String(params.id));

			let queryParameters: any = assign({}, extraQueryParams);
			let headerParams: any = assign({}, this.defaultHeaders);
			headerParams['Content-Type'] = 'application/json';

			// verify required parameter 'id' is set
			if (params.id == null) {
				throw new Error('Missing required parameter id when calling procurementUnitOfMeasuresIdPut');
			}
			// verify required parameter 'unitOfMeasure' is set
			if (params.unitOfMeasure == null) {
				throw new Error('Missing required parameter unitOfMeasure when calling procurementUnitOfMeasuresIdPut');
			}
			let fetchParams = {
				method: 'PUT',
				headers: headerParams,
				body: JSON.stringify(params.unitOfMeasure),

			};

			if (extraFetchParams) {
				fetchParams = assign(fetchParams, extraFetchParams);
			}

			let localVarPathWithQueryParameters = localVarPath + (localVarPath.indexOf('?') !== -1 ? '&' : '?') + querystring.stringify(queryParameters);

			return fetch(localVarPathWithQueryParameters, fetchParams).then((response) => {
				if (response.status >= 200 && response.status < 300) {
					return response.json();
				} else {
					let error = new Error(response.statusText);
					(error as any).response = response;
					throw error;
				}
			});
		}
		/**
		 *
		 * Create Unit Of Measure
		 * @param unitOfMeasure
		 */
		public procurementUnitOfMeasuresPost (params: {  unitOfMeasure: UnitOfMeasure; }, extraQueryParams?: any, extraFetchParams?: any ) : Promise<UnitOfMeasure> {
			const localVarPath = this.basePath + '/procurement/unitOfMeasures';

			let queryParameters: any = assign({}, extraQueryParams);
			let headerParams: any = assign({}, this.defaultHeaders);
			headerParams['Content-Type'] = 'application/json';

			// verify required parameter 'unitOfMeasure' is set
			if (params.unitOfMeasure == null) {
				throw new Error('Missing required parameter unitOfMeasure when calling procurementUnitOfMeasuresPost');
			}
			let fetchParams = {
				method: 'POST',
				headers: headerParams,
				body: JSON.stringify(params.unitOfMeasure),

			};

			if (extraFetchParams) {
				fetchParams = assign(fetchParams, extraFetchParams);
			}

			let localVarPathWithQueryParameters = localVarPath + (localVarPath.indexOf('?') !== -1 ? '&' : '?') + querystring.stringify(queryParameters);

			return fetch(localVarPathWithQueryParameters, fetchParams).then((response) => {
				if (response.status >= 200 && response.status < 300) {
					return response.json();
				} else {
					let error = new Error(response.statusText);
					(error as any).response = response;
					throw error;
				}
			});
		}
	}
//}
//export namespace  {
	'use strict';

	export class UserDefinedFieldsApi {
		protected basePath = 'https://api-na.myconnectwise.net/v4_6_release/apis/3.0';
		public defaultHeaders : any = {};

		constructor(basePath?: string) {
			if (basePath) {
				this.basePath = basePath;
			}
		}

		/**
		 *
		 * Get User Defined Fields Count
		 * @param conditions
		 */
		public systemUserDefinedFieldsCountGet (params: {  conditions?: string; }, extraQueryParams?: any, extraFetchParams?: any ) : Promise<Count> {
			const localVarPath = this.basePath + '/system/userDefinedFields/count';

			let queryParameters: any = assign({}, extraQueryParams);
			let headerParams: any = assign({}, this.defaultHeaders);
			if (params.conditions !== undefined) {
				queryParameters['conditions'] = params.conditions;
			}

			let fetchParams = {
				method: 'GET',
				headers: headerParams,

			};

			if (extraFetchParams) {
				fetchParams = assign(fetchParams, extraFetchParams);
			}

			let localVarPathWithQueryParameters = localVarPath + (localVarPath.indexOf('?') !== -1 ? '&' : '?') + querystring.stringify(queryParameters);

			return fetch(localVarPathWithQueryParameters, fetchParams).then((response) => {
				if (response.status >= 200 && response.status < 300) {
					return response.json();
				} else {
					let error = new Error(response.statusText);
					(error as any).response = response;
					throw error;
				}
			});
		}
		/**
		 *
		 * Get User Defined Fields
		 * @param conditions
		 * @param orderBy
		 * @param childconditions
		 * @param customfieldconditions
		 * @param page
		 * @param pageSize
		 */
		public systemUserDefinedFieldsGet (params: {  conditions?: string; orderBy?: string; childconditions?: string; customfieldconditions?: string; page?: number; pageSize?: number; }, extraQueryParams?: any, extraFetchParams?: any ) : Promise<Array<UserDefinedField>> {
			const localVarPath = this.basePath + '/system/userDefinedFields';

			let queryParameters: any = assign({}, extraQueryParams);
			let headerParams: any = assign({}, this.defaultHeaders);
			if (params.conditions !== undefined) {
				queryParameters['conditions'] = params.conditions;
			}

			if (params.orderBy !== undefined) {
				queryParameters['orderBy'] = params.orderBy;
			}

			if (params.childconditions !== undefined) {
				queryParameters['childconditions'] = params.childconditions;
			}

			if (params.customfieldconditions !== undefined) {
				queryParameters['customfieldconditions'] = params.customfieldconditions;
			}

			if (params.page !== undefined) {
				queryParameters['page'] = params.page;
			}

			if (params.pageSize !== undefined) {
				queryParameters['pageSize'] = params.pageSize;
			}

			let fetchParams = {
				method: 'GET',
				headers: headerParams,

			};

			if (extraFetchParams) {
				fetchParams = assign(fetchParams, extraFetchParams);
			}

			let localVarPathWithQueryParameters = localVarPath + (localVarPath.indexOf('?') !== -1 ? '&' : '?') + querystring.stringify(queryParameters);

			return fetch(localVarPathWithQueryParameters, fetchParams).then((response) => {
				if (response.status >= 200 && response.status < 300) {
					return response.json();
				} else {
					let error = new Error(response.statusText);
					(error as any).response = response;
					throw error;
				}
			});
		}
		/**
		 *
		 * Delete User Defined Field By Id
		 * @param id
		 */
		public systemUserDefinedFieldsIdDelete (params: {  id: number; }, extraQueryParams?: any, extraFetchParams?: any ) : Promise<{}> {
			const localVarPath = this.basePath + '/system/userDefinedFields/{id}'
				.replace('{' + 'id' + '}', String(params.id));

			let queryParameters: any = assign({}, extraQueryParams);
			let headerParams: any = assign({}, this.defaultHeaders);
			// verify required parameter 'id' is set
			if (params.id == null) {
				throw new Error('Missing required parameter id when calling systemUserDefinedFieldsIdDelete');
			}
			let fetchParams = {
				method: 'DELETE',
				headers: headerParams,

			};

			if (extraFetchParams) {
				fetchParams = assign(fetchParams, extraFetchParams);
			}

			let localVarPathWithQueryParameters = localVarPath + (localVarPath.indexOf('?') !== -1 ? '&' : '?') + querystring.stringify(queryParameters);

			return fetch(localVarPathWithQueryParameters, fetchParams).then((response) => {
				if (response.status >= 200 && response.status < 300) {
					return response.json();
				} else {
					let error = new Error(response.statusText);
					(error as any).response = response;
					throw error;
				}
			});
		}
		/**
		 *
		 * Get User Defined Field By Id
		 * @param id
		 */
		public systemUserDefinedFieldsIdGet (params: {  id: number; }, extraQueryParams?: any, extraFetchParams?: any ) : Promise<UserDefinedField> {
			const localVarPath = this.basePath + '/system/userDefinedFields/{id}'
				.replace('{' + 'id' + '}', String(params.id));

			let queryParameters: any = assign({}, extraQueryParams);
			let headerParams: any = assign({}, this.defaultHeaders);
			// verify required parameter 'id' is set
			if (params.id == null) {
				throw new Error('Missing required parameter id when calling systemUserDefinedFieldsIdGet');
			}
			let fetchParams = {
				method: 'GET',
				headers: headerParams,

			};

			if (extraFetchParams) {
				fetchParams = assign(fetchParams, extraFetchParams);
			}

			let localVarPathWithQueryParameters = localVarPath + (localVarPath.indexOf('?') !== -1 ? '&' : '?') + querystring.stringify(queryParameters);

			return fetch(localVarPathWithQueryParameters, fetchParams).then((response) => {
				if (response.status >= 200 && response.status < 300) {
					return response.json();
				} else {
					let error = new Error(response.statusText);
					(error as any).response = response;
					throw error;
				}
			});
		}
		/**
		 *
		 * Update User Defined Field
		 * @param id
		 * @param operations
		 */
		public systemUserDefinedFieldsIdPatch (params: {  id: number; operations: Array<PatchOperation>; }, extraQueryParams?: any, extraFetchParams?: any ) : Promise<UserDefinedField> {
			const localVarPath = this.basePath + '/system/userDefinedFields/{id}'
				.replace('{' + 'id' + '}', String(params.id));

			let queryParameters: any = assign({}, extraQueryParams);
			let headerParams: any = assign({}, this.defaultHeaders);
			headerParams['Content-Type'] = 'application/json';

			// verify required parameter 'id' is set
			if (params.id == null) {
				throw new Error('Missing required parameter id when calling systemUserDefinedFieldsIdPatch');
			}
			// verify required parameter 'operations' is set
			if (params.operations == null) {
				throw new Error('Missing required parameter operations when calling systemUserDefinedFieldsIdPatch');
			}
			let fetchParams = {
				method: 'PATCH',
				headers: headerParams,
				body: JSON.stringify(params.operations),

			};

			if (extraFetchParams) {
				fetchParams = assign(fetchParams, extraFetchParams);
			}

			let localVarPathWithQueryParameters = localVarPath + (localVarPath.indexOf('?') !== -1 ? '&' : '?') + querystring.stringify(queryParameters);

			return fetch(localVarPathWithQueryParameters, fetchParams).then((response) => {
				if (response.status >= 200 && response.status < 300) {
					return response.json();
				} else {
					let error = new Error(response.statusText);
					(error as any).response = response;
					throw error;
				}
			});
		}
		/**
		 *
		 * Replace User Defined Field
		 * @param id
		 * @param userDefinedField
		 */
		public systemUserDefinedFieldsIdPut (params: {  id: number; userDefinedField: UserDefinedField; }, extraQueryParams?: any, extraFetchParams?: any ) : Promise<UserDefinedField> {
			const localVarPath = this.basePath + '/system/userDefinedFields/{id}'
				.replace('{' + 'id' + '}', String(params.id));

			let queryParameters: any = assign({}, extraQueryParams);
			let headerParams: any = assign({}, this.defaultHeaders);
			headerParams['Content-Type'] = 'application/json';

			// verify required parameter 'id' is set
			if (params.id == null) {
				throw new Error('Missing required parameter id when calling systemUserDefinedFieldsIdPut');
			}
			// verify required parameter 'userDefinedField' is set
			if (params.userDefinedField == null) {
				throw new Error('Missing required parameter userDefinedField when calling systemUserDefinedFieldsIdPut');
			}
			let fetchParams = {
				method: 'PUT',
				headers: headerParams,
				body: JSON.stringify(params.userDefinedField),

			};

			if (extraFetchParams) {
				fetchParams = assign(fetchParams, extraFetchParams);
			}

			let localVarPathWithQueryParameters = localVarPath + (localVarPath.indexOf('?') !== -1 ? '&' : '?') + querystring.stringify(queryParameters);

			return fetch(localVarPathWithQueryParameters, fetchParams).then((response) => {
				if (response.status >= 200 && response.status < 300) {
					return response.json();
				} else {
					let error = new Error(response.statusText);
					(error as any).response = response;
					throw error;
				}
			});
		}
		/**
		 *
		 * Create User Defined Field
		 * @param userDefinedField
		 */
		public systemUserDefinedFieldsPost (params: {  userDefinedField: UserDefinedField; }, extraQueryParams?: any, extraFetchParams?: any ) : Promise<UserDefinedField> {
			const localVarPath = this.basePath + '/system/userDefinedFields';

			let queryParameters: any = assign({}, extraQueryParams);
			let headerParams: any = assign({}, this.defaultHeaders);
			headerParams['Content-Type'] = 'application/json';

			// verify required parameter 'userDefinedField' is set
			if (params.userDefinedField == null) {
				throw new Error('Missing required parameter userDefinedField when calling systemUserDefinedFieldsPost');
			}
			let fetchParams = {
				method: 'POST',
				headers: headerParams,
				body: JSON.stringify(params.userDefinedField),

			};

			if (extraFetchParams) {
				fetchParams = assign(fetchParams, extraFetchParams);
			}

			let localVarPathWithQueryParameters = localVarPath + (localVarPath.indexOf('?') !== -1 ? '&' : '?') + querystring.stringify(queryParameters);

			return fetch(localVarPathWithQueryParameters, fetchParams).then((response) => {
				if (response.status >= 200 && response.status < 300) {
					return response.json();
				} else {
					let error = new Error(response.statusText);
					(error as any).response = response;
					throw error;
				}
			});
		}
	}
//}
